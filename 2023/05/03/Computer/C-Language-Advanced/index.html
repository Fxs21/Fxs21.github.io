

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Shuang">
  <meta name="keywords" content="Shuang">
  
    <meta name="description" content="C 语言的进阶知识. 库函数; 内存管理; 文件 IO; 数据结构; 架构设计.">
<meta property="og:type" content="article">
<meta property="og:title" content="C Language Advanced">
<meta property="og:url" content="http://example.com/2023/05/03/Computer/C-Language-Advanced/index.html">
<meta property="og:site_name" content="Shuang blog">
<meta property="og:description" content="C 语言的进阶知识. 库函数; 内存管理; 文件 IO; 数据结构; 架构设计.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/C-Language.svg">
<meta property="article:published_time" content="2023-05-03T04:00:00.000Z">
<meta property="article:modified_time" content="2025-11-25T14:38:32.576Z">
<meta property="article:author" content="Shuang">
<meta property="article:tag" content="计算机">
<meta property="article:tag" content="Code">
<meta property="article:tag" content="C 语言">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/C-Language.svg">
  
  
  
  <title>C Language Advanced - Shuang blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>windsand</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/train.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C Language Advanced"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-05-03 12:00" pubdate>
          2023年5月3日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          100 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C Language Advanced</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="C-语言进阶"><a href="#C-语言进阶" class="headerlink" title="C 语言进阶"></a>C 语言进阶</h1><h2 id="0-库函数"><a href="#0-库函数" class="headerlink" title="0 库函数"></a>0 库函数</h2><h3 id="0-1-标准输出"><a href="#0-1-标准输出" class="headerlink" title="0.1 标准输出"></a>0.1 标准输出</h3><ol>
<li><p><code>printf</code>: 将字符串进行格式化转换,然后进行标准化输出.等价于 <code>fprintf(stdout, ...)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br><span class="hljs-comment">// format: 格式化字符串, 包含普通字符和格式说明符</span><br><span class="hljs-comment">// ...: 可变参数列表, 对应格式字符串中的格式说明符</span><br><span class="hljs-comment">// 返回值: 成功时返回输出的字符数, 失败时返回负值</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>格式化字符串结构分为</p>
<ul>
<li><p>普通字符: 原样输出</p>
</li>
<li><p>转义序列: 如 <code>\n, \t</code></p>
</li>
<li><p>格式说明符: 以 <code>%</code> 开头,形式为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">%[flags][width][.precision][length]specifier<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>基本格式说明符(若<code>%</code>后的字符不是转换字符,则为未定义行为)</p>
<table>
<thead>
<tr>
<th align="left">specifier</th>
<th align="left">用途</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>%d</code> 或 <code>%i</code></td>
<td align="left">有符号十进制整数</td>
<td align="left"><code>printf(&quot;%d&quot;, 123);</code> → <code>123</code></td>
</tr>
<tr>
<td align="left"><code>%u</code></td>
<td align="left">无符号十进制整数</td>
<td align="left"><code>printf(&quot;%u&quot;, 255);</code> → <code>255</code></td>
</tr>
<tr>
<td align="left"><code>%o</code></td>
<td align="left">无符号八进制整数</td>
<td align="left"><code>printf(&quot;%o&quot;, 10);</code> → <code>12</code></td>
</tr>
<tr>
<td align="left"><code>%x / %X</code></td>
<td align="left">无符号十六进制整数</td>
<td align="left"><code>printf(&quot;%x&quot;, 255);</code> → <code>ff</code></td>
</tr>
<tr>
<td align="left"><code>%f / %F</code></td>
<td align="left">十进制浮点数</td>
<td align="left"><code>printf(&quot;%f&quot;, 3.14);</code> → <code>3.140000</code></td>
</tr>
<tr>
<td align="left"><code>%e / %E</code></td>
<td align="left">科学计数法浮点数</td>
<td align="left"><code>printf(&quot;%e&quot;, 123.45);</code> → <code>1.234500e+02</code></td>
</tr>
<tr>
<td align="left"><code>%g / %G</code></td>
<td align="left">自动选择 <code>%f / %e</code></td>
<td align="left"><code>printf(&quot;%g&quot;, 0.000123);</code> → <code>0.000123</code></td>
</tr>
<tr>
<td align="left"><code>%c</code></td>
<td align="left">单个字符</td>
<td align="left"><code>printf(&quot;%c&quot;, &#39;A&#39;);</code> → <code>A</code></td>
</tr>
<tr>
<td align="left"><code>%s</code></td>
<td align="left">字符串</td>
<td align="left"><code>printf(&quot;%s&quot;, &quot;hello&quot;);</code> → <code>hello</code></td>
</tr>
<tr>
<td align="left"><code>%p</code></td>
<td align="left">指针地址</td>
<td align="left"><code>printf(&quot;%p&quot;, &amp;var);</code> → <code>0x7ffd42a1b2cc</code></td>
</tr>
<tr>
<td align="left"><code>%%</code></td>
<td align="left">输出百分号</td>
<td align="left"><code>printf(&quot;%%&quot;);</code> → <code>%</code></td>
</tr>
</tbody></table>
</li>
<li><p>标志(flags 出现顺序不限): 用于修改转换说明</p>
<table>
<thead>
<tr>
<th align="left">flags</th>
<th align="left">作用</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-</code></td>
<td align="left">左对齐</td>
<td align="left"><code>printf(&quot;%-10s&quot;, &quot;hello&quot;);</code> → <code>hello</code></td>
</tr>
<tr>
<td align="left"><code>+</code></td>
<td align="left">强制显示正负号</td>
<td align="left"><code>printf(&quot;%+d&quot;, 5);</code> → <code>+5</code></td>
</tr>
<tr>
<td align="left"><kbd>space</kbd></td>
<td align="left">正数前显示空格</td>
<td align="left"><code>printf(&quot;% d&quot;, 5);</code> → <code>5</code></td>
</tr>
<tr>
<td align="left"><code>0</code></td>
<td align="left">用零填充而非空格</td>
<td align="left"><code>printf(&quot;%05d&quot;, 42);</code> → <code>00042</code></td>
</tr>
<tr>
<td align="left"><code>#</code></td>
<td align="left">替代形式</td>
<td align="left"><code>printf(&quot;%#x&quot;, 10);</code> → <code>0xa</code></td>
</tr>
</tbody></table>
</li>
<li><p>宽度(width) &amp;&amp; 精度(precision)</p>
<table>
<thead>
<tr>
<th align="left">width.precision</th>
<th align="left">作用</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>数字</code></td>
<td align="left">最小字段宽度</td>
<td align="left"><code>printf(&quot;%10s&quot;, &quot;hi&quot;);</code> → <code>hi</code></td>
</tr>
<tr>
<td align="left"><code>.*</code></td>
<td align="left">精度(动态指定)</td>
<td align="left"><code>printf(&quot;%.*f&quot;, 2, 3.14159);</code> → <code>3.14</code></td>
</tr>
<tr>
<td align="left"><code>.数字</code></td>
<td align="left">精度</td>
<td align="left"><code>printf(&quot;%.2f&quot;, 3.14159);</code> → <code>3.14</code></td>
</tr>
</tbody></table>
</li>
<li><p>长度修饰符(length): 用于将参数指定为某种类型</p>
<table>
<thead>
<tr>
<th align="left">length</th>
<th align="left">用途</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>h</code></td>
<td align="left"><code>short int</code></td>
<td align="left"><code>printf(&quot;%hd&quot;, (short)32767);</code></td>
</tr>
<tr>
<td align="left"><code>l</code></td>
<td align="left"><code>long int</code></td>
<td align="left"><code>printf(&quot;%ld&quot;, 123456789L);</code></td>
</tr>
<tr>
<td align="left"><code>ll</code></td>
<td align="left"><code>long long int</code></td>
<td align="left"><code>printf(&quot;%lld&quot;, 123456789012LL);</code></td>
</tr>
<tr>
<td align="left"><code>L</code></td>
<td align="left"><code>long double</code></td>
<td align="left"><code>printf(&quot;%Lf&quot;, 3.1415926535L);</code></td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="0-2-标准输入"><a href="#0-2-标准输入" class="headerlink" title="0.2 标准输入"></a>0.2 标准输入</h3><ol>
<li><p><code>scanf</code>: 从标准输入读取输入,根据 format 进行匹配, 赋给后续的各个参数.等价于 <code>scanf(stdout, ...)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">scanf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br><span class="hljs-comment">// format: 格式化字符串,指定输入数据的预期格式</span><br><span class="hljs-comment">// ...: 可变参数列表, 对应格式字符串中的格式说明符.注意必须是变量的地址</span><br><span class="hljs-comment">// 返回值: 成功时返回成功读取的数据项数量.失败或到达文件末尾时返回 EOF</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>格式串字符串结构</p>
<ul>
<li><p>空白字符: 空格, 制表符, 换行符</p>
</li>
<li><p>非空白字符: 必须与输入精确匹配的字符</p>
</li>
<li><p>格式说明符: 以 <code>%</code> 开头,形式为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">%[*][width][length]specifier<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>基本格式说明符</p>
<table>
<thead>
<tr>
<th align="left">specifier</th>
<th align="left">用途</th>
<th align="left">示例</th>
<th align="left">输入示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>%d</code></td>
<td align="left">有符号十进制整数</td>
<td align="left"><code>scanf(&quot;%d&quot;, &amp;num);</code></td>
<td align="left"><code>123</code></td>
</tr>
<tr>
<td align="left"><code>%i</code></td>
<td align="left">整数(自动检测进制)</td>
<td align="left"><code>scanf(&quot;%i&quot;, &amp;num);</code></td>
<td align="left"><code>123</code>, <code>0x7B</code>, <code>0173</code></td>
</tr>
<tr>
<td align="left"><code>%u</code></td>
<td align="left">无符号十进制整数</td>
<td align="left"><code>scanf(&quot;%u&quot;, &amp;num);</code></td>
<td align="left"><code>255</code></td>
</tr>
<tr>
<td align="left"><code>%o</code></td>
<td align="left">无符号八进制整数</td>
<td align="left"><code>scanf(&quot;%o&quot;, &amp;num);</code></td>
<td align="left"><code>12</code> (十进制10)</td>
</tr>
<tr>
<td align="left"><code>%x, %X</code></td>
<td align="left">无符号十六进制整数</td>
<td align="left"><code>scanf(&quot;%x&quot;, &amp;num);</code></td>
<td align="left"><code>ff</code> (十进制255)</td>
</tr>
<tr>
<td align="left"><code>%f, %e, %g</code></td>
<td align="left">浮点数</td>
<td align="left"><code>scanf(&quot;%f&quot;, &amp;f);</code></td>
<td align="left"><code>3.14</code></td>
</tr>
<tr>
<td align="left"><code>%lf</code></td>
<td align="left">双精度浮点数</td>
<td align="left"><code>scanf(&quot;%lf&quot;, &amp;d);</code></td>
<td align="left"><code>3.14159</code></td>
</tr>
<tr>
<td align="left"><code>%c</code></td>
<td align="left">单个字符</td>
<td align="left"><code>scanf(&quot;%c&quot;, &amp;ch);</code></td>
<td align="left"><code>A</code></td>
</tr>
<tr>
<td align="left"><code>%s</code></td>
<td align="left">字符串(不包含空白符)</td>
<td align="left"><code>scanf(&quot;%s&quot;, str);</code></td>
<td align="left"><code>hello</code></td>
</tr>
<tr>
<td align="left"><code>%[ ]</code></td>
<td align="left">扫描字符集合</td>
<td align="left"><code>scanf(&quot;%[a-z]&quot;, str);</code></td>
<td align="left"><code>hello</code></td>
</tr>
<tr>
<td align="left"><code>%p</code></td>
<td align="left">指针地址</td>
<td align="left"><code>scanf(&quot;%p&quot;, &amp;ptr);</code></td>
<td align="left"><code>0x7ffd42a1b2cc</code></td>
</tr>
<tr>
<td align="left"><code>%%</code></td>
<td align="left">匹配百分号</td>
<td align="left"><code>scanf(&quot;%%&quot;);</code></td>
<td align="left"><code>%</code></td>
</tr>
</tbody></table>
</li>
<li><p>修饰符</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">作用</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>*</code></td>
<td align="left">赋值抑制符(读取但不存储)</td>
<td align="left"><code>scanf(&quot;%*d %d&quot;, &amp;num);</code></td>
</tr>
<tr>
<td align="left"><code>数字</code></td>
<td align="left">最大字段宽度</td>
<td align="left"><code>scanf(&quot;%5s&quot;, str);</code></td>
</tr>
<tr>
<td align="left"><code>h</code></td>
<td align="left"><code>short int</code></td>
<td align="left"><code>scanf(&quot;%hd&quot;, &amp;s_num);</code></td>
</tr>
<tr>
<td align="left"><code>l</code></td>
<td align="left"><code>long int</code> 或 <code>double</code></td>
<td align="left"><code>scanf(&quot;%ld&quot;, &amp;l_num);</code></td>
</tr>
<tr>
<td align="left"><code>ll</code></td>
<td align="left"><code>long long int</code></td>
<td align="left"><code>scanf(&quot;%lld&quot;, &amp;ll_num);</code></td>
</tr>
<tr>
<td align="left"><code>L</code></td>
<td align="left"><code>long double</code></td>
<td align="left"><code>scanf(&quot;%Lf&quot;, &amp;ld_num);</code></td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="0-3-排序查找"><a href="#0-3-排序查找" class="headerlink" title="0.3 排序查找"></a>0.3 排序查找</h3><ol>
<li><p>快速排序算法 <code>&lt;stdlib.h&gt;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// qsort 函数是类型无关的通用排序函数.实现了 Quick Sort</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">qsort</span><span class="hljs-params">(<span class="hljs-type">void</span> *base, <span class="hljs-type">size_t</span> nmemb, <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">           <span class="hljs-type">int</span> (*compare)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *))</span>;<br><span class="hljs-comment">// base:    目标数组</span><br><span class="hljs-comment">// nmemb:   数组中元素数量</span><br><span class="hljs-comment">// size:    每个元素的大小(单位为 byte)</span><br><span class="hljs-comment">// compare: 比较函数的指针.返回值小于 0 时.表示 param1 排在 param2 前(即默认升序)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>二分查找 <code>&lt;stdlib.h&gt;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 二分查找成功返回指向该元素的指针.未找到返回 NULL</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">bsearch</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *base, <span class="hljs-type">size_t</span> nmemb, <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">              <span class="hljs-type">int</span> (*compare)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *))</span>;<br><span class="hljs-comment">// key:     查找元素的指针.注意数据类型应该与数组元素保持相同</span><br><span class="hljs-comment">// base:    目标数组</span><br><span class="hljs-comment">// nmemb:   数组中元素数量</span><br><span class="hljs-comment">// size:    每个元素的大小(单位为 byte)</span><br><span class="hljs-comment">// compare: 比较函数的指针</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>快排使用示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">// 数据结构.其中 key 为排序依据</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">char</span> key[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> value;<br>&#125; Record;<br><br><span class="hljs-comment">// 比较函数(字典序)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">record_compare</span><span class="hljs-params">(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *a, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *b)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(((Record *)a)-&gt;key, ((Record *)b)-&gt;key);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    Record records[<span class="hljs-number">4</span>] = &#123;<br>        &#123;<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">100</span>&#125;, &#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">200</span>&#125;, &#123;<span class="hljs-string">&quot;date&quot;</span>, <span class="hljs-number">300</span>&#125;, &#123;<span class="hljs-string">&quot;cherry&quot;</span>, <span class="hljs-number">400</span>&#125;&#125;;<br><br>    <span class="hljs-comment">// 排序</span><br>    qsort(records, <span class="hljs-number">4</span>, <span class="hljs-keyword">sizeof</span>(Record), record_compare);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;records[%d] %s - %d\n&quot;</span>, i, records[i].key, records[i].value);<br><br>    <span class="hljs-comment">// 查找</span><br>    Record key = &#123;<span class="hljs-string">&quot;cherry&quot;</span>, <span class="hljs-number">0</span>&#125;;<br>    Record *result = bsearch(&amp;key, records, <span class="hljs-number">4</span>, <span class="hljs-keyword">sizeof</span>(Record), record_compare);<br><br>    <span class="hljs-keyword">if</span> (result)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Found: %s, data: %d\n&quot;</span>, result-&gt;key, result-&gt;value);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not found\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1 内存管理"></a>1 内存管理</h2><h3 id="1-1-内存布局"><a href="#1-1-内存布局" class="headerlink" title="1.1 内存布局"></a>1.1 内存布局</h3><ol>
<li><p>C 程序在运行时,内存分为以下几个主要区域(Segments)</p>
<table>
<thead>
<tr>
<th align="left"><strong>内存区域</strong></th>
<th align="left"><strong>存储内容</strong></th>
<th align="left"><strong>特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">代码段(Text)</td>
<td align="left">存放编译后的机器指令(二进制代码)</td>
<td align="left">只读.程序运行时不可修改</td>
</tr>
<tr>
<td align="left">数据段(Data)</td>
<td align="left">已初始化全局变量 &amp; 静态变量</td>
<td align="left">程序启动时分配.生命周期直到程序结束</td>
</tr>
<tr>
<td align="left">BSS 段(BSS)</td>
<td align="left">未初始化全局变量 &amp; 静态变量</td>
<td align="left">程序启动时清零.生命周期直到程序结束</td>
</tr>
<tr>
<td align="left">堆(Heap)</td>
<td align="left">动态分配(<code>malloc, calloc, realloc, free</code>)</td>
<td align="left">手动管理.增长方向从低地址向高地址</td>
</tr>
<tr>
<td align="left">栈(Stack)</td>
<td align="left">局部变量,函数参数,返回地址等</td>
<td align="left">自动管理(函数调用时入栈,返回时出栈).<br />增长方向从高地址向低地址,大小有限</td>
</tr>
</tbody></table>
</li>
<li><p>内存布局图示(linux 64bit)</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss">高地址<br>┌─────────────────────┐<br>│        Stack        │ ← 由高地址向低地址增长<br>├─────────────────────┤<br>│          ↓          │<br>│          ↑          │<br>├─────────────────────┤<br>│        Heap         │ ← 由低地址向高地址增长<br>├─────────────────────┤<br>│        BSS          │ (未初始化全局变量)<br>├─────────────────────┤<br>│        Data         │ (已初始化全局变量)<br>├─────────────────────┤<br>│        <span class="hljs-selector-tag">Text</span>         │ (程序指令)<br>低地址<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-2-内存分配"><a href="#1-2-内存分配" class="headerlink" title="1.2  内存分配"></a>1.2  内存分配</h3><ol>
<li><p>需要使用到 <code>&lt;stdlib.h&gt;</code> 头文件中的库函数</p>
</li>
<li><p><code>malloc</code>: 向系统申请分配 <code>size</code> 个字节的内存空间,返回一个指向该空间的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-comment">// 调用成功返回一个申请的内存空间指针,类型为 void *</span><br><span class="hljs-comment">// 调用失败返回 NULL.若设置 size = 0,同样返回 NULL</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>calloc</code>: 在内存中动态的申请 <code>nmemb</code> 个长度为 <code>size</code> 的连续内存空间,并全部初始化为0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> nmemb, <span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-comment">// 调用成功返回一个申请的内存空间指针,类型为 void *</span><br><span class="hljs-comment">// 调用失败返回 NULL.若设置 size = 0,同样返回 NULL</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>realloc</code>: 重新分配内存空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>可以增大或减小已分配内存的大小</li>
<li>其实现通常为新分配内存,然后复制内容,最后释放原内存.注意新内存仍不会初始化</li>
<li><code>ptr</code> 指向先前分配的内存空间.当参数 <code>ptr==NULL</code> 时,等同于调用 <code>malloc</code></li>
</ul>
</li>
<li><p><code>free</code>: 释放动态空间内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>free</code> 释放的内存空间必须是由 <code>malloc, calloc, realloc</code> 函数申请.否则会导致未定义行为</li>
<li>若参数 <code>ptr==NULL</code>,则不执行任何操作.多次对同一指针调用 <code>free</code>,将导致未定义行为</li>
<li><code>free</code> 函数不改变参数 <code>ptr</code> 的值.为避免悬空指针,释放空间后需将指针的值置为 <code>NULL</code></li>
</ul>
</li>
</ol>
<h3 id="1-3-内存池"><a href="#1-3-内存池" class="headerlink" title="1.3 内存池"></a>1.3 内存池</h3><ol>
<li>内存泄漏<ul>
<li>C 语言不具备垃圾回收机制,需要手动释放内存.<code>malloc</code> 和 <code>free</code> 应该成对编写</li>
<li><code>malloc</code> 可以申请任意尺寸的内存空间.得到的空间是连续的,经常使用数组索引</li>
</ul>
</li>
<li>内存池: 预先从系统申请分配一大块内存.然后由程序自己管理这块内存的分配和释放,而不是每次需要时都想操作系统申请<ul>
<li>频繁使用 <code>malloc</code> 和 <code>free</code> 手动分配和释放内存很容易产生大量的内存碎片</li>
<li>系统调用开销: <code>malloc</code> 函数向操作系统申请堆内存经历了从应用层切入系统内核层的过程</li>
<li><code>malloc</code> 的执行时间是不确定的.取决于当前堆的状态,对于实时系统是致命的</li>
</ul>
</li>
<li>内存池的工作流程<ul>
<li>预分配: 在程序初始化或对象创建时,一次性向系统申请一大块连续内存</li>
<li>自定义分配: 当程序需要内存时,从这块预分配的内存中划出一部分给程序使用</li>
<li>自定义释放: 当程序释放内存时,并不真正还给系统.而是将其标记为空闲,放回池中供下次分配使用</li>
<li>集中销毁: 当整个池不再需要时(如程序退出或对象销毁), 一次性将整块大内存归还给系统</li>
</ul>
</li>
<li>固定大小内存池(Fixed-Size Pool)<ul>
<li>思想: 池中所有内存块都是固定大小的</li>
<li>优点: 分配和释放仅为 O(1),速度块; 不会产生无法利用的小空闲块; 分配 &#x2F; 释放的时间固定</li>
<li>缺点: 申请的大小与池中块大小不匹配时无法使用.通常用于频繁分配单一类型对象的场景</li>
<li>工作流程<ul>
<li>将大内存块分割为一个个大小相等的小块</li>
<li>用一个空闲链表将这些小块连接</li>
<li>分配时,从链表头部取下一块,返回给用户</li>
<li>释放时,将用户还回的块重新插回链表头部</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="2-文件-IO"><a href="#2-文件-IO" class="headerlink" title="2 文件 IO"></a>2 文件 IO</h2><h3 id="2-1-打开文件"><a href="#2-1-打开文件" class="headerlink" title="2.1 打开文件"></a>2.1 打开文件</h3><ol>
<li><p>文件操作的思想</p>
<ul>
<li>流(stream): C 将 文件, 设备, 内存缓冲区抽象为 流.是一个单向流动的数据序列</li>
<li>缓冲机制(buffering): 程序不直接与硬件交互,而是与一块内存区域(缓冲)交互.直接满足特定条件时进行 flush</li>
<li>文件指针(file pointer): 流的具体实现通过 <code>FILE</code> 的结构体来管理.而 <code>FILE *</code> 变量即为操作文件的句柄</li>
</ul>
</li>
<li><p>程序启动时,会自动打开三个标准流,无需 <code>fopen</code></p>
<ul>
<li><code>stdin</code>: 标准输入(通常对应键盘).用于 <code>scanf, getchar</code> 等</li>
<li><code>stdout</code>: 标准输出(通常对应显示器).用于 <code>printf, puts</code> 等</li>
<li><code>stderr</code>: 标准错误(通常对应显示器).用于输出错误信息</li>
</ul>
</li>
<li><p>缓冲区</p>
<ul>
<li><p>对于写入操作,程序会先将数据写入缓冲区,直到缓冲区被写满或文件关闭时才一次性写入设备中</p>
</li>
<li><p>对于读取操作,如果数据已经在缓冲区中,则立即返回给程序.否则,系统会将一大块数据从设备读入缓冲区</p>
</li>
<li><p>如果需要立即将数据写入设备中,可使用 <code>fflush</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fflush</span><span class="hljs-params">(FILE *stream)</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>fopen</code>: 打开一个文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *<span class="hljs-title function_">fopen</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode )</span>;<br><span class="hljs-comment">// 调用成功返回一个指向 FILE 结构的文件指针.通过该指针对文件进行操作.失败返回 NULL</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>打开模式</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>“r”</td>
<td>只读.文件必须存在</td>
</tr>
<tr>
<td>“w”</td>
<td>只写.文件存在则清空,不存在则创建</td>
</tr>
<tr>
<td>“a”</td>
<td>追加.文件存在则追加到末尾,不存在则创建</td>
</tr>
<tr>
<td>“r+”</td>
<td>读写.文件必须存在</td>
</tr>
<tr>
<td>“w+”</td>
<td>读写.文件存在则清空,不存在则创建</td>
</tr>
<tr>
<td>“a+”</td>
<td>读写.文件存在则可读可追加,不存在则创建</td>
</tr>
<tr>
<td>b</td>
<td>可与以上6种模式结合(如 “rb, “r+b”); 表示操作对象为二进制文件</td>
</tr>
</tbody></table>
</li>
<li><p><code>fclose</code> 函数: 关闭一个文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fclose</span><span class="hljs-params">( FILE *fp )</span>;<br><span class="hljs-comment">/* fp: 使用 fopen 获取的文件指针</span><br><span class="hljs-comment"> * 调用成功返回0,失败返回 EOF</span><br><span class="hljs-comment"> * 调用 fclose 后系统才会将缓冲区的数据写入文件,并释放该文件的相关资源 */</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-2-顺序读写"><a href="#2-2-顺序读写" class="headerlink" title="2.2 顺序读写"></a>2.2 顺序读写</h3><ol>
<li><p>读取单个字符(下列函数均声明于 <code>&lt;stdio.h&gt;</code>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fgetc, getc: 从文件流中读取下一个字符,并推进文件的位置指示器 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fgetc</span><span class="hljs-params">(FILE *stream)</span>;  <span class="hljs-comment">// 函数原型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getc</span><span class="hljs-params">(FILE *stream)</span>;   <span class="hljs-comment">// 通常实现为宏</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>写入单个字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fputc, putc 函数: 向文件流写入单个字符 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *stream)</span>;  <span class="hljs-comment">// 函数原型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *stream)</span>;   <span class="hljs-comment">// 通常实现为宏</span><br><span class="hljs-comment">/* 返回值: 遇到错误或文件结束时返回 EOF.否则返回已写入的字符本身 */</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>读取字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fgets 函数: 从指定的文件中读取字符串 */</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> size, FILE *stream)</span>;<br><span class="hljs-comment">/* s: 指向存放读取得到字符串的位置</span><br><span class="hljs-comment"> * size: 指定读取的字符数(包括自动添加的 &#x27;\0&#x27;).想读取10个字符,应令 size = 11</span><br><span class="hljs-comment"> * stream: 指定一个待操作的数据流</span><br><span class="hljs-comment"> * 返回值: 调用成功,返回 s 指向的地址.若发生错误,返回 NULL</span><br><span class="hljs-comment"> * 当遇到换行符 &#x27;\n&#x27; 就会停止本次字符串的读取</span><br><span class="hljs-comment"> * 注意 gets 函数不安全,已被 C99 弃用并从 C11 除名 */</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>写入字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fputs 函数: 将字符串写入到指定的文件中,结尾的 &#x27;\0&#x27; 不会被写入 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, FILE *stream)</span>;<br><br><span class="hljs-comment">/* puts 函数: 将字符串写入 stdout 并自动追加换行符.方便打印消息 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">puts</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>格式化读写文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fscanf 函数: f 表示 file,对文件进行读取 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fscanf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br><br><span class="hljs-comment">/* fprintf 函数: f 表示 file,对文件进行写入 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>二进制读写文件</p>
<ul>
<li><code>fopen</code> 函数可以指定文件的打开模式(文本, 二进制).但后续对文件的操作并不一定是对应的形式</li>
<li>无论以哪种模式打开文件,都不能决定写入数据的形式.它们只是影响换行符的表现形式.</li>
<li>真正决定数据写入模式的是 相关的文件读写函数</li>
</ul>
</li>
<li><p><code>fread</code> 函数: 从指定文件中读取指定尺寸的数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">fread</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span>;<br><span class="hljs-comment">/* ptr:     指向存放数据的内存块地址</span><br><span class="hljs-comment"> * size:    待读取的每个元素的尺寸</span><br><span class="hljs-comment"> * nmemb:   指定待读取的元素个数</span><br><span class="hljs-comment"> * stream:  指向一个待读取的文件流</span><br><span class="hljs-comment"> * 返回值:  调用成功返回实际读取到的元素个数,即 nmemb</span><br><span class="hljs-comment"> * 如果返回值小于 nmemb,说明读取到文件末尾或发生错误 */</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>fwrite</code> 函数: 将指定数据写入到指定文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">fwrite</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span>;<br><span class="hljs-comment">/* ptr:    指向存放数据的内存块地址</span><br><span class="hljs-comment"> * size:   待写入的每个元素的尺寸</span><br><span class="hljs-comment"> * nmemb:  指定待写入的元素个数</span><br><span class="hljs-comment"> * stream: 指向一个待写入的文件流 */</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-3-随机读写"><a href="#2-3-随机读写" class="headerlink" title="2.3 随机读写"></a>2.3 随机读写</h3><ol>
<li><p>系统为每个打开的文件设置了一个位置指示器,用于表示当前的读写位置</p>
</li>
<li><p><code>ftell</code> 函数: 返回当前的读写位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">ftell</span><span class="hljs-params">(FILE *stream)</span>;<br><span class="hljs-comment">/* stream: 指定待操作的文件流</span><br><span class="hljs-comment"> * 返回值: 指定文件的当前读写位置</span><br><span class="hljs-comment"> * 如果将文件看作一个数组,那么 ftell 的返回值就是&quot;数组&quot;的下标 */</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>fseek</code> 函数: 设置文件位置指示器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">long</span> <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> whence)</span>;<br><span class="hljs-comment">/* stream: 指定待操作的文件流</span><br><span class="hljs-comment"> * offset: 指定偏移的字节数量</span><br><span class="hljs-comment"> * whence: 指定开始偏移的位置 */</span><br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>whence</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SEEK_SET</td>
<td>文件开头</td>
</tr>
<tr>
<td>SEEK_CUR</td>
<td>当前位置</td>
</tr>
<tr>
<td>SEEK_END</td>
<td>文件末尾</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">fseek(fp, <span class="hljs-number">100</span>, SEEK_SET); <span class="hljs-comment">// 定位到文件的第100字节位置</span><br>fseek(fp, <span class="hljs-number">-5</span>, SEEK_END);  <span class="hljs-comment">// 定位到文件的倒数第5个字节位置</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>fseek</code> 需要考虑可移植性</p>
<ul>
<li>不同操作系统对换行符的处理不同,导致定位会出现误差</li>
<li>对于二进制模式打开的文件, <code>fseek</code> 在某些操作系统中可能不支持 SEEK_END</li>
<li>对于文本模式打开的文件, <code>whence</code> 参数只有取 SEEK_SET 才有意义</li>
<li>传递给 offset 的参数值要么为 0,要么是上一次对同一文件调用 <code>ftell</code> 函数获得的返回值</li>
</ul>
</li>
</ol>
<h2 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3 面向对象"></a>3 面向对象</h2><h3 id="3-1-封装"><a href="#3-1-封装" class="headerlink" title="3.1 封装"></a>3.1 封装</h3><ol>
<li><p><strong>封装: 隐藏实现细节,仅暴露必要接口</strong></p>
</li>
<li><p>实现方式: 使用 <code>struct</code> 存储数据,使用头文件(<code>.h</code>)声明公共接口,而源文件(<code>.c</code>)隐藏私有实现</p>
</li>
<li><p><code>person.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 不完整类型(此处仅声明,不定义)隐藏数据细节 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> <span class="hljs-title">Person</span>;</span><br><br><span class="hljs-comment">/* 构造函数 / 析构函数 */</span><br>Person* <span class="hljs-title function_">person_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">person_destroy</span><span class="hljs-params">(Person *p)</span>;<br><br><span class="hljs-comment">/* 公共方法(接口)隐藏实现细节 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_name</span><span class="hljs-params">(Person *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">person_get_name</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_age</span><span class="hljs-params">(Person *p, <span class="hljs-type">int</span> age)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">person_get_age</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">person_greet</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>person.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span></span><br><br><span class="hljs-comment">/* 完整定义 Person(仅在此文件可见) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">/* 实现构造函数 / 析构函数 */</span><br>Person* <span class="hljs-title function_">person_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age)</span> &#123;<br>    Person *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Person));<br>    p-&gt;name = strdup(name);<br>    p-&gt;age = age;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_destroy</span><span class="hljs-params">(Person *p)</span> &#123;<br>    <span class="hljs-built_in">free</span>(p-&gt;name);<br>    <span class="hljs-built_in">free</span>(p);<br>&#125;<br><br><span class="hljs-comment">/* 公共方法实现 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_greet</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, I&#x27;m %s, age %d!\n&quot;</span>, p-&gt;name, p-&gt;age);<br>&#125;<br><br><span class="hljs-comment">/* set, get 方法实现 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_name</span><span class="hljs-params">(Person *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span> &#123;<br>    <span class="hljs-built_in">free</span>(p-&gt;name);<br>    p-&gt;name = strdup(name);<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">person_get_name</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span> &#123;<br>    <span class="hljs-keyword">return</span> p-&gt;name;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_age</span><span class="hljs-params">(Person *p, <span class="hljs-type">int</span> age)</span> &#123;<br>    p-&gt;age = age;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">person_get_age</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span> &#123;<br>    <span class="hljs-keyword">return</span> p-&gt;age;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>main.c</code> 使用示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;student.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    Person *p = person_create(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>);<br>    person_greet(p);  <span class="hljs-comment">// 输出: Hello, I&#x27;m Alice, age 25!</span><br>    person_set_age(p, <span class="hljs-number">10</span>);<br>    person_set_name(p, <span class="hljs-string">&quot;Bob&quot;</span>);<br>    person_greet(p);  <span class="hljs-comment">// 输出: Hello, I&#x27;m Bob, age 10!</span><br>    person_destroy(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-2-继承"><a href="#3-2-继承" class="headerlink" title="3.2 继承"></a>3.2 继承</h3><ol>
<li><p><strong>继承: 子类继承父类的属性和方法</strong></p>
</li>
<li><p>实现方式: 结构体嵌套(父结构体作为子结构体的第一个成员),通过类型转换模拟继承</p>
</li>
<li><p><code>student.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">Student</span>;</span><br>Student* <span class="hljs-title function_">student_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *university)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">student_destroy</span><span class="hljs-params">(Student *s)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">student_study</span><span class="hljs-params">(<span class="hljs-type">const</span> Student *s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *subject)</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>student.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;student.h&quot;</span></span><br><br><span class="hljs-comment">/* Student 的私有定义 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> &#123;</span><br>    Person *base;     <span class="hljs-comment">// 通过指针持有 Person(避免不完整类型问题)</span><br>    <span class="hljs-type">char</span> *university; <span class="hljs-comment">// 子类特有的数据</span><br>&#125;;<br><br><span class="hljs-comment">/* Student 的构造函数.通过调用 Person 的构造函数工作 */</span><br>Student* <span class="hljs-title function_">student_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *university)</span> &#123;<br>    Student *s = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Student));<br>    s-&gt;base = person_create(name, age);<br>    s-&gt;university = strdup(university);<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-comment">/* Student 的析构函数.通过调用 Person 的析构函数工作 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">student_destroy</span><span class="hljs-params">(Student *s)</span> &#123;<br>    person_destroy(s-&gt;base);<br>    <span class="hljs-built_in">free</span>(s-&gt;university);<br>    <span class="hljs-built_in">free</span>(s);<br>&#125;<br><br><span class="hljs-comment">/* 子类 Student 独有的方法 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">student_study</span><span class="hljs-params">(<span class="hljs-type">const</span> Student *s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *subject)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s is studying %s at %s.\n&quot;</span>, person_get_name(s-&gt;base), subject, s-&gt;university);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>main.c</code> 使用示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;student.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">/* 创建 Student 对象(已经完全隐藏了 Person 的细节) */</span><br>    Student *s = student_create(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Stanford&quot;</span>);<br>    student_study(s, <span class="hljs-string">&quot;Computer Science&quot;</span>);  <span class="hljs-comment">// 只能依赖公共接口工作</span><br>    student_destroy(s);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-3-多态"><a href="#3-3-多态" class="headerlink" title="3.3 多态"></a>3.3 多态</h3><ol>
<li><p><strong>多态: 同一接口,不同实现</strong>(使用函数指针实现动态绑定.类似 C++ 的虚函数表)</p>
</li>
<li><p><code>shape.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Shape 基类前向声明 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Shape</span> <span class="hljs-title">Shape</span>;</span><br><br><span class="hljs-comment">/* Shape 虚函数表(模拟 C++ 的 vtable).并为子类提供必要的定义 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ShapeVTable</span> &#123;</span><br>    <span class="hljs-type">void</span> (*draw)(<span class="hljs-type">const</span> Shape *);<br>    <span class="hljs-type">double</span> (*area)(<span class="hljs-type">const</span> Shape *);<br>&#125; ShapeVTable;<br><br><span class="hljs-comment">/* Shape 基类结构体(子类需要了解布局) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Shape</span> &#123;</span><br>    <span class="hljs-type">const</span> ShapeVTable *vtable; <span class="hljs-comment">// 每个对象绑定自己的虚表</span><br>&#125;;<br><br><span class="hljs-comment">/* Shape 公共接口(多态方法) */</span><br><span class="hljs-type">void</span>   <span class="hljs-title function_">shape_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">shape_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span>;<br><span class="hljs-type">void</span>   <span class="hljs-title function_">shape_delete</span><span class="hljs-params">(Shape *shape)</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>shape.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><br><span class="hljs-comment">/* 多态方法: 通过虚表调用具体实现 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">shape_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-keyword">if</span> (shape &amp;&amp; shape-&gt;vtable &amp;&amp; shape-&gt;vtable-&gt;draw) &#123;<br>        shape-&gt;vtable-&gt;draw(shape);<br>    &#125;<br>    <span class="hljs-comment">// 可以添加错误处理</span><br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">shape_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-keyword">if</span> (shape &amp;&amp; shape-&gt;vtable &amp;&amp; shape-&gt;vtable-&gt;area) &#123;<br>        <span class="hljs-keyword">return</span> shape-&gt;vtable-&gt;area(shape);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>; <span class="hljs-comment">// 可以添加错误处理</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">shape_delete</span><span class="hljs-params">(Shape *shape)</span> &#123;<br>    <span class="hljs-built_in">free</span>(shape);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>circle.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> <span class="hljs-title">Circle</span>;</span><br>Circle *<span class="hljs-title function_">circle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>circle.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;circle.h&quot;</span></span><br><br><span class="hljs-comment">/* Circle 的私有定义 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> &#123;</span><br>    Shape base;  <span class="hljs-comment">// 继承 Shape(必须放在首位)</span><br>    <span class="hljs-type">double</span> radius;<br>&#125;;<br><br><span class="hljs-comment">/* Circle 的 draw 实现 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">circle_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Circle *circle = (<span class="hljs-type">const</span> Circle *)shape; <span class="hljs-comment">// 向下转型</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Circle (radius=%.2f)\n&quot;</span>, circle-&gt;radius);<br>&#125;<br><br><span class="hljs-comment">/* Circle 的 area 实现 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">circle_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Circle *circle = (<span class="hljs-type">const</span> Circle *)shape;<br>    <span class="hljs-keyword">return</span> M_PI * circle-&gt;radius * circle-&gt;radius;<br>&#125;<br><br><span class="hljs-comment">/* Circle 的虚表 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> ShapeVTable circle_vtable = &#123;<br>    .draw = circle_draw,<br>    .area = circle_area<br>&#125;;<br><br><span class="hljs-comment">/* Circle 构造函数 */</span><br>Circle *<span class="hljs-title function_">circle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br>    Circle *circle = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Circle));<br>    <span class="hljs-keyword">if</span> (circle) &#123;<br>        circle-&gt;base.vtable = &amp;circle_vtable;<br>        circle-&gt;radius = radius;<br>    &#125;<br>    <span class="hljs-keyword">return</span> circle;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>rectangle.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span> <span class="hljs-title">Rectangle</span>;</span><br>Rectangle *<span class="hljs-title function_">rectangle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height)</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>rectangle.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rectangle.h&quot;</span></span><br><br><span class="hljs-comment">/* Rectangle 的私有定义 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span> &#123;</span><br>    Shape base;  <span class="hljs-comment">// 继承 Shape(必须放在首位)</span><br>    <span class="hljs-type">double</span> width, height;<br>&#125;;<br><br><span class="hljs-comment">/* Rectangle 的 draw 实现 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rectangle_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Rectangle *rect = (<span class="hljs-type">const</span> Rectangle *)shape;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Rectangle (%.2f x %.2f)\n&quot;</span>, rect-&gt;width, rect-&gt;height);<br>&#125;<br><br><span class="hljs-comment">/* Rectangle 的 area 实现 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">rectangle_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Rectangle *rect = (<span class="hljs-type">const</span> Rectangle *)shape;<br>    <span class="hljs-keyword">return</span> rect-&gt;width * rect-&gt;height;<br>&#125;<br><br><span class="hljs-comment">/* Rectangle 的虚表 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> ShapeVTable rectangle_vtable = &#123;<br>    .draw = rectangle_draw,<br>    .area = rectangle_area<br>&#125;;<br><br><span class="hljs-comment">/* Rectangle 构造函数 */</span><br>Rectangle *<span class="hljs-title function_">rectangle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height)</span> &#123;<br>    Rectangle *rect = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Rectangle));<br>    <span class="hljs-keyword">if</span> (rect) &#123;<br>        rect-&gt;base.vtable = &amp;rectangle_vtable;<br>        rect-&gt;width = width;<br>        rect-&gt;height = height;<br>    &#125;<br>    <span class="hljs-keyword">return</span> rect;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;circle.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rectangle.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">/* 创建不同子类对象 */</span><br>    Circle *circle = circle_create(<span class="hljs-number">3.0</span>);<br>    Rectangle *rectangle = rectangle_create(<span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>);<br><br>    <span class="hljs-keyword">if</span> (!circle || !rectangle) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Memory allocation failed!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 用基类指针存储 */</span><br>    Shape *shapes[] = &#123;<br>        (Shape *)circle,<br>        (Shape *)rectangle,<br>    &#125;;<br><br>    <span class="hljs-comment">/* 多态调用 */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>        shape_draw(shapes[i]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Area: %.2f\n\n&quot;</span>, shape_area(shapes[i]));<br>    &#125;<br><br>    <span class="hljs-comment">/* 使用统一的删除接口 */</span><br>    shape_delete((Shape *)circle);<br>    shape_delete((Shape *)rectangle);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Circle (radius=3.00)<br>Area: 28.27<br><br>Rectangle (4.00 x 5.00)<br>Area: 20.00<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-4-重载"><a href="#3-4-重载" class="headerlink" title="3.4 重载"></a>3.4 重载</h3><ol>
<li><p><code>_Generic</code> 是 C11 引入的编译时类型选择机制.根据表达式的类型在编译期选择不同的代码分支</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">_Generic</span>(expression, \<br>    type1: value1,   \<br>    type2: value2,   \<br>    ...,             \<br>    <span class="hljs-keyword">default</span>: value   \<br>)<br></code></pre></td></tr></table></figure>

<ul>
<li><code>_Generic</code> 仅通过 <code>expression</code> 分析类型,不会计算 <code>expression</code></li>
<li><code>_Generic</code> 可以返回任意类型.如函数指针(然后立即进行函数调用,实现函数重载)</li>
<li><code>_Generic</code> 支持匹配各种类型.如指针, 数组, 结构体</li>
<li><code>_Generic</code> 会将 <code>const, volatile</code> 也作为区别类型的依据</li>
<li>必须有匹配到的类型. 若没有匹配到的类型且没有 <code>default</code>, 将会编译报错</li>
</ul>
</li>
<li><p>根据类型返回不同的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> type_name(X) _Generic((X), \</span><br><span class="hljs-meta">    int:     <span class="hljs-string">&quot;int&quot;</span>,                \</span><br><span class="hljs-meta">    double:  <span class="hljs-string">&quot;double&quot;</span>,             \</span><br><span class="hljs-meta">    char*:   <span class="hljs-string">&quot;string&quot;</span>,             \</span><br><span class="hljs-meta">    default: <span class="hljs-string">&quot;unknown&quot;</span>             \</span><br><span class="hljs-meta">)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, type_name(<span class="hljs-number">10</span>));      <span class="hljs-comment">// 输出 &quot;int&quot;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, type_name(<span class="hljs-number">3.14</span>));    <span class="hljs-comment">// 输出 &quot;double&quot;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, type_name(<span class="hljs-string">&quot;hello&quot;</span>)); <span class="hljs-comment">// 输出 &quot;string&quot;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, type_name(<span class="hljs-string">&#x27;A&#x27;</span>));     <span class="hljs-comment">// 输出 &quot;unknown&quot;(char 未定义)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>模拟函数重载</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">print_int</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;int: %d\n&quot;</span>, x); &#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">print_double</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;double: %f\n&quot;</span>, x); &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> print(X) _Generic((X), \</span><br><span class="hljs-meta">    int:    print_int,         \</span><br><span class="hljs-meta">    double: print_double       \</span><br><span class="hljs-meta">)(X) <span class="hljs-comment">/* 注意: 这里紧接着的 (X) 是函数调用 */</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    print(<span class="hljs-number">10</span>);   <span class="hljs-comment">// 调用 print_int</span><br>    print(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// 调用 print_double</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="4-算法分析"><a href="#4-算法分析" class="headerlink" title="4 算法分析"></a>4 算法分析</h2><h3 id="4-1-分析方法"><a href="#4-1-分析方法" class="headerlink" title="4.1 分析方法"></a>4.1 分析方法</h3><ol>
<li>基本概念<ul>
<li>数据结构: 组织大量数据的方法</li>
<li>算法分析: 对算法运行时间的评估</li>
<li><strong>算法(algorithm)</strong>: 为求解一个问题所需遵循的,被清楚指定的简单指令集合</li>
<li>当某种算法被给定时,则需要确定该算法所需的时间和空间等资源量</li>
</ul>
</li>
<li>建立无穷大量之间的相对级别<ul>
<li>$\mathrm{if} \quad \exists c,n_0\in N_+,N\geq n_0\quad\mathrm{s.t.} T(N)\leq cf(N), \mathrm{then} \quad T(N)&#x3D;O(f(N))$</li>
<li>$\mathrm{if} \quad \exists c,n_0\in N_+,N\geq n_0  \quad  \mathrm{s.t.} T(N)\geq cg(N),\mathrm{then} \quad T(N)&#x3D;\Omega(g(N))$</li>
<li>$T(N)&#x3D;O(h(N))  \quad and\quad T(N)&#x3D;\Omega(h(N)) \iff T(N)&#x3D;\Theta(h(N))$</li>
<li>$T(N)&#x3D;O(p(N)) \quad and \quad T(N)\neq \Theta(p(N)), \mathrm{then} \quad T(N)&#x3D;o(f(N))$</li>
</ul>
</li>
<li>简要说明<ul>
<li>$O$: 高阶无穷大</li>
<li>$\Omega$: 低阶无穷大</li>
<li>$\Theta$: 同阶无穷大</li>
<li>$o$: 严格的高阶无穷大</li>
</ul>
</li>
<li><strong>一般采用大 $O$ 记法</strong>.例如 $T(N)&#x3D;2N^2+N&#x3D;O(N^2)$<ul>
<li>不要将常数或低阶项放入大 $O$,直接忽略即可</li>
<li>典型的增长率(递增排列): $C, \mathrm{log}N, \mathrm{log}^2N, N, N\mathrm{log}N, N^2, N^3, 2^N$</li>
<li>可以使用洛必达法则确定两个函数的相对级别</li>
</ul>
</li>
<li>待分析的问题<ul>
<li>最重要的资源一般为运行时间</li>
<li>在这里分析对运行时间的影响因素有: 使用的算法, 对该算法的输入(主要方面)</li>
<li>考虑两个函数<ul>
<li>$T_{avg}(N)$: 输入为 N 时算法所花费的平均时间</li>
<li>$T_{worst}(N)$: 输入为 N 时算法在最坏情况下花费的时间</li>
<li><strong>主要考虑 $T_{worst}(N)$.因为它为所有的输入提供了一个运行时间上界</strong></li>
</ul>
</li>
<li>当两个程序花费的时间大致相同时,判断运行速度的方法是将其编码并运行</li>
<li>为简化分析,系数,低阶项,常数项直接抛弃.只计算其上界,即 大 $O$</li>
</ul>
</li>
</ol>
<h3 id="4-2-排序算法"><a href="#4-2-排序算法" class="headerlink" title="4.2 排序算法"></a>4.2 排序算法</h3><ol>
<li><p>排序算法接受的参数为: 数组首地址, 及一个表示数组元素个数的整数</p>
<ul>
<li>基于比较的排序: 假定对于元素而言,运算符 <code>&lt;, &gt;</code> 是存在的</li>
<li>逆序(inversion): 与线性代数中的关于排列的逆序数定义类似<ul>
<li>n 个互异数的数组的平均逆序数为 $\frac{n(n-1)}4$</li>
<li>通过交换相邻元素进行排序的任何算法平均需要 $\Omega(N^2)$</li>
<li>排序算法通过删除逆序进行,为了有效运行,必须每次删除不止一个逆序</li>
</ul>
</li>
</ul>
</li>
<li><p>排序的一般下界</p>
<ul>
<li>任何只用到比较的算法在最坏的情况下需要 $\Omega(N\log N)$ 次比较,因而归并排序和堆排序最优</li>
<li>任何只用到比较的算法在平均的情况下需要 $\Omega(N\log N)$ 次比较,因而快速排序是最优的</li>
</ul>
</li>
<li><p>桶排序(bucket sort)</p>
<ul>
<li>问题: 存在 $n$ 个整数 $a_i(0\leq x_i\leq M-1,1\leq i\leq n)$ 需要排序</li>
<li>预留一个大小为 $M$ 的 count 数组.即 count 有 $M$ 个单元(桶).初始情况下 count 内元素为空</li>
<li>当 $a_i$ 被读入时,$\mathrm{count}[a_i]$ 自增1;所有的输入被读入后,扫描数组 count,打印排好序的表</li>
<li>该算法的时间花费为 $O(M+N)$</li>
</ul>
</li>
<li><p>基数排序(radix sort)是桶式排序的推广</p>
<ul>
<li><p>考虑当桶的数量远大于数的个数时.桶排序便不再适合</p>
</li>
<li><p>若存在 $n$ 个整数 $a_i(0\leq x_i\leq n^p-1,1\leq i\leq n)$ 需要排序.进行多次桶式排序</p>
</li>
<li><p>第一步以最低位进行桶式排序,依次按位数桶式排序,直到最高位完成进行桶式排序</p>
</li>
<li><p>该算法的时间花费为 $O(p(n+b))$.其中 p 为趟数,n 为元素个数,b 为桶数</p>
</li>
<li><p>例: 对 0~9 的立方进行基数排序</p>
<ul>
<li>原始数组: [0, 1, 512, 343, 64, 125, 216, 27, 8, 729]</li>
<li>第一次排序结果: [0, 1, 512 ,343, 64, 125, 216, 27, 8, 729]</li>
<li>第二次排序结果: [8, 1, 0], [216, 512], [729,27,125],  [343], [64]</li>
<li>第三次排序结果: [64,27,8,1,0], [125], [216], [343], [512], [729]</li>
</ul>
</li>
</ul>
</li>
<li><p>插入排序(insert sort)</p>
<ul>
<li><p>将数组假想为两部分: 前面的为已排序数组,后面的为待排序数组</p>
</li>
<li><p>初始状态为已排序数组只有第一个元素,剩余为待排序数组</p>
</li>
<li><p>遍历待排序数组,将每个未排序元素插入到已排序数组中恰当的位置</p>
</li>
<li><p>时间复杂度: $O(N^2)$</p>
<ul>
<li>当输入数据为逆序时,达到此上界</li>
<li>当输入数据已排序时,运行时间为 $O(N)$</li>
<li>对于几乎已经排序的数据(逆序数 I 较小),插入排序很快,其时间为 $O(I+N)$</li>
</ul>
</li>
</ul>
</li>
<li><p>希尔排序(缩小增量排序, diminishing increment sort): 先将整个待排序的序列分割为若干子序列分别进行直接插入排序,待整个序列中的记录基本有序时,在对全体进行直接插入排序</p>
<ul>
<li><p>增量序列: $h_1, h_2, \dots,h_t$,其中 $h_1 &#x3D; 1$</p>
</li>
<li><p>$h_k$-排序数组: $\forall i,arr[i] \leq arr[i+h_k]$</p>
</li>
<li><p>希尔增量通常取 $h_t &#x3D; \lfloor n&#x2F;2 \rfloor, h_k &#x3D; \lfloor h_{k+1}&#x2F;2 \rfloor$</p>
</li>
<li><p>时间复杂度(希尔排序算法简单,但分析极其困难)</p>
<ul>
<li>希尔增量下的希尔排序的最坏情形运行时间 $\Theta(N^2)$</li>
<li>Hibbard 增量: 形如 $1, 3, 7, \dots , 2^k-1$.最坏情形运行时间 $\Theta(N^\frac32)$</li>
</ul>
</li>
</ul>
</li>
<li><p>堆排序(heap sort): 考虑建立二叉堆 $O(N)$,执行 N 次 <code>deleteMin</code> $O(N\log N)$.按照顺序,最小的元素将会先离开堆,将这些元素记录到第二个数组即可得到排序数组</p>
<ul>
<li>上述算法需要额外的数组空间,可以每次在 <code>deleteMin</code> 操作后,将最后空出来的单元用于存放元素.此时得到的将是逆序的排序数组,因而可以构建具有 <code>deleteMax</code> 操作的二叉堆</li>
<li>堆排序是非常稳定的算法: 平均使用的比较只比最坏情形略少</li>
</ul>
</li>
<li><p>归并排序(merge sort): 以分治递归的形式合并已排序数组 $O(N\log N)$.使用的比较次数几乎最优</p>
<ul>
<li>考虑合并2个已排序的数组: 设定2个指针分别指向数组的起始位置.比较2个指针指向的元素,将较小的元素放入输出数组,并移动指针.重复这一过程,直到某一指针到达末尾</li>
</ul>
</li>
<li><p>快速排序(quick sort): 实践中最快的已知排序算法,平均运行时间 $O(N\log N)$</p>
<ul>
<li><p>若 S 中元素个数为 0 或 1,则直接返回</p>
</li>
<li><p>选取 S 中的任意元素 v,其称为基准(pivot)</p>
</li>
<li><p>分区并排序: 将 $S-{v}$ 分为两个不相交集合: $S_1 &#x3D;{x\in S-{v}|x\leq v},S_2 &#x3D;{x\in S-{v}|x\geq v} $ </p>
</li>
<li><p>递归地将小于基准元素的子数列和大于基准值元素的子数组排序</p>
</li>
<li><p>选取基准</p>
<ul>
<li>错误的方式: 选取第一个元素作为基准.若输入是预排序或反序的,将会产生劣质的分割</li>
<li>安全的方式: 随机选取基准.但考虑到生成随机数是昂贵的,因而无法减少算法其余部分的平均运行时间</li>
<li>数中值分割法: 基准的最好选择是数组的中值,但这很难算出.因而可以考虑三个元素(左侧,中心,右侧位置)的中值作为基准.消除了预排序输入的坏情形,并减少约 5% 的时间</li>
</ul>
</li>
<li><p>分割策略</p>
<ul>
<li>将基准元与最后的元素进行交换,使得基准元离开要被分割的数据段</li>
<li>设置双指针 i, j. 初始时刻分别指向数组的第一个元素和倒数第二个元素(因为最后一个元素为基准)</li>
<li>当 i &lt; j 时,将 i 右移,直到遇到大于基准元的数.同理,将 j 左移,直到遇到小于基准元的数</li>
<li>若停止后的仍满足 i &lt; j,则将 i, j 指向的两个元素互换.重复该过程,直到 i, j 彼此交错</li>
<li>当 i, j 交错后,将基准元与 i 所指向的元素互换,即可完成分割</li>
</ul>
</li>
<li><p>对于小数组(n &lt; 20),快速排序不如插入排序好</p>
<ul>
<li>由于快速排序是递归的,因此小数组排序的情况经常发生</li>
<li>对小数组不进行递归排序,而进行插入排序将会节约15%的时间.截至范围可选择 n&#x3D;10</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="4-3-贪婪算法"><a href="#4-3-贪婪算法" class="headerlink" title="4.3 贪婪算法"></a>4.3 贪婪算法</h3><ol>
<li>贪婪算法分阶段工作.在每一个阶段,认为所作的决定是最好的,而不考虑将来的后果(即局部最优)<ul>
<li>当算法终止时,若局部最优就是全局最优,则算法正确.否则将得到一个次优解(suboptimal solution)</li>
<li>若不要求绝对最佳答案,也可通过简单的贪婪算法生成近似答案</li>
</ul>
</li>
<li>Huffman 编码<ul>
<li>ASCII 编码有约100个可打印字符和控制字符组成,需要 $\lceil \log 128\rceil&#x3D;7$ 位表示,可添加第8位作为校验位<ul>
<li>现实中,许多文件都含有大量的数字,空格和换行,而 q, x 很少</li>
<li>采用非等长编码,使经常出现的字符代码较短,可以节约磁盘空间</li>
</ul>
</li>
<li>对于代表字符的二进制代码,可以用二叉树来表示<ul>
<li>只在树叶上有数据.且每个字符从根节点开始,用0指示向左分支,用1指示向右分支</li>
<li>若字符 $c_i$ 在深度 $d_i$ 处,且出现 $f_i$ 次.则该字符代码的值(cost)为 $\sum d_i f_i$</li>
</ul>
</li>
</ul>
</li>
<li>Huffman 算法<ul>
<li>假设字符数量为 C.算法开始时存在 C 棵单节点树(每个字符一颗)</li>
<li>任意选取有最小权(树的权等于其树叶频率的和)的两棵树,任意形成以这两棵树为子树的新树</li>
<li>将这样的过程进行 C-1 次.即可得到最优 Huffman 编码树</li>
</ul>
</li>
</ol>
<h3 id="4-4-分治算法"><a href="#4-4-分治算法" class="headerlink" title="4.4 分治算法"></a>4.4 分治算法</h3><ol>
<li>分治(divide and conquer)算法<ul>
<li>分: 递归解决较小的问题(基本情况除外)</li>
<li>治: 从子问题的解 构建原问题的解</li>
</ul>
</li>
<li>最近点问题: 找出平面上点列中最近(欧几里得距离)的一对点<ul>
<li>暴力算法: 计算每个点对之间的距离,找出最小值 $O(N^2)$</li>
<li>分治算法思路<ul>
<li>将平面上的点分为两半,最近点对存在三种可能: 均在左, 均在右, 一个在左一个在右</li>
<li>记不同情况的最近点对的最小距离为: 左侧点集 $d_l$,右侧点集 $d_r$,两侧点间的距离 $d_c$</li>
<li>对于 $d_l, d_r$,可以递归的进行计算.关键在于如何计算 $d_c$</li>
</ul>
</li>
<li>$d_c$ 的计算<ul>
<li>令 $\delta &#x3D; \min(d_l, d_r)$.如果 $d_c$ 对 $\delta$ 有改进,则只需计算 $d_c$</li>
<li>若 $d_c$ 是这样的距离,则定义 $d_c$ 的两个点必然在分割线的 $\delta$ 邻域内(一个带状区域).限制考察点的数量</li>
<li>对于均匀分布的点集,则平均有 $O(\sqrt N)$ 个点位于邻域内,此时可采用暴力求解 $O(N)$</li>
</ul>
</li>
</ul>
</li>
<li>选择问题: 找出含有 N 个元素的表 S 中的第 k 个最小的元素(对于中位数 $k &#x3D; \lceil N&#x2F;2 \rceil$ 特别关注)<ul>
<li>通过对元素的快速排序,此问题以 $O(N\log N)$ 的最坏情形时间解决</li>
<li>五分化中项的中项 选择快速排序的基准<ul>
<li>将 N 个元素分为 $\lfloor N&#x2F;5 \rfloor$ 组,每5个元素一组,最多忽略4个元素</li>
<li>找出每组的中项,得到 $\lfloor N&#x2F;5 \rfloor$ 个中项的表 M,找出 M 的中项并返回</li>
</ul>
</li>
<li>使用五分化中项的中项的快速选择算法的运行时间为 $O(N)$.但实践中该算法并不实用</li>
</ul>
</li>
</ol>
<h3 id="4-5-动态规划"><a href="#4-5-动态规划" class="headerlink" title="4.5 动态规划"></a>4.5 动态规划</h3><ol>
<li><p>动态规划(dynamic programming)</p>
<ul>
<li>动态规划将复杂问题分解为相对简单的子问题.并通过存储子问题的解来避免重复计算.提高效率</li>
<li>数学递归公式均可直接翻译为递归算法,但现实中编译器往往不发正确对待递归算法,而导致低效</li>
<li>当这种情况发生时,便需要给编译器提供帮助.改写为非递归的算法,并将子问题的答案记录在一个表内</li>
</ul>
</li>
<li><p>示例: Fibonacci 数列</p>
<ul>
<li><p>自然递归效率非常低,是指数级别的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-1</span>) + fib(n<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>自顶向下的备忘录法(Top-Down with Memoization)</p>
<ul>
<li><p>从原问题开始,递归分解问题.在递归过程中检查子问题是否已经解决过(查表)</p>
</li>
<li><p>若没解决过,计算并存储结果; 若已经解决过,直接返回存储的结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 自顶向下的备忘录法.不推荐,仍然有递归的开销 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_N 100</span><br><span class="hljs-type">int</span> memo[MAX_N]; <span class="hljs-comment">// 备忘录.初始化为 -1 标记未计算</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fib_memo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 如果已经计算过.直接返回</span><br>    <span class="hljs-keyword">if</span> (memo[n] != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> memo[n];<br>    &#125;<br>    <span class="hljs-comment">// 基础情况直接进行赋值.fib(0) = 0; fib(1) = 1</span><br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>        memo[n] = n;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>    <span class="hljs-comment">// 计算并存储结果</span><br>    memo[n] = fib_memo(n<span class="hljs-number">-1</span>) + fib_memo(n<span class="hljs-number">-2</span>);<br>    <span class="hljs-keyword">return</span> memo[n];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>自底向上的表格法(Bottom-Up Tabulation)</p>
<ul>
<li><p>从最小的子问题开始,逐步构建更大规模问题的解</p>
</li>
<li><p>通常使用数组(DP 表)顺序存储所有子问题的解</p>
</li>
<li><p>循环迭代填充 DP 表,直到获得原问题的解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 自底向上的表格法.推荐做法 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fib_dp</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br><br>    <span class="hljs-comment">// 1. 创建 DP 表(实际上这里只需要前两个值.但为了演示使用数组)</span><br>    <span class="hljs-type">int</span> dp[n+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 2. 初始化已知的最小子问题的解</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 3. 自底向上填充 DP 表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>        dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];<br><br>    <span class="hljs-comment">// 4. 返回原问题的解</span><br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="5-数据结构"><a href="#5-数据结构" class="headerlink" title="5 数据结构"></a>5 数据结构</h2><h3 id="5-1-list"><a href="#5-1-list" class="headerlink" title="5.1 list"></a>5.1 list</h3><ol>
<li><p>表: 形如 $a_1, a_2,\dots ,a_n$ 的有限序列.其中 $a_i$ 为数据元素 </p>
<ul>
<li>其大小为 n (当 n&#x3D;&#x3D;0 称为空表,empty list)</li>
<li>表的操作: 创建空表, 插入, 删除, 查找, 获取, 修改, 清空, 获取长度</li>
<li>由于数组对于插入和删除元素的运行太慢,一般不用简单数组实现表</li>
</ul>
</li>
<li><p>链表: 由一系列的无需在内存中相连的结构组成</p>
<ul>
<li>每个结构含有表元素以及指向该元素后继元结构的指针(next 指针)</li>
<li>最后一个元素的 next 指针 指向 NULL</li>
<li>预留一个标志节点作为表头(head).其位置为0</li>
</ul>
</li>
<li><p>双链表: 在数据结构中增加一个域,使其指向前一个单元</p>
<ul>
<li><p>增加空间需求.因为需要额外存储一个指针</p>
</li>
<li><p>使得插入和删除的开销增加一倍.因为需要维护两个指针</p>
</li>
<li><p>简化删除操作.因为不再需要定位前驱元</p>
</li>
</ul>
</li>
<li><p>循环链表: 循环链表将链表的最后一个结点的指针指向头结点,形成一个环状结构</p>
</li>
<li><p>栈(stack): 限制插入和删除只能在一个位置(栈顶, top)进行的表</p>
<ul>
<li>栈的基本操作有: 入栈(push), 出栈(pop), 查看栈顶(peek &#x2F; top)</li>
<li>栈的特点: 后进先出(LIFO),且只有栈顶元素可访问</li>
<li>栈的链表实现及其操作不涉及栈的大小,因此均为常数时间开销.缺点在于需要承担 <code>malloc,free</code> 的开销</li>
<li>当栈采用头插法进行入栈,则头节点的后继元即为栈顶,因此出栈只需删除头节点的后继元</li>
</ul>
</li>
<li><p>队列(queue): 限制插入(队尾, rear)和删除(队头, front)只能在两端分别进行的表</p>
<ul>
<li>队列的基本操作有 入队(enqueue), 出队(dequeue)</li>
<li>队列的特点: 先进先出(FIFO);只有队头元素可访问</li>
<li>队列的链表实现的注意事项<ul>
<li>队列需要指向队头(front)和队尾(rear)的两个指针</li>
<li>当进行入队操作时,采用尾插法,且需要将 rear 指针向后移动一位</li>
<li>当进行出队操作时,需要先判断队列是否为空(front &#x3D;&#x3D; rear),然后删除 front 指针的后继元</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>优先队列</strong>(priority queue): 是允许至少插入(入队)和删除最小(出队: 删除最小元素)的数据结构</p>
<ul>
<li>使用简单链表: 在表头进行插入 $O(1)$,遍历链表以实现删除最小元 $O(n)$</li>
<li>始终让表保持排序状态: 进行顺序插入 $O(n)$ 和删除操作 $O(1)$</li>
<li>二叉查找树: 对插入和删除操作均为 $O(\log n)$</li>
</ul>
</li>
</ol>
<h3 id="5-2-hash"><a href="#5-2-hash" class="headerlink" title="5.2 hash"></a>5.2 hash</h3><ol>
<li><p>散列表(hash table): 高效的 <code>key-value</code> 映射数据结构.以 $O(1)$ 实现查找, 插入, 删除</p>
</li>
<li><p>映射函数(hash function): 将关键字映射到 [0, Table-Size) 区间中的某个数,且放到适当的单元中</p>
<ul>
<li>理想的映射函数应运算简单</li>
<li>相同的关键字必须始终产生相同的索引</li>
<li>不同的关键字应该尽可能均匀地映射到不同的索引上,减少冲突</li>
</ul>
</li>
<li><p>散列函数示例</p>
<ul>
<li><p>若输入的关键字为整数,一般采用返回 <code>key mod tableSize</code>.保证表的大小为素数时效果较好</p>
</li>
<li><p>若输入的关键字为字符串.可将字符串中的字符的 ASCII 码值之和作为关键字(简单,但当表很大时将会分配不均)</p>
</li>
</ul>
</li>
<li><p>冲突(collision): 两个关键字散列到同一个值</p>
<ul>
<li><p>当一个元素被插入处已存在另一个元素(即不同关键字的散列值相同),此时将产生冲突</p>
</li>
<li><p>解决冲突的方式有: 分离链接法(separate chaining), 开放定址法(open addressing)</p>
</li>
</ul>
</li>
<li><p>分离链接法: 将散列到同一个值的所有元素保存到一个表中</p>
<ul>
<li><p>插入操作: 遍历相应的表以检查该元素是否以处于适当的位置.如果是新元素,则将其插入到表的前端&#x2F;末尾</p>
</li>
<li><p>示例: 关键字为前10个数的平方(0, 1, 4, 9, 16, 25, 36, 49, 64, 81).散列函数为 $hash(x) &#x3D; x \space mod \space 10$</p>
</li>
<li><p>则分离链接散列表形如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">+-------+<br>| 索引0 | --&gt; [ (key=0, value=?) | next ] --&gt; NULL<br>+-------+<br>| 索引1 | --&gt; [ (key=81, value=?) | next ] --&gt; [ (key=1, value=?) | next ] --&gt; NULL<br>+-------+<br>| 索引2 | --&gt; NULL<br>+-------+<br>| 索引3 | --&gt; NULL<br>+-------+<br>| 索引4 | --&gt; [ (key=64, value=?) | next ] --&gt; [ (key=4, value=?) | next ] --&gt; NULL<br>+-------+<br>| 索引5 | --&gt; [ (key=25, value=?) | next ] --&gt; NULL<br>+-------+<br>| 索引6 | --&gt; [ (key=36, value=?) | next ] --&gt; [ (key=16, value=?) | next ] --&gt; NULL<br>+-------+<br>| 索引7 | --&gt; NULL<br>+-------+<br>| 索引8 | --&gt; NULL<br>+-------+<br>| 索引9 | --&gt; [ (key=49, value=?) | next ] --&gt; [ (key=9, value=?) | next ] --&gt; NULL<br>+-------+<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>开放定址法: 当冲突发生时,按照某种预定的探测序列在数组中寻找下一个空闲的桶</p>
<ul>
<li>考虑单元 $h_0(X),h_1(X),h_2(X), \cdots,$相继试选.其中 $h_i(X) &#x3D; (hash(x)+F(i))\mod \mathrm{tableSize}$</li>
<li>函数 $F$ 是冲突解决方法,且 $F(0) &#x3D; 0$ </li>
<li>开放地址法需要将所有数据置于表内,因此散列表较大.但省去了给新单元分配地址的时间</li>
</ul>
</li>
</ol>
<h3 id="5-3-tree"><a href="#5-3-tree" class="headerlink" title="5.3 tree"></a>5.3 tree</h3><ol>
<li><p>树的递归定义: 一棵<strong>树</strong>是一些节点的集合(可以是空集).若非空,则一棵树由称为<strong>根</strong>(root)的节点 r,以及0个或多个非空的(子)树 $T_1,T_2,\dots,T_k$ 组成,这些<strong>子树</strong>中的每一颗的根都被来自根 r 的一条有向边所连接</p>
<ul>
<li><strong>叶</strong>(leaf): 没有子节点的节点</li>
<li><strong>兄弟</strong>(sibling): 具有相同父节点的节点</li>
<li><strong>路径</strong>(path): 从节点 $n_1$ 到 $n_k$ 的路径为 $n_1, n_2,\dots,n_k$ 的一个序列.且对于 $1\leq i&lt;k$,有 $n_i$ 是 $n_{i+1}$ 的父节点</li>
<li><strong>路径的长</strong>(length): 路径上 边的条数,即 $k-1$.每一节点到自身的路径长为0</li>
<li><strong>深度</strong>(depth): 对于任意节点 $n_i$,其深度为从根到 $n_i$ 的唯一路径的长</li>
</ul>
</li>
<li><p><strong>二叉树</strong>: 每个节点的子节点都不超过2个的树</p>
<ul>
<li>平均二叉树的深度通常比节点数 N 小得多,平均深度为 $O(\sqrt N)$</li>
<li><strong>二叉查找树</strong>(binary search tree)的平均深度为 $O(\log N)$.但在最坏的情况下可以为 N-1</li>
<li>二叉树经常用于查找.给树中的每个节点指定一个关键字值(假定为整数,且唯一)</li>
</ul>
</li>
<li><p><strong>二叉查找树</strong>: 对于树中的每个节点 X,其左子树所有关键字值小于 X 关键字值,右子树所有关键字值大于 X 关键字值</p>
<ul>
<li>考虑到树的递归定义,对二叉查找树的操作通常采用递归处理</li>
<li>考虑到所有的元素都是有序的,因此假定运算符 <code>&lt;, =, &gt;</code> 均可用于这些元素</li>
</ul>
</li>
<li><p><strong>AVL树</strong>(Adelson-Velskii Landis): 带有平衡条件(需易保持)的二叉查找树.且保证树的深度为$O(\log N)$</p>
<ul>
<li>AVL 树要求每个节点的左子树和右子树的高度最多差1(空树的高度定义为-1)</li>
<li>AVL 树的高度最多为$1.44\log (N+2)-1.328$. 因此可以保证除插入外的操作(删除为惰性)均为 $O(\log N)$</li>
<li>AVL 树的插入操作可能会破坏平衡条件,因此隐含着困难.但总是可以经过修正(旋转)使得性质恢复</li>
</ul>
</li>
<li><p><strong>堆</strong>(heap): 被完全填满的二叉树(完全二叉树, complete binary tree),底层可以例外(从左到右填入)</p>
<ul>
<li>高为 h 的完全二叉树节点数为: $[2^h, 2^{h+1})$.因而完全二叉树的高是 $\lfloor \log N \rfloor$</li>
<li>完全二叉树可以用数组进行表示,而不需要指针</li>
<li>考虑位置为 i 的元素,其左子节点位于 2i,右子节点位于左子节点后的 2i+1,父节点位于 $\lfloor i&#x2F;2 \rfloor$ </li>
<li>堆数据结构将由 一个数组(无论关键字是什么类型), 一个代表最大值的整数, 当前堆大小的整数 组成</li>
</ul>
</li>
<li><p>堆序性质: 在一个堆中,对于任意节点 X, X 父节点的关键字小于 X 的关键字(根节点除外)</p>
<ul>
<li>考虑需要找出最小元,因此最小元应该在根上</li>
<li>将任意子树也视为一个堆,则任意节点应小于其所有后裔</li>
</ul>
</li>
</ol>
<h3 id="5-4-graph"><a href="#5-4-graph" class="headerlink" title="5.4 graph"></a>5.4 graph</h3><ol>
<li><p>图(graph): 由顶点(vertex)的集合 V,边(edge)的集合 E 组成</p>
<ul>
<li>每条边都是点对(v, w), 其中 $v,w\in V$</li>
<li>若点对是有序的,则图是有向(directed)的,称为有向图(digraph)</li>
<li>顶点 v, w 邻接等价于当 $(v,w)\in E$</li>
<li>边可以有第三种成分: 权(weight) 或 值(cost)</li>
</ul>
</li>
<li><p>图中的路径(path)</p>
<ul>
<li>路径是顶点序列: $w_1, w_2, \dots, w_N \space\space \mathrm{s.t.}(w_i,w_{i+1})\in E,1\leq i&lt;E$ </li>
<li>路径的长(length): 边的数量,即 N-1</li>
<li>环(loop): 从一个顶点到自身的边</li>
<li>简单路径: 所有的顶点都互异,但第一个和最后一个顶点可以相同</li>
</ul>
</li>
<li><p>图中的圈(cycle)</p>
<ul>
<li>有向图中的圈: 满足 $w_1 &#x3D; w_N$ 且长至少为1的一条路径</li>
<li>无向图中的圈则额外要求边是互异的</li>
</ul>
</li>
<li><p>连通(connected)</p>
<ul>
<li>在无向图中从每一个顶点到每个其他顶点都存在一条路径</li>
<li>在有向图中,这种性质称为强连通(strongly connected)</li>
<li>若有向图不是强连通的,但其基础图(underlying graph, 即去掉弧的方向)是连通的,则称为弱连通(weakly connected)</li>
<li>完全图(complete graph): 每个顶点间都存在一条边</li>
</ul>
</li>
<li><p>图的表示(有向图)</p>
<ul>
<li>使用一个二维数组,即**邻接矩阵(adjacent matrix)**表示<ul>
<li>对于每条边(u, v),置 <code>A[u][v] = 1</code>.其他元素为0</li>
<li>若该边有一个权,则可置 <code>A[u][v]</code> 等于该权.使用很大&#x2F;小的数表示不存在的边</li>
<li>若图是稀疏的(sparse), 该方法所需求的空间 $\Theta(|V|^2)$ 过大了</li>
</ul>
</li>
<li><strong>邻接表(adjacent list)</strong>: 对每一个顶点,使用一个表存放所有的邻接点<ul>
<li>空间需求为 $O(|E|+|V|)$</li>
<li>邻接表是图的标准表示方法</li>
</ul>
</li>
<li>考虑到实际中顶点都有名字,因此需要使用散列表建立名字到数字的映射<ul>
<li>散列表中对每个顶点存储一个名字和一个内部编号( 1 ~ |V| 之间)</li>
</ul>
</li>
</ul>
</li>
<li><p>输入一个赋权图: 与每条边 $(v_i, v_j)$ 联系的是穿越该弧的代价 $c_{i,j}$</p>
<ul>
<li>赋权路径长(weighted path length): $v_1v_2\dots v_N$ 路径的值为 $\sum\limits^{N-1}<em>{i&#x3D;1}c</em>{i,j}$</li>
</ul>
</li>
<li><p>单源最短路径问题: 给定赋权图 $G&#x3D;(V,E)$ 和特定顶点 s 作为输入,找出 s 到 G 每个点的最短赋权路径</p>
</li>
<li><p>无权最短路径</p>
<ul>
<li><p>广度优先搜索(breadth-first search): 按层处理顶点,距离最近的先辈赋值,最远的最后赋值</p>
</li>
<li><p>显然顶点s到自身距离为0,然后考察与s邻接的点,其距离为1.然后考察邻接的邻接,直到完成所有点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unWeigted</span><span class="hljs-params">(table t)</span> &#123;<br>    vertex v, w;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> currDist = <span class="hljs-number">0</span>; currDist &lt; numVetex; ++currDist)<br>        <span class="hljs-keyword">for</span> each vertex v<br>            <span class="hljs-title function_">if</span><span class="hljs-params">(!t[v].known &amp;&amp; t[v].dist == currDist)</span> &#123;<br>                t[v].known = True;<br>                <span class="hljs-keyword">for</span> each w adjacent to v<br>                    <span class="hljs-title function_">if</span><span class="hljs-params">(t[w].dist == infinity)</span> &#123;<br>                        t[w].dist = currDist + <span class="hljs-number">1</span>;<br>                        t[w].path = v;<br>                    &#125;<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Dijkstra 算法: 考虑赋权图的单源最短路径问题.仍借鉴无权时的思路</p>
<ul>
<li>顶点 s 到自身的距离为0,将其标记为已知,因为此时多了一个已知点,则可以获得其到达邻接点的距离</li>
<li>选取距离最小的点(贪心法,greedy algorithm)标记为已知,则有可以更新其到达邻接点的距离</li>
<li>重复该过程,直到获得到达目标点的最短距离</li>
<li>对于没有负值边的图,该算法总能完成.一旦出现负值边,则可能出现错误的答案</li>
</ul>
</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="category-chain-item">计算机</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="print-no-link">#计算机</a>
      
        <a href="/tags/Code/" class="print-no-link">#Code</a>
      
        <a href="/tags/C-%E8%AF%AD%E8%A8%80/" class="print-no-link">#C 语言</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C Language Advanced</div>
      <div>http://example.com/2023/05/03/Computer/C-Language-Advanced/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Shuang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年5月3日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/06/01/Tool/Linux/" title="Linux">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/05/01/Computer/C-Language-Basic/" title="C Language Basic">
                        <span class="hidden-mobile">C Language Basic</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
