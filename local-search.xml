<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>STM32 入门</title>
    <link href="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="STM32"><a href="#STM32" class="headerlink" title="STM32"></a>STM32</h1><h2 id="0-开发板介绍"><a href="#0-开发板介绍" class="headerlink" title="0 开发板介绍"></a>0 开发板介绍</h2><h3 id="0-1-STM32-开发板"><a href="#0-1-STM32-开发板" class="headerlink" title="0.1 STM32 开发板"></a>0.1 STM32 开发板</h3><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/0-STM32F103C8T6-Board-Features.jpg"></p><ol><li>使用右侧 SWD 接口下载程序及供电</li><li>32.768KHz 晶振: 连接到 LSE(low-speed external clock signal),给 RTC 提供时钟.<br>如果无需使用掉电不丢失时间的功能,可去掉.由内部 40KHz 的 RC 时钟源给 RTC 提供时钟</li><li>8MHz 晶振: 连接到 HSE(high-speed external clock signal),给 SYSCLK 提供时钟.<br>由于芯片内部的 HSI RC 时钟源不够精准,<strong>通常采用外部独立时钟源来为芯片提供系统时钟</strong></li></ol><h3 id="0-2-开发板引脚图"><a href="#0-2-开发板引脚图" class="headerlink" title="0.2 开发板引脚图"></a>0.2 开发板引脚图</h3><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/0-STM32F103C8T6-Blue-Pill-Pin-Layout.gif"></p><h3 id="0-3-最小系统板电路"><a href="#0-3-最小系统板电路" class="headerlink" title="0.3 最小系统板电路"></a>0.3 最小系统板电路</h3><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/0-%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E7%94%B5%E8%B7%AF.png"></p><ul><li>3V3 与 GND 间的 100pF 滤波电容: 保证供电电压的稳定</li><li><strong>晶振</strong>: 8MHz 晶振的典型电路.20pF 作为起振电容.接到芯片的5,6号脚.3,4号引脚预留接 32.768KHz 晶振</li><li><strong>复位</strong>: NRST 接到7号引脚,低电平复位<ul><li>刚上电时,电容充电,相当于短路,NRST 下拉至 GND(上电复位).充满电后短路,上拉至 3V3</li><li>之后,K1 断开时,NRST 拉至 3V3.K1 闭合时,电容放电,NRST 接地(手动复位)</li></ul></li><li><strong>启动配置</strong>: H1 起到开关的作用.实际中采用跳线帽的方式选择模式</li><li><strong>下载端口</strong>: SWDIO, SWCLK 分别接到芯片的34,37号引脚(PA13,14).正负极间同样可以加滤波电容</li></ul><h2 id="1-STM32"><a href="#1-STM32" class="headerlink" title="1 STM32"></a>1 STM32</h2><h3 id="1-1-STM32-命名规则"><a href="#1-1-STM32-命名规则" class="headerlink" title="1.1 STM32 命名规则"></a>1.1 STM32 命名规则</h3><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/1-STM32%E7%B3%BB%E5%88%97%E4%BA%A7%E5%93%81%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99.png"></p><h3 id="1-2-存储器和总线构架"><a href="#1-2-存储器和总线构架" class="headerlink" title="1.2 存储器和总线构架"></a>1.2 存储器和总线构架</h3><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/1-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png"></p><h3 id="1-3-STM32F103C8T6-引脚定义"><a href="#1-3-STM32F103C8T6-引脚定义" class="headerlink" title="1.3 STM32F103C8T6 引脚定义"></a>1.3 STM32F103C8T6 引脚定义</h3><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/1-STM32F103C8T6%E5%BC%95%E8%84%9A%E5%AE%9A%E4%B9%89.png"></p><h3 id="1-4-片上资源-外设"><a href="#1-4-片上资源-外设" class="headerlink" title="1.4 片上资源(外设)"></a>1.4 片上资源(外设)</h3><table><thead><tr><th>英文缩写</th><th>名称</th><th>英文缩写</th><th>名称</th></tr></thead><tbody><tr><td>NVIC</td><td>嵌套向量中断控制器</td><td>CAN</td><td>CAN 通信</td></tr><tr><td>SysTick</td><td>系统滴答定时器</td><td>USB</td><td>USB 通信</td></tr><tr><td>RCC</td><td>复位和时钟控制</td><td>RTC</td><td>实时时钟</td></tr><tr><td>GPIO</td><td>通用 IO 口</td><td>CRC</td><td>CRC 校验</td></tr><tr><td>AFIO</td><td>复用 IO 口</td><td>PWR</td><td>电源控制</td></tr><tr><td>EXTI</td><td>外部中断</td><td>BKP</td><td>备份寄存器</td></tr><tr><td>TIM</td><td>定时器</td><td>IWDG</td><td>独立看门狗</td></tr><tr><td>ADC</td><td>模数转换器</td><td>WWDG</td><td>窗口看门狗</td></tr><tr><td>DMA</td><td>直接内存访问</td><td>DAC</td><td>数模转换器</td></tr><tr><td>USART</td><td>同步 &#x2F; 异步串口通信</td><td>SDIO</td><td>SD 卡接口</td></tr><tr><td>I2C</td><td>I2C 通信</td><td>FSMC</td><td>可变静态存储控制器</td></tr><tr><td>SPI</td><td>SPI 通信</td><td>USB OTG</td><td>USB 主机接口</td></tr></tbody></table><h2 id="2-相关软件"><a href="#2-相关软件" class="headerlink" title="2 相关软件"></a>2 相关软件</h2><h3 id="2-1-开发必备"><a href="#2-1-开发必备" class="headerlink" title="2.1 开发必备"></a>2.1 开发必备</h3><ol><li><p><strong>Keil5 MDK: IDE, 集成开发环境</strong></p><ul><li><p>运行 <code>MDK542a.exe</code> 文件,更改安装路径后,一路点击 <code>next</code> 即可</p></li><li><p>软件注册: 以管理员身份运行 Keil5 -&gt; <code>File</code> -&gt; <code>License Management</code> -&gt; 复制 CID</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/2-%E6%B3%A8%E5%86%8CKeil.png"></p></li><li><p>运行 <code>keygen_new2032.exe</code> 文件 -&gt; 粘贴 <code>CID</code> -&gt; <code>Target</code> 选 <code>ARM</code> -&gt; 点击 <code>Generate</code> 生成序列码</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/2-keygen.png"></p></li><li><p>将序列码粘贴到 keil5 中的 <code>New License ID Code</code> 栏 -&gt; <code>ADD LIC</code></p></li></ul></li><li><p><strong>器件支持包: 对相应的 MCU 型号提供支持</strong></p><ul><li><p>离线安装: 下载后,运行相应的器件支持包文件即可(<code>Keil.STM32F1xx_DFP.2.2.0.pack</code>)</p></li><li><p>在线安装: 打开 Keil -&gt; <code>Pack Installer</code> -&gt; <code>Device</code> -&gt; <code>STMicroelectronics</code> -&gt; install 后缀 <code>DFP</code> 的文件</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/2-%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85%E5%99%A8%E4%BB%B6%E6%94%AF%E6%8C%81%E5%8C%85.png"></p></li></ul></li><li><p><strong>STLink 驱动</strong>: Keil5 安装目录中自带(<code>Keil5\ARM\STLink\USBDriver\dpinst_amd64.exe</code>)</p></li><li><p><strong>JLink 驱动</strong>: 同样位于 Keil5 安装目录中(<code>Keil5\ARM\Segger.JLink.exe</code>)</p></li><li><p><strong>USB 转串口驱动</strong>: 运行 <code>CH341SER.EXE</code></p></li><li><p>STM32 开发方式</p><ul><li>基于寄存器: STM32 结构复杂,寄存器数量太多,不推荐</li><li>基于库函数: 使用 ST 官方提供的函数,间接配置寄存器</li><li>基于 HAL 库: 图形化界面配置 STM32</li></ul></li><li><p>基于库函数需要 STM32 库函数的文件(固件库)</p></li></ol><h3 id="2-2-新建工程"><a href="#2-2-新建工程" class="headerlink" title="2.2 新建工程"></a>2.2 新建工程</h3><ol><li><p>在 Keil5 中 -&gt; <code>Project</code> -&gt; <code>New uVision Project</code> -&gt; 设置工程文件名(project) -&gt; 选择芯片型号</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/2-%E9%80%89%E6%8B%A9%E8%8A%AF%E7%89%87%E5%9E%8B%E5%8F%B7.png"></p></li><li><p><strong>添加固件库文件: 在工程目录中创建 Start 目录存放下列启动文件(STM32程序从启动文件开始执行)</strong></p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/2-Start%E6%96%87%E4%BB%B6%E5%A4%B9.png"></p></li><li><p><strong>将文件添加到工程</strong></p><ul><li><p>将左侧的 <code>Source Group 1</code> 改名为 <code>Start</code> -&gt; 右击后选择 <code>Add Existing Files to Group</code> 添加文件</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/2-%E6%B7%BB%E5%8A%A0%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6.png"></p></li><li><p>启动文件需要根据型号选择(这里选择仅 <code>startup_stm32f10x_md.s</code>)</p></li></ul></li><li><p><strong>添加文件夹的头文件路径</strong>: <code>Options</code> -&gt; <code>C/C++</code> -&gt; 在 <code>Include Paths</code> 栏添加路径</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/2-%E6%B7%BB%E5%8A%A0%E5%A4%B4%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84.png"></p></li><li><p><strong>编写测试函数</strong>: 首先创建 User 目录用于存放用户代码</p><ul><li><p>创建 <code>main.c</code> 文件并添加到工程</p><ul><li><p>右键 <code>Target</code> -&gt; <code>Add Group</code> 并将名称改为 <code>User</code> -&gt; 右键 <code>Add New item...</code></p></li><li><p>选择 <code>C File</code> -&gt; 名称设为 <code>main</code> -&gt; 修改文件存放路径为 <code>User</code> 目录</p></li></ul></li><li><p>测试配置: 打开 <code>main</code> 文件在空白处右击,选择 insert <code>#include file stm32f10x.h</code> -&gt; 编写任意代码 -&gt; <code>Build</code></p></li><li><p>若编译没有错误说明工程建立正常.到此可以进行<strong>基于寄存器的开发</strong>.如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;  <span class="hljs-comment">/* 点亮 PC13 的 LED */</span><br>RCC-&gt;APB2ENR |= <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<span class="hljs-comment">/* 开启 APB2 的 GPIOC 时钟 */</span><br>GPIOC-&gt;CRH |= <span class="hljs-number">3</span> &lt;&lt; (<span class="hljs-number">4</span> * (<span class="hljs-number">13</span> - <span class="hljs-number">8</span>));<span class="hljs-comment">/* 指定 GPIO_Pin_13 为推挽输出.50MHz */</span><br>GPIOC-&gt;ODR &amp;= !(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">13</span>);<span class="hljs-comment">/* 指定 GPIO_Pin_13 引脚的电压为低 */</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>连接最小系统板时需要选择对应的调试方式(这里使用 STLink)</p><ul><li><p><code>Options</code> -&gt; <code>Debug</code> -&gt; Use 栏选择 <code>ST-Link Debugger</code> -&gt; <code>Settings</code> -&gt; <code>Flash Download</code> -&gt; 勾选 <code>Reset and Run</code></p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/2-%E9%85%8D%E7%BD%AE%E8%B0%83%E8%AF%95%E6%96%B9%E5%BC%8F.png"></p></li></ul></li></ol><h3 id="2-3-添加库函数"><a href="#2-3-添加库函数" class="headerlink" title="2.3 添加库函数"></a>2.3 添加库函数</h3><ol><li><p>在工程新建 <code>Library</code> 目录,添加 <code>Libraries\STM32F10x_StdPeriph_Driver\src, inc</code> 目录下的所有文件(各23个)</p></li><li><p>将 <code>Project\STM32F10x_StdPeriph_Template</code> 目录下的三个文件添加到工程的 <code>User</code> 目录</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/2-User%E6%96%87%E4%BB%B6%E5%A4%B9.png"></p></li><li><p>添加全局宏定义</p><ul><li><p>打开 <code>&quot;stm32f10x.h&quot;</code> 文件,在文件末尾有条件编译语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_STDPERIPH_DRIVER</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x_conf.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>因此需要宏定义 <code>USE_STDPERIPH_DRIVER</code>: <code>Options</code> -&gt; 在 <code>C/C++ Define</code> 栏填 <code>USE_STDPERIPH_DRIVER</code></p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/2-%E5%AE%8F%E5%AE%9A%E4%B9%89.png"></p></li></ul></li><li><p>需要再次完成 <strong>将文件添加到工程,添加文件夹的头文件路径</strong> 步骤</p></li><li><p>至此可以进行<strong>基于库函数的开发</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-comment">/* 配置 GPIOC.并设置为: 推挽输出,引脚选中13, 速率50MHz */</span><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);<br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOC, &amp;GPIO_InitStructure);<br>GPIO_ResetBits(GPIOC, GPIO_Pin_13);  <span class="hljs-comment">// 将 PC13 置为低电平</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>库函数调用逻辑: 复位中断函数才是程序的入口(在复位后执行).其职责为调用 <code>SystemInit, main</code> 函数</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/2-%E5%B7%A5%E7%A8%8B%E6%9E%B6%E6%9E%84.png"></p></li></ol><h3 id="2-4-Keil5-使用"><a href="#2-4-Keil5-使用" class="headerlink" title="2.4 Keil5 使用"></a>2.4 Keil5 使用</h3><ol><li><strong>界面设置(Configuration)</strong><ul><li><code>Configuration</code> -&gt; <code>Color &amp; Fonts</code> -&gt; <code>C/C++ Editor files</code> -&gt; 设置字体及其大小</li><li><code>Configuration</code> -&gt; <code>Editor</code> -&gt; <code>Encoding</code> 改为 <code>UTF-8</code> 编码, <code>Tab Size</code> 改为4</li><li><code>Manage Project Items</code> -&gt; 可以调整左侧文件显示的顺序</li></ul></li><li>Keil 中直接写入汉字报错的解决方式<ul><li><code>Options</code> -&gt; <code>C/C++</code> -&gt; <code>Misc Controls</code> 栏填入 <code>--no-multibyte-chars</code></li></ul></li></ol><h3 id="2-5-串口下载"><a href="#2-5-串口下载" class="headerlink" title="2.5 串口下载"></a>2.5 串口下载</h3><ol><li><p>启动模式</p><table><thead><tr><th>BOOT1</th><th>BOOT 0</th><th>启动模式</th><th>说明</th></tr></thead><tbody><tr><td>X</td><td>0</td><td>主闪存存储器</td><td>主闪存存储器被选为启动区域,主要使用方式</td></tr><tr><td>0</td><td>1</td><td>系统存储器</td><td>系统存储器被选为启动区域,串口下载</td></tr><tr><td>1</td><td>1</td><td>内置 SRAM</td><td>内置SRAM被选为启动区域,程序调试</td></tr></tbody></table><ul><li><strong>当 boot0 选为0时.运行主程序</strong></li><li>当 boot0 选为1,boot1 选为0时.运行 <code>BootLoader</code> 程序</li><li>当 boot0 选为1,boot1 选为1时.进行程序调试</li></ul></li><li><p>FlyMcu 串口下载程序</p><ul><li><p>需要连接 USB转串口模块的 RX(PA9), TX(PA10), GND</p></li><li><p>需要工程生成的 HEX 文件(在 Keil 中 <code>Options for target</code> -&gt; <code>output</code> 勾选 <code>Creact HEX File</code>)</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/2-CreateHEX.png"></p></li><li><p><code>搜索串口</code> -&gt; bps 默认115200 -&gt; 选择下载的程序文件(.hex)</p></li><li><p>单片机引脚配置: 让STM32执行 <code>BootLoader</code> 程序</p><ul><li>将 Boot0 配置为1(插在右边), Boot1 配置为0(插在左边)</li><li>按下复位键,此时 STM32 将不断接收 USART1 的数据.刷新到主闪存</li></ul></li><li><p>点击<code>开始编程</code>.写入完成后,将 Boot0 配置为0(插在左边).按下复位键.程序开始执行</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/2-FlyMcu.png"></p></li></ul></li><li><p><strong>STM32 一键下载</strong>(需要搭建另外的电路)</p><ul><li>但是仍可以勾选<code>编程后执行</code>,反勾选<code>编程到FLASH时写选项字节</code></li><li>然后 boot0 选为1 -&gt; 按下复位键 -&gt; 下载程序.完成下载后程序会直接运行</li><li>原理为指定运行程序从 0800 0000 开始运行.复位其本质后仍执行 <code>BootLoader</code> 程序</li></ul></li><li><p>ST-LINK Utility(需连接 ST Link 下载)</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/2-ST-LINK-Utility.png"></p><ul><li><strong><code>Target</code> -&gt; <code>Option Bytes</code>(快捷键 Ctrl + B): 打开选项字节的设置页面</strong></li></ul></li></ol><h2 id="3-GPIO-输入输出"><a href="#3-GPIO-输入输出" class="headerlink" title="3 GPIO 输入输出"></a>3 GPIO 输入输出</h2><h3 id="3-1-GPIO-结构"><a href="#3-1-GPIO-结构" class="headerlink" title="3.1 GPIO 结构"></a>3.1 GPIO 结构</h3><ol><li><p>GPIO 基本结构</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/3-GPIO%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png"></p><ul><li>I&#x2F;O 引脚连接驱动器寄存器到 APB2</li><li>内核写入(读取)输出寄存器(输入寄存器),以此控制(读取) I&#x2F;O 引脚的高低电平</li></ul></li><li><p>IO 口的基本结构</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/3-IO%E5%8F%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png"></p></li><li><p>输入电路分析</p><ul><li><code>保护二极管</code>对输入电压进行限幅: 确保输入电压范围在 $V_{SS} \sim V_{DD}$</li><li><code>上拉电阻和下拉电阻</code>: 避免引脚悬空导致的输入数据不确定, 设定一个默认值<ul><li>上方闭合,下方断开: <strong>上拉输入模式,即默认高电平</strong></li><li>上方断开,下方闭合: <strong>下拉输入模式,即默认低电平</strong></li><li>开关均断开: <strong>浮空输入模式</strong></li></ul></li><li><code>施密特触发器</code>(图中翻译错误): 对输入电压整形,然后写入<code>输入数据寄存器</code><ul><li>输入电压大于某个上限,输出瞬间升为高电平;</li><li>输入电压小于某个下限,输出瞬间将为低电平;否则不变</li></ul></li><li>模拟输入, 复用功能输入<ul><li><strong>模拟输入</strong>需要连续量,因此在施密特触发器之前.连接到 ADC.此时 GPIO 失效</li><li><strong>复用功能输入</strong>(如串口的输入引脚)需要数字量,因此在施密特触发器之后</li></ul></li></ul></li><li><p>输出电路分析: 输出可由 <code>输出数据寄存器</code>(普通IO输出) 或 <code>片上外设</code>(<strong>复用功能输出</strong>) 控制</p><ul><li><code>位设置/清除寄存器</code>: 单独操作输出数据寄存器的某一位, 而不影响其他位<br>将需要置1的对应写1,其余写0,即可自动将相应位置置1,其他位不变</li><li><code>输出数据寄存器</code>: 输出整个寄存器的数据.只能整体写入,不能单独操作某一位</li><li><code>数据输出选择器</code>: 选择由输出数据寄存器或是复用功能输出</li><li><code>P-MOS, N-MOS</code>的作用: 输出控制<ul><li>当 P-MOS,N-MOS 均有效时为<strong>推挽输出</strong>, 高低电平均有驱动能力</li><li>当 P-MOS 无效, N-MOS 有效时为<strong>开漏输出</strong>,仅低电平具有驱动能力<ul><li>当数据寄存器为1时,N-MOS 断开,呈现出高阻态</li><li>当数据寄存器为0时,N-MOS 导通,输出低电平</li><li>开漏输出模式可以用于通信协议的驱动,如 I2C</li><li>开漏输出模式输出 5V 信号: 在 I&#x2F;O 口外接一个上拉电阻到 5V 电源正极</li></ul></li><li>当 P-MOS N-MOS 均无效时,<strong>输出关闭</strong>,端口电平由外部控制</li></ul></li></ul></li></ol><h3 id="3-2-标准库代码分析"><a href="#3-2-标准库代码分析" class="headerlink" title="3.2 标准库代码分析"></a>3.2 标准库代码分析</h3><ol><li><p>对 <code>stm32f10x_gpio.h, stm32f10x_gpio.c</code> 源码的分析</p></li><li><p><strong>头文件中的通用格式</strong>: 防止重复包含以及保证对 C++ 的兼容性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __STM32F10x_GPIO_H  <span class="hljs-comment">/* 防止头文件重复包含 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __STM32F10x_GPIO_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus  <span class="hljs-comment">/* 对 C++ 的兼容 */</span></span><br> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* 对 C++ 的兼容 */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __STM32F10x_GPIO_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>参数合理性判断</strong>: 对于后续编写的函数,需要判断传入参数是否为 GPIO.在调用函数前断言</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOB) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOC) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOD) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOE) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOF) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOG))</span><br><br><span class="hljs-comment">/* 分析: 断言参数 expr.若非零,则通过.否则断言失败,直接在编译时报错,并指出错误位置 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))</span><br></code></pre></td></tr></table></figure></li><li><p><strong>枚举定义</strong>: 初始化时,需要根据手册中的位组合确定模式时,提前对其定义.枚举非常多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 分析: 对于输出最大速率寄存器的组合,在这里直接定义为对应的值,方便使用 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>  GPIO_Speed_10MHz = <span class="hljs-number">1</span>,<span class="hljs-comment">/* MODE = 01 */</span><br>  GPIO_Speed_2MHz,<span class="hljs-comment">/* MODE = 10 */</span><br>  GPIO_Speed_50MHz<span class="hljs-comment">/* MODE = 11 */</span><br>&#125;GPIOSpeed_TypeDef;<br></code></pre></td></tr></table></figure></li><li><p>读取特定引脚的电平信号(寄存器操作)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 将 IDR 寄存器的值与引脚掩码按位与,获取其状态.如果非零,则返回 SET,否则为 RESET */</span><br><span class="hljs-keyword">if</span> ((GPIOx-&gt;IDR &amp; GPIO_Pin) != (<span class="hljs-type">uint32_t</span>)Bit_RESET)<br>bitstatus = (<span class="hljs-type">uint8_t</span>)Bit_SET;<br><span class="hljs-keyword">else</span><br>bitstatus = (<span class="hljs-type">uint8_t</span>)Bit_RESET;<br></code></pre></td></tr></table></figure></li><li><p>指定引脚电平(寄存器操作)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">GPIOx-&gt;BSRR = GPIO_Pin;<span class="hljs-comment">/* 将指定引脚电平置高 set */</span><br>GPIOx-&gt;BRR = GPIO_Pin; <span class="hljs-comment">/* 将指定引脚电平置低 reset */</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-3-GPIO-输出"><a href="#3-3-GPIO-输出" class="headerlink" title="3.3 GPIO 输出"></a>3.3 GPIO 输出</h3><ol><li><p><code>led.h</code> 头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LED_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED_H</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">led_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">led_on</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">led_off</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">led_turn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>led.c</code> 源文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;led.h&quot;</span></span><br><br><span class="hljs-comment">/* LED 状态定义: 低电平点亮对应0,若为高电平点亮则修改为1 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED_ON0</span><br><br><span class="hljs-comment">/* 引脚定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>LED_GPIO_CLK RCC_APB2Periph_GPIOC</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED_GPIO_PORT GPIOC</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED_GPIO_PIN GPIO_Pin_13</span><br><br><span class="hljs-comment">/* 初始化 LED 对应的 GPIO */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">led_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>RCC_APB2PeriphClockCmd(LED_GPIO_CLK, ENABLE);<br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>GPIO_InitStructure.GPIO_Pin = LED_GPIO_PIN;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(LED_GPIO_PORT, &amp;GPIO_InitStructure);<br><span class="hljs-keyword">if</span>(!LED_ON) <span class="hljs-comment">/* 若为低电平点亮,则设置 GPIO 初始化后默认为高电平 */</span><br>GPIO_SetBits(LED_GPIO_PORT, LED_GPIO_PIN);<br>&#125;<br><br><span class="hljs-comment">/* 点亮 led */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">led_on</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>GPIO_WriteBit(LED_GPIO_PORT, LED_GPIO_PIN, (BitAction)LED_ON);<br>&#125;<br><br><span class="hljs-comment">/* 熄灭 led */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">led_off</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>GPIO_WriteBit(LED_GPIO_PORT, LED_GPIO_PIN, (BitAction)(!LED_ON));<br>&#125;<br><br><span class="hljs-comment">/* 翻转 led */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">led_turn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (!GPIO_ReadOutputDataBit(LED_GPIO_PORT, LED_GPIO_PIN))<br>GPIO_SetBits(LED_GPIO_PORT, LED_GPIO_PIN);<br><span class="hljs-keyword">else</span><br>GPIO_ResetBits(LED_GPIO_PORT, LED_GPIO_PIN);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code> 测试程序(led 闪烁)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;led.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>led_init();<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>delay(<span class="hljs-number">500</span>);<br>led_turn();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-GPIO-输入"><a href="#3-4-GPIO-输入" class="headerlink" title="3.4 GPIO 输入"></a>3.4 GPIO 输入</h3><ol><li><p><code>key.h</code> 头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> KEY_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_H</span><br><br><span class="hljs-comment">/* 按键值定义: 无按键按下为0, UP 为1, DOWN 为2 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> KEY_NONE = <span class="hljs-number">0</span>, KEY_UP = <span class="hljs-number">1</span>, KEY_DOWN = <span class="hljs-number">2</span>,&#125; Key_Type;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">key_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br>Key_Type <span class="hljs-title function_">key_get</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>key.c</code> 源文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;key.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;delay.h&quot;</span></span><br><br><span class="hljs-comment">/* 按键状态定义: 0表示按下接地(低电平), 1表示未按下 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_ON0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_OFF1</span><br><br><span class="hljs-comment">/* 引脚定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>KEY1_GPIO_CLK RCC_APB2Periph_GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_GPIO_PORT GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_GPIO_PIN GPIO_Pin_1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY2_GPIO_CLK RCC_APB2Periph_GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY2_GPIO_PORT GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY2_GPIO_PIN GPIO_Pin_3</span><br><br><span class="hljs-comment">/* 初始化按键 GPIO */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">key_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>RCC_APB2PeriphClockCmd(KEY1_GPIO_CLK | KEY2_GPIO_CLK, ENABLE); <span class="hljs-comment">/*开启按键端口的时钟*/</span><br>    GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Pin = KEY1_GPIO_PIN; <br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; <span class="hljs-comment">/* 上拉输入 */</span><br>GPIO_Init(KEY1_GPIO_PORT, &amp;GPIO_InitStructure); <span class="hljs-comment">/* 初始化 key1 */</span><br><br>GPIO_InitStructure.GPIO_Pin = KEY2_GPIO_PIN; <br>GPIO_Init(KEY2_GPIO_PORT, &amp;GPIO_InitStructure);<span class="hljs-comment">/* 初始化 key2 */</span><br>&#125;<br><br><span class="hljs-comment">/* 阻塞式获取按键是否按下: 当按键按下时,代码阻塞,直到松手</span><br><span class="hljs-comment">*  流程: 检测 GPIO 的 IDR 寄存器.若为低电平,则延时消抖 -&gt; 等待松手 -&gt; 延时消抖 -&gt; 返回按键值</span><br><span class="hljs-comment">*  返回值: 返回0表示没有按键按下,返回其他值则表示有对应的按键按下 */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-type">static</span> <span class="hljs-title function_">key_pressed</span><span class="hljs-params">(GPIO_TypeDef* GPIOx, <span class="hljs-type">uint16_t</span> GPIO_Pin)</span> &#123;<br><span class="hljs-keyword">return</span> KEY_ON == GPIO_ReadInputDataBit(GPIOx, GPIO_Pin);<br>&#125;<br><br><span class="hljs-comment">/* 消抖函数 */</span><br><span class="hljs-type">void</span> <span class="hljs-type">static</span> <span class="hljs-title function_">deshaking</span><span class="hljs-params">(GPIO_TypeDef* GPIOx, <span class="hljs-type">uint16_t</span> GPIO_Pin)</span> &#123;<br>delay(<span class="hljs-number">20</span>); <span class="hljs-keyword">while</span>(key_pressed(GPIOx, GPIO_Pin))&#123;&#125;; delay(<span class="hljs-number">20</span>);<br>&#125;<br><br><span class="hljs-comment">/* 扫描按下的键值.按键映射为: KEY1 -&gt; UP, KEY2 -&gt; DOWN */</span><br>Key_Type <span class="hljs-title function_">key_get</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>Key_Type key = KEY_NONE;<br><span class="hljs-keyword">if</span> (key_pressed(KEY1_GPIO_PORT, KEY1_GPIO_PIN)) &#123;<br>deshaking(KEY1_GPIO_PORT, KEY1_GPIO_PIN);<br>key = KEY_UP;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key_pressed(KEY2_GPIO_PORT, KEY2_GPIO_PIN)) &#123;<br>deshaking(KEY2_GPIO_PORT, KEY2_GPIO_PIN);<br>key = KEY_DOWN;<br>&#125;<br><span class="hljs-keyword">return</span> key;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code> 测试代码(按键按下后 oled 屏幕显示对应键值)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;oled.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;key.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>oled_init();<br>key_init();<br>oled_show_string(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;KEY:&quot;</span>);<br>Key_Type key = KEY_NONE;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>key = key_get();<br><span class="hljs-keyword">if</span> (key == KEY_UP)&#123; <span class="hljs-comment">// key2 逻辑</span><br>oled_show_string(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;UP  &quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == KEY_DOWN) &#123; <span class="hljs-comment">// key1 逻辑</span><br>oled_show_string(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;DOWN&quot;</span>);<br>&#125; <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-5-定时器中断读取按键"><a href="#3-5-定时器中断读取按键" class="headerlink" title="3.5 定时器中断读取按键"></a>3.5 定时器中断读取按键</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 操作定义</span><br><span class="hljs-comment">** 短按: 按下时间 &lt; 1秒</span><br><span class="hljs-comment">** 长按: 按下时间 &gt; 1秒</span><br><span class="hljs-comment">** </span><br><span class="hljs-comment">** 按键事件</span><br><span class="hljs-comment">** 长按事件: 出现1次长按操作</span><br><span class="hljs-comment">** 单击事件: 1次短按后,间隔0.5秒内无操作</span><br><span class="hljs-comment">** 双击事件: 2次短按时间 &lt; 0.5秒.则这2次短按产生一次双击事件</span><br><span class="hljs-comment">** 特别的:   短按 + 0.5秒内长按不算双击.长按 + 0.5秒内短按也不算双击</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="4-EXTI-外部中断"><a href="#4-EXTI-外部中断" class="headerlink" title="4 EXTI 外部中断"></a>4 EXTI 外部中断</h2><h3 id="4-1-中断"><a href="#4-1-中断" class="headerlink" title="4.1 中断"></a>4.1 中断</h3><ol><li><p>中断系统</p><ul><li>中断允许微控制器在执行主程序的同时,对发生的特定事件做出及时响应</li><li>在 STM32 中,中断用于处理外部事件,如按键输入,定时器溢出,串口数据接收等</li><li><strong>中断处理程序: 一段特殊的代码,用于处理中断事件</strong></li><li>当中断发生时,自动跳转到对应中断向量表项中存储的中断处理程序地址,并执行其中的代码</li></ul></li><li><p>中断向量表</p><ul><li><strong>中断处理程序的入口地址存储在中断向量表中</strong></li><li>中断向量表是一个存储中断处理程序地址的数组,每个中断都有一个对应的向量表项</li></ul></li><li><p><strong>中断优先级: 每个中断都有一个优先级,用于确定中断的相对重要性</strong></p><ul><li>较高优先级的中断将优先处理,而较低优先级的中断可能会被延迟处理</li><li><strong>中断嵌套: 即在一个中断处理程序中,可以允许更高优先级的中断打断当前正在执行的中断处理程序.以确保对于紧急事件的及时响应</strong></li></ul></li></ol><h3 id="4-2-NVIC"><a href="#4-2-NVIC" class="headerlink" title="4.2 NVIC"></a>4.2 NVIC</h3><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/4-NVIC.png"></p><ol><li><strong>NVIC(Nested Vectored Interrupt Controller, 嵌套向量中断控制器)是内核外设</strong><ul><li>中断通道可以将 EXTI, TIM, ADC, USART… 作为输入</li><li>只有一条输出通道,根据中断优先级分配先后顺序</li></ul></li><li>优先级分组: 由优先级寄存器的4位决定<ul><li>优先级寄存器分为高 n 位的抢占优先级和低 (4-n) 位的响应优先级</li><li><strong>抢占优先级可以中断嵌套,响应优先级则需要进行排队</strong></li></ul></li></ol><h3 id="4-3-EXTI"><a href="#4-3-EXTI" class="headerlink" title="4.3 EXTI"></a>4.3 EXTI</h3><ol><li><p>EXTI 基本结构</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/4-EXTI.png"></p></li><li><p><strong>EXTI(Extern Interrupt, 外部中断)</strong></p><ul><li>EXTI 可以监测指定 GPIO 口的电平信号,当其指定的 GPIO 口产生电平变化时,EXTI 将立即向 NVIC 发出中断申请,经过 NVIC 裁决后即可中断 CPU 主程序,使 CPU 执行 EXTI 对应的中断程序</li><li>支持所有的 GPIO 口.但同 Pin 不能同时触发</li><li><strong>触发方式: 上升 &#x2F; 下降 &#x2F; 双边沿, 软件触发</strong></li><li>通道数: 16个 GPIO_Pin, PVD 输出, RTC 闹钟, USB 唤醒, 以太网唤醒</li></ul></li><li><p>响应方式</p><ul><li><strong>中断响应: 正常中断流程,申请中断</strong></li><li><strong>事件响应: 不申请中断,通向其他外设,触发其他外设的操作</strong></li></ul></li></ol><h3 id="4-4-AFIO"><a href="#4-4-AFIO" class="headerlink" title="4.4 AFIO"></a>4.4 AFIO</h3><ol><li><p><strong>AFIO 功能: 引脚复用功能重映射, 中断引脚选择</strong></p></li><li><p>中断引脚选择: PA0~PG0 只能有一个通过 AFIO 的选择到达 EXTI</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/4-AFIO.png"></p></li><li><p>AFIO 引脚重映射(以 TIM2 的 CH1 为例)</p><ul><li><p>TIM2 的 CH1 原本位于 PA0.可以将其重映射到 PA15</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/4-AFIO%E9%87%8D%E6%98%A0%E5%B0%84.png"></p></li><li><p>因此,可以使用部分重映射1或完全重映射实现使用 PA15 作为 TIM2 的 CH1</p></li><li><p>需要注意的是,PA15 原本的功能是作为 JTAG 的调试功能,因此还需要将其关闭,作为普通 GPIO 引脚</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/4-JTAG%E5%A4%B1%E8%83%BD.png"></p></li></ul></li><li><p>具体代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 实现 GPIO 重映射 */</span><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);  <span class="hljs-comment">// 重映射须开启 AFIO 时钟</span><br>GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE);  <span class="hljs-comment">// 将 TIM2 的引脚部分重映射1</span><br>GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);  <span class="hljs-comment">// 将 JTAG 引脚失能,作为普通 GPIO 引脚使用</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="4-5-代码"><a href="#4-5-代码" class="headerlink" title="4.5 代码"></a>4.5 代码</h3><ol><li><p><code>sensor.h</code> 头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SENSOR_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SENSOR_H</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sensor_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">sensor_get</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>sensor.c</code> 源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;delay.h&quot;</span></span><br><br><span class="hljs-type">uint16_t</span> sensor_count;<span class="hljs-comment">//全局变量，用于计数</span><br><br><span class="hljs-comment">/* 计数传感器初始化 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sensor_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-comment">/* GPIO 初始化 */</span><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);<br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOB, &amp;GPIO_InitStructure);<br><br><span class="hljs-comment">/* AFIO 选择中断引脚: 中断源为 PB14.使其电平信号可以通过 AFIO.进入 EXTI */</span><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);<br>GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);<br><br><span class="hljs-comment">/* EXTI 初始化: 外部触发中断模式,下降沿触发,开启中断</span><br><span class="hljs-comment">** 使得 PB14 引脚的电平信号可以通过 EXTI.进入 NVIC */</span><br>EXTI_InitTypeDef EXTI_InitStructure;<br>EXTI_InitStructure.EXTI_Line = EXTI_Line14;<br>EXTI_InitStructure.EXTI_LineCmd = ENABLE;<br>EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;<br>EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;<br>EXTI_Init(&amp;EXTI_InitStructure);<br><br><span class="hljs-comment">/* NVIC 中断分组: 2位抢占,2位响应.注意整个工程的 NVIC 分组只能设置为某一种 */</span><br>NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<br><br><span class="hljs-comment">/* NVIC 配置: 中断通道为 10~15,抢占优先级为1,响应优先级为1*/</span><br>NVIC_InitTypeDef NVIC_InitStructure;<br>NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn; <span class="hljs-comment">// 此处根据中断源选择中断通道</span><br>NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<br>NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="hljs-number">1</span>;<br>NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="hljs-number">1</span>;<br>NVIC_Init(&amp;NVIC_InitStructure);<br>&#125;<br><br><span class="hljs-comment">/* 获取计数传感器的计数值 */</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">sensor_get</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-keyword">return</span> sensor_count;<br>&#125;<br><br><span class="hljs-comment">/* 根据中断源确定中断函数名(位于启动文件中),并编写中断函数 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">EXTI15_10_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-comment">/* 因为 PIN15~10 均进入该中断函数,故需要获取中断标志,确定是 PB14 进入中断</span><br><span class="hljs-comment">    ** 而只要中断标志位置1,就会申请中断,因此中断函数中需要清除中断标志位 */</span><br><span class="hljs-keyword">if</span> (EXTI_GetITStatus(EXTI_Line14) == SET) &#123;<br><span class="hljs-comment">/* 实测传感器会抖动,加入延时再次判断即可解决 */</span><br>delay_us(<span class="hljs-number">100</span>);<br><span class="hljs-keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_14) == <span class="hljs-number">0</span>)<br>sensor_count++;<br>EXTI_ClearITPendingBit(EXTI_Line14);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code> 测试函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;oled.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sensor.h&quot;</span></span><br><br><span class="hljs-comment">/* 红外对射计次传感器: 信号连接于 PB14.每当遮光片移开时,count++ */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>oled_init();<br>sensor_init();<br>oled_show_string(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;count:&quot;</span>);<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>oled_show_num(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, sensor_get(), <span class="hljs-number">5</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>判断是否成功进入中断的方法</p><ul><li>进入调试模式,在中断函数设置一个断点</li><li>选择全速运行代码,手动触发一个中断条件,使代码进入中断</li><li>如果代码运行到设置的断点处,说明进入了中断</li></ul></li></ol><h2 id="5-TIM-定时器"><a href="#5-TIM-定时器" class="headerlink" title="5 TIM 定时器"></a>5 TIM 定时器</h2><h3 id="5-1-定时器"><a href="#5-1-定时器" class="headerlink" title="5.1 定时器"></a>5.1 定时器</h3><ol><li><p><strong>定时器: 对输入时钟计数,在计数值达到设定值时触发中断</strong></p><ul><li>基本定时功能: 每隔一段时间产生一个中断</li><li>定时器输出比较: 常用来产生 PWM 波形</li><li>定时器输入捕获: 测量方波频率</li><li>定时器编码器接口: 读取正交编码器的输出波形</li></ul></li><li><p>定时器类型</p><table><thead><tr><th><strong>类型</strong></th><th align="left"><strong>编号</strong></th><th><strong>总线</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>基本定时器</td><td align="left">TIM6 &amp; TIM7</td><td>APB1</td><td>定时中断, 主模式触发 DAC</td></tr><tr><td>通用定时器</td><td align="left">TIM2 ~ TIM5</td><td>APB1</td><td>拥有基本定时器全部功能. 额外具有: 内外时钟源选择,<br />输入捕获输出比较, 编码器接口, 主从触发模式等功能</td></tr><tr><td>高级定时器</td><td align="left">TIM1 &amp; TIM8</td><td>APB2</td><td>拥有通用定时器全部功能. 额外具有: 重复计数器,<br />死区生成, 互补输出, 刹车输入等功能</td></tr></tbody></table></li><li><p>基本定时器</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/5-%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A1%86%E5%9B%BE.png"></p><ul><li><strong>时基单元: 最基本的计数计时电路</strong><ul><li><code>PSC 预分频器</code>: 对 72MHz 的时钟进行预分频.实际分频系数 &#x3D; PSC + 1</li><li><code>CNT 计数器</code>: 对预分频后的时钟进行计数.每有一个上升沿,CNT ++</li><li><code>ARR 自动重装载寄存器</code>: 存储计数目标.<strong>当计数值 &#x3D;&#x3D; 重装值时,产生一个中断信号,并清零计数器</strong></li></ul></li><li><strong>主模式输出: 可以将定时器的更新事件映射到触发控制器(TRGO),TRGO 接到 DAC 的触发转换引脚</strong></li></ul></li><li><p>通用定时器</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/5-%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A1%86%E5%9B%BE.png"></p><ul><li><strong>通用计时器的时基单元: 通用定时器包含基本定时器的电路.时基单元是相似的</strong></li><li>内外时钟选择:<code>TIMx_ETR</code>引脚接一个外部方波时钟.经过<code>极性选择,边沿检测,预分频器,输入滤波</code>后分为两路<ul><li>向上进入<code>触发控制器</code>,作为时基单元的时钟</li><li>向下进入<code>TRGI</code>,用作触发输入.触发定时器的从模式</li></ul></li><li><code>ITR</code> 信号: 来自其他定时器从 <code>TRGO</code> 的输出</li><li><code>TIIF_ED</code>: 连接到输入捕获单元的 CH1 引脚</li><li><code>TI1FP1, TI2FP2</code>: 连接到输入滤波器和边沿检测器的后面</li><li><strong>主模式输出: TRGO 可将内部的事件映射到 TRGO 引脚</strong></li></ul></li><li><p>高级定时器</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/5-%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A1%86%E5%9B%BE.png"></p><ul><li>高级定时器包含了通用定时器的电路.额外增加了下列内容<ul><li>申请中断的后面加入一个 <code>REP</code> 重复次数计数器,可以每个几个计数周期才发生一次更新事件&#x2F;中断</li><li><code>DTG</code> 寄存器: 死区生成电路.右侧输出引脚变为了两个,可以输出一对互补的 PWM 波</li><li><code>TIMxBKIN</code>: 若 <code>TIMxBKIN</code> 引脚产生刹车信号或内部时钟失效,将由控制电路自动切断电机输出</li></ul></li></ul></li></ol><h3 id="5-2-时基单元"><a href="#5-2-时基单元" class="headerlink" title="5.2 时基单元"></a>5.2 时基单元</h3><ol><li><p>预分频时序图</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/5-%E8%AE%A1%E6%95%B0%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE1-2.png"></p><ul><li><p><code>预分频缓冲器(影子寄存器)</code>: 实际上起作用的寄存器.预分频控制寄存器修改后,为保证此计数周期内频率一致.<br>该修改并不立即生效,在本次计数结束后才生效.<code>自动加载寄存器, 捕获 / 比较寄存器</code>同样有影子寄存器</p></li><li><p>计数器计数频率公式<br>$$<br>\mathrm{CK_CNT} &#x3D; \frac{\mathrm{CK_PSC}}{\mathrm{(PSC +1)}}<br>$$</p></li></ul></li><li><p>计数器时序图</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/5-%E8%AE%A1%E6%95%B0%E5%99%A8%E6%97%B6%E5%BA%8F.png"></p><ul><li><strong>计数器溢出频率公式</strong><br>$$<br>\mathrm{freq} &#x3D; \frac{\mathrm{CK_CNT}}{\mathrm{(ARR + 1)}}<br>&#x3D; \frac{\mathrm{CK_PSC}}{\mathrm{(PSC +1)(ARR + 1)}}<br>$$</li></ul></li></ol><h3 id="5-3-RCC-时钟树"><a href="#5-3-RCC-时钟树" class="headerlink" title="5.3 RCC 时钟树"></a>5.3 RCC 时钟树</h3><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/5-RCC%E6%97%B6%E9%92%9F%E6%A0%91.png"></p><ol><li>RCC 产生和配置时钟,然后发送给各个外设的系统<ul><li><strong>时钟是所有外设运行的基础,需要最先配置</strong></li><li>左侧为时钟产生电路,右侧为时钟分配电路.中间的 <code>SYSCLK</code> 为系统时钟(72MHz)</li></ul></li><li><strong>程序在 <code>main</code> 函数之前会执行 <code>SystemInit</code> 函数,以配置时钟树</strong><ul><li>首先尝试以 线路1 按照 8MHz 频率运行,稳定后切换为 线路2</li><li>CSS 可以检测时钟运行是否正常.若出错会切换到内部时钟</li></ul></li></ol><h3 id="5-4-定时中断"><a href="#5-4-定时中断" class="headerlink" title="5.4 定时中断"></a>5.4 定时中断</h3><ol><li><p>定时中断基本结构</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/5-%E5%AE%9A%E6%97%B6%E4%B8%AD%E6%96%AD%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png"></p><ul><li>基本定时中断配置步骤:<ul><li>开启 RCC 的 TIM 外设时钟</li><li>时基单元的时钟源选择(选择内部时钟模式). 配置时基单元</li><li>配置中断输出控制,允许更新中断输出到 NVIC. 配置 NVIC,打开定时器的中断通道</li></ul></li></ul></li><li><p><code>timer.h</code> 头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> TIMER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIMER_H</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">timer_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>timer.c</code> 源文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><br><span class="hljs-comment">/* 定时中断初始化 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">timer_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-comment">/* 开启 TIM2 时钟 */</span><br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);<br><span class="hljs-comment">/* 配置时钟模式.设置为使用内部时钟驱动 TIM2 的时基单元 */</span><br>TIM_InternalClockConfig(TIM2);<br><br><span class="hljs-comment">/* 配置时基单元.滤波采样频率为1分频,向上计数.定时器重装频率为 72M/10000/7200 = 1Hz */</span> <br>TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;<br>TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;  <span class="hljs-comment">// 滤波采样分频</span><br>TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<br>TIM_TimeBaseInitStructure.TIM_Period = <span class="hljs-number">10000</span> - <span class="hljs-number">1</span>;<br>TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="hljs-number">7200</span> - <span class="hljs-number">1</span>;<br>TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 重复计数器.高级定时器才有</span><br>TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);<br><br><span class="hljs-comment">/* 由于上面的 TIM_TimeBaseInit 函数会生成一个更新事件,使得预分频寄存器和重复计数器的值立即生效</span><br><span class="hljs-comment">    ** 更新中断标志位此时被置1,初始化完成后便立即进入中断.所以在使能更新中断前要手动清除中断标志位 */</span><br>TIM_ClearFlag(TIM2, TIM_FLAG_Update);<br><br><span class="hljs-comment">/* 配置中断输出控制 */</span><br>TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);  <span class="hljs-comment">// 使能更新中断.开启更新中断到 NVIC 的通路</span><br>TIM_Cmd(TIM2, ENABLE);  <span class="hljs-comment">// 使能 TIM2</span><br><br><span class="hljs-comment">/* NVIC 中断分组 */</span><br>NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<br><span class="hljs-comment">/* NVIC 配置 */</span><br>NVIC_InitTypeDef NVIC_InitStructure;<br>NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;  <span class="hljs-comment">// 注意 TIM2 的通道为 TIM2_IRQn</span><br>NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<br>NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="hljs-number">2</span>;<br>NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="hljs-number">1</span>;<br>NVIC_Init(&amp;NVIC_InitStructure);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code> 测试函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;oled.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;timer.h&quot;</span></span><br><br><span class="hljs-type">uint16_t</span> second;<br><br><span class="hljs-comment">/* 程序现象: 屏幕每秒刷新 second 的值 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>oled_init();<br>timer_init();<br>oled_show_string(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;second:&quot;</span>);<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>oled_show_num(<span class="hljs-number">1</span>, <span class="hljs-number">12</span>, second, <span class="hljs-number">5</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* TIM2 中断函数(在启动文件中找到对应的中断函数名) */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">TIM2_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET) &#123;<br>second ++;  <span class="hljs-comment">// 中断函数代码...</span><br>TIM_ClearITPendingBit(TIM2, TIM_IT_Update);  <span class="hljs-comment">// 中断函数中需手动清除中断标志位</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用外部时钟的 TIM 配置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 将初始化TIM中的 TIM_InternalClockConfig(TIM2) 替换为以下代码即可选择外部时钟作为时钟源</span><br><span class="hljs-comment">** 通过 ETR 引脚的外部时钟配置 TIM2.并设置为不分频,极性为高电平或上升沿有效,滤波器强度0x0F */</span><br>TIM_ETRClockMode2Config(TIM2, TIM_ExtTRGPSC_OFF, TIM_ExtTRGPolarity_NonInverted, <span class="hljs-number">0x0F</span>);<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-5-输出比较"><a href="#5-5-输出比较" class="headerlink" title="5.5 输出比较"></a>5.5 输出比较</h3><ol><li><p><strong>OC(Output Compare, 输出比较)</strong></p><ul><li><strong>通过比较 CNT 和 CCR 寄存器值(CNT 计数自增,CCR 手动给定).</strong><br><strong>然后对输出电平 置1 &#x2F; 置0 &#x2F; 翻转,实现输出一定频率和占空比的 PWM 波形</strong></li><li>每个高级寄存器(前3个通道拥有死区生成和互补输出功能)和通用寄存器均拥有4个输出比较通道</li><li>CCR 被输入捕获和输出比较共用<ul><li>使用输入捕获时,CCR 作为捕获寄存器</li><li>使用输出比较时,CCR 作为比较寄存器</li></ul></li></ul></li><li><p><strong>PWM(Pulse Width Modulation 脉冲宽度调制)</strong></p><ul><li>在惯性系统中,可以通过对一系列脉冲的宽度进行调制,来等效地获得所需要的模拟参量</li><li>参数: 频率: $freq &#x3D; \frac{1}{T_S}$, 占空比: $duty &#x3D; \frac{T_{ON}}{T_S}$, 分辨率: 占空比变化步距(1%即可)<br>其中 $T_S$ 为周期(高低电平变化一次的时间), $T_{ON}$ 为周期中高电平的维持时间</li></ul></li><li><p>捕获 &#x2F; 比较通道</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/5-%E6%8D%95%E8%8E%B7%E6%AF%94%E8%BE%83%E9%80%9A%E9%81%93.png"></p></li><li><p>输出比较模式(输出模式控制器)</p></li></ol><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>冻结</td><td>CNT&#x3D;CCR 时,REF 保持为原状态.即维持为暂停时刻的状态不变</td></tr><tr><td>匹配时置有效电平</td><td>CNT&#x3D;CCR 时,REF 置有效电平</td></tr><tr><td>匹配时置无效电平</td><td>CNT&#x3D;CCR 时,REF 置无效电平</td></tr><tr><td>匹配时电平翻转</td><td>CNT&#x3D;CCR 时,REF 电平翻转</td></tr><tr><td>强制为无效电平</td><td>CNT 与 CCR 无效,REF 强制为无效电平</td></tr><tr><td>强制为有效电平</td><td>CNT 与 CCR 无效.REF 强制为有效电平</td></tr><tr><td><strong>PWM 模式1</strong></td><td>**向上计数: CNT &lt; CCR 时,REF 置有效电平;CNT ≥ CCR 时,REF 置无效电平**<br />向下计数: CNT &gt; CCR 时,REF 置无效电平;CNT ≤ CCR 时,REF 置有效电平</td></tr><tr><td><strong>PWM 模式2</strong></td><td>**向上计数: CNT &lt; CCR 时,REF 置无效电平,CNT ≥ CCR 时,REF 置有效电平**<br />向下计数: CNT &gt; CCR 时,REF 置有效电平,CNT ≤ CCR 时,REF 置无效电平</td></tr></tbody></table><ol start="5"><li><p>高级定时器输出比较(相较于通用定时器可以输出互补电平信号和产生死区)</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/5-%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83.png"></p><ul><li>输出 <code>OC1,OC1N</code> 分别接到外部推挽电路的控制极,2个推挽电路构成 H桥,3个推挽电路即可驱动三相无刷电机</li><li><code>死区生成器</code>: 在 MOS 管关闭时,进行一段延时,然后是另一个 MOS 管导通.防止因器件原因造成正负极短路</li></ul></li><li><p>PWM 基本结构</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/5-PWM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png"></p><ul><li>图示中蓝线为 CNT(不断自增); 红线为 CCR(手动设置); 黄线为 ARR(手动设置).PWM 模式1</li><li>输出 PWM 波形不需要进行中断申请</li></ul></li><li><p><strong>PWM 参数计算</strong></p><ul><li><p>已知 $\mathrm{CK_PSC}$, PSC, ARR, CCR.计算频率, 占空比, 分辨率</p><ul><li><p>频率:     $\mathrm{freq} &#x3D; \frac{\mathrm{CK_PSC}}{\mathrm{(PSC + 1)}\mathrm{(ARR + 1)}}$</p></li><li><p>占空比: $\mathrm{Duty} &#x3D; \frac{\mathrm{CCR}}{\mathrm{(ARR + 1)}}$</p></li><li><p>分辨率: $\mathrm{Reso} &#x3D; \frac{1}{(\mathrm{ARR} + 1)}$</p></li></ul></li><li><p>已知 时钟频率, PWM 频率, 占空比, 分辨率时.计算 PSC, ARR, CCR</p><ul><li>$\mathrm{ARR+1} &#x3D; \frac{1}{\mathrm{Reso}}$</li><li>$\mathrm{CCR} &#x3D; \frac{\mathrm{Duty}}{\mathrm{Reso}}$ </li><li>$\mathrm{PSC + 1} &#x3D; \frac{\mathrm{Reso\cdot CK_{PSC}}}{\mathrm{freq}}$</li></ul></li><li><p><strong>确定 PSC, ARR, CCR 的方式</strong></p><ul><li>首先根据分辨率决定 ARR.如要求分辨率为 1% 时, (ARR + 1) &#x3D; 100.此后固定 ARR 的值,方便计算</li><li>此时 CRR 值即为占空比的百分数.如 CCR &#x3D; 50 时,占空比 duty &#x3D; 50%.代码中改变 CRR,即可调节占空比</li><li>最后确定 PSC 的值.代码中改变 PSC,即可调节频率</li></ul></li></ul></li></ol><h3 id="5-6-PWM-输出"><a href="#5-6-PWM-输出" class="headerlink" title="5.6 PWM 输出"></a>5.6 PWM 输出</h3><ol><li><p><code>pwm.h</code> 头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> PWM_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PWM_H</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">pwm_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">pwm_set_compare</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> compare)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">pwm_set_prescaler</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> prescaler)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>pwm.c</code> 源文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><br><span class="hljs-comment">/* PWM 初始化 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pwm_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-comment">/* 开启 TIM2, GPIOA 时钟 */</span><br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);<br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);<br><br><span class="hljs-comment">/* GPIO 初始化 */</span><br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  <span class="hljs-comment">// 受外设控制的引脚需配置为复用模式</span><br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<br><br><span class="hljs-comment">/* 配置时钟源 */</span><br>TIM_InternalClockConfig(TIM2); <span class="hljs-comment">// 选择 TIM2 为内部时钟</span><br><br><span class="hljs-comment">/* 时基单元初始化 */</span><br>TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;<br>TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<br>TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<br>TIM_TimeBaseInitStructure.TIM_Period = <span class="hljs-number">1000</span> - <span class="hljs-number">1</span>;  <span class="hljs-comment">// ARR</span><br>TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="hljs-number">72</span> - <span class="hljs-number">1</span>;  <span class="hljs-comment">// PSC</span><br>TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="hljs-number">0</span>;  <span class="hljs-comment">//重复计数器.高级定时器才会用到</span><br>TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);<br>TIM_Cmd(TIM2, ENABLE);  <span class="hljs-comment">/* 使能 TIM2,定时器开始运行 */</span><br><br><span class="hljs-comment">/* 配置 OC */</span><br>TIM_OCInitTypeDef TIM_OCInitStructure;<br>TIM_OCStructInit(&amp;TIM_OCInitStructure);<br>TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;  <span class="hljs-comment">// PWM 模式1</span><br>TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;  <span class="hljs-comment">// 低电平为有效电平</span><br>TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;  <span class="hljs-comment">// 使能输出</span><br>TIM_OCInitStructure.TIM_Pulse = <span class="hljs-number">0</span>;  <span class="hljs-comment">// CCR</span><br>TIM_OC1Init(TIM2, &amp;TIM_OCInitStructure);  <span class="hljs-comment">// 初始化 TIM2 的通道1</span><br>&#125;<br><br><span class="hljs-comment">/* 设置 PWM 的 CCR(范围: 0~1000. 由 ARR+1 的值决定) */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pwm_set_compare</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> compare)</span> &#123;<br>TIM_SetCompare1(TIM2, compare);  <span class="hljs-comment">// 设置 CCR1 的值</span><br>&#125;<br><br><span class="hljs-comment">/* 设置 PWM 的 PSC(范围: 0~65535).freq = CK_PSC / (PSC + 1) / (ARR + 1) */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pwm_set_prescaler</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> prescaler)</span> &#123;<br>TIM_PrescalerConfig(TIM2, prescaler, TIM_PSCReloadMode_Immediate);  <span class="hljs-comment">// 设置 PSC 的值</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code> 测试函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;oled.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pwm.h&quot;</span></span><br><br><span class="hljs-comment">/* LED 连接于 PA0(低电平点亮).将会观察到类似呼吸灯的现象 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>oled_init();<br>pwm_init();<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">1000</span>; i++) &#123;<br>pwm_set_compare(i);  <span class="hljs-comment">// PWM 占空比逐渐增大,LED 逐渐变亮</span><br>delay(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 延时1ms,便于观察现象</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">1000</span>; i++) &#123;<br>pwm_set_compare(<span class="hljs-number">1000</span> - i);  <span class="hljs-comment">// PWM 占空比逐渐减小,LED 逐渐变暗</span><br>delay(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-7-输入捕获"><a href="#5-7-输入捕获" class="headerlink" title="5.7 输入捕获"></a>5.7 输入捕获</h3><ol><li><p><strong>IC(Input Capture 输入捕获)</strong></p><ul><li>输入捕获模式下<ul><li>当通道输入引脚出现指定电平跳变时,当前 CNT 的值将被锁存到 CCR 中</li><li>可用于测量 PWM 波形的频率, 占空比, 脉冲间隔, 电平持续时间等参数</li></ul></li><li>每个高级定时器和通用定时器都拥有4个输入捕获通道<ul><li>可配置为 PWMI 模式,同时测量频率和占空比</li><li>可配合主从触发模式,实现硬件全自动测量</li></ul></li></ul></li><li><p><strong>频率测量方法</strong></p><ul><li><strong>测频法</strong>: 在闸门时间 T 内对上升沿计次 N,则频率 $f_x &#x3D; \frac{N}{T}$</li><li><strong>测周法</strong>: 两个上升沿内以标准频率 $f_c$ 计次 N,则频率 $f_x &#x3D; \frac{f_c}{N}$</li><li><strong>中界频率</strong>: 测频法与测周法误差相等的频率 $f_m &#x3D; \sqrt{\frac{f_c}{T}}$</li></ul></li><li><p>捕获比较通道框图</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/5-%E6%8D%95%E8%8E%B7%E6%AF%94%E8%BE%83%E9%80%9A%E9%81%93%E6%A1%86%E5%9B%BE.png"></p></li><li><p>主从触发模式</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/5-%E4%B8%BB%E4%BB%8E%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F.png"></p><ul><li><strong>主模式: 可将定时器内部的信号映射到 TRGO 引脚,触发其他外设</strong></li><li><strong>从模式: 接收其他外设或使用自身外设的信号.用以控制自身控制器的运行</strong></li><li>触发源选择: 指定 从模式的触发信号 得到 TRGI,然后触发选定的从模式</li></ul></li><li><p>输入捕获基本结构</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/5-%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png"></p><ul><li>从GPIO口输入方波信号,经过<code>滤波器, 边沿检测, 极性选择</code>得到 <code>TI1FP1</code>,最后连接到 <code>CCR1</code></li><li>当<code>TI1FP1</code>出现上升沿,不断自增的 <code>CNT</code> 转运到 <code>CCR1</code> 中</li><li>同时,触发源选择为 <code>TI1FP1</code>,从模式配置为 <code>Reset</code>.当 <code>TI1FP1</code> 出现上升沿,<code>CNT</code> 自动清零,再次自增</li></ul></li><li><p>PWMI 基本结构</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/5-PWMI%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png"></p><ul><li>PWMI 与 输入捕获的区别在于使用2个通道捕获同一 GPIO,可以同时测量周期和占空比</li><li>当上升沿来临,<code>TI1FP1</code> 触发,<code>CCR1</code> 捕获,清零 <code>CNT</code></li><li><code>TI1FP2</code>配置为下降沿触发.当下降沿来临,<code>TI1FP2</code> 触发,<code>CCR2</code> 捕获,不清零 <code>CNT</code></li><li>因而 <code>CCR2</code> 的值反映高电平维持时间,<code>CCR1</code> 的值反映周期的时间.占空比为 $\frac{CCR2}{CCR1}$</li></ul></li></ol><h3 id="5-8-频率测量"><a href="#5-8-频率测量" class="headerlink" title="5.8 频率测量"></a>5.8 频率测量</h3><ol><li><p><code>ic.h</code> 头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> IC_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IC_H</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ic_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ic_get_freq</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ic_get_duty</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>ic.c</code> 源文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><br><span class="hljs-comment">/* 输入捕获初始化 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ic_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-comment">/* 开启 TIM3, GPIOA 时钟*/</span><br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);<br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);<br><br><span class="hljs-comment">/* GPIO 初始化 */</span><br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<br><br><span class="hljs-comment">/* 配置时钟源.选择 TIM3 为内部时钟 */</span><br>TIM_InternalClockConfig(TIM3);<br><br><span class="hljs-comment">/* 时基单元初始化 */</span><br>TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;<br>TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<br>TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<br>TIM_TimeBaseInitStructure.TIM_Period = <span class="hljs-number">65536</span> - <span class="hljs-number">1</span>;  <span class="hljs-comment">// ARR</span><br>TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="hljs-number">72</span> - <span class="hljs-number">1</span>;  <span class="hljs-comment">// PSC</span><br>TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="hljs-number">0</span>;<br>TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);<br><br><span class="hljs-comment">/* PWMI 模式初始化 */</span><br>TIM_ICInitTypeDef TIM_ICInitStructure;<br>TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;  <span class="hljs-comment">// 选择配置定时器通道1</span><br>TIM_ICInitStructure.TIM_ICFilter = <span class="hljs-number">0xF</span>;  <span class="hljs-comment">// 输入滤波器参数.过滤信号抖动</span><br>TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;  <span class="hljs-comment">//极性.上升沿触发捕获</span><br>TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;  <span class="hljs-comment">// 捕获预分频.不分频,每次信号都触发捕获</span><br>TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;  <span class="hljs-comment">// 输入信号交叉.选择直通</span><br>TIM_PWMIConfig(TIM3, &amp;TIM_ICInitStructure);  <span class="hljs-comment">// 把另一个通道配置为相反的配置,实现 PWMI 模式</span><br><br><span class="hljs-comment">/* 选择触发源及从模式.TI1 产生上升沿时,会触发 CNT 归零 */</span><br>TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);  <span class="hljs-comment">// 触发源选择 TI1FP1</span><br>TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);  <span class="hljs-comment">// 从模式选择复位</span><br><br><span class="hljs-comment">/* TIM 使能.使能TIM3，定时器开始运行 */</span><br>TIM_Cmd(TIM3, ENABLE);<br>&#125;<br><br><span class="hljs-comment">/* 获取输入捕获的频率.测周法.频率 fx = fc / N */</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ic_get_freq</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1000000</span> / (TIM_GetCapture1(TIM3) + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/* 获取输入捕获的占空比.占空比 Duty = CCR2 / CCR1 * 100 */</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ic_get_duty</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-keyword">return</span> (TIM_GetCapture2(TIM3) + <span class="hljs-number">1</span>) * <span class="hljs-number">100</span> / (TIM_GetCapture1(TIM3) + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code> 测试函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;oled.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pwm.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ic.h&quot;</span></span><br><br><span class="hljs-comment">/* 使用导线连接 PA0 与 PA6.将会观察到屏幕显示 freq, duty */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>oled_init();<br>pwm_init();<br>ic_init();<br>oled_show_string(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Freq:00000Hz&quot;</span>);<br>oled_show_string(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Duty:00%&quot;</span>);<br>pwm_set_prescaler(<span class="hljs-number">720</span> - <span class="hljs-number">1</span>);  <span class="hljs-comment">// PWM 频率 freq = 72M / (PSC + 1) / 100</span><br>pwm_set_compare(<span class="hljs-number">50</span>);  <span class="hljs-comment">// PWM 占空比 duty = CCR / 100</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>oled_show_num(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, ic_get_freq(), <span class="hljs-number">5</span>);<br>oled_show_num(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, ic_get_duty(), <span class="hljs-number">5</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-9-编码器"><a href="#5-9-编码器" class="headerlink" title="5.9 编码器"></a>5.9 编码器</h3><ol><li><p>编码器接口(Encoder Interface)</p><ul><li>编码器接口可接收增量(正交)编码器的信号<ul><li>根据编码器旋转产生的正交信号脉冲</li><li>自动控制 CNT 自增或自减,从而指示 编码器的位置, 旋转方向, 旋转速度</li></ul></li><li>每个高级定时器和通用定时器都拥有1个编码器接口</li><li>编码器接口的两个输入引脚借用了输入捕获的通道1和通道2</li></ul></li><li><p>正交编码器</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/5-%E6%AD%A3%E4%BA%A4%E7%BC%96%E7%A0%81%E5%99%A8.png"></p><ul><li>由于正转和反转输出的波形一致,故仅凭一项输出信号无法判断旋转方向.因此需要 A, B相</li><li>A相与B相 相位差90°.每当出现边沿变化时,判断另一相的状态,对照右侧表格,即可确定旋转方向</li></ul></li><li><p>编码器接口基本结构</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/5-%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png"></p><ul><li><p>当编码器正转时,CNT++; 反转时,CNT–.结合固定的闸门时间,即可完成测速任务</p></li><li><p><code>TI1FP1, TI2FP2</code>来自 GPIO 端口输入.<strong>类似于一个外部时钟源,配置为编码器模式</strong></p><ul><li>因此此时 PSC 建议设为 0,不进行分频.ARR 设为 65535,最大</li></ul></li><li><p>配置 GPIO 为输入模式 -&gt; 配置时基单元 -&gt; 配置输入捕获单元 -&gt; 配置编码器接口(下行代码)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 编码器接口配置.并设置为: 定时器3, 选择编码器模式, TI1, TI2都计数, 不反相</span><br><span class="hljs-comment">** 注意此时参数的 Rising 和 Falling 不再代表上升沿和下降沿了,而是代表是否反相</span><br><span class="hljs-comment">** 此函数必须在输入捕获初始化之后进行,否则输入捕获的配置会覆盖此函数的部分配置 */</span><br>TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12,<br>                           TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>编码器测速</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int16_t</span> speed;  <span class="hljs-comment">// 速度变量</span><br><br><span class="hljs-comment">/* 获取编码器的增量值.在编码器模式下,CNT 会根据编码器信号自动进行加减 */</span><br><span class="hljs-type">int16_t</span> <span class="hljs-title function_">Encoder_Get</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-type">int16_t</span> tmp = TIM_GetCounter(TIM3); <span class="hljs-comment">// 使用 tmp 缓存 CNT</span><br>TIM_SetCounter(TIM3, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 清零 CNT</span><br><span class="hljs-keyword">return</span> tmp;  <span class="hljs-comment">// 注意 CNT 类型为 uint16_t,这里隐式转为了 int16_t</span><br>&#125;<br><br><span class="hljs-comment">/* 将编码器的 A,B相分别连接到 PA6, PA7.旋转编码器可以获取转速 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>oled_init();<br>timer_init();<br>encoder_init();<br>oled_show_string(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Speed:&quot;</span>);<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>oled_show_signed_num(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, speed, <span class="hljs-number">5</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* TIM2 中断函数.这里使用 TIM2 定时中断 1s,作为闸门时间,计算速度 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">TIM2_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET) &#123;<br>speed = encoder_get();  <span class="hljs-comment">// 每隔固定时间段读取一次编码器计数增量值,即为速度值</span><br>TIM_ClearITPendingBit(TIM2, TIM_IT_Update);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-ADC"><a href="#6-ADC" class="headerlink" title="6 ADC"></a>6 ADC</h2><h3 id="6-1-ADC-功能"><a href="#6-1-ADC-功能" class="headerlink" title="6.1  ADC  功能"></a>6.1  ADC  功能</h3><ol><li><p><strong>ADC(Analog-Digital Converter, 模拟-数字转换器)</strong></p><ul><li>作用: 可将引脚上连续变化的模拟电压 转换为内存中存储的数字变量</li><li>18个输入通道: 可测量16个外部(GPIO)和2个内部信号源(温度传感器,内部参考电压)<ul><li>输入电压范围: 0 ~ 3.3V</li><li>分辨率为 12位: 即表示范围 $0 \sim 2^{12}-1$</li><li>1$\mu$s 转换时间: 即开始转换到产生结果耗时.对应频率为 1MHz</li></ul></li><li>STM32 增强功能: 规则组和注入组两个转换单元</li></ul></li><li><p>逐次逼近型 ADC 结构(<code>ADC0809</code> 内部结构图, 8位逐次逼近型)</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/6-%E9%80%90%E6%AC%A1%E9%80%BC%E8%BF%91%E5%9E%8BADC.png"></p></li><li><p>ADC 框图</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/6-ADC%E6%A1%86%E5%9B%BE.png"></p></li><li><p>ADC 基本结构</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/6-ADC%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png"></p><ul><li>配置 GPIO 为模拟输入模式 -&gt; 配置数据选择器 -&gt; 配置 ADC 转换器 -&gt; 开启 ADC</li></ul></li><li><p><strong>规则组的转换模式</strong></p><ul><li>单次转换: 在一次转换结束后,转换结果存放在数据寄存器中,置 EOC 标志位,结束转换</li><li>连续转换: 在一次转换结束后,置 EOC 标志位,立即开始下一轮的转换</li><li>非扫描模式: 规则组的序列只有一个通道有效.即只处理一个通道的信号</li><li>扫描模式: 规则组的序列有效,一次转换多个通道的信号</li></ul></li><li><p>ADC 转换触发控制</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/6-ADC12%E8%A7%84%E5%88%99%E9%80%9A%E9%81%93%E7%9A%84%E5%A4%96%E9%83%A8%E8%A7%A6%E5%8F%91.png"></p></li><li><p>数据对齐: 对于一个12位ADC,其转换结果为12位数据.而数据寄存器为16位,需进行数据对齐</p><ul><li><strong>右对齐: 有效数据右对齐,左边补0</strong></li><li>左对齐: 有效数据左对齐,右边补0</li></ul></li><li><p>转换时间(采样, 保持, 量化, 编码)</p><ul><li>ADC 的总转换时间: <code>T = 采样时间 + 12.5 * ADC 周期</code></li><li>采样时间可在程序中配置.量化编码因是12位 ADC,需要 12.5 个周期</li><li>例: 采样时间配置为1.5, ADC 频率为14MHz,则总转换时间为14个 ADC 周期,即 1us</li></ul></li></ol><h3 id="6-2-ADC-代码"><a href="#6-2-ADC-代码" class="headerlink" title="6.2 ADC 代码"></a>6.2 ADC 代码</h3><ol><li><p><code>ad.h</code> 头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> AD_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AD_H</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ad_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ad_get_value</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>ad.c</code> 源文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><br><span class="hljs-comment">/* ADC 初始化 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ad_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-comment">/* 开启 ADC1, GPIOA 时钟 */</span><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);<br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);<br><br><span class="hljs-comment">/* 设置 ADC 时钟分频 */</span><br>RCC_ADCCLKConfig(RCC_PCLK2_Div6);  <span class="hljs-comment">// 6分频. ADCCLK = 72MHz / 6 = 12MHz</span><br><br><span class="hljs-comment">/* GPIO 初始化 */</span><br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOA, &amp;GPIO_InitStructure);  <span class="hljs-comment">// 将 PA0 引脚初始化为模拟输入</span><br><br><span class="hljs-comment">/* 规则组通道配置.规则组序列1的位置,配置为通道0 */</span><br>ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="hljs-number">1</span>, ADC_SampleTime_55Cycles5);<br><br><span class="hljs-comment">/* ADC 初始化 */</span><br>ADC_InitTypeDef ADC_InitStructure;<br>ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;  <span class="hljs-comment">// 独立模式.即单独使用 ADC1</span><br>ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;  <span class="hljs-comment">// 数据右对齐</span><br>ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;  <span class="hljs-comment">// 软件触发,不需要外部触发</span><br>ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;  <span class="hljs-comment">// 连续转换失能.每转换一次规则组序列后停止</span><br>ADC_InitStructure.ADC_ScanConvMode = DISABLE;  <span class="hljs-comment">// 扫描模式失能.只转换规则组的序列1这一个位置</span><br>ADC_InitStructure.ADC_NbrOfChannel = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 通道数.非扫描模式下只能是1</span><br>ADC_Init(ADC1, &amp;ADC_InitStructure);<br>ADC_Cmd(ADC1, ENABLE);  <span class="hljs-comment">/* ADC 使能.使能 ADC1 */</span><br><br><span class="hljs-comment">/* ADC 校准.固定流程,内部有电路会自动执行校准 */</span><br>ADC_ResetCalibration(ADC1);  <span class="hljs-comment">// 复位校准</span><br><span class="hljs-keyword">while</span> (ADC_GetResetCalibrationStatus(ADC1) == SET);  <span class="hljs-comment">// 等待复位完成</span><br>ADC_StartCalibration(ADC1);  <span class="hljs-comment">// 启动校准</span><br><span class="hljs-keyword">while</span> (ADC_GetCalibrationStatus(ADC1) == SET);  <span class="hljs-comment">// 等待校准完成</span><br>&#125;<br><br><span class="hljs-comment">/* 获取 ADC 转换的值(范围: 0~4095) */</span><br><span class="hljs-comment">/* 如果是软件触发 ADC 单次转换,需要等待转换完成,当转换结束时,置 EOC 标志位</span><br><span class="hljs-comment">** 软件读取 ADC_DR 数据后,硬件自动清除 EOC 标志位,因此无需手动清除 */</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ad_get_value</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>ADC_SoftwareStartConvCmd(ADC1, ENABLE);  <span class="hljs-comment">// 软件触发 AD 转换一次</span><br><span class="hljs-keyword">while</span> (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);  <span class="hljs-comment">// 等待 EOC 标志位.即等待 AD 转换结束</span><br><span class="hljs-keyword">return</span> ADC_GetConversionValue(ADC1);  <span class="hljs-comment">// 读数据寄存器，得到 AD 转换的结果</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code> 测试函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;oled.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ad.h&quot;</span></span><br><br><span class="hljs-type">uint16_t</span> ad_value;  <span class="hljs-comment">// AD 转换后的原始值</span><br><span class="hljs-type">float</span> voltage;  <span class="hljs-comment">// 对应电压</span><br><br><span class="hljs-comment">/* 将电位器的输出引脚连接于 PA0.则拧动电位器即可看到电压数值变化 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>oled_init();<br>ad_init();<br>oled_show_string(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;ad_value:&quot;</span>);<br>oled_show_string(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;voltage:0.00V&quot;</span>);<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>ad_value = ad_get_value();  <span class="hljs-comment">// 获取 AD 转换的值</span><br>voltage = (<span class="hljs-type">float</span>)ad_value / <span class="hljs-number">4095</span> * <span class="hljs-number">3.3</span>;  <span class="hljs-comment">// 将AD值线性变换到 0~3.3 的范围</span><br>oled_show_num(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, ad_value, <span class="hljs-number">4</span>);<br>oled_show_num(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>, voltage, <span class="hljs-number">1</span>);<br>oled_show_num(<span class="hljs-number">2</span>, <span class="hljs-number">11</span>, (<span class="hljs-type">uint16_t</span>)(voltage * <span class="hljs-number">100</span>) % <span class="hljs-number">100</span>, <span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="7-DMA"><a href="#7-DMA" class="headerlink" title="7 DMA"></a>7 DMA</h2><h3 id="7-1-DMA-功能"><a href="#7-1-DMA-功能" class="headerlink" title="7.1 DMA 功能"></a>7.1 DMA 功能</h3><ol><li><p><strong>DMA(Direct Memory Access, 直接存储器存取)</strong></p><ul><li>DMA 可以提供外设和存储器或者存储器和存储器之间的高速数据传输</li><li>本质上是从某个地址取出数据,转运到另一地址</li><li>作用: DMA 数据传输无须 CPU 干预,节省 CPU 的资源</li><li>12个独立可配置的通道: DMA1(7个通道), DMA2(5个通道)</li><li>每个通道都支持软件触发和特定的硬件触发</li></ul></li><li><p><strong>存储器映像</strong></p><table><thead><tr><th>类型</th><th>起始地址</th><th>存储器</th><th>用途</th></tr></thead><tbody><tr><td>ROM</td><td>0x0800 0000</td><td>程序存储器 Flash</td><td>存储编译后的 C 语言程序代码</td></tr><tr><td></td><td>0x1FFF F000</td><td>系统存储器</td><td>存储 BootLoader,用于串口下载</td></tr><tr><td></td><td>0x1FFF F800</td><td>选项字节</td><td>存储一些独立于程序代码的配置参数</td></tr><tr><td>RAM</td><td>0x2000 0000</td><td>运行内存 SRAM</td><td>存储运行过程中的临时变量</td></tr><tr><td></td><td>0x4000 0000</td><td>外设寄存器</td><td>存储各个外设的配置参数</td></tr><tr><td></td><td>0xE000 0000</td><td>内核外设寄存器</td><td>存储内核各个外设的配置参数</td></tr></tbody></table></li><li><p>DMA 框图</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/7-DMA%E6%A1%86%E5%9B%BE.png"></p><ul><li>DMA 通过 <code>DMA 总线</code>主动访问各种存储器.DMA 总线是被分时复用的<ul><li><code>仲裁器</code>根据通道的优先级处理 DMA 通道的冲突</li><li><code>总线矩阵</code>也有仲裁器,当 CPU 和 DMA 访问同一目标时.保障 CPU 正常工作</li></ul></li><li>DMA 作为外设,也有寄存器.连接在 <code>AHB 总线</code>上,因此 CPU 可以访问,配置 DMA<ul><li>硬件可通过 DMA 请求线路向 DMA 发出硬件触发信号</li></ul></li></ul></li><li><p><strong>DMA 基本结构</strong></p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/7-DMA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png"></p><ul><li>DMA 数据转运<ul><li>条件: DMA 使能, <code>传输计数器</code> &gt; 0, 触发源有触发信号</li><li>方向: 外设 -&gt; 存储器, 存储器 -&gt; 外设, Flash -&gt; SRAM</li><li>参数: 源端和目标的 <code>起始地址, 数据宽度, 地址是否自增</code></li></ul></li><li><strong>传输计数器</strong>: 在完成一次转运后会进行自减,当其值为0时结束转运,起始地址参数复位<ul><li><code>自动重装器</code>: 可以在传输计数器自减到0后,恢复传输计数器的值,再次自减.使得可以循环转运</li><li>DMA 转运完成后,必须先关闭 DMA,然后再次开启,才能给 <code>传输计数器</code> 写值</li></ul></li><li>触发方式: 由 <code>M2M</code> 控制<ul><li>软件触发: DMA 不断运行,直到 <code>传输计数器</code> 清零.此时不应开启 <code>自动重装器</code>,一般用于存储器间数据转运</li><li>硬件触发: 达到某种条件(如 ADC 转换完成,串口接收到数据,达到定时时间),触发 DMA 运行</li></ul></li></ul></li><li><p>DMA1 请求映像 </p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/7-DMA1%E8%AF%B7%E6%B1%82%E6%98%A0%E5%83%8F.png"></p><ul><li><strong>每个通道的硬件触发源不同.而软件触发都一样.需要根据触发选择 ADC 通道</strong></li><li>对于外设请求信号的选择: 由外设的 DMA 控制决定,开启就可以发出请求信号</li><li>外设请求信号经过 或门到硬件请求.一般只开启一个外设请求</li></ul></li><li><p>DMA 传输数据宽度</p><ul><li>源端宽度 &#x3D; 目标宽度: 正常传输</li><li>源端宽度 &gt; 目标宽度: 高位舍弃</li><li>源端宽度 &lt; 目标宽度: 高位补0</li></ul></li></ol><h3 id="7-2-DMA-数据转运"><a href="#7-2-DMA-数据转运" class="headerlink" title="7.2 DMA 数据转运"></a>7.2 DMA 数据转运</h3><ol><li><p><code>myDMA.h</code> 头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MYDMA_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MYDMA_H</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">myDMA_init</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> source, <span class="hljs-type">uint32_t</span> destination, <span class="hljs-type">uint16_t</span> times)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">myDMA_transfer</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> times)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>myDMA.c</code> 源文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><br><span class="hljs-comment">/* DMA 初始化函数</span><br><span class="hljs-comment">** source:原数组的首地址</span><br><span class="hljs-comment">** destination:目的数组的首地址</span><br><span class="hljs-comment">** times:转运的数据大小(转运次数) */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">myDMA_init</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> source, <span class="hljs-type">uint32_t</span> destination, <span class="hljs-type">uint16_t</span> times)</span> &#123;<br><span class="hljs-comment">/* 开启 DMA 时钟 */</span><br>RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);<br><br><span class="hljs-comment">/* DMA 初始化 */</span><br><span class="hljs-comment">/* 源地址为 source(32位), 数据宽度 1Byte, 地址自增</span><br><span class="hljs-comment">** 目标地址为 destination(32位), 数据宽度 1Byte, 地址自增 */</span><br>DMA_InitTypeDef DMA_InitStructure;<br>DMA_InitStructure.DMA_PeripheralBaseAddr = source;<br>DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;<br>DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;<br>DMA_InitStructure.DMA_MemoryBaseAddr = destination;<br>DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;<br>DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;<br><br><span class="hljs-comment">/* 转运数据的方向为:外设作为 source(即外设 -&gt; 存储器). source -&gt; destination</span><br><span class="hljs-comment">** 缓冲区大小(传输寄存器的值)为 times(转运的次数), 传输模式为正常(不自动重装)</span><br><span class="hljs-comment">** 存储器到存储器即软件触发, 优先级为中等, 开启 DMA */</span><br>DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;<br>DMA_InitStructure.DMA_BufferSize = times;<br>DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;<br>DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;<br>DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;  <span class="hljs-comment">// 优先级.选择中等</span><br>DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);<br><br><span class="hljs-comment">/* DMA 使能.这里暂不使能.在 myDMA_transfer() 函数启动 DMA */</span><br>DMA_Cmd(DMA1_Channel1, DISABLE);<br>&#125;<br><br><span class="hljs-comment">/* 启动 DMA 数据转运 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">myDMA_transfer</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> times)</span> &#123;<br>DMA_Cmd(DMA1_Channel1, DISABLE);  <span class="hljs-comment">// DMA 失能.在写入传输计数器之前,需要 DMA 暂停工作</span><br>DMA_SetCurrDataCounter(DMA1_Channel1, times);  <span class="hljs-comment">// 写入传输计数器,指定将要转运的次数</span><br>DMA_Cmd(DMA1_Channel1, ENABLE);  <span class="hljs-comment">// DMA 使能.开始工作</span><br><br><span class="hljs-keyword">while</span> (DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);  <span class="hljs-comment">// 等待 DMA 工作完成</span><br>DMA_ClearFlag(DMA1_FLAG_TC1);  <span class="hljs-comment">// 清除工作完成标志位</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code> 测试函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;oled.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myDMA.h&quot;</span></span><br><br><span class="hljs-type">uint8_t</span> source[] = &#123;<span class="hljs-number">0x12</span>, <span class="hljs-number">0x13</span>, <span class="hljs-number">0x14</span>, <span class="hljs-number">0x15</span>&#125;;  <span class="hljs-comment">// 数据源</span><br><span class="hljs-type">uint8_t</span> destination[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// 转运目的地</span><br><br><span class="hljs-comment">/* OLED 屏幕上将会显示 数据转运 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>oled_init();<br>myDMA_init((<span class="hljs-type">uint32_t</span>)source, (<span class="hljs-type">uint32_t</span>)destination, <span class="hljs-number">4</span>);<br>myDMA_transfer(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 使用 DMA 转运数组</span><br><span class="hljs-comment">/* 显示 地址信息 */</span><br>oled_show_string(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;DataA&quot;</span>); oled_show_hex_num(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, (<span class="hljs-type">uint32_t</span>)source, <span class="hljs-number">8</span>);<br>oled_show_string(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;DataB&quot;</span>); oled_show_hex_num(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>, (<span class="hljs-type">uint32_t</span>)destination, <span class="hljs-number">8</span>);<br><span class="hljs-comment">/* 显示数组 source */</span><br>oled_show_hex_num(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, source[<span class="hljs-number">0</span>], <span class="hljs-number">2</span>); oled_show_hex_num(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, source[<span class="hljs-number">1</span>], <span class="hljs-number">2</span>);<br>oled_show_hex_num(<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, source[<span class="hljs-number">2</span>], <span class="hljs-number">2</span>); oled_show_hex_num(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, source[<span class="hljs-number">3</span>], <span class="hljs-number">2</span>);<br><span class="hljs-comment">/* 显示数组 destination */</span><br>oled_show_hex_num(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, destination[<span class="hljs-number">0</span>], <span class="hljs-number">2</span>); oled_show_hex_num(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, destination[<span class="hljs-number">1</span>], <span class="hljs-number">2</span>);<br>oled_show_hex_num(<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, destination[<span class="hljs-number">2</span>], <span class="hljs-number">2</span>); oled_show_hex_num(<span class="hljs-number">4</span>, <span class="hljs-number">10</span>, destination[<span class="hljs-number">3</span>], <span class="hljs-number">2</span>);<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="7-3-DMA-与-ADC"><a href="#7-3-DMA-与-ADC" class="headerlink" title="7.3 DMA 与 ADC"></a>7.3 DMA 与 ADC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;oled.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ad.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ad_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">uint16_t</span> ad_value[<span class="hljs-number">4</span>];<br><br><span class="hljs-comment">/* 需要将 4个传感器分别连接于 PA0 ~ PA3.可观察 AD 转换结果 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>oled_init();<br>ad_init();<br>oled_show_string(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;AD0:&quot;</span>);<br>oled_show_string(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;AD1:&quot;</span>);<br>oled_show_string(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;AD2:&quot;</span>);<br>oled_show_string(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;AD3:&quot;</span>);<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>oled_show_num(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, ad_value[<span class="hljs-number">0</span>], <span class="hljs-number">4</span>);<br>oled_show_num(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, ad_value[<span class="hljs-number">1</span>], <span class="hljs-number">4</span>);<br>oled_show_num(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, ad_value[<span class="hljs-number">2</span>], <span class="hljs-number">4</span>);<br>oled_show_num(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, ad_value[<span class="hljs-number">3</span>], <span class="hljs-number">4</span>);<br>&#125;;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ad_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-comment">/* 开启 ADC1, GPIOA, DMA1 时钟 */</span><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);<br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);<br>RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);<br>RCC_ADCCLKConfig(RCC_PCLK2_Div6);  <span class="hljs-comment">/* 设置 ADC 时钟分频 */</span><br><br><span class="hljs-comment">/* GPIO 初始化 */</span><br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOA, &amp;GPIO_InitStructure);  <span class="hljs-comment">// 将 PA0 ~ PA3 引脚初始化为模拟输入</span><br><br><span class="hljs-comment">/* 规则组通道配置.规则组序列 1~4 的位置,配置为通道 0~3 */</span><br>ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="hljs-number">1</span>, ADC_SampleTime_55Cycles5);<br>ADC_RegularChannelConfig(ADC1, ADC_Channel_1, <span class="hljs-number">2</span>, ADC_SampleTime_55Cycles5);<br>ADC_RegularChannelConfig(ADC1, ADC_Channel_2, <span class="hljs-number">3</span>, ADC_SampleTime_55Cycles5);<br>ADC_RegularChannelConfig(ADC1, ADC_Channel_3, <span class="hljs-number">4</span>, ADC_SampleTime_55Cycles5);<br><br><span class="hljs-comment">/* ADC 初始化 */</span><br>ADC_InitTypeDef ADC_InitStructure;<br>ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;  <span class="hljs-comment">// 独立模式.即单独使用 ADC1</span><br>ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;  <span class="hljs-comment">// 数据右对齐</span><br>ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;  <span class="hljs-comment">// 外部触发</span><br>ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;  <span class="hljs-comment">// 连续转换使能.转换规则组完成后开始下一次</span><br>ADC_InitStructure.ADC_ScanConvMode = ENABLE;  <span class="hljs-comment">// 扫描模式使能.每轮转换多次</span><br>ADC_InitStructure.ADC_NbrOfChannel = <span class="hljs-number">4</span>;  <span class="hljs-comment">// 通道数.扫描规则组的前4个通道</span><br>ADC_Init(ADC1, &amp;ADC_InitStructure);<br><br>ADC_DMACmd(ADC1, ENABLE);  <span class="hljs-comment">/* ADC1 触发 DMA1 的信号使能 */</span><br>ADC_Cmd(ADC1, ENABLE);  <span class="hljs-comment">/* ADC 使能.使能 ADC1 */</span><br><br><span class="hljs-comment">/* ADC 校准.固定流程,内部有电路会自动执行校准 */</span><br>ADC_ResetCalibration(ADC1);  <span class="hljs-comment">// 复位校准</span><br><span class="hljs-keyword">while</span> (ADC_GetResetCalibrationStatus(ADC1) == SET);  <span class="hljs-comment">// 等待复位完成</span><br>ADC_StartCalibration(ADC1);  <span class="hljs-comment">// 启动校准</span><br><span class="hljs-keyword">while</span> (ADC_GetCalibrationStatus(ADC1) == SET);  <span class="hljs-comment">// 等待校准完成</span><br><span class="hljs-comment">/* 软件触发 ADC 工作.由于 ADC 处于连续转换模式,故触发一次后 ADC 将连续不断地工作 */</span><br>ADC_SoftwareStartConvCmd(ADC1, ENABLE);<br><br><span class="hljs-comment">/* DMA 初始化 */</span><br><span class="hljs-comment">/* 源地址为 ADC1-&gt;DR, 数据宽度 2Byte, 地址不自增.每次都访问该寄存器</span><br><span class="hljs-comment">** 目标地址为 ad_value, 数据宽度 2Byte, 地址自增 */</span><br>DMA_InitTypeDef DMA_InitStructure;<br>DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class="hljs-type">uint32_t</span>)&amp;ADC1-&gt;DR;<br>DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;<br>DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;<br>DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="hljs-type">uint32_t</span>)ad_value;<br>DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;<br>DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;<br><br><span class="hljs-comment">/* 转运数据的方向为:外设作为 source(即外设 -&gt; 存储器)</span><br><span class="hljs-comment">** 缓冲区大小(传输寄存器的值)为 4(使能的通道数), 传输模式为自动重装</span><br><span class="hljs-comment">** 外设到存储器即硬件触发, 优先级为中等, 开启 DMA */</span><br>DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;<br>DMA_InitStructure.DMA_BufferSize = <span class="hljs-number">4</span>;<br>DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;<br>DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;<br>DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;  <span class="hljs-comment">// 优先级.选择中等</span><br>DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);<br>DMA_Cmd(DMA1_Channel1, ENABLE);  <span class="hljs-comment">/* DMA 通道1使能 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-USART-串口"><a href="#8-USART-串口" class="headerlink" title="8 USART 串口"></a>8 USART 串口</h2><h3 id="8-1-通信接口"><a href="#8-1-通信接口" class="headerlink" title="8.1 通信接口"></a>8.1 通信接口</h3><ol><li><p><strong>通信协议</strong></p><table><thead><tr><th>名称</th><th>引脚</th><th>双工</th><th>时钟</th><th>电平</th><th>设备</th></tr></thead><tbody><tr><td>USART</td><td>TX, RX</td><td>全双工</td><td>异步</td><td>单端</td><td>点对点</td></tr><tr><td>I2C</td><td>SCL, SDA</td><td>半双工</td><td>同步</td><td>单端</td><td>多设备</td></tr><tr><td>SPI</td><td>SCLK, MOSI, MISO, CS</td><td>全双工</td><td>同步</td><td>单端</td><td>多设备</td></tr><tr><td>CAN</td><td>CAN_H, CAN_L</td><td>半双工</td><td>异步</td><td>差分</td><td>多设备</td></tr><tr><td>USB</td><td>DP, DM</td><td>半双工</td><td>异步</td><td>差分</td><td>点对点</td></tr></tbody></table><ul><li>全双工: 通信双方能够同时进行双向通信.一般需要2根通信线</li><li>半双工: 通信双方无法同时输入 &#x2F; 输出数据</li><li>单工: 数据传输方向为单向</li><li>时钟: 确定数据的采集时机</li></ul></li><li><p>电平标准: 数据1&#x2F;0的表达方式(当电平信号不一致时,需要加入电平转换芯片)</p><table><thead><tr><th>电平标准</th><th>data: 1</th><th>data: 0</th></tr></thead><tbody><tr><td><strong>TTL</strong></td><td><strong>+3.3V 或 +5V</strong></td><td><strong>0V</strong></td></tr><tr><td>RS232 电平</td><td>-3 ~ -15V</td><td>+3 ~ +15</td></tr><tr><td>RS485 电平(差分信号)</td><td>+2 ~ +6V</td><td>-2 ~ -6V</td></tr></tbody></table></li><li><p>串口时序</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/8-%E4%B8%B2%E5%8F%A3%E6%97%B6%E5%BA%8F.png"></p></li><li><p>串口参数</p><ul><li><strong>波特率: 串口通信的速率.每秒传输码元的个数</strong></li><li>比特率: 每秒传输的比特数(bit&#x2F;s).二进制情况下,码元即是 bit,波特率等于比特率</li><li>起始位: 标志一个数据帧的开始,固定为低电平(空闲时为高电平)</li><li><strong>数据位: 数据帧的有效载荷.1为高电平,0为低电平.低位先行</strong></li><li>校验位: 用于数据验证(如奇校验表示连同校验位共有奇数个1,还有 CRC 校验)</li><li>停止位: 用于数据帧间隔.固定为高电平</li></ul></li></ol><h3 id="8-2-USART-外设"><a href="#8-2-USART-外设" class="headerlink" title="8.2 USART 外设"></a>8.2 USART 外设</h3><ol><li><p><strong>USART(Universal Synchronous&#x2F;Asynchronous Receiver&#x2F;Transmitter, 通用同步&#x2F;异步收发器)</strong></p><ul><li>STM32 内部集成 USART 外设<ul><li>可根据数据寄存器的一个字节数据自动生成数据帧时序.由 TX 引脚发送</li><li>可自动接收 RX 引脚的数据帧时序,拼接为一个字节数据,存放于数据寄存器</li><li>自带波特率发生器.最高达4.5Mbits&#x2F;s.本质是一个预分频器</li></ul></li><li>可配置参数<ul><li>数据位长度(<strong>8</strong> &#x2F; 9). 停止位长度(0.5 &#x2F; <strong>1</strong> &#x2F; 1.5 &#x2F; 2)</li><li>校验位: <strong>无校验,</strong> 奇校验, 偶校验</li><li>支持同步模式, 硬件流控制, DMA, 智能卡, IrDA, LIN</li></ul></li></ul></li><li><p>USART 框图</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/8-USART%E6%A1%86%E5%9B%BE.png"></p><ul><li><code>TX</code> 引脚连接 <code>发送移位寄存器</code>,在<code>发送器控制</code>的控制下,将数据按位移出<ul><li>当 <code>TDR</code>(只写) 被写入数据时,先检查<code>移位寄存器</code>是否有数据正在移位</li><li>若无,则数据发送到<code>移位寄存器</code>,同时,置 <code>TXE 标志位</code>,可以再次向 <code>TDR</code> 写入数据</li><li>若有,则等待移位完成后,立即转移数据</li></ul></li><li><code>RX</code> 连接通向 <code>接收移位寄存器</code>,在<code>接收器控制</code>的控制下,将数据按位移出<ul><li><code>接收移位寄存器</code>按位读取 <code>RX</code> 引脚的信号</li><li>读取满1byte 后,将数据转移到 <code>RDR</code>.同时,置 <code>RXNE 标志位</code>.此时可从 <code>RDR</code>(只读)读出数据</li></ul></li></ul></li><li><p>USART 基本结构</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/8-USART%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png"></p><ul><li>APB的时钟信号到达波特率发生器进行分频</li><li>发送器 &#x2F; 接收器的波特率 &#x3D; $\mathrm{\frac{f_{PCLK}} { {16} \cdot {DIV} } }$. 由 <code>波特率寄存器 BRR</code> 中的 <code>DIV</code> 决定</li></ul></li></ol><h3 id="8-3-收发数据"><a href="#8-3-收发数据" class="headerlink" title="8.3 收发数据"></a>8.3 收发数据</h3><ol><li><p><code>serial.h</code> 头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SERIAL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERIAL_H</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">serial_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">serial_send_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> byte)</span>;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">serial_get_flag</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">serial_get_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>serial.c</code> 源文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><br><span class="hljs-comment">/* 串口初始化 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">serial_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-comment">/* 开启 USART1, GPIOA 时钟 */</span><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);<br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);<br><br><span class="hljs-comment">/* GPIO 初始化 */</span><br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;  <span class="hljs-comment">// TX 复用推挽输出</span><br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<br><br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;  <span class="hljs-comment">// RX 上拉输入</span><br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<br><br><span class="hljs-comment">/* USART1 初始化.波特率9600, 发送和接收数据, 无校验, 停止位长度1, 字长8, 无流控 */</span><br>USART_InitTypeDef USART_InitStructure;<br>USART_InitStructure.USART_BaudRate = <span class="hljs-number">9600</span>;<br>USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<br>USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;<br>USART_InitStructure.USART_Parity = USART_Parity_No;<br>USART_InitStructure.USART_StopBits = USART_StopBits_1;<br>USART_InitStructure.USART_WordLength = USART_WordLength_8b;<br>USART_Init(USART1, &amp;USART_InitStructure);<br><br><span class="hljs-comment">/* 中断输出配置.开启串口接收数据的中断 */</span><br>USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);<br><span class="hljs-comment">/* USART 使能.使能 USART1,串口开始运行 */</span><br>USART_Cmd(USART1, ENABLE);<br><br><span class="hljs-comment">/* NVIC中断分组 */</span><br>NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<br><span class="hljs-comment">/* NVIC 配置*/</span><br>NVIC_InitTypeDef NVIC_InitStructure;<br>NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;  <span class="hljs-comment">// 选择 NVIC 的 USART1 线</span><br>NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<br>NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="hljs-number">1</span>;<br>NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="hljs-number">1</span>;<br>NVIC_Init(&amp;NVIC_InitStructure);<br>&#125;<br><br><span class="hljs-comment">/* 串口发送一个字节 byte */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">serial_send_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> byte)</span> &#123;<br>USART_SendData(USART1, byte);  <span class="hljs-comment">// 将字节数据写入数据寄存器 TDR</span><br><span class="hljs-keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);  <span class="hljs-comment">// 等待发送完成</span><br><span class="hljs-comment">/* 下次写入数据寄存器会自动清除发送完成标志位,故此循环后,无需清除标志位 */</span><br>&#125;<br><br><span class="hljs-type">uint8_t</span> serial_data;  <span class="hljs-comment">// 串口接收的数据</span><br><span class="hljs-type">uint8_t</span> serial_flag;  <span class="hljs-comment">// 串口接收的标志位.1表示有数据待读</span><br><br><span class="hljs-comment">/* 获取串口接收标志位.1表示有数据待读.读取后自动置0 */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">serial_get_flag</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (serial_flag == <span class="hljs-number">1</span>) &#123;<br>serial_flag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 获取串口接收的数据(范围: 0~255) */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">serial_get_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-keyword">return</span> serial_data;<br>&#125;<br><br><span class="hljs-comment">/* USART1 中断函数 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">USART1_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (USART_GetITStatus(USART1, USART_IT_RXNE) == SET) &#123;<br>serial_data = USART_ReceiveData(USART1);  <span class="hljs-comment">// 读取数据寄存器,存放在接收的数据变量</span><br>serial_flag = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 有数据待读</span><br>USART_ClearITPendingBit(USART1, USART_IT_RXNE);  <span class="hljs-comment">// 清除USART1的RXNE标志位.读DR自动清除</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code> 测试函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;oled.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;serial.h&quot;</span></span><br><br><span class="hljs-comment">/* 连接USB转串口模块的 RX(PA9), TX(PA10).使用电脑发送数据,STM32 将数据+1后回传 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>oled_init();<br>serial_init();<br>oled_show_string(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;RxData:&quot;</span>);<br><span class="hljs-type">uint8_t</span> data = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span>(serial_get_flag()) &#123;<br>data = serial_get_data();<br>serial_send_byte(data + <span class="hljs-number">8</span>);<br>oled_show_hex_num(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, data, <span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="8-4-重定向-printf"><a href="#8-4-重定向-printf" class="headerlink" title="8.4 重定向 printf"></a>8.4 重定向 <code>printf</code></h3><ol><li><p>格式化打印: 对 <code>printf</code>函数的重定向</p></li><li><p>打开工程文件中的 <code>Options for target</code>,勾选 <code>Use MicroLIB</code>(Keil 为嵌入式平台准备的精简库)</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/8-UseMicroLib.png"></p></li><li><p><strong>由于<code>printf</code>函数底层调用<code>fput</code>函数不断打印,因此可以将 <code>printf</code> 函数重定向为向串口发送数据</strong></p></li><li><p>方法1: 重写的<code>fputc</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span> &#123;<br>serial_send_byte(ch);  <span class="hljs-comment">// 这是一个串口传输数据的函数,需要自行实现</span><br><span class="hljs-keyword">return</span> ch;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方法2: 对 <code>sprintf</code> 的封装(<code>sprintf</code> 函数: 将内容打印打印到字符串中)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">serial_printf</span><span class="hljs-params">(<span class="hljs-type">char</span> *format, ...)</span> &#123;<br><span class="hljs-type">char</span> <span class="hljs-built_in">string</span>[<span class="hljs-number">100</span>];               <span class="hljs-comment">// 定义字符数组</span><br>va_list arg;                    <span class="hljs-comment">// 定义可变参数列表数据类型的变量 arg</span><br>va_start(arg, format);          <span class="hljs-comment">// 从 format 开始,接收参数列表到 arg 变量</span><br><span class="hljs-built_in">vsprintf</span>(<span class="hljs-built_in">string</span>, format, arg);  <span class="hljs-comment">// 使用 vsprintf 打印格式化字符串和参数列表到字符数组中</span><br>va_end(arg);                    <span class="hljs-comment">// 结束变量 arg</span><br>serial_send_string(String);     <span class="hljs-comment">// 串口发送字符数组的函数,需要自行实现</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="9-I2C-通信"><a href="#9-I2C-通信" class="headerlink" title="9 I2C 通信"></a>9 I2C 通信</h2><h3 id="9-1-I2C-协议"><a href="#9-1-I2C-协议" class="headerlink" title="9.1 I2C 协议"></a>9.1 I2C 协议</h3><ol><li><p><strong>I2C(Inter IC BUS).由 Philips 公司开发的一种通用数据总线</strong></p><ul><li><strong>通信线: SCL(Serial Clock), SDA(Serial Data)</strong></li><li>属于同步通信,半双工通信.可以数据应答,支持总线挂载多设备</li><li>I2C 外设出厂会有一个地址(7位或10位)</li></ul></li><li><p>硬件电路</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/9-I2C%E7%A1%AC%E4%BB%B6.png"></p><ul><li>SDA 和 SCL 的控制<ul><li>主机拥有对 SCL 线的完全控制权.也可控制空闲状态下的 SDA 线</li><li>从机只能读取 SCL 线,也不允许主动控制 SDA 线</li><li>仅在应答或主机要读取从机时才能获取 SDA 的控制权</li></ul></li><li>接线方式<ul><li>所有 I2C 设备的 SCL 连在一起,SDA 连在一起.均默认为高电平</li><li><strong>设备的 SCL 和 SDA 均要配置成开漏输出模式,禁止输出高电平</strong></li><li>SCL 和 SDA 各添加一个上拉电阻,阻值一般为4.7KΩ</li></ul></li></ul></li><li><p><strong>I2C 时序基本单元</strong></p><ul><li><strong>起始与终止</strong>: 始终由主机控制,从机无权发送该指令<ul><li>起始条件: 主机拉低 SDA 电平(下降沿,此时从机复位),然后拉低 SCL,占用 SCL</li><li>终止条件: 主机先放开 SCL,然后放开 SDA (上升沿).回到初始态</li><li>除了起始和终止条件,每个时序单元的 SCL 以低电平开始,也以低电平结束</li></ul></li><li><strong>发送数据</strong><ul><li>起始状态后.SCL,SDA均为低电平.主机将数据置于 SDA 线(高位先行)</li><li>然后释放 SCL.从机在 SCL 高电平期间读取数据位,需要尽快读取,最好在上升沿时就立即读取</li><li>当 SCL 高电平时, SDA 不应发生变化,维持一段时间后,主机再次拉低 SCL.完成一位数据的传输</li><li>循环上述过程8次,即可传输一个字节的数据</li></ul></li><li><strong>接收数据</strong><ul><li>主机需要先释放 SDA.在 SCL 低电平期间,从机将数据置于 SDA 线(高位先行)</li><li>然后主机释放 SCL.由主机读取数据位</li><li>SDA 总是在 SCL 低电平(下降沿)时被放置数据,在 SCL 高点平(上升沿)时被读取</li></ul></li><li><strong>主机发送应答</strong>: 主机接收完一个字节后,在下一个时钟发送一位数据.0为应答,1为非应答</li><li><strong>接收从机应答</strong>: 主机发送完一个字节后,在下一个时钟接收一位数据.0为应答,1为非应答</li></ul></li><li><p>通信开始后,发送数据的分析</p><ul><li><p><strong>第一个字节: 高7位为接收数据的地址, 第8位表示后续操作类型(0:写入 &#x2F; 1:读取)</strong></p></li><li><p>然后接收应答: 主机发送完最低位数据时,松开 SDA,同时拉低 SCL (下降沿),此时从机应拉低 SDA<br>主机在一段时间后松开 SCL,并读取应答数据(0 为应答),再次拉低 SCL,此时从机应松开 SDA</p></li><li><p><strong>第二个字节: 发送想要操作的寄存器地址 或是 指令控制字.同样需要接收应答</strong></p></li><li><p>后续字节: 传输真正的数据(寄存器的地址将会自增).当完成传输时,主机需要产生一个终止条件</p></li></ul></li><li><p>通信开始后,接收数据的分析</p><ul><li>由于第一字节指定读取数据后,下一字节的数据将由从机发送.因此没有机会指定想要操作的寄存器</li><li>只能先发送数据,然后指定寄存器地址,紧接着终止,再开始读取数据.间接的指定寄存器地址</li><li>当主机不想再接收数据时,需要在发送应答时给出非应答,此时从机将不再发送数据</li></ul></li></ol><h3 id="9-2-软件-I2C"><a href="#9-2-软件-I2C" class="headerlink" title="9.2 软件 I2C"></a>9.2 软件 I2C</h3><ol><li><p>基本时序(I2C 指定位置写 &#x2F; 读数据的辅助函数)</p><ul><li><p>基础代码: 写 SCL, 读&#x2F;写 SDA</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 对 SCL, SDA 对应的引脚进行宏定义.宏定义可与配置 GPIO 代码一起封装为 iicInit 函数*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_Prot_SCL GPIOB</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_Prot_SDA GPIOB</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_Pin_SCL GPIO_Pin_10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_Pin_SDA GPIO_Pin_11</span><br><br><span class="hljs-comment">/* 辅助函数 写 SCL: 参数 bit 为对引脚电平的操作(0为低电平, 1为高电平) */</span><br><span class="hljs-type">void</span> _wSCL(<span class="hljs-type">uint8_t</span> bit) &#123; GPIO_WriteBit(GPIO_Port_SCL, GPIO_Pin_SCL, (BitAction)bit);&#125;<br><span class="hljs-comment">/* 辅助函数 读取 SDA */</span><br><span class="hljs-type">uint8_t</span> _rSDA(<span class="hljs-type">void</span>) &#123; <span class="hljs-keyword">return</span> GPIO_ReadInputDataBit(GPIO_Prot_SDA, GPIO_Pin_SDA);&#125;<br><span class="hljs-comment">/* 辅助函数 写入 SDA */</span><br><span class="hljs-type">void</span> _wSDA(<span class="hljs-type">uint8_t</span> bit) &#123; GPIO_WriteBit(GPIO_Port_SDA, GPIO_Pin_SDA, (BitAction)bit);&#125;<br></code></pre></td></tr></table></figure></li><li><p>起始 &#x2F; 终止条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 辅助函数 发送起始条件 */</span><br><span class="hljs-type">void</span> _start(<span class="hljs-type">void</span>) &#123;<br>_wSDA(<span class="hljs-number">1</span>); _wSCL(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 依次释放 SDA, SCL</span><br>_wSDA(<span class="hljs-number">0</span>); _wSCL(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 依次占用 SDA, SCL</span><br>&#125;<br><br><span class="hljs-comment">/* 辅助函数 发送终止条件 */</span><br><span class="hljs-type">void</span> _stop(<span class="hljs-type">void</span>) &#123;<br>_wSDA(<span class="hljs-number">0</span>); _wSCL(<span class="hljs-number">1</span>); _wSDA(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>发送 &#x2F; 接收字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 辅助函数 主机发送字节 */</span><br><span class="hljs-type">void</span> _sendByte(<span class="hljs-type">uint8_t</span> byte) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i ++) &#123;<br>_wSDA(byte &amp; (<span class="hljs-number">0x80</span> &gt;&gt; i));  <span class="hljs-comment">// 高位先行</span><br>_wSCL(<span class="hljs-number">1</span>); _wSCL(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 驱动时钟前行.此时,从机读取数据</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* 辅助函数 主机接收字节 */</span><br><span class="hljs-type">uint8_t</span> _receiveByte(<span class="hljs-type">void</span>) &#123;<br><span class="hljs-type">uint8_t</span> byte = <span class="hljs-number">0x00</span>;<br>_wSDA(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 释放 SDA,交给从机控制.又因为此时 SCL 为低电平,从机放置数据</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i ++) &#123;<br>_wSCL(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 主机准备读取数据</span><br><span class="hljs-keyword">if</span> (_rSDA() == <span class="hljs-number">1</span>) &#123;byte |= (<span class="hljs-number">0x80</span> &gt;&gt; i);&#125;  <span class="hljs-comment">// 若为1,置于 byte 高位.否则默认0</span><br>_wSCL(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 此时,从机放置数据</span><br>&#125;<br><span class="hljs-keyword">return</span> byte;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>发送 &#x2F; 接收应答</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 辅助函数 主机发送应答.参数 ackBit 为0表示应答,为1表示非应答 */</span><br><span class="hljs-type">void</span> _sendAck(<span class="hljs-type">uint8_t</span> ackBit) &#123;<br>_wSDA(ackBit);<br>_wSCL(<span class="hljs-number">1</span>); _wSCL(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 驱动时钟前行.此时,从机读取数据</span><br>&#125;<br><br><span class="hljs-comment">/* 辅助函数 主机接收应答 */</span><br><span class="hljs-type">uint8_t</span> _receiveAck(<span class="hljs-type">void</span>) &#123;<br>_wSDA(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 此时,从机放置数据</span><br>    _wSCL(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 主机准备读取数据</span><br>    <span class="hljs-type">uint8_t</span> ackBit = _rSDA();<br>_wSCL(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> ackBit;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>I2C 指定位置写 &#x2F; 读数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MPU6050_ADDRESS0xD0  <span class="hljs-comment">// 宏定义从机 MPU6050_ADDRESS 的地址</span></span><br><br><span class="hljs-comment">/* 对 MPU6050 指定指定地址写数据.参数 regAdr: 指定寄存器地址. byte: 待发送的数据 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MPU6050_WriteReg</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> regAdr, <span class="hljs-type">uint8_t</span> byte)</span> &#123;<br>_start(); _sendByte(MPU6050_ADDRESS); _receiveAck(); <span class="hljs-comment">// 点名从机</span><br>_sendByte(regAdr); _receiveAck();  <span class="hljs-comment">// 指定寄存器地址</span><br>_sendByte(byte); _receiveAck();  <span class="hljs-comment">// 写入数据</span><br>_stop();  <span class="hljs-comment">// 完成</span><br>&#125;<br><br><span class="hljs-comment">/* 对 MPU6050 指定指定地址写数据 */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">MPU6050_ReadReg</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> regAdr)</span> &#123;<br>    _start(); _sendByte(MPU6050_ADDRESS); _receiveAck(); <span class="hljs-comment">// 点名从机</span><br>_sendByte(regAdr); _receiveAck();  <span class="hljs-comment">// 指定寄存器地址</span><br>    _start(); _sendByte(MPU6050_ADDRESS | <span class="hljs-number">0x01</span>); _receiveAck(); <span class="hljs-comment">// 转入读的时序</span><br>    <br><span class="hljs-type">uint8_t</span> Data = _receiveByte(); <span class="hljs-comment">// 读出数据</span><br>_sendAck(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 不应答,因此从机不再发送.否则从机继续发送</span><br>_stop();  <span class="hljs-comment">// 完成</span><br><span class="hljs-keyword">return</span> Data;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="9-3-硬件-I2C"><a href="#9-3-硬件-I2C" class="headerlink" title="9.3 硬件 I2C"></a>9.3 硬件 I2C</h3><ol><li><p>STM32 内部集成了硬件 I2C 收发电路</p><ul><li>可以由硬件自动执行时钟生成,起始终止条件生成,应答位收发,数据收发等功能.减轻CPU的负担</li><li>支持7位&#x2F;10位地址模式(若第一字节的前5位为11110,则表示10位地址)</li><li>支持不同的通讯速度,标准速度(高达100 kHz), 快速(高达400 kHz)</li><li>支持 DMA, 多主机模型, 兼容 SMBus(System Management Bus)协议</li></ul></li><li><p>I2C 基本结构图</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/9-I2C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p></li><li><p>配置 I2C</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 配置 I2C.并设置为 clockSpeed=50k, 占空比为2:1, 开启应答, 作为从机响应7位地址, 地址为 0x00 */</span><br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);<br>I2C_InitTypeDef I2C_InitStructure;<br>I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;<br>I2C_InitStructure.I2C_ClockSpeed = <span class="hljs-number">50000</span>;  <span class="hljs-comment">// 当时钟速度 &gt;100KHz 为快速模式</span><br>I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;  <span class="hljs-comment">// 快速模式才有效.标准模式为1:1</span><br>I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;<br>I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;<br>I2C_InitStructure.I2C_OwnAddress1 = <span class="hljs-number">0x00</span>;<br>I2C_Init(I2C2, &amp;I2C_InitStructure);<br>I2C_Cmd(I2C2, ENABLE);  <span class="hljs-comment">// 使能 I2C</span><br></code></pre></td></tr></table></figure></li><li><p>硬件 I2C 指定地址写 &#x2F; 读数据的辅助函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 辅助函数: 等待事件完成.并设置超时退出机制 */</span><br><span class="hljs-type">void</span> _waitEvent(I2C_TypeDef *I2Cx, <span class="hljs-type">uint32_t</span> I2C_Evenr) &#123;<br>    <span class="hljs-type">uint32_t</span> Timeout = <span class="hljs-number">10000</span>;<br><span class="hljs-keyword">while</span> (I2C_CheckEvent(I2Cx, I2C_EVENT) != SUCCESS) &#123;<br><span class="hljs-keyword">if</span> (--Timeout) &#123;<span class="hljs-keyword">break</span>;&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* 辅助函数: 点名从机. 作用: 作为主机发送从机的7位地址数据</span><br><span class="hljs-comment">** 参数: slaveAdr: 从机地址, state: 0表示后续发送数据,否则接收数据</span><br><span class="hljs-comment">** 执行过程: 产生起始条件 -&gt; 等待发送 -&gt; 发送7位地址数据 -&gt; 等待发送完成 */</span><br><span class="hljs-type">void</span> _callSlaveMachine(<span class="hljs-type">uint8_t</span> slaveAdr, <span class="hljs-type">uint8_t</span> state) &#123;<br>    I2C_GenerateSTART(I2C2, ENABLE);<br>_waitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT);<br>    <span class="hljs-keyword">if</span>(state == <span class="hljs-number">0</span>) &#123;<br>        I2C_Send7bitAddress(I2C2, slaveAdr, I2C_Direction_Transmitter);<br>    _waitEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        I2C_Send7bitAddress(I2C2, slaveAdr, I2C_Direction_Receiver);<br>    MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 辅助函数: 发送并等待数据完成发送 */</span><br><span class="hljs-type">void</span> _sendData(<span class="hljs-type">uint8_t</span> data) &#123;<br>    I2C_SendData(I2C2, data);<br>    _waitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTING);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>硬件 I2C 指定地址写 &#x2F; 读数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 对 MPU6050 指定指定地址写数据 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MPU6050_WriteReg</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> regAdr, <span class="hljs-type">uint8_t</span> byte)</span> &#123;<br>    _callSlaveMachine(MPU6050_ADDRESS, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 发送从机地址,点名从机,准备发送数据</span><br>    _sendData(regAdr);  <span class="hljs-comment">// 指定待操作的寄存器</span><br>    _sendData(byte);  <span class="hljs-comment">// 指定待写入的数据</span><br>    I2C_GenerateSTOP(I2C2, ENABLE);  <span class="hljs-comment">// 产生停止条件</span><br>&#125;<br><br><span class="hljs-comment">/* 对 MPU6050 指定指定地址读数据 */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">MPU6050_ReadReg</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> regAdr)</span> &#123;<br>    _callSlaveMachine(MPU6050_ADDRESS, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 发送从机地址,点名从机,准备发送数据</span><br>_sendData(regAdr);  <span class="hljs-comment">// 指定待操作的寄存器</span><br>_callSlaveMachine(MPU6050_ADDRESS, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 发送从机地址,点名从机,准备读取数据</span><br>    <br>I2C_AcknowledgeConfig(I2C2, DISABLE);  <span class="hljs-comment">// 在接收最后一个字节之前提前将应答失能</span><br>I2C_GenerateSTOP(I2C2, ENABLE);  <span class="hljs-comment">// 在接收最后一个字节之前提前申请停止条件</span><br>_waitEvent(I2C2, I2C_EVENT_MASTER_BYTE_RECEIVED);  <span class="hljs-comment">// 等待接收到数据</span><br><span class="hljs-type">uint8_t</span> data = I2C_ReceiveData(I2C2);  <span class="hljs-comment">// 读出并记录数据,这里原本应自动应答,但应答被失能,无法应答</span><br>    <br>I2C_AcknowledgeConfig(I2C2, ENABLE);  <span class="hljs-comment">// 使能应答,防止影响后续读取多个字节</span><br>    <span class="hljs-keyword">return</span> data<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="10-SPI-通信"><a href="#10-SPI-通信" class="headerlink" title="10 SPI 通信"></a>10 SPI 通信</h2><h3 id="10-1-SPI-协议"><a href="#10-1-SPI-协议" class="headerlink" title="10.1 SPI 协议"></a>10.1 SPI 协议</h3><ol><li><p><strong>SPI(Serial Peripheral Interface): 由Motorola公司开发的一种通用数据总线</strong></p><ul><li>通信线: SCK(Serial Clock), SS(Slave Select),<br>MOSI(Master Output Slave Input), MISO(Master Input Slave Output)</li><li>同步, 全双工.支持总线挂载多设备(一主多从)</li></ul></li><li><p>硬件电路</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/10-SPI%E7%A1%AC%E4%BB%B6.jpg"></p><ul><li>所有 SPI 设备的 SCK, MOSI, MISO 分别连在一起<ul><li><strong>SCK: 时钟线</strong>.完全由主机掌控.由主机进行输出,从机得到输入</li><li><strong>MOSI: 主机输出从机输入</strong>.在主机上,表现为数据输出.在从机上,表现为数据输入</li><li><strong>MISO: 主机输入从机输出</strong>.在主机上,表现为数据输入.在从机上,表现为数据输出</li></ul></li><li><strong>主机另外引出多条 SS 控制线,分别接到各从机的 SS 引脚</strong><ul><li>当从机的 SS 高电平时,MISO 必须为高阻态,不允许从机输出,防止 MISO 数据冲突</li><li>SS 低电平有效,且只能同时选中一个从机.如需指定从机输入输出数据.则将对应的 SS 拉至低电平</li><li>输出的引脚需配置为推挽输出,保证高低电平均有强驱动能力.输入的引脚需配置为浮空或上拉输入</li></ul></li></ul></li><li><p>SPI 数据交换</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/10-SPI%E7%A7%BB%E4%BD%8D%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><ul><li><code>波特率发生器</code>时钟上升沿时,所有移位寄存器向左移位,置于引脚</li><li><code>波特率发生器</code>时钟下降沿时,对引脚电平采样,置于移位寄存器的最低位</li><li>主机与从机的数据交换<ul><li>在一个周期内,从机由高位移出的数据传输到主机的低位,主机由高位移出的数据传输到从机的低位</li><li>循环8次后,从机的数据完整到达主机,主机的数据也完整达到从机,完成一次数据交换</li></ul></li><li>如果仅需主机发送数据,仍然需要执行数据交换,忽略接收到的数据即可</li><li>如果仅需接收从机数据,仍然需要执行数据交换,此时主机可使用任意数据交换(一般0x00或0xFF)</li></ul></li><li><p>SPI 基本时序</p><ul><li>起始条件: SS 从高电平切换到低电平</li><li>终止条件: SS 从低电平切换到高电平</li><li>可选择 上升&#x2F;下降沿 移位.可配置时钟相位提前半个时钟<ul><li><code>CPOL(Clock Polarity)</code>: CPOL&#x3D;0: SCK 空闲时为低电平; CPOL&#x3D;1: SCK 空闲时为高电平</li><li><code>CPHA(Clock phase)</code><ul><li>CPHA&#x3D;0: SCK 奇数边沿时移入数据.偶数边沿移出数据(提前)</li><li>CPHA&#x3D;1: SCK 奇数边沿时移出数据.偶数边沿移入数据(正常)</li></ul></li></ul></li><li><strong>模式0 使用最多(CPOL&#x3D;0,CPHA&#x3D;0): 空闲时,SCK为低电平,上升沿采集数据</strong></li></ul></li><li><p>SPI 通常使用指令码和读写数据的方式操作从机: 从机选择 -&gt; 发送指令 -&gt; 发送数据</p></li></ol><h3 id="10-2-软件-SPI"><a href="#10-2-软件-SPI" class="headerlink" title="10.2 软件 SPI"></a>10.2 软件 SPI</h3><ol><li><p>配置 GPIO</p><ul><li>推挽输出: MOSI, SCK(默认低电平,对应模式0), SS(默认高电平,不选中从机)</li><li>上拉输入: MISO</li></ul></li><li><p>SPI 基本时序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 对 SS, SCK, MISO, MOSI 对应的引脚进行宏定义.宏定义可与配置 GPIO 代码一起封装为 spiInit 函数</span><br><span class="hljs-comment">** 注意初始化时需要将 SS 置高电平,SCK 置低电平*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_Prot_SS   GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_Prot_SCK  GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_Prot_MISO GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_Prot_MOSI GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_Pin_SS    GPIO_Pin_4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_Pin_SCK   GPIO_Pin_5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_Pin_MISO  GPIO_Pin_6</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_Pin_MOSI  GPIO_Pin_7</span><br><br><span class="hljs-comment">/* 辅助函数 SS 从机选择 */</span><br><span class="hljs-type">void</span> _wSS(<span class="hljs-type">uint8_t</span> bit) &#123;GPIO_WriteBit(GPIO_Port_SS, GPIO_Pin_SS, (BitAction)bit);&#125;<br><span class="hljs-comment">/* 辅助函数 SCK 时钟输出 */</span><br><span class="hljs-type">void</span> _wSCK(<span class="hljs-type">uint8_t</span> bit) &#123;GPIO_WriteBit(GPIO_Port_SCK, GPIO_Pin_SCK, (BitAction)bit);&#125;<br><span class="hljs-comment">/* 辅助函数 MOSI 数据输出 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">wMOSI</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> bit)</span> &#123;GPIO_WriteBit(GPIO_Port_MISO, GPIO_Pin_MOSI, (BitAction)bit);&#125;<br><span class="hljs-comment">/* 辅助函数 MISO 数据读出 */</span><br><span class="hljs-type">uint8_t</span> rMISO &#123;<span class="hljs-keyword">return</span> GPIO_ReadInputDataBit(GPIO_Port_MISO, GPIO_Pin_MISO);&#125;<br></code></pre></td></tr></table></figure></li><li><p>SPI 协议</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* SPI 起始 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;_wSS(<span class="hljs-number">0</span>);&#125;<br><span class="hljs-comment">/* SPI 终止 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;_wSS(<span class="hljs-number">1</span>);&#125;<br><br><span class="hljs-comment">/* SPI 交换字节(模式0) */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">swapByte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> byteSend)</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i ++) &#123;<br>        wMOSI(byteSend &amp; <span class="hljs-number">0x80</span>);  <span class="hljs-comment">// 输出数据,高位先行</span><br>        byteSend &lt;&lt;= <span class="hljs-number">1</span><br>        wSCK(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (rMISO() == <span class="hljs-number">1</span>) &#123;byteSend |= <span class="hljs-number">0x01</span>;&#125;  <span class="hljs-comment">// 读出数据</span><br>        wSCK(<span class="hljs-number">0</span>);<br>    &#125;<br><span class="hljs-keyword">return</span> byteSend;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="10-3-硬件-SPI"><a href="#10-3-硬件-SPI" class="headerlink" title="10.3 硬件 SPI"></a>10.3 硬件 SPI</h3><ol><li><p>STM32 内部集成了硬件 SPI 收发电路</p><ul><li>可配置 8 &#x2F; 16位数据帧, 高 &#x2F; 低位先行</li><li>时钟频率: PCLK &#x2F; (2, 4, 8, 16, 32, 64, 128, 256)</li><li>支持多主机模型(主&#x2F;从操作), 可精简为半双工&#x2F;单工通信, 支持 DMA, 兼容 I2S 协议</li></ul></li><li><p>SPI 基本结构</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/10-SPI%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png"></p></li><li><p>配置SPI</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 配置SPI.并设置为: 主机模式, 双线全双工, CPOL=0, CPHA=0,(模式0) 波特率预分频 128</span><br><span class="hljs-comment">** 8位数据帧, 高位先行, NSS 软件模拟, CRC 校验默认设置为7 */</span><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);<br>SPI_InitTypeDef SPI_InitStructure;<br>SPI_InitStructure.SPI_Mode = SPI_Mode_Master;<br>SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;<br>SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;<br>SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;<br>SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_128;<br>SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;<br>SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;<br>SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;<br>SPI_InitStructure.SPI_CRCPolynomial = <span class="hljs-number">7</span>;<br>SPI_Init(SPI1, &amp;SPI_InitStructure);<br>SPI_Cmd(SPI1, ENABLE);<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;_wSS(<span class="hljs-number">1</span>);&#125;<br></code></pre></td></tr></table></figure></li><li><p>交换字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">swapByte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> byteSend)</span> &#123;<br><span class="hljs-keyword">while</span> (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) != SET);<br>SPI_I2S_SendData(SPI1, byteSend);<br><span class="hljs-keyword">while</span> (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) != SET);<br><span class="hljs-keyword">return</span> SPI_I2S_ReceiveData(SPI1);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="11-RTC-实时时钟"><a href="#11-RTC-实时时钟" class="headerlink" title="11 RTC 实时时钟"></a>11 RTC 实时时钟</h2><h3 id="11-1-Unix-时间戳"><a href="#11-1-Unix-时间戳" class="headerlink" title="11.1 Unix 时间戳"></a>11.1 Unix 时间戳</h3><ol><li><p><strong>Unix 时间戳(Timestamp): 从 UTC &#x2F; GMT 的 <code>1970年1月1日00:00:00</code> 开始经过的秒数</strong></p><ul><li>秒计数器为 32&#x2F;64 位的整型变量</li><li>各时区的秒计数器相同,但不同时区通过偏移得到当地时间</li></ul></li><li><p>GMT(Greenwich Mean Time): 格林尼治标准时间,将地球自转一周的时间等分为24小时</p></li><li><p>UTC(Universal Time Coordinated): 协调世界时,以原子钟为基础的时间计量系统</p></li><li><p>时间戳与时间的转换: C语言的 <code>&lt;time.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> tm* <span class="hljs-title function_">gmtime</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">time_t</span>*)</span>;     <span class="hljs-comment">// 秒计数器转换为日期时间</span><br><span class="hljs-keyword">struct</span> tm* <span class="hljs-title function_">localtime</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">time_t</span>*)</span>;  <span class="hljs-comment">// 秒计数器转换为当地时间</span><br><span class="hljs-type">time_t</span> <span class="hljs-title function_">mktime</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tm*)</span>;            <span class="hljs-comment">// 日期时间转换为秒计数器</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="11-2-BKP-备份寄存器"><a href="#11-2-BKP-备份寄存器" class="headerlink" title="11.2 BKP 备份寄存器"></a>11.2 BKP 备份寄存器</h3><ol><li><p>BKP 可用于存储用户应用程序数据</p><ul><li>当 VDD(2.0 ~ 3.6V)电源被切断时,仍由 VBAT(1.8 ~ 3.6V)维持供电</li><li>就算系统复位,电源复位,BKP 也不会复位</li><li>用户数据存储容量: 20字节(中&#x2F;小容量), 84字节(大容量&#x2F;互联型)</li></ul></li><li><p><strong>TAMPER 引脚产生的侵入事件会将所有备份寄存器内容清除</strong></p></li><li><p>RTC 引脚输出: RTC 校准时钟, RTC 闹钟脉冲, 秒脉冲</p></li><li><p>BPK 基本结构</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/11-BPK%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png"></p></li><li><p><strong>读写 BKP</strong></p><ul><li><p>PWR, BKP 初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);<span class="hljs-comment">// 开启 PWR 的时钟</span><br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);<span class="hljs-comment">// 开启 BKP 的时钟</span><br>PWR_BackupAccessCmd(ENABLE);  <span class="hljs-comment">// 使用 PWR 开启对备份寄存器的访问</span><br></code></pre></td></tr></table></figure></li><li><p>读写备份寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">BKP_WriteBackupRegister(BKP_DR1, <span class="hljs-number">0x1234</span>);         <span class="hljs-comment">// 将 0x1234 写入数据寄存器1(1~10)</span><br><span class="hljs-type">uint16_t</span> data = BKP_ReadBackupRegister(BKP_DR1);  <span class="hljs-comment">// 将 数据寄存器1 的值读出</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="11-3-RTC-实时时钟"><a href="#11-3-RTC-实时时钟" class="headerlink" title="11.3 RTC 实时时钟"></a>11.3 RTC 实时时钟</h3><ol><li><p><strong>RTC(Real Time Clock): 实时时钟,RTC是一个独立的定时器,可为系统提供时钟 &#x2F; 日历功能</strong></p><ul><li>RTC 和 时钟配置系统处于后备区域,系统复位时数据不清零</li><li>拥有32位可编程计数器,对应 Unix 时间戳的秒计数器</li><li>拥有20位可编程预分频器,适配不同频率的输入时钟.可选时钟源有<ul><li>HSE 时钟除以128(8MHz&#x2F;128)</li><li><strong>LSE 振荡器时钟(32.768KHZ)</strong></li><li>LSI 振荡器时钟(40KHz)</li></ul></li></ul></li><li><p>RTC 框图</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/11-RTC%E6%A1%86%E5%9B%BE.png"></p></li><li><p>RTC 基本结构</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/11-RTC%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png"></p></li><li><p>RTC 计时</p><ul><li><p>设置本地时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-type">time_t</span> seconds;       <span class="hljs-comment">// 全局变量 seconds 存储秒数时间戳</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> <span class="hljs-title">timeDate</span>;</span>  <span class="hljs-comment">// 全局变量 timeDate 存储时间结构体</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">myRTC_setTime</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-comment">//2024-01-01 00:00:00 Monday 伦敦时间</span><br>timeDate.tm_hour = <span class="hljs-number">0</span>;<br>timeDate.tm_min = <span class="hljs-number">0</span>;<br>timeDate.tm_sec = <span class="hljs-number">0</span>;<br>timeDate.tm_year = <span class="hljs-number">124</span>;  <span class="hljs-comment">// since 1900</span><br>timeDate.tm_mon = <span class="hljs-number">0</span>;  <span class="hljs-comment">// since 0</span><br>timeDate.tm_mday = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 月的天数</span><br><span class="hljs-comment">//timeDate.tm_wday = 1;  // 周的天数</span><br><span class="hljs-comment">//timeDate.tm_yday = 0;  // 年的天数</span><br><span class="hljs-comment">//timeDate.tm_isdst = 0;  // 非夏令时</span><br><br>seconds = mktime(&amp;timeDate);  <span class="hljs-comment">// 生成秒计数器时间</span><br>    RTC_SetCounter(seconds);  <span class="hljs-comment">// 将秒计数器写入到 RTC 的 CNT 中</span><br>    RTC_WaitForLastTask();    <span class="hljs-comment">// 等待上一次操作完成</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>初始化RTC</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);  <span class="hljs-comment">// 开启 PWR 的时钟</span><br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);  <span class="hljs-comment">// 开启 BKP 的时钟</span><br>PWR_BackupAccessCmd(ENABLE);  <span class="hljs-comment">// 使用 PWR 开启对备份寄存器的访问</span><br><br><span class="hljs-comment">/* 通过写入备份寄存器 DR1 的标志位,判断 RTC 是否是第一次配置.if成立则执行第一次的 RTC 配置 */</span><br><span class="hljs-keyword">if</span> (BKP_ReadBackupRegister(BKP_DR1) != <span class="hljs-number">0xA5A5</span>) &#123;  <span class="hljs-comment">/* 0XA5A5 为标志位 */</span><br>    RCC_LSEConfig(RCC_LSE_ON);  <span class="hljs-comment">// 开启 LSE 时钟</span><br>    <span class="hljs-keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSERDY) != SET);  <span class="hljs-comment">// 等待 LSE 准备就绪</span><br>    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);  <span class="hljs-comment">// 选择 RTCCLK 来源为 LSE</span><br>    RCC_RTCCLKCmd(ENABLE);  <span class="hljs-comment">// RTCCLK 使能</span><br>    RTC_WaitForSynchro();  <span class="hljs-comment">// 等待同步</span><br>    RTC_WaitForLastTask();  <span class="hljs-comment">// 等待上一次操作完成</span><br>    RTC_SetPrescaler(<span class="hljs-number">32768</span> - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 设置 RTC 预分频器.保证计数频率为 1Hz</span><br>    RTC_WaitForLastTask();  <span class="hljs-comment">// 等待上一次操作完成</span><br>    <br>    myRTC_setTime();  <span class="hljs-comment">// 设置初始时间</span><br>    BKP_WriteBackupRegister(BKP_DR1, <span class="hljs-number">0xA5A5</span>);  <span class="hljs-comment">// 在备份寄存器写入标志位</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    RTC_WaitForSynchro();  <span class="hljs-comment">// 等待同步</span><br>    RTC_WaitForLastTask();  <span class="hljs-comment">// 等待上一次操作完成</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>读取时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> tm* <span class="hljs-title function_">myRTC_readTime</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    seconds = RTC_GetCounter() + <span class="hljs-number">8</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>;  <span class="hljs-comment">// 读取 RTC 的 CNT.改为北京时间</span><br>    timeDate = *(localtime(&amp;seconds));  <span class="hljs-comment">// 转化为 tm 结构体存储</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="12-PWR-电源控制"><a href="#12-PWR-电源控制" class="headerlink" title="12 PWR 电源控制"></a>12 PWR 电源控制</h2><h3 id="12-1-PWR"><a href="#12-1-PWR" class="headerlink" title="12.1 PWR"></a>12.1 PWR</h3><ol><li><p><strong>PWR(Power Control, 电源控制): 负责 STM32 内部的电源供电部分,可实现可编程电压检测器和低功耗模式</strong></p></li><li><p>电源框图</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/12-%E7%94%B5%E6%BA%90%E6%A1%86%E5%9B%BE.png"></p></li><li><p>上电复位和掉电复位</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/12-%E4%B8%8A%E7%94%B5%E5%A4%8D%E4%BD%8D%E5%92%8C%E6%8E%89%E7%94%B5%E5%A4%8D%E4%BD%8D.png"></p></li><li><p><strong>可编程电压检测器(PVD): 监控 VDD 电源电压,当 VDD 上升&#x2F;下降到 PVD 阈值时,触发中断,执行紧急关闭任务</strong></p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/12-PVD%E7%9A%84%E9%97%A8%E9%99%90.png"></p></li></ol><h3 id="12-2-低功耗模式"><a href="#12-2-低功耗模式" class="headerlink" title="12.2 低功耗模式"></a>12.2 低功耗模式</h3><ol><li><p><strong>低功耗模式: 在系统空闲时,降低 STM32 的功耗,延长设备的使用时间</strong></p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/12-%E4%BD%8E%E5%8A%9F%E8%80%97%E6%A8%A1%E5%BC%8F.png"></p></li><li><p><strong>芯片在低功耗模式下无法直接下载程序: 下载程序步骤:按住复位键,点击下载程序,然后及时松开复位键</strong></p></li><li><p>修改芯片主频(修改文件 <code>Start/system_stm32f10x.c</code>)</p><ul><li>外部可见变量 <code>SystemCoreClock</code>: 系统主频的值</li><li>搜索 <code>SYSCLK_FREQ_xxMHz</code>,在此处进行的宏定义将会决定运行哪个设置系统时钟的函数</li></ul></li><li><p>进入睡眠模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">__WFI();  <span class="hljs-comment">// 进入睡眠模式,等待中断唤醒.一般置于主循环的最后一行</span><br>__WFE();  <span class="hljs-comment">// 进入睡眠模式,等待唤醒事件</span><br></code></pre></td></tr></table></figure></li><li><p>进入停机 &#x2F; 待机模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);  <span class="hljs-comment">// 停机和待机模式需开启 PWR 的时钟</span><br>PWR_EnterSTOPMode(PWR_Regulator_ON, PWR_STOPEntry_WFI);  <span class="hljs-comment">// 进入停止模式,并等待外部中断唤醒</span><br><span class="hljs-comment">//PWR_EnterSTANDBYMode();  // 进入待机模式,并等待指定的唤醒事件.唤醒后程序从头执行</span><br>SystemInit();  <span class="hljs-comment">// 从停止模式唤醒后,需重新配置时钟为 HSE(72MHz).而待机模式不需要</span><br></code></pre></td></tr></table></figure></li><li><p>设置闹钟或 PA0 上升沿唤醒待机模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">PWR_WakeUpPinCmd(ENABLE);  <span class="hljs-comment">// 使能 WakeUp 引脚(PA0)唤醒待机的功能(默认下拉低电平,高电平有效)</span><br>RTC_SetAlarm(<span class="hljs-type">uint32_t</span> AlarmValue);  <span class="hljs-comment">// 设置 RTC 闹钟的值</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="13-WDG-看门狗"><a href="#13-WDG-看门狗" class="headerlink" title="13 WDG 看门狗"></a>13 WDG 看门狗</h2><h3 id="13-1-看门狗功能"><a href="#13-1-看门狗功能" class="headerlink" title="13.1 看门狗功能"></a>13.1 看门狗功能</h3><ol><li><p><strong>看门狗(WDG, Watchdog)</strong></p><ul><li>监测程序的运行状态,当程序卡死时复位程序.保证安全性和可靠性</li><li><strong>看门狗本质是定时器,在指定的时间范围内,若未重置计数器,则硬件电路将产生复位信号</strong></li></ul></li><li><p><strong>独立看门狗(Independent WDG)</strong></p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/13-%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97%E6%A1%86%E5%9B%BE.png"></p><ul><li><p>键寄存器 IWDG_KR: 控制寄存器,用于控制硬件电路的工作,避免干扰发生</p><table><thead><tr><th>写入键寄存器的值</th><th>作用</th></tr></thead><tbody><tr><td>0xCCCC</td><td>启用独立看门狗</td></tr><tr><td>0xAAAA</td><td>IWDG_RLR 中的值重新加载到计数器(喂狗)</td></tr><tr><td>0x5555</td><td>解除 IWDG_PR, IWDG_RLR 的写保护</td></tr><tr><td>0x5555之外的值</td><td>启用 IWDG_PR, IWDG_RLR 的写保护</td></tr></tbody></table></li><li><p>超时时间</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/13-%E7%9C%8B%E9%97%A8%E7%8B%97%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4.png"></p><ul><li>超时时间: $T_{IWDG}$ &#x3D; 时钟周期 * PR 预分频系数 * (重装计数值 + 1)</li><li>其中,时钟周期&#x3D;1&#x2F;40KHz, PR 预分频系数只能取表中限定的值, 重装计数值12位(0~4095)</li></ul></li></ul></li><li><p><strong>窗口看门狗(Window WDG): 要求看门狗在精确计时窗口时作用(过早过晚均不行)</strong></p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/13-%E7%AA%97%E5%8F%A3%E7%9C%8B%E9%97%A8%E7%8B%97%E6%A1%86%E5%9B%BE.png"></p></li><li><p>对比独立看门狗与窗口看门狗</p><table><thead><tr><th></th><th>独立看门狗</th><th>窗口看门狗</th></tr></thead><tbody><tr><td>复位时机</td><td>计数器减到0</td><td>计数器T[5:0] 减到0 &#x2F; 过早重装计数器</td></tr><tr><td>中断</td><td>&#x2F;</td><td>早期唤醒中断</td></tr><tr><td>时钟源</td><td>LSI(40KHz)</td><td>PCLK1(36MHz)</td></tr><tr><td>预分频系数</td><td>4, 8, 32, 64, 128, 256</td><td>1, 2, 4, 8</td></tr><tr><td>计数器</td><td>12位</td><td>6位</td></tr><tr><td>超时时间</td><td>0.1ms ~ 26214.4ms</td><td>113us ~ 58.25ms</td></tr><tr><td>喂狗方式</td><td>写入键寄存器,重装固定值 RLR</td><td>直接写入计数器</td></tr><tr><td>防误操作</td><td>键寄存器和写保护</td><td>&#x2F;</td></tr><tr><td>用途</td><td>独立工作,对时间精度要求较低</td><td>要求看门狗在精确计时窗口起作用</td></tr></tbody></table></li></ol><h3 id="13-2-看门狗代码"><a href="#13-2-看门狗代码" class="headerlink" title="13.2 看门狗代码"></a>13.2 看门狗代码</h3><ol><li><p>判断复位信号来源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) == SET) &#123;  <span class="hljs-comment">// 成立说明是独立看门狗复位</span><br><span class="hljs-comment">//if (RCC_GetFlagStatus(RCC_FLAG_WWDGRST) == SET) &#123;  // 成立说明是窗口看门狗复位</span><br>RCC_ClearFlag();  <span class="hljs-comment">// 标志位不会自动清除,进入后需要手动清除</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>操作独立看门狗</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* IWDG 初始化.LSI 会在设置看门狗后自动配置,无需手动开启 */</span><br>IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);  <span class="hljs-comment">// 独立看门狗写使能</span><br>IWDG_SetPrescaler(IWDG_Prescaler_16);  <span class="hljs-comment">// 设置预分频为16</span><br>IWDG_SetReload(<span class="hljs-number">2499</span>);  <span class="hljs-comment">// 设置重装值为2499,独立看门狗的超时时间为 1/40000 * 16 * 2500=1s</span><br>IWDG_ReloadCounter();  <span class="hljs-comment">// 重装计数器,初始化喂狗. 主循环中每1秒都需要喂狗,否则复位</span><br>IWDG_Enable();  <span class="hljs-comment">// 独立看门狗使能</span><br><span class="hljs-comment">/* 主循环中喂狗 */</span><br>IWDG_ReloadCounter();  <span class="hljs-comment">//重装计数器</span><br></code></pre></td></tr></table></figure></li><li><p>操作窗口看门狗</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* WWDG 初始化.以窗口时长 30~50ms 为例 */</span><br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);  <span class="hljs-comment">// 开启 WWDG 的时钟</span><br>WWDG_SetPrescaler(WWDG_Prescaler_8);  <span class="hljs-comment">// 设置预分频为8</span><br>WWDG_SetWindowValue(<span class="hljs-number">0x40</span> | <span class="hljs-number">21</span>);  <span class="hljs-comment">// 设置窗口时长 1/36,000,000 * 4096 * 8 * (54-21) = 30ms</span><br>WWDG_Enable(<span class="hljs-number">0x40</span> | <span class="hljs-number">54</span>);  <span class="hljs-comment">// 使能并第一次喂狗,超时时间为 1/36,000,000 * 4096 * 8 * (54+1) = 50ms</span><br><span class="hljs-comment">/* 主循环中喂狗 */</span><br>WWDG_SetCounter(<span class="hljs-number">0x40</span> | <span class="hljs-number">54</span>);  <span class="hljs-comment">//重装计数器</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="14-Flash-闪存"><a href="#14-Flash-闪存" class="headerlink" title="14 Flash 闪存"></a>14 Flash 闪存</h2><h3 id="14-1-Flash-功能"><a href="#14-1-Flash-功能" class="headerlink" title="14.1 Flash 功能"></a>14.1 Flash 功能</h3><ol><li><p>STM32F1 系列中容量产品 Flash 闪存模块组织</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/14-%E9%97%AA%E5%AD%98%E6%A8%A1%E5%9D%97%E7%BB%84%E7%BB%87.png"></p></li><li><p><strong>读写 Flash 的用途</strong></p><ul><li><strong>利用程序存储器的剩余空间,保存用户数据(掉电不丢失)</strong></li><li><strong>通过在程序中编程(In-Application Programming),实现程序自我更新</strong></li></ul></li><li><p>下载程序方式</p><ul><li><strong>在线编程(In-Circuit Programming)</strong>: 更新程序存储器的全部内容<ul><li>通过 JTAG, SWD 协议(ST Link)或系统加载程序(Bootloader)下载程序</li></ul></li><li><strong>在程序中编程(In-Application Programming)</strong>: 使用微控制器支持的任意通信接口下载程序<ul><li>需要自己编写 Bootloader 程序(存储于程序更新时不覆盖的地方)</li><li>需要更新程序时,控制程序跳转到 Bootloader,接收通信数据(程序信息)</li><li>然后通过控制 Flash 读写,将程序信息存储于程序正常运行的地方</li></ul></li></ul></li><li><p>Flash 基本结构</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/14-Flash%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png"></p></li><li><p><strong>指针访问存储器</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// #define __IO volatile  // STM32对__IO的宏定义</span><br><span class="hljs-type">uint16_t</span> Data = *((__IO <span class="hljs-type">uint16_t</span> *)(<span class="hljs-number">0x08000000</span>));  <span class="hljs-comment">// 读取0x8000 0000地址的数据</span><br>* ((__IO <span class="hljs-type">uint16_t</span> *)(<span class="hljs-number">0x80000000</span>)) = <span class="hljs-number">0x1234</span>;  <span class="hljs-comment">// 给0x8000 0000地址写入数据.需要先解锁,执行相应流程</span><br></code></pre></td></tr></table></figure></li><li><p><strong>器件电子签名: 存放于闪存的系统存储区域,不可更改</strong></p><ul><li>读取方式: 使用指针直接读取指定地址下的存储器获得</li><li>闪存容量(单位kb)寄存器(16位)基地址: <code>0x1FFF F7E0</code></li><li>产品唯一身份标识寄存器(96位)基地址: <code>0x1FFF F7E8</code></li></ul></li></ol><h3 id="14-2-Flash-代码"><a href="#14-2-Flash-代码" class="headerlink" title="14.2 Flash 代码"></a>14.2 Flash 代码</h3><ol><li><p>读取 Flash: 通过指针直接读取指定地址的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 参数: address 要读取数据的字地址. 返回值: 指定地址下的数据</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">MyFLASH_ReadWord</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> address)</span>&#123;<span class="hljs-keyword">return</span> *((__IO <span class="hljs-type">uint32_t</span> *)(address));&#125;<br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">MyFLASH_ReadHalfWord</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> address)</span> &#123;<span class="hljs-keyword">return</span> *((__IO <span class="hljs-type">uint16_t</span> *)(address));&#125;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">MyFLASH_ReadByte</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> address)</span> &#123;<span class="hljs-keyword">return</span> *((__IO <span class="hljs-type">uint8_t</span> *)(address));&#125;<br></code></pre></td></tr></table></figure></li><li><p>擦除 Flash: 每次擦除前后都要解锁,加锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// FLASH 的所有页都会被擦除,包括程序文件本身.擦除后,程序将不复存在</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MyFLASH_EraseAllPages</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>FLASH_Unlock();  <span class="hljs-comment">// 解锁</span><br>FLASH_EraseAllPages();  <span class="hljs-comment">// 全擦除</span><br>FLASH_Lock(); <span class="hljs-comment">// 加锁</span><br>&#125;<br><br><span class="hljs-comment">// 擦除 pageAddress 页地址的数据</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MyFLASH_ErasePage</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> pageAddress)</span> &#123;<br>FLASH_Unlock();<br>FLASH_ErasePage(pageAddress);  <span class="hljs-comment">// 页擦除</span><br>FLASH_Lock();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>写入 Flash: 每次写入数据前后都要解锁,加锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在指定 address 地址写入数据 data</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MyFLASH_ProgramWord</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> address, <span class="hljs-type">uint32_t</span> data)</span> &#123;<br>FLASH_Unlock();  <span class="hljs-comment">// 解锁</span><br>FLASH_ProgramWord(Address, data);  <span class="hljs-comment">// 编程字(32位)</span><br>FLASH_Lock();  <span class="hljs-comment">// 加锁</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">MyFLASH_ProgramHalfWord</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> address, <span class="hljs-type">uint16_t</span> data)</span>  &#123;<br>FLASH_Unlock();<br>FLASH_ProgramHalfWord(address, data);  <span class="hljs-comment">// 编程半字(16位)</span><br>FLASH_Lock();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>中间层: 定义数组,当数据更新时先写入数组,然后写入闪存.上电时读取闪存数据到数组.对闪存数据统一管理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STORE_START_ADDRESS  0x0800FC00  <span class="hljs-comment">// 存储的起始地址(最后一页)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STORE_COUNT          512         <span class="hljs-comment">// 存储数据的个数</span></span><br><span class="hljs-type">uint16_t</span> Store_Data[STORE_COUNT];  <span class="hljs-comment">// 定义 SRAM 数组,大小为 512*16/8 = 1024 Byte = 1Kib</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Store_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">// 初始化参数存储模块</span><br>    <span class="hljs-comment">/* 如果是第一次使用,先初始化 */</span><br><span class="hljs-keyword">if</span> (MyFLASH_ReadHalfWord(STORE_START_ADDRESS) != <span class="hljs-number">0xA5A5</span>) &#123;<br>MyFLASH_ErasePage(STORE_START_ADDRESS);  <span class="hljs-comment">// 擦除指定页</span><br>MyFLASH_ProgramHalfWord(STORE_START_ADDRESS, <span class="hljs-number">0xA5A5</span>);  <span class="hljs-comment">// 写入自己规定的标志位</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">1</span>; i &lt; STORE_COUNT; i ++) &#123;  <span class="hljs-comment">// 将闪存数据全部清0,不包括标志位</span><br>MyFLASH_ProgramHalfWord(STORE_START_ADDRESS + i * <span class="hljs-number">2</span>, <span class="hljs-number">0x0000</span>);  <br>&#125;<br>&#125;<br><span class="hljs-comment">/* 上电时.将闪存数据加载回 SRAM 数组,实现 SRAM 数组的掉电不丢失 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>; i &lt; STORE_COUNT; i ++) &#123;  <span class="hljs-comment">// 读取闪存数据到数组,包括标志位</span><br>Store_Data[i] = MyFLASH_ReadHalfWord(STORE_START_ADDRESS + i * <span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Store_Save</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;  <span class="hljs-comment">// 保存数据到闪存.每当需要更新闪存时,调用该函数</span><br>MyFLASH_ErasePage(STORE_START_ADDRESS);  <span class="hljs-comment">// 擦除指定页</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>; i &lt; STORE_COUNT; i ++) &#123;  <span class="hljs-comment">// 写入数据,包括标志位</span><br>MyFLASH_ProgramHalfWord(STORE_START_ADDRESS + i * <span class="hljs-number">2</span>, Store_Data[i]);<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Store_Clear</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;  <span class="hljs-comment">// 将 SRAM 数组有效数据清0,不包括标志位</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">1</span>; i &lt; STORE_COUNT; i ++) &#123;<br>Store_Data[i] = <span class="hljs-number">0x0000</span>;<br>&#125;<br>Store_Save();  <span class="hljs-comment">// 保存数据到闪存</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>读取芯片 ID</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">*((__IO <span class="hljs-type">uint16_t</span> *)(<span class="hljs-number">0x1FFFF7E0</span>));  <span class="hljs-comment">// 闪存容量寄存器的值</span><br>*((__IO <span class="hljs-type">uint32_t</span> *)(<span class="hljs-number">0x1FFFF7E8</span>));  <span class="hljs-comment">// 产品唯一身份标识寄存器的值,共96位</span><br>*((__IO <span class="hljs-type">uint32_t</span> *)(<span class="hljs-number">0x1FFFF7E8</span> + <span class="hljs-number">0x04</span>));<br>*((__IO <span class="hljs-type">uint32_t</span> *)(<span class="hljs-number">0x1FFFF7E8</span> + <span class="hljs-number">0x08</span>));<br></code></pre></td></tr></table></figure></li><li><p><strong>指定烧录程序是的起始地址</strong>: 打开工程选项 -&gt; Target</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/14-%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F%E8%B5%B7%E5%A7%8B%E5%9C%B0%E5%9D%80.png"></p></li><li><p><strong>程序占用空间大小查看</strong></p><ul><li><p>编译完成后会出现提示信息: <code>Program Size: Code=2784 RO-data=1788 RW-data=4 ZI-data=2660</code></p><ul><li><code>Code + RO=-data + Rw-data = 4576</code>: ROM 使用空间</li><li><code>Rw-data + ZI-data = 2664</code>:  RAM 使用空间</li></ul></li><li><p>双击 <code>Target 1</code> 出现 <code>Project.map</code> 文件,拉到文件底部,可以直接查看程序占用空间情况</p><p><img src="/2024/11/11/STM32/STM32%E5%9F%BA%E7%A1%80/assets/14-%E7%A8%8B%E5%BA%8F%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%E6%9F%A5%E7%9C%8B.png"></p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>STM32 入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言入门</title>
    <link href="/2024/10/30/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/"/>
    <url>/2024/10/30/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="0-编译链接"><a href="#0-编译链接" class="headerlink" title="0 编译链接"></a>0 编译链接</h2><h3 id="0-1-源代码处理"><a href="#0-1-源代码处理" class="headerlink" title="0.1 源代码处理"></a>0.1 源代码处理</h3><ol><li><strong>预处理(Preprocessing)</strong>: 根据预处理指令,对源代码(source code file)进行文本替换(宏定义,条件编译,文件包含)<ul><li>删除所有注释 <code>//, /* */</code></li><li>展开所有宏定义 <code>#define</code></li><li>处理所有的条件编译指令 <code>#if, #ifdef, #endif...</code></li><li>添加行号和文件名标识</li><li>保留所有的 #pragma 编译器指令,留给编译器</li></ul></li><li><strong>编译(Compilation)</strong>: 将经过预处理之后的程序转换成特定汇编代码(assembly code).生成文本文<ul><li>词法分析: 将代码的字符序列转化为一系列 token(如关键字, 标识符, 特殊符号…)</li><li>语法分析: 生成以表达式为节点的语法树</li><li>语义分析: 进行静态语义分析(如类型转换).此时语法树有了类型</li></ul></li><li><strong>汇编(Assemble)</strong>: 将汇编代码转换成机器码(machine code),生成的文件称目标文件(二进制格式)</li><li><strong>链接(Linking)</strong>: 将多个目标文件以及所需的库文件(.so等)链接成最终的可执行文件(executable file)<ul><li>地址空间分配: 将目标文件的段信息进行合并</li><li>符号决议</li><li>重定位: 程序中调用的函数,全局变量在编译并未确定其地址.此时修正它们的地址</li></ul></li></ol><h3 id="0-2-宏定义"><a href="#0-2-宏定义" class="headerlink" title="0.2 宏定义"></a>0.2 宏定义</h3><ol><li><p>工作方式</p><ul><li><p>程序扩展 <code>#define</code> 的步骤</p><ul><li>调用宏时,对参数进行检查.如果包含了 <code>#define</code>  定义的符号,将其替换(双引号中的除外)</li><li>替换文本被插入到程序原来的位置.对于带参数的宏,参数名会被值替换</li><li>再次对结果文本进行扫描.如果还有由 <code>#define</code> 定义的符号,重复上述步骤</li></ul></li><li><p><code>#define</code> 定义的符号可以嵌套,但不能递归</p></li><li><p>预处理在编译之前,因此编译器不会对宏定义进行语法检查</p></li><li><p>预处理器搜索 <code>#define</code> 定义的符号时不检查字符串常量的内容</p></li><li><p>利用 <code>临近字符串自动连接的特性</code> 可将宏参数插入字符串常量</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT(FORMAT, VALUE)\</span><br><span class="hljs-meta">   printf(<span class="hljs-string">&quot;The value is &quot;</span> FORMAT <span class="hljs-string">&quot;\n&quot;</span>, VALUE)</span><br><br>PRINT(<span class="hljs-string">&quot;%d&quot;</span>, x+<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 替换为 printf(&quot;The value is &quot; &quot;%d&quot; &quot;\n&quot;, x+3);</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>注意事项</p><ul><li><p>宏定义中的空格不能忽视</p></li><li><p>宏不是语句.因此不需要分号</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> assert(e) ((void)(e) || _assert_error(__FILE__,__LINE__))</span><br></code></pre></td></tr></table></figure><ul><li><code>e</code>: 一个表达式. 当 <code>e==0</code> 时, <code>_assert_error(__FILE__,__LINE__)</code> 函数将被调用</li><li>由于 <code>||</code> 顺序求值.当  <code>e!=0</code>,右侧不会被计算</li></ul></li><li><p>宏不是类型定义</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 宏常用于多个不同变量的类型在一处说明.修改变量类型时仅需修改宏定义.提高可移植性 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOOTYPE struct foo</span><br>FOOTYPE a,b;<br><br><span class="hljs-comment">/* 类型定义更加通用 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> <span class="hljs-title">FOOTYPE</span>;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>预定义宏</p><table><thead><tr><th>符号</th><th>示例值</th><th>含义</th></tr></thead><tbody><tr><td><code>__FILE__</code></td><td>“name.c”</td><td>进行编译的源文件名</td></tr><tr><td><code>__LINE__</code></td><td>25</td><td>文件当前行号</td></tr><tr><td><code>__DATE__</code></td><td>“Aug 24 2023”</td><td>文件被编译的日期</td></tr><tr><td><code>__TIME__</code></td><td>“18:04:30”</td><td>文件被编译的时间</td></tr><tr><td><code>__STDC__</code></td><td>1</td><td>若编译器遵循 ANSI C,其值为1.否则未定义</td></tr></tbody></table></li><li><p>预处理指令</p></li></ol><table><thead><tr><th align="left">指令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">#define</td><td align="left">定义宏</td></tr><tr><td align="left">#include</td><td align="left">包含一个源代码文件</td></tr><tr><td align="left">#undef</td><td align="left">取消已定义的宏</td></tr><tr><td align="left">#ifdef</td><td align="left">如果宏已经定义返回真</td></tr><tr><td align="left">#ifndef</td><td align="left">如果宏没有定义返回真</td></tr><tr><td align="left">#if</td><td align="left">如果给定条件为真,则编译下面代码</td></tr><tr><td align="left">#else</td><td align="left">#if 的替代方案</td></tr><tr><td align="left">#elif</td><td align="left">如果 #if 的条件不为真,且当前条件为真.则编译下面代码</td></tr><tr><td align="left">#endif</td><td align="left">结束一个 #if……#else 条件编译块</td></tr><tr><td align="left">#error</td><td align="left">当遇到标准错误时,输出错误消息</td></tr><tr><td align="left">#pragma</td><td align="left">使用标准化方法,向编译器发布特殊的命令到编译器中</td></tr></tbody></table><ol start="5"><li><p><code>#define</code></p><ul><li><p><strong>无参宏定义</strong>: <code>#define name stuff</code> </p><ul><li>作用: 在该指令后面内容中,每当 <code>name</code> 出现,预处理器将其替换为 <code>stuff</code> </li><li>若 <code>stuff</code> 很长,可以将其分为几行,在行尾加上 <code>\</code> 表示下一行是上一行的延续<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG_PRINT print(<span class="hljs-string">&quot;File %s line %d: x=%d, y=%d, z=%d&quot;</span> \</span><br><span class="hljs-meta">__FILE__, __LINE__, x, y, z)</span><br>x *= <span class="hljs-number">2</span>; y += x; z = x * y;<br>DEBUG_PRINT;<span class="hljs-comment">//将打印出 文件名,行号,x,y,z的值</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>含参数宏定义</strong>: <code>#dedine name(parameter-list) stuff</code> </p><ul><li>其中参数列表 <code>parameter-list</code> 是由逗号分隔的符号列表,可能会出现在 <code>stuff</code> 中</li><li>作用: 在该指令后面内容中,每当 <code>name(parameter-list)</code> 出现,预处理器将其替换为 <code>stuff</code>,且每个参数均对应地被替换.注意在参数上加上括号,避免参数与操作符的相互作用而产生不可预料的后果<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(x) ((x) * (x))</span><br>SQUARE(<span class="hljs-number">5</span>); <span class="hljs-comment">//将被预处理器替换为 ((5) * (5))</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>可变参数宏定义</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHOWLIST(...) printf(__VA_ARGS__)</span><br>SHOWLIST(Clang, <span class="hljs-number">520</span>, pi);<span class="hljs-comment">//输出为 Clang, 520, pi</span><br></code></pre></td></tr></table></figure><ul><li><code>...</code> 表示可变参数.可变参数允许空参数</li><li><code>__VA_ARGS__</code> 在预处理中被实际的参数集替换</li></ul></li><li><p><code>#</code>: <strong>记号字符串化运算符</strong></p><ul><li><p>带参数的宏定义中,<code>#</code> 运算符后面应该跟一个参数</p></li><li><p><code>#argument</code> 会被预处理器翻译为字符串 <code>&quot;argument&quot;</code> </p></li><li><p>多个空白字符将被替换为一个空格</p></li><li><p><code>&quot;</code>将被替换为<code>\&quot;</code>,<code>\</code>将被替换为<code>\\</code>.即<code>&quot;</code> 和<code>\</code>被自动转义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT(FORMAT, VALUE)printf(<span class="hljs-string">&quot;The value of &quot;</span> #VALUE <span class="hljs-string">&quot; is &quot;</span> FORMAT <span class="hljs-string">&quot;\n&quot;</span>, VALUE)</span><br> <br>PRINT(<span class="hljs-string">&quot;%d&quot;</span>, x+<span class="hljs-number">3</span>);<br><span class="hljs-comment">//将被替换为 printf(&quot;The value of x+3 is %d\n&quot;, x+3);</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>##</code>: <strong>标记粘贴运算符</strong>,将两侧的符号连接为一个符号.可用于宏定义中从分离的文本片段创建标识符</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADD_TO_SUM(sum_number, value)\</span><br><span class="hljs-meta">   sum ## sum_number += value</span><br> <br>ADD_TO_SUM(<span class="hljs-number">5</span>,<span class="hljs-number">25</span>);<br><span class="hljs-comment">//将被替换为 sum5 += 25;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>宏不是函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> abs(x) (((x) &gt;= 0) ? (x) : -(x))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(a,b) ((a) &gt; (b)) ? (a) : (b)</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>宏定义只会被机械地替换.括号是为了保证不会因运算优先级出错</strong></p></li><li><p>在带参数的宏定义中,若一个操作数在多处用到,则会被求值多次</p><ul><li>例如 <code>max</code> 中,若 <code>a[i] &gt; b</code>,则 <code>max(a[i++], b)</code> 被展开为<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">((a[i++]) &gt; (b)) ? (a[i++]) : (b)  <span class="hljs-comment">// 使得 i 自增2次</span><br></code></pre></td></tr></table></figure></li><li>解决方法: 确保宏中的参数没有副作用 或 使用函数的方法实现</li></ul></li><li><p>如果宏参数在定义中出现的次数超过1次,且具有副作用.则使用时可能出现危险</p></li><li><p>带副作用的操作符和函数:</p><ul><li><code>++, --</code> 运算符</li><li><code>getchar()</code> 函数</li></ul></li></ul></li><li><p>宏相对于函数的区别</p><ul><li><p>函数调用有压栈,弹栈的额外开销</p></li><li><p>函数声明时需要指出参数的类型,宏不用</p></li><li><p>命名约定: 使用宏的语法和函数完全一致,为进行区别.<strong>宏名一般全大写</strong></p></li><li><p>函数只需出现在代码的某一处.而每个宏出现的地方都会被替换,导致代码变长</p></li><li><p><strong>函数无法传递将 <code>类型</code> 作为函数参数传递,宏可以</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MALLOC(n, type) ( (type *)malloc( (n) * sizeof(type) ) )</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-3-条件编译"><a href="#0-3-条件编译" class="headerlink" title="0.3 条件编译"></a>0.3 条件编译</h3><ol><li>声明<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> constant-expression</span><br>statements<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> constant-expression</span><br>    other statements<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    other statements<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li>其中 <code>constant-expression</code> 是常量表达式,由预处理器进行求值</li><li>该常量表达式 一般为字面值,或是一个由 <code>#define</code> 定义的符号.必须在程序执行前确定该值</li><li>如果<code>#if</code> 后面的 <code>constant-expression</code> 为真(非零),则 <code>statements</code> 被编译.否则将其删除</li><li><code>#elif</code> 子句出现的次数不限</li><li><code>#elif</code> 后面的每个 <code>constant-expression</code>语句 只有前面的所有常量表达式全为假时 才会被编译</li><li><code>#else</code> 后面的每个 <code>other statements</code>语句 只有前面的所有常量表达式全为假时 才会被编译</li></ul></li><li>使用方式<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x=%d, y=%d&quot;</span>,x,y);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li>检查是否被定义<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span>defined(symbol)<span class="hljs-comment">// 如果定义了符号 symbol ...</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>symbol    <span class="hljs-comment">// 如果定义了符号 symbol ...</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span>!defined(symbol)<span class="hljs-comment">// 如果未定义符号 symbol ...</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span>symbol    <span class="hljs-comment">// 如果未定义符号 symbol ...</span></span><br></code></pre></td></tr></table></figure></li><li>指令嵌套<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined( OS_UNIX )</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OPTION1</span><br>unix_version_of_option1();<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/*OPTION1*/</span></span><br>            <br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OPTION2</span><br>unix_version_of_option2();<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/*OPTION2*/</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined( OS_MSDOS )</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OPTION2</span><br>msdos_version_of_option2();<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/*OPTION2*/</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/*defined( OS_UNIX )*/</span></span><br></code></pre></td></tr></table></figure><ul><li><code>#endif</code> 语句后加上一条注释标签,帮助阅读</li><li>上述代码的用意为 <code>在不同的操作系统中根据选项决定使用不同的方案</code></li></ul></li></ol><h3 id="0-4-文件包含"><a href="#0-4-文件包含" class="headerlink" title="0.4 文件包含"></a>0.4 文件包含</h3><ol><li><p>头文件中通常会包含</p><ul><li><p>明示常量, 宏函数, 函数声明, 结构体模板定义, 类型定义</p></li><li><p>在头文件中声明外部变量可实现与其他文件共享变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> status = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 该变量声明于源代码文件中(.c),且具有文件作用域</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> status;  <span class="hljs-comment">// 该语句声明于头文件中(.h).则包含了该头文件的代码均可访问 status 变量</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>#include</code></p><ul><li>预处理器将会删除此指令,然后用包含的文件内容取代</li><li>当头文件被包含时,位于头文件内的所有内容都要被编译</li><li>每个头文件仅需包含一组函数&#x2F;数据的声明</li></ul></li><li><p>包含库函数的头文件: <code>#include &lt;filename&gt;</code></p><ul><li><code>filename</code> 并不存在限制.但约定标准库文件以 <code>.h</code> 结尾</li></ul></li><li><p>包含本地文件: <code>#include &quot;filename&quot;</code></p><ul><li>处理方式: 先在源文件的当前位置查找,若没有,则用查找函数库头文件的方式查找</li></ul></li><li><p>嵌套文件包含</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __HEADER_NAME__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __HEADER_NAME__ 1</span><br><span class="hljs-comment">/* All the stuff that you want in the header file */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li><strong>使用条件编译可以避免多重包含</strong></li><li>当第一次包含该文件时, <code>#define __HEADER_NAME__ 1</code> 被执行,再次包含时将被忽略</li><li>定义可以省略<code>1</code>, 即: <code>#define __HEADER_NAME__ </code>.该符号被定义为一个空字符,也是被定义的</li></ul></li><li><p><code>#error</code>: 生成错误信息</p><ul><li><p>语法: <code>#error text of error message</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span>defined(OPTION_A)</span><br><span class="hljs-comment">/* stuff needed for option A */</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span>defined(OPTION_B)</span><br><span class="hljs-comment">/* stuff needed for option B */</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span>defined(OPTION_C)</span><br><span class="hljs-comment">/* stuff needed for option C */</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">error</span> NO option selected!</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>#line</code></p><ul><li>语法: <code>#line number &quot;string&quot;</code></li><li>作用: 通知编译器 <code>number</code> 是下一行输入的行号.<code>&quot;string&quot;</code> 为可选部分.表示将其作为当前文件的名字</li><li><code>#line</code> 将会修改 <code>__LINE__</code> 和 <code>__FILE__</code> 的值</li><li>常用于将其他语言代码转化为 C代码的程序</li></ul></li><li><p>无效指令</p><ul><li>语法: 以 <code>#</code> 开头,但后面没有内容的行</li><li>处理方式: 被预处理器简单地删除</li><li>用法: 凸显某一行<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">#<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>#<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-5-词法分析"><a href="#0-5-词法分析" class="headerlink" title="0.5 词法分析"></a>0.5 词法分析</h3><ol><li><p><code>token</code> 指程序的一个基本组成单元</p></li><li><p>词法分析器: 编译器中负责将程序分解为一个一个符号的部分</p><ul><li>符号之间的空白(空格符,制表符,换行符)将会被忽略</li></ul></li><li><p>词法分析的贪心法</p><ul><li>C 语言分为单字符符号和多字符符号</li><li><strong>编译器在读取符号时的规则为: 每一个符号应包含尽可能多的字符</strong></li><li>编译器将程序分解为符号的方法: 从左往右读入字符,如果该字符可能成为一个符号,那么再读入下一个字符.判断已读入的2个字符是否可能组成一个符号,如果可能继续读入,重复步骤,直到不可能组成一个有意义的符号</li><li>除了字符串和字符常量,符号的中间不能嵌入空白(空格符,制表符,换行符)</li></ul></li></ol><h3 id="0-6-链接"><a href="#0-6-链接" class="headerlink" title="0.6 链接"></a>0.6 链接</h3><ol><li><p>编译与链接</p><ul><li>C 程序可由多个部分分别编译组成,连接器可以将其合并成一个整体</li><li>编译器一般只处理一个文件,因此无法检测出需要了解多个文件才能察觉的错误</li><li>连接器在许多系统独立于 C 语言实现,因而如果错误与 C 语言相关,连接器是无法察觉的</li></ul></li><li><p>连接器</p><ul><li><strong><code>分别编译</code>是 C 语言的一个重要思想.多个源程序分别编译,在恰当的时候整合</strong></li><li>连接器并不需要理解 C 语言.它理解机器语言和内存布局.而编译器将源程序翻译给连接器</li><li>连接器读入目标模块,同时生成载入模块<ul><li>对于目标模块的每个外部对象,连接器需要检查载入模块中是否有同名的外部对象</li><li>没有,则将该外部对象添加到载入模块</li><li>若有,则处理命名冲突</li></ul></li><li>除了外部对象,目标模块还可能包含对其他模块中外部对象的引用<ul><li>如调用了 printf 函数的程序,包含一个对 printf 函数的引用</li><li>该引用指向一个位于某个库文件中的外部对象</li></ul></li></ul></li><li><p>声明与定义</p><ul><li>当 <code>int a;</code> 语句声明于函数外部.a 定义为一个外部整型变量.且会为 a 分配存储空间,将其初始化为0</li><li>声明 <code>extern int a;</code> 时,并非是对 a 的定义(但仍是外部变量).连接器认为这是对外部变量 a 的引用,而非定义</li><li>每个外部对象必须在程序的某个地方定义</li></ul></li><li><p>形参, 实参, 返回值</p><ul><li>任何一个 C 函数都有返回类型: <code>void</code> 或函数生成结果的类型<ul><li>若函数在调用它的文件中,第一次调用之前进行了声明或定义.则其返回值类型是非常明确的</li><li>若函数在被声明或定义之前被调用,则返回类型默认为 <code>int</code></li><li>若需要调用另一文件中的函数,则应在调用它的文件中对其进行声明</li></ul></li><li>形参和实参的匹配<ul><li>ANSI C 允许声明时指定函数的类型</li><li>函数声明中可以省略参数类型的说明(函数定义中不能省略).<code>float -&gt; double; short, char -&gt; int</code></li></ul></li></ul></li></ol><h2 id="1-库函数"><a href="#1-库函数" class="headerlink" title="1  库函数"></a>1  库函数</h2><h3 id="1-1-字符类别测试"><a href="#1-1-字符类别测试" class="headerlink" title="1.1 字符类别测试"></a>1.1 字符类别测试</h3><ol><li><p>下列函数声明于 <code>&lt;ctype.h&gt;</code></p></li><li><p>下面这些函数参数类型均为 <code>int</code>,其值必须为<code>EOF</code>或可用<code>unsigned char</code>类型表示的字符</p></li><li><p>函数的返回值类型也为 <code>int</code>.若满足指定的条件,返回非零值(真).否则返回0(假)</p><table><thead><tr><th>函数</th><th>假定的判断</th></tr></thead><tbody><tr><td>isalnum(c)</td><td>小写字母或数字</td></tr><tr><td>isalpha(c)</td><td>字母</td></tr><tr><td>iscntrl(c)</td><td>控制字符</td></tr><tr><td>isdigit(c)</td><td>十进制数</td></tr><tr><td>isgraph(c)</td><td>除空格外的可打印字符</td></tr><tr><td>islower(c)</td><td>小写字母</td></tr><tr><td>isprint(c)</td><td>包括空格的可打印字符</td></tr><tr><td>ispunct(c)</td><td>除空格,字母,数字外的可打印字符</td></tr><tr><td>isspace(c)</td><td>空格&#x2F;换页符&#x2F;换行符&#x2F;回车符&#x2F;横(纵)向制表符</td></tr><tr><td>isupper(c)</td><td>大写字母</td></tr><tr><td>isxdigit(c)</td><td>十六进制数</td></tr></tbody></table></li><li><p>在7位 ASCII 字符集中</p><ul><li>可打印字符为 0x20(‘ ‘)~0x7E(‘-‘)</li><li>控制字符为 0(NUL)~0x1F(US), 再加上0x7F(DEL)</li></ul></li><li><p>字符的大小写转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">tolower</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 当 c 为大写字母时才会进行转换.否则返回 c 自身</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">toupper</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-2-字符串函数"><a href="#1-2-字符串函数" class="headerlink" title="1.2 字符串函数"></a>1.2 字符串函数</h3><ol><li><p>下列函数声明于 <code>&lt;string.h&gt;</code>.其中有2组字符串函数.分别以 <code>str, mem</code> 开头</p></li><li><p>比较函数将参数作为 <code>unsigned char</code> 类型的数组处理</p><ul><li><code>s, t</code> 类型为 <code>char *</code></li><li><code>cs, ct</code> 类型为 <code>const char *</code></li><li><code>n</code> 类型为 <code>size_t</code></li><li><code>c</code>类型为 <code>int</code>(会被转换为<code>char</code>)</li></ul><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><strong>char *strcpy(s, ct);</strong></td><td>将 ct 复制到 s 中(包括<code>&#39;\0&#39;</code>),返回 s</td></tr><tr><td>char *strncpy(s, ct, n);</td><td>复制过程最大数目被限制为 n.若 ct 不足 n 个,用<code>&#39;\0&#39;</code>填充</td></tr><tr><td><strong>char *strcat(s, ct);</strong></td><td>将 ct 连接到 s 的尾部,返回 s</td></tr><tr><td>char *strncat(s, ct, n);</td><td>连接过程最大数目被限制为 n. 并以 <code>&#39;\0&#39;</code> 结束</td></tr><tr><td><strong>int strcmp(cs, ct);</strong></td><td>比较 cs 和 ct</td></tr><tr><td>int strncmp(cs, ct, n);</td><td>比较过程最大数目被限制为n</td></tr><tr><td>char *strchr(cs, c);</td><td>在 cs 中查找字符 c.若不存在返回<code>NULL</code></td></tr><tr><td>char *strrchr(cs, c);</td><td>将查找的方向反向</td></tr><tr><td>size_t strspn(cs, ct);</td><td>计算 cs 中包含 ct 前缀长度</td></tr><tr><td>size_t strcspn(cs, ct);</td><td>计算 cs 中不包含 ct 前缀长度</td></tr><tr><td>char *strpbrk(cs, ct);</td><td>在 cs 中查找 ct 包含的任意字符.若不存在返回<code>NULL</code></td></tr><tr><td><strong>char *strstr(cs, ct);</strong></td><td>在cs中查找ct.返回指向第一次出现的位置的指针</td></tr><tr><td><strong>size_t strlen(cs);</strong></td><td>计算 cs 的长度</td></tr><tr><td>char *strerror(n);</td><td>返回一个指向 与错误编号n对应的错误信息字符串 的指针</td></tr><tr><td>char *strtok(s, ct);</td><td>在 s 中搜索由 ct 中字符界定的记号</td></tr></tbody></table></li><li><p>由 <code>mem</code> 开头的函数按字符数组的方式操作对象</p><ul><li><code>s, t</code> 类型为 <code>void *</code> </li><li><code>cs, ct</code> 类型为 <code>const void *</code></li><li><code>n</code> 类型为 <code>size_t</code></li><li><code>c</code> 类型为 <code>int</code>(将会被转换为 <code>unsigned char</code>)</li></ul><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><strong>void *memcpy(s, ct, n);</strong></td><td>将 ct 的 n 个字符复制到 s 中,返回 s</td></tr><tr><td>void *memmove(s, ct, n);</td><td>将复制过程扩展为 对象重叠时仍可正确执行</td></tr><tr><td>int memcmp(cs, ct, n);</td><td>与 <code>strcmp</code> 相似</td></tr><tr><td>void *memchr(cs, c, n);</td><td>在 cs 中查找字符 c.若不存在返回<code>NULL</code></td></tr><tr><td><strong>void *memset(s, c, n);</strong></td><td>将 s 的前 n 个对象替换为 c,返回s</td></tr></tbody></table></li></ol><h3 id="1-3-标准输入输出"><a href="#1-3-标准输入输出" class="headerlink" title="1.3 标准输入输出"></a>1.3 标准输入输出</h3><ol><li><p><code>getchar</code></p><ul><li>函数原型: <code>int getchar(void)</code></li><li>作用: 从标准输入一次读入一个字符</li><li>机制: 每次被调用时返回下一个输入字符.如果遇到文件结尾,返回EOF(在<code>stdio.h</code>中定义)</li></ul></li><li><p><code>putchar</code></p><ul><li>函数原型: <code>int putchar(int)</code></li><li>作用: 将字符送到标准输出上,默认为屏幕</li><li>机制: 若无错误发生,返回输出的字符.若发生错误,返回EOF</li></ul></li><li><p><code>perror</code>: 打印错误信息(函数定义于 <code>stdio.h</code>)</p><ul><li><code>errno</code>(外部变量,在<code>errno.h</code>中定义)用于保存错误代码</li><li>函数原型: <code>void perror(char const *message);</code></li><li>作用: 打印出 <code>message</code> 指向的字符串,加上一个 空格和分号.然后打印一条解释 <code>errno</code> 当前错误的信息</li></ul></li><li><p><code>printf</code></p><ul><li><p>函数原型: <code>int printf(const char *format, ...)</code></p></li><li><p>作用: 将字符串进行格式化转换,然后进行标准化输出.等价于 <code>fprintf(stdout, ...)</code></p></li><li><p>机制: 按照 <code>format</code> 参数说明的格式进行转换,写入标准输出流.返回值为实际写入的字数.出错返回一个负值</p></li><li><p>格式串的组成</p><ul><li><p>普通字符: 被复制到输出流</p></li><li><p>转换说明: 决定下一后续参数的转换和打印.以<code>%</code>开头,转换字符结束.中间还可包含:</p><ol><li><code>标志(出现顺序不限)</code>: 用于修改转换说明<ul><li><code>-</code>: 指定被转换的参数在其字段左对齐</li><li><code>+</code>: 指定在输出的数前面加上 <code>正负号</code></li><li><code>空格</code>: 若第一个字符不是<code>正负号</code>, 则在其前面加上一个空格</li><li><code>0</code>: 对于数值转换,当输出长度小于字段宽度时,用0填充</li><li><code>#</code>: 指定另一种输出形式<ul><li>若为<code>o</code>转换,则第一个数字为0</li><li>若为 <code>e/E/f/g/G</code>转换,指定输出总是包括一个小数点</li><li><code>g/G</code> 转换还将保留尾部无意义的0</li></ul></li></ul></li><li><code>数值</code>: 用于指定最小字段宽度<ul><li>若参数字符数小于该数值,则在参数左边填充一些字符(通常为空格)</li><li>若指定左对齐,则在参数右边填充</li><li>若设置了0填充,则填充字符为0</li></ul></li><li><code>.</code>: 用于分隔字段宽度和精度</li><li><code>数值</code>: 用于指定精度<ul><li>若对象为字符串,则指定打印的字符最大个数</li><li>若为<code>e/E/f</code>转换,则指定打印的小数点后的位数</li><li>若为<code>g/G</code>转换,则指定打印的有效数字位数</li><li>若对象为整型数,则指定打印的数字位数(必要时进行0填充)</li></ul></li><li><code>h/l/L</code>: 长度修饰符,用于将参数指定为某种类型<ul><li><code>h</code>: 指定为 short&#x2F;unsigned short 类型</li><li><code>l</code>: 指定为 long&#x2F;unsigned long 类型</li><li><code>L</code>: 指定为 long double 类型</li></ul></li><li>宽度和精度均可用 <code>*</code> 进行指定.此时该值将通过转换下一参数(int 类型)得到</li></ol></li><li><p><code>printf</code> 转换字符(若<code>%</code>后的字符不是转换字符,则为未定义行为)</p><table><thead><tr><th>转换字符</th><th>参数类型 &amp; 转换结果</th></tr></thead><tbody><tr><td>d, i</td><td>int. 有符号十进制表示</td></tr><tr><td>o</td><td>unsigned int. 无符号八进制表示(无前导0)</td></tr><tr><td>x, X</td><td>unsigned int. 无符号十六进制表示(无前导0x&#x2F;0X),区分大小写</td></tr><tr><td>u</td><td>int. 无符号十进制表示</td></tr><tr><td>c</td><td>int. 转换为 unsigned char 类型后为1个字符</td></tr><tr><td>s</td><td>char *. 打印字符串的字符.直到 <code>&#39;\0&#39;</code> 或 达到被精度指定的字符数</td></tr><tr><td>f</td><td>double. 形式为: [-]mmm.ddd 的十进制表示<br />d 的数目由精度指定,默认为6. 当精度为0时不打印小数点</td></tr><tr><td>e, E</td><td>double. 形式为: <code>$[-]m.dddddd \quad e/E\pm xx$</code> 的十进制表示<br />d 的数目由精度指定,默认为6. 当精度为0时不打印小数点</td></tr><tr><td>g, G</td><td>double. 当指数小于-4或大于精度时,采用 %e&#x2F;%E 的格式<br />否则采用 %f 的格式. 尾部的0与小数点不打印</td></tr><tr><td>p</td><td>void *. 打印指针值</td></tr><tr><td>n</td><td>int *. 到目前为止,printf 输出的字符数目被写到相应的参数<br />不进行参数转换</td></tr><tr><td>%</td><td>不进行参数转化.打印 <code>%</code></td></tr></tbody></table></li></ul></li></ul></li><li><p><code>scanf</code></p><ul><li><p>函数原型: <code>int scanf(const char *format, ...)</code></p></li><li><p>作用: 从标准输入读取输入,根据<code>format</code>进行转换,并将转换后的值 赋给后续的各个参数,而这些参数必须是指针. 等价于 <code>scanf(stdout, ...)</code></p></li><li><p>机制: 当 <code>format</code> 用完时,函数返回实际被转换并赋值的输入项的数目.若到达文件的末尾或在转换输入前出错,则返回 <code>EOF</code></p></li><li><p>格式串的组成</p><ul><li><p>空格和制表符</p></li><li><p>普通字符(除%),将与标准输入流的下一个空白字符进行匹配</p></li><li><p>转换说明: 决定下一个输入字符的转换方式.以<code>%</code>开头,转换字符结束.中间还可包含:</p><ol><li><code>*</code>: 赋值屏蔽字符.跳过对应的输入字段,不进行赋值</li><li><code>某个数值</code>: 指定最大字段宽度的数</li><li><code>h/l/L</code>: 指定目标字段宽度(类似 <code>printf</code> )</li></ol></li><li><p><code>scanf</code> 转换字符</p><table><thead><tr><th>转换字符</th><th>参数类型 &amp; 输入数据</th></tr></thead><tbody><tr><td>d</td><td>int *. 十进制整型数</td></tr><tr><td>i</td><td>int *. 整型数,可以为八进制(0开头)或十六进制(0x&#x2F;0X开头)</td></tr><tr><td>o</td><td>int *. 八进制整型数</td></tr><tr><td>u</td><td>unsigned int *. 无符号十进制整型数</td></tr><tr><td>x</td><td>int *. 十六进制整型数</td></tr><tr><td>c</td><td>char *. 根据字段宽度的大小(默认为1)将读取的字符保存到指定的数组中,不增加<code>&#39;\0&#39;</code><br />此时,读取输入将不会跳过空白符.若要读取下一非空白字符,可使用%1s</td></tr><tr><td>s</td><td>char *. 由非空白符组成的字符串(不包含引号).自动在数组末尾增加 <code>&#39;\0&#39;</code></td></tr><tr><td>e&#x2F;f&#x2F;g</td><td>float *. 浮点数的输入格式为: <code>$\pm$</code>(可选), 数字串(可能有小数), 指数字段(可选)</td></tr><tr><td>p</td><td>void *. 指针值</td></tr><tr><td>n</td><td>int *. 到目前为止,将 sacnf 读取的字符数目被写到相应的参数<br />不读取输入字符.不增加已转换的项目计数</td></tr><tr><td>[…]</td><td>char *.与方括号中的字符集合 匹配的输入字符中 最长的非空字符串<br /><code>[]...]</code> 表示集合中包含字符<code>]</code>. 自动在数组末尾增加 <code>&#39;\0&#39;</code></td></tr><tr><td>[^…]</td><td>char *.与方括号中的字符集合 <strong>不匹配</strong>的输入字符中 最长的非空字符串<br /><code>[^]...]</code> 表示集合中<strong>不包含</strong>字符<code>]</code>. 自动在数组末尾增加 <code>&#39;\0&#39;</code></td></tr><tr><td>%</td><td>表示 <code>%</code>,不进行赋值</td></tr></tbody></table></li></ul></li></ul></li></ol><h3 id="1-4-整型函数"><a href="#1-4-整型函数" class="headerlink" title="1.4 整型函数"></a>1.4 整型函数</h3><ol><li><p>算术(下列整型函数均声明于 <code>&lt;stdlib.h&gt;</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">abs</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">labs</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">int</span> value)</span>;<br><span class="hljs-type">div_t</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> numerator, <span class="hljs-type">int</span> denominator)</span>;<br><span class="hljs-type">ldiv_t</span> <span class="hljs-title function_">ldiv</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">int</span> numerator, <span class="hljs-type">long</span> <span class="hljs-type">int</span> denominator)</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>abs</code> 函数返回参数的绝对值, <code>labs</code> 函数处理的对象为 <code>long int</code> 类型</p></li><li><p><code>div</code> 函数进行带余整数除法,返回一个 <code>div_t</code> 的结构.包含两个字段:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> quot; <span class="hljs-comment">//商</span><br><span class="hljs-type">int</span> rem;  <span class="hljs-comment">//余数</span><br></code></pre></td></tr></table></figure></li><li><p><code>ldiv</code> 函数处理的对象为 <code>long int</code> 类型,而返回 <code>ldiv_t</code> 结构</p></li></ul></li><li><p>随机数</p><ul><li><p>用于产生伪随机数的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">rand</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">srand</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seed)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>rand</code> 返回一个范围在 0~RAND_MAX(至少为32767) 的伪随机数</p></li><li><p>可以用对 <code>rand</code> 返回值取模,然后加上一个偏移量的方式获取一个固定区间的随机数</p></li><li><p><code>srand</code> 函数可以设置随机数种子.根据参数对随机数发生器初始化</p></li><li><p>可以用时间作为随机数产生器的种子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">srand( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) time(<span class="hljs-number">0</span>) );<br></code></pre></td></tr></table></figure></li></ul></li><li><p>字符串转换</p><ul><li><p>字符串转换函数将 字符串转换为数值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">atoi</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>)</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">atol</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>)</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strtol</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">char</span> **unused, <span class="hljs-type">int</span> base)</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strtoul</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">char</span> **unused, <span class="hljs-type">int</span> base)</span>; <br><span class="hljs-type">double</span> <span class="hljs-title function_">atof</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">strtod</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">char</span> **unused)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>atoi,atol</code> 函数进行基数为10的转换</li><li><code>strtol,strtoul</code> 函数允许指定基数,还允许访问字符串的剩余部分</li><li>如果参数 <code>string</code> 中包含了前导空白字符 以及非法缀尾字符,将会被忽略</li><li>参数 <code>base</code> 的取值范围为 2<del>36,此时字母 A</del>Z 分别表示 10~35</li><li>特别的,当 <code>base</code> 的值为0时,表示接受 程序中任何可书写的整型字面值</li></ul></li><li><p>例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">x = strol(<span class="hljs-string">&quot;   590bear&quot;</span>, next, <span class="hljs-number">12</span>);<br></code></pre></td></tr></table></figure><ul><li>该指令的返回值为 9947,由于 e 在基数为12时非法,转换终止</li><li><code>next</code> 是一个指向指针的指针,指向的内容为: 指向字母 e 的指针</li></ul></li><li><p>如果参数 <code>string</code> 中不包含任何一个合法数值,返回0</p></li><li><p>如果被转换的值无法表示,函数将在 <code>errno</code> 中存储值 <code>ERANGE</code>.并返回下表中的一个值</p><table><thead><tr><th>函数</th><th>返回值</th></tr></thead><tbody><tr><td>strol</td><td>若值过大且为负,返回 <code>LONG_MIN</code>. 若值过大且为正,返回 <code>LONG_MAX</code></td></tr><tr><td>stroul</td><td>若值过大,返回 <code>ULONG_MAX</code></td></tr></tbody></table></li></ul></li></ol><h3 id="1-5-浮点型函数"><a href="#1-5-浮点型函数" class="headerlink" title="1.5 浮点型函数"></a>1.5 浮点型函数</h3><ul><li>下列函数声明于 <code>&lt;math.h&gt;</code>.绝大多数的参数和返回值类型为 <code>double</code></li><li>若函数的参数不在定义域内,出现<code>定义域错误</code>.函数返回一个由编译器提供的错误值,并置 <code>errno</code> 值为 <code>EDOM</code></li><li>若函数的结果值过大&#x2F;小,超出 <code>double</code> 的范围,出现返回错误.<ul><li>若过大,函数返回 <code>HUGE_VAL</code>(在<code>math.h</code>中定义)</li><li>若过小,函数返回 0,事实上也是范围错误</li></ul></li></ul><ol><li><p>三角函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*参数为弧度制的角度值*/</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">sin</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">cos</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">tan</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><br><span class="hljs-comment">/* 返回值为弧度制的角度值 */</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">asin</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">acos</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">atan</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span>;<br><br><span class="hljs-comment">/* 返回值为 y/x 的反正切值,利用参数的符号决定象限 */</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">atan2</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br></code></pre></td></tr></table></figure></li><li><p>双曲函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*参数为弧度制的角度值*/</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">sinh</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">cosh</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">tanh</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br></code></pre></td></tr></table></figure></li><li><p>对数和指数函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">exp</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">log</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">log10</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>exp</code> 返回 $e^x$</li><li><code>log</code> 返回 $\mathrm{ln}x$</li><li><code>log10</code> 返回 $\mathrm{log}_{10} x$</li><li>利用换底公式 $\mathrm{log}_b x&#x3D;\frac{\mathrm{ln} x}{\mathrm{ln} b}$ 计算任意底数的对数</li></ul></li><li><p>浮点表示形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">frexp</span><span class="hljs-params">(<span class="hljs-type">double</span> value, <span class="hljs-type">int</span> *exponent)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">ldexp</span><span class="hljs-params">(<span class="hljs-type">double</span> fraction, <span class="hljs-type">int</span> exponent)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">modf</span><span class="hljs-params">(<span class="hljs-type">double</span> value, <span class="hljs-type">double</span> *ipart)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>frexp</code> 函数返回值 <code>fraction</code>,取值范围为 [0.5, 1).满足 $\mathrm{fraction}\cdot2^\mathrm{exponent} &#x3D; \mathrm{value}$</li><li><code>ldexp</code> 函数相对地返回 <code>value</code>: $\mathrm{value}&#x3D;\mathrm{fraction}\cdot2^\mathrm{exponent}$</li><li><code>modf</code> 函数将浮点值分成整数和小数两部分,它们拥有与原值相同的符号</li></ul></li><li><p>幂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">pow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>pow</code> 函数返回 $x^y$. 计算时可能会用到对数</li><li><code>sqrt</code> 函数返回 $\sqrt{x}$</li></ul></li><li><p>底数,顶数,绝对值,余数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">floor</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">ceil</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">fabs</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">fmod</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>floor</code> 函数返回不大于参数的最大整数值,即向下取整</li><li><code>ceil</code> 函数返回不小于参数的最小整数值,即向上取整</li><li><code>fabs</code> 函数返回参数的绝对值</li><li><code>fmod</code> 函数返回 x&#x2F;y 的余数,符号与 x 相同</li></ul></li></ol><h3 id="1-6-日期和时间函数"><a href="#1-6-日期和时间函数" class="headerlink" title="1.6 日期和时间函数"></a>1.6 日期和时间函数</h3><ol><li><p>处理器时间(下列时间&#x2F;日期函数均声明于 <code>&lt;time.h&gt;</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">clock_t</span> <span class="hljs-title function_">clock</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>clock</code> 函数返回程序开始起处理去所消耗的时间,可能是个近似值</li><li>若需要精确时间,可在<code>main</code>函数开始调用一次<code>clock</code>,随后的调用进行减法来获取时间</li><li>若时间值过大,或机器无法获得时间,返回 -1</li><li><code>clock</code> 函数返回的数字由编译器定义,一般为处理器时钟滴答的次数</li><li>若需要将返回值换算成秒,应将其除以 <code>CLOCKS_PER_SEC</code></li></ul></li><li><p>当天时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">time_t</span> <span class="hljs-title function_">time</span><span class="hljs-params">(<span class="hljs-type">time_t</span> *returned_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>若参数为非NULL指针,则时间值将通过这个指针存储</li><li>若时间值太大,或机器无法提供日期和时间,返回 -1</li><li>标准并未规定时间的编码方式,因此不应使用字面值常量</li></ul></li><li><p>日期和时间的转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">ctime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> <span class="hljs-type">const</span> *time_value)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">difftime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> time1, <span class="hljs-type">time_t</span> time2)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>ctime</code> 函数的参数为 指向 <code>time_t</code> 的指针,返回一个指向字符串的指针<ul><li>返回的字符串格式为: <code>Sun Jul 4 04:02:48 1976\n\0</code></li><li>字符串内部的空格是固定的</li></ul></li><li><code>difftime</code> 函数计算 <code>time2 - time1</code> 的值,并将结果转换为秒</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> tm *<span class="hljs-title function_">gmtime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> <span class="hljs-type">const</span> *time_value)</span>;<br><span class="hljs-keyword">struct</span> tm *<span class="hljs-title function_">localtime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> <span class="hljs-type">const</span> *time_value)</span>;<br></code></pre></td></tr></table></figure></li><li><p>将一个 <code>time_t</code> 的值转换为一个 <code>tm</code> 结构,可以方便地访问各组成部分</p><ul><li><p><code>gmtime</code> 函数转换为世界协调时间</p></li><li><p><code>localtime</code> 函数转换为当地时间</p></li><li><p><code>tm</code> 结构的字段</p><table><thead><tr><th>类型 &amp; 名称</th><th>范围</th><th>含义</th></tr></thead><tbody><tr><td><code>int tm_sec</code></td><td>0~61</td><td>分之后的秒数</td></tr><tr><td><code>int tm_min</code></td><td>0~59</td><td>小时后的分数</td></tr><tr><td><code>int tm_hour</code></td><td>0~23</td><td>午夜后的小时数</td></tr><tr><td><code>int tm_mday</code></td><td>1~31</td><td>当月的日期</td></tr><tr><td><code>int tm_mon</code></td><td>0~11</td><td>1月后的月数</td></tr><tr><td><code>int tm_year</code></td><td>0~?</td><td>1900年后的年数</td></tr><tr><td><code>int tm_wday</code></td><td>0~6</td><td>星期天之后的天数</td></tr><tr><td><code>int tm_yday</code></td><td>0~365</td><td>1月1日后的天数</td></tr><tr><td><code>int tm_isdat</code></td><td></td><td>夏令时标志</td></tr></tbody></table></li></ul></li><li><p>将 <code>tm</code> 结构转换为字符串格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">asctime</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tm <span class="hljs-type">const</span> *tm_ptr)</span>;<br><span class="hljs-type">size_t</span> <span class="hljs-title function_">strftime</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">size_t</span> maxsize, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *format, <span class="hljs-keyword">struct</span> tm <span class="hljs-type">const</span> *tm_str)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>asctime</code> 转换为字符串的格式与 <code>ctime</code> 一致</p><ul><li><p><code>strftime</code> 格式化的非常灵活</p></li><li><p>若转换的结果字符串长度小于 <code>maxsize</code>,则该字符串将被复制到 <code>string</code> 中</p></li><li><p><code>strftime</code> 的返回值为字符串的长度.若返回的是 -1,则 <code>string</code> 内容未定义</p></li><li><p><code>strftime</code> 格式代码</p><table><thead><tr><th>代码</th><th>被…替代</th></tr></thead><tbody><tr><td>%%</td><td><code>%</code></td></tr><tr><td>%a(%A)</td><td>星期中的某天,用当地的简写(全写)表示</td></tr><tr><td>%b(%B)</td><td>月份,用当地的简写(全写)表示</td></tr><tr><td>%c</td><td>日期和时间,使用 <code>%x %X</code></td></tr><tr><td>%d</td><td>月份中的某天(01~31)</td></tr><tr><td>%H</td><td>小时,24小时制(00~23)</td></tr><tr><td>%I</td><td>小时,12小时制(00~12)</td></tr><tr><td>%J</td><td>一年中的某天(001~366)</td></tr><tr><td>%m</td><td>月份(01~12)</td></tr><tr><td>%M</td><td>分钟(00~59)</td></tr><tr><td>%P</td><td>AM&#x2F;PM</td></tr><tr><td>%S</td><td>秒(00~61)</td></tr><tr><td>%U(%W)</td><td>一年中的第几个星期(00~53),以星期日&#x2F;星期一为第一天</td></tr><tr><td>%w</td><td>一星期的第几天,星期日为 0</td></tr><tr><td>%x(%X)</td><td>日期&#x2F;时间,本地格式</td></tr><tr><td>%y(%Y)</td><td>当前世纪的年份(00~99)&#x2F;年份的全写(如2023)</td></tr><tr><td>%z</td><td>时区的简写,无法判断时为空</td></tr></tbody></table></li></ul></li><li><p>将 <code>tm</code> 结构转化为 <code>time_t</code> 值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">time_t</span> <span class="hljs-title function_">mktime</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tm *tm_ptr)</span>;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-7-排序和查找"><a href="#1-7-排序和查找" class="headerlink" title="1.7 排序和查找"></a>1.7 排序和查找</h3><ol><li><p>排序 <code>&lt;stdlib.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">qsort</span><span class="hljs-params">(<span class="hljs-type">void</span> *base, <span class="hljs-type">size_t</span> n_elements, <span class="hljs-type">size_t</span> el_size, \</span><br><span class="hljs-params">           <span class="hljs-type">int</span> (*compare)(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *) )</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>qsort</code> 函数是类型无关的,对任意数据类型的,固定长度的数组进行升序排序</p></li><li><p><code>base</code> 参数: 指向待排序的数组</p></li><li><p><code>n_elements</code> 参数: 指定数组中的元素数目</p></li><li><p><code>el_size</code> 参数: 指定每个元素的长度(单位为 字符)</p></li><li><p><code>compare</code> 是一个函数指针,对需要排序的元素类型进行比较.在排序时,调用该函数进行大小比较</p></li><li><p>比较函数接受2个参数,指向待比较的值.返回一个整数,表示参数的大小关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">//定义一个结构,根据 key 排序</span><br> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>     <span class="hljs-type">char</span> key[<span class="hljs-number">10</span>];<br>     <span class="hljs-type">int</span> otherData;<br> &#125; Record;<br><br><span class="hljs-comment">//比较函数,直接返回 strcmp 的计算结果</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">recordCompare</span><span class="hljs-params">(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *a, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *b)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>( (Record *)a-&gt;key, (Record *)b-&gt;key );<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Record <span class="hljs-built_in">array</span>[<span class="hljs-number">50</span>];<br>    qsort(<span class="hljs-built_in">array</span>, <span class="hljs-number">50</span>, <span class="hljs-keyword">sizeof</span>(Record), recordCompare);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>二分查找 <code>&lt;stdlib.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">bsearch</span><span class="hljs-params">(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *key, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *base, <span class="hljs-type">size_t</span> n_elements,\</span><br><span class="hljs-params">             <span class="hljs-type">size_t</span> el_size, <span class="hljs-type">int</span> (*compare)(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *) )</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>key</code> 参数: 待查找的值,必须和目标数组元素的类型相同</p></li><li><p><code>base</code> 参数: 指向目标数组</p></li><li><p><code>n_elements</code> 参数: 数组的元素数目</p></li><li><p><code>el_size</code> 参数: 每个元素的长度(以字符为单位)</p></li><li><p><code>compare</code> 参数: 指向比较参数.与 <code>qsort</code> 函数相同</p></li><li><p><code>bsearch</code> 函数: 返回一个指针,指向查找到的数组元素.若不存在,返回 <code>NULL</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">//定义一个结构,根据 key 排序</span><br> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>     <span class="hljs-type">char</span> key[<span class="hljs-number">10</span>];<br>     <span class="hljs-type">int</span> otherData;<br> &#125; Record;<br><br><span class="hljs-comment">//比较函数,直接返回 strcmp 的计算结果</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">recordCompare</span><span class="hljs-params">(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *a, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *b)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>( (Record *)a-&gt;key, (Record *)b-&gt;key );<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Record <span class="hljs-built_in">array</span>[<span class="hljs-number">50</span>];<br>    Record key; <span class="hljs-comment">//待查找的对象</span><br>    Record *ans;<br>    <br>    <span class="hljs-built_in">strcpy</span>(key.key, <span class="hljs-string">&quot;value&quot;</span>);<span class="hljs-comment">//比较函数中用到的 key 字段必须填充</span><br>    qsort(<span class="hljs-built_in">array</span>, <span class="hljs-number">50</span>, <span class="hljs-keyword">sizeof</span>(Record), recordCompare);<span class="hljs-comment">//二分查找需要先排序</span><br>    ans = bsearch(&amp;key, <span class="hljs-built_in">array</span>, <span class="hljs-number">50</span>, <span class="hljs-keyword">sizeof</span>(Record, recordCompare));<br>    <span class="hljs-comment">/* 现在 ans指向查找到的目标 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-8-信号"><a href="#1-8-信号" class="headerlink" title="1.8 信号"></a>1.8 信号</h3><ol><li><p>信号</p><ul><li>程序中绝大部分事件由其本身引发.但对于外部中断等事件,程序需要预备对这类时间作出反应</li><li><strong>信号表示一种事件,可能会异步发生.程序可设置一个信号处理函数,当信号发生,就调用它</strong></li><li>下面的函数位于 <code>&lt;signal.h&gt;</code></li></ul></li><li><p>信号名</p><table><thead><tr><th>信号</th><th>含义</th></tr></thead><tbody><tr><td>SIGABRT</td><td>程序请求异常终止</td></tr><tr><td>SIGFPE</td><td>发生一个算术错误</td></tr><tr><td>SIGILL</td><td>检测到非法指令</td></tr><tr><td>SIGSEGV</td><td>检测到对内存的非法访问</td></tr><tr><td>SIGINT</td><td>收到一个交互性注意信号</td></tr><tr><td>SIGTERM</td><td>收到一个终止程序的请求</td></tr></tbody></table><ul><li><code>SIGABRT</code> 是由 <code>abort</code> 函数引发的信号,用于终止程序</li><li><code>SIGILL</code> 提示 CPU 试图执行一条非法指令</li><li><code>SIGINT</code> 和 <code>SIGTERM</code> 是异步的,由程序外部产生</li></ul></li><li><p>处理信号</p><ul><li><p>显式的引发一个信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">raise</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span>;<br></code></pre></td></tr></table></figure></li><li><p>当一个信号发生时,程序可以有3种反应: 缺省方式(终止程序); 将其忽略; 设置信号处理函数对其反应</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*signal(<span class="hljs-type">int</span> sig, <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">int</span>))) (<span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><ul><li><code>signal</code> 是一个函数.返回一个函数指针,指向一个参数为 <code>int</code> 的无返回值函数</li><li><code>sig</code> 参数是<code>信号名</code>中列举的信号之一</li><li><code>handler</code> 参数是希望为该信号设置的处理函数,是一个函数指针,指向一个参数为 <code>int</code> 的无返回值函数</li><li>当信号发生时,信号的代码作为参数传递给 <code>handler</code> 指向的信号处理函数</li><li><code>signal</code> 返回一个指向该信号以前的处理函数的指针</li><li><code>signal.h</code> 定义了宏 <code>SIG_DFL, SIG_IGN</code>,可作为 <code>handler</code> 参数的值.分别表示缺省处理&#x2F;忽略信号</li></ul></li></ul></li><li><p>信号处理函数</p><ul><li>当一个已设置的信号处理函数的信号发生时,系统恢复对该信号的缺省行为(防止处理函数内部再次发生该信号而引起无限循环),然后,信号处理函数被调用,信号代码作为参数传入</li><li>信号处理函数可能执行的工作非常有限.对于异步信号,不应调用除 <code>signal.h</code> 以外的库函数</li><li>信号处理函数仅能向一个类型为 <code>volatile sig_atomic_t</code> 的静态变量赋值,其他静态数据可能无法访问</li><li>从一个信号处理函数返回,将导致执行流从信号发生的地点恢复执行(除了<code>SIGFPE</code>,无法完成计算)</li><li>若希望将来再次捕获同类型信号,需要在处理函数返回前,调用 <code>signal</code> 函数进行设置</li></ul></li></ol><h3 id="1-9-非本地跳转"><a href="#1-9-非本地跳转" class="headerlink" title="1.9 非本地跳转"></a>1.9 非本地跳转</h3><ol><li><p>类似于 <code>goto</code> 语句,但作用域并非局限于函数作用域</p></li><li><p>需要包含头文件 <code>setjump.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">setjump</span><span class="hljs-params">(jmp_buf state)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">longjump</span><span class="hljs-params">(jmp_buf state, <span class="hljs-type">int</span> value)</span>;<br></code></pre></td></tr></table></figure><ul><li>调用方式: 声明一个 <code>jmp_buf</code> 变量,使用 <code>setjump</code> 函数进行初始化,返回值为0</li><li><code>setjump</code> 会将程序信息保存到缓冲区.调用 <code>sejump</code> 时所处的函数成为 <code>顶层函数</code></li><li>在<code>顶层函数</code>或其他被它调用的函数处 调用 <code>longjump</code> 时,被保存的程序信息将会恢复.跳回 <code>顶层函数</code></li><li>当 <code>setjump</code> 函数第一次被调用返回0.当 <code>setjump</code> 作为 <code>longjump</code> 的执行结果时,返回 <code>value</code></li></ul></li></ol><h3 id="1-10-执行环境"><a href="#1-10-执行环境" class="headerlink" title="1.10 执行环境"></a>1.10 执行环境</h3><ol><li><p>终止执行 <code>&lt;stdlib.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">atexit</span><span class="hljs-params">(<span class="hljs-type">void</span> (func)(<span class="hljs-type">void</span>))</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>abort</code> 函数用于不正常地终止一个正在执行的程序.它将引发 <code>SIGABRT</code>,可为它设置信号处理函数</li><li><code>atexit</code> 函数可将一些函数注册为 <code>退出函数</code>.当程序要正常终止时,退出函数将被调用</li><li><strong><code>exit</code> 函数用于正常终止程序.当它被调用时,所有被 <code>atexit</code> 注册为退出函数按被注册顺序逆序依次调用.然后所有用于流的缓冲区被刷新,所有打开的文件被关闭,用<code>tempfile</code>函数创建的文件被删除.退出状态返回给宿主环境.程序停止执行</strong></li><li><code>exit</code> 函数的<code>status</code> 参数将会返回给操作系统</li><li><code>exit</code> 函数没有返回值: 当 <code>exit</code> 结束时,程序已经消失,它已无处可返</li></ul></li><li><p><strong>断言: 声明某事应该为真</strong> <code>&lt;assert.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">assert</span><span class="hljs-params">(<span class="hljs-type">int</span> expression)</span>;  <span class="hljs-comment">// 实际上这是不是函数,而是一个宏</span><br><span class="hljs-comment">/* expression 若为假,向标准错误打印一条诊断信息并终止程序.若为真,程序继续执行 */</span><br></code></pre></td></tr></table></figure></li><li><p>断言一般用于程序调试.当程序被完整地测试完毕,可在包含头文件 <code>aseert.h</code> 之前增加:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDEBUG</span><br><span class="hljs-comment">/* 定义了 NDEBUG 之后,预处理将丢弃所有的断言,而不必在源文件中实际将其删除 */</span><br></code></pre></td></tr></table></figure></li><li><p>执行系统命令 <code>&lt;stdlib.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">system</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *command)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>system</code> 函数将字符串参数传递给宿主操作系统</li><li><code>system</code> 函数可用 <code>NULL</code> 参数进行调用,用于询问命令处理器是否存在.若存在,返回一个非零值</li></ul></li></ol><h2 id="2-数据"><a href="#2-数据" class="headerlink" title="2 数据"></a>2 数据</h2><h3 id="2-1-基本数据类型"><a href="#2-1-基本数据类型" class="headerlink" title="2.1 基本数据类型"></a>2.1 基本数据类型</h3><ol><li><p>C 语言中的所有类型,要么是对象类型,要么是函数类型</p><ul><li>对象: 可以在其中表示值的一块存储区域(注意并非面向对象的对象)</li><li>函数: 并非对象,且其类型由 返回值类型, 参数的数量, 类型 共同决定</li></ul></li><li><p>C 语言的5种基本数据类型</p><ul><li>整型(short, int, long, long long)</li><li>浮点型(float, double, long double)</li><li>字符型(char)</li><li>布尔型(_Bool)</li><li>枚举(enum)</li></ul></li><li><p><strong>C 语言并未给定 int 的具体尺寸为多少字节,只需满足: <code>short &lt;= int &lt;= long &lt;= long int</code></strong><br><strong>因此需要 sizeof 运算符获取数据类型或表达式的尺寸</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">sizeof</span>(type_name);<br><span class="hljs-keyword">sizeof</span>(object);<br><span class="hljs-keyword">sizeof</span> object;<br></code></pre></td></tr></table></figure></li><li><p>ANSI C规定的整型的最小范围</p><table><thead><tr><th align="left">类型</th><th align="left">最小值</th><th>最大值</th></tr></thead><tbody><tr><td align="left">char</td><td align="left">0</td><td>127</td></tr><tr><td align="left">signed char</td><td align="left">-127</td><td>127</td></tr><tr><td align="left">unsigned char</td><td align="left">0</td><td>255</td></tr><tr><td align="left">short</td><td align="left">-32767</td><td>32767</td></tr><tr><td align="left">unsigned short</td><td align="left">0</td><td>65535</td></tr><tr><td align="left">int</td><td align="left">-32767</td><td>32767</td></tr><tr><td align="left">unsigned int</td><td align="left">0</td><td>65535</td></tr><tr><td align="left">long</td><td align="left">-2147483647</td><td>2147483647</td></tr><tr><td align="left">unsigned long</td><td align="left">0</td><td>4294967259</td></tr></tbody></table></li><li><p><code>&lt;limits.h&gt;</code> 中说明了不同整数&#x2F;浮点数类型的特点</p><table><thead><tr><th align="center"></th><th align="center">signed</th><th align="center">signed</th><th align="center">unsigned</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">最小值</td><td align="center">最大值</td><td align="center">最大值</td></tr><tr><td align="center">字符</td><td align="center">SCHAR_MIN</td><td align="center">SCHAR_MAX</td><td align="center">USCHAR_MAX</td></tr><tr><td align="center">短整型</td><td align="center">SHRT_MIN</td><td align="center">SHRT_MAX</td><td align="center">USHRT_MAX</td></tr><tr><td align="center">整型</td><td align="center">INT_MIN</td><td align="center">INT_MAX</td><td align="center">UINT_MAX</td></tr><tr><td align="center">长整型</td><td align="center">LONG_MIN</td><td align="center">LONG_MAX</td><td align="center">ULONG_MAX</td></tr><tr><td align="center">单精度</td><td align="center">FLT_MIN</td><td align="center">FLT_MAX</td><td align="center">&#x2F;</td></tr><tr><td align="center">双精度</td><td align="center">DBL_MIN</td><td align="center">DBL_MAX</td><td align="center">&#x2F;</td></tr><tr><td align="center">扩展精度</td><td align="center">LDBL_MIN</td><td align="center">LDBL_MAX</td><td align="center">&#x2F;</td></tr></tbody></table></li><li><p><strong>缺省的 <code>char</code> 并未规定是否有符号</strong></p><ul><li>使用 <code>char</code> 型变量时最好将其范围限制在 [0, 127]</li><li>当明确声明了 <code>char</code> 是否有符号后,才对其进行算数运算</li></ul></li><li><p>整型字面值</p><ul><li><p>缺省情况下的十进制字面值将被指定为最短的能容纳该值的类型</p></li><li><p>在字面值加上后缀可以指定其整型的类型</p><ul><li><p>l&#x2F;L: long</p></li><li><p>u&#x2F;U: unsigned</p></li><li><p>u&#x2F;l 可以进行组合</p></li></ul></li><li><p>八进制表示方法: 在数值前加上 <code>0</code></p></li><li><p>十六进制表示方法: 在数值前加上 <code>0x</code></p></li><li><p>字符常量: 单引号下的单个字符(也可以是转义字符或三字母词)</p></li></ul></li><li><p>枚举类型: 其值为符号常量,而非字面值</p><ul><li>枚举类型的变量其本质上是整型</li><li>枚举声明中的符号名会被当作整型常量处理(从0开始,后面的值比前面大1)</li></ul></li><li><p>浮点类型</p><ul><li>浮点数字面值在缺省情况下为 <code>double</code>.后缀为 l&#x2F;L 可指定其为 <code>float</code></li><li>所有浮点类型必须可以容纳 $10^{-37}\sim 10^{37}$ 间的任意值</li></ul></li></ol><h3 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h3><ol><li><p>变量和常量是程序处理的两种基本数据类型</p><ul><li>通常待处理的数据会被置于内存中</li><li>存放数据的位置即是一个地址,CPU 可以通过地址找到该数据</li></ul></li><li><p>变量命名规则</p><ul><li>只能由英文字母(<code>_</code> 也视为字母)和数字组成</li><li>英文字母开头</li><li>区分大小写</li><li>不能使用关键字</li></ul></li><li><p>ANSI C 有32个关键字:</p><table><thead><tr><th>auto</th><th>break</th><th>case</th><th>char</th><th>const</th><th>continue</th><th>default</th><th>do</th></tr></thead><tbody><tr><td>double</td><td>else</td><td>enum</td><td>extern</td><td>float</td><td>for</td><td>goto</td><td>if</td></tr><tr><td>int</td><td>long</td><td>register</td><td>return</td><td>short</td><td>signed</td><td>sizeof</td><td>static</td></tr><tr><td>struct</td><td>switch</td><td>typedef</td><td>union</td><td>xxxxxxxxxx const int cnum &#x3D; 520;const int *const p &#x3D; &cnum;c</td><td>void</td><td>volatile</td><td>while</td></tr></tbody></table><ul><li>C99 标准新增5个关键字: <code>inline, restrict, _Bool, _Complex, _Imaginary</code></li><li>C11 标准新增7个关键字: <code>_Alignas, _Alignof, _Atomic, _Static_assert, _Noreturn, _Thread_local, _Generic</code></li></ul></li><li><p>局部变量</p><ul><li><code>for</code> 语句中的初始化语句定义的是局部变量,仅适用于复合语句内部</li><li><strong>一个函数定义的变量无法在另一个函数中访问</strong></li><li>C 语言允许随处定义变量</li></ul></li><li><p>全局变量</p><ul><li><strong>定义于函数之外的即为全局变量.会自动初始化为 0</strong></li><li>函数内部存在同名全局变量和局部变量时,会屏蔽掉全局变量</li></ul></li><li><p>减少全局变量的使用</p><ul><li>全局在程序退出是才会被释放.导致占用更多内存</li><li>使用全局变量将导致: 命名空间污染,耦合性提高</li></ul></li><li><p>C 语言的变量有用两种生存期: 静态存储期和自动存储期</p><ul><li><strong>静态存储期:</strong> 程序执行时一直占据存储空间,程序关闭才释放.如: 具有文件作用域的变量,函数名</li><li><strong>自动存储期</strong>: 代码块结束时自动释放存储空间.如: 具有代码块作用域的变量</li></ul></li><li><p>寄存器变量</p><ul><li>寄存器存在于 CPU 内部,CPU 对寄存器的读取和存储几乎没有延时</li><li><code>register</code>: 用于声明寄存器变量.编译器会自动考虑判断将其放入寄存器</li></ul></li><li><p>静态局部变量</p><ul><li><code>static</code>: 用于声明局部变量时,将局部变量设为静态存储期,与全局变量一致</li><li>静态局部变量仅会被初始化一次</li><li>静态局部变量仍未局部变量,无法在别的函数中直接访问</li></ul></li></ol><h3 id="2-3-常量"><a href="#2-3-常量" class="headerlink" title="2.3 常量"></a>2.3 常量</h3><ol><li><p>[基本数据类型](#2.1 基本数据类型)中的数据类型可作为常量,常用的还有字符串常量和符号常量</p><ul><li><p><strong>字符串常量: C 语言没有单独的字符串类型,采取字符数组的方式定义字符串</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> 变量名[字符数量];<br><span class="hljs-type">char</span> name[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br><span class="hljs-type">char</span> name[] = <span class="hljs-string">&quot;ys&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><p>用一个转义字符 <code>&#39;\0&#39;</code> (空字符)表示字符串的结束位置.当系统读取到该转义字符时,说明字符串结束</p></li><li><p>以数组形式初始化时,需要给结尾的 ‘\0’ 留出位置</p></li><li><p>使用字符串常量初始化并赋值时,编译器会自动在末尾补上 ‘\0’</p></li></ul></li><li><p>符号常量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> 标识符 常量</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> YEAR 2023</span><br></code></pre></td></tr></table></figure></li><li><p>转义字符</p><table><thead><tr><th>转义字符</th><th>含义</th></tr></thead><tbody><tr><td>\a</td><td>响铃(BEL)</td></tr><tr><td>\b</td><td>退格(BS)</td></tr><tr><td>\f</td><td>换页(FF)</td></tr><tr><td>\n</td><td>换行(LF)</td></tr><tr><td>\r</td><td>回车(CR)</td></tr><tr><td>\t</td><td>水平制表(HT)</td></tr><tr><td>\v</td><td>垂直制表(VT)</td></tr><tr><td>\</td><td>\</td></tr><tr><td>‘</td><td>‘</td></tr><tr><td>“</td><td>“</td></tr><tr><td>?</td><td>?</td></tr><tr><td>\0</td><td>NULL</td></tr><tr><td>\0dd</td><td>八进制值</td></tr><tr><td>\xhh</td><td>十六进制值</td></tr></tbody></table></li></ul></li><li><p><code>const</code> 关键字用来声明常量.常量与变量的区别仅在于其值不可修改</p><ul><li><code>int const a;</code> 与 <code>const int a;</code> 声明方式变量时的效果完全相同</li><li>由于常量的值不可修改.因此声明时一般要进行初始化</li><li>作为形参的常量在函数被调用时会得到实参的值</li></ul></li><li><p><code>const</code> 与指针</p><ul><li><code>int const *pci;</code>: pci 指向一个整型常量</li><li><code>int *const pci;</code>: pci 指向一个整型变量,指向不可修改</li><li><code>int const *const pci;</code>: pci 指向一个整型常量,且指向不可修改</li></ul></li><li><p><code>const</code> 与 <code>#define</code></p><ul><li><code>const</code> 只能使用于可以出现变量的地方</li><li><code>#define</code> 可以创建名字常量.只要字面值可以出现的地方均可使用</li></ul></li><li><p>初始化</p><ul><li>在程序链接时,静态变量存储位置被指定.因此若静态变量未显示地初始化,会初始化0.且初始化只会进行一次</li><li>自动变量在链接时其存储位置无法判断.因此自动变量没有缺省的初始值.对其初始化会包含一条隐式的赋值语句<ol><li>对自动变量的初始化 相比于赋值语句效率不会提高(除非声明为 const 变量)</li><li>隐式的赋值语句会使得自动变量每次执行到它们的时候都会重新初始化</li><li>由于初始化在运行时执行,因此可以用任何表达式作为初始值</li><li>自动变量创建而未初始化时,其值没有意义</li></ol></li></ul></li></ol><h3 id="2-4-运算符"><a href="#2-4-运算符" class="headerlink" title="2.4 运算符"></a>2.4 运算符</h3><table><thead><tr><th>优先级</th><th>运算符</th><th>结合律</th></tr></thead><tbody><tr><td>0</td><td>强制分组: ()</td><td>—&gt;</td></tr><tr><td>1</td><td>后缀运算符: [] () . -&gt; ++ –</td><td>—&gt;</td></tr><tr><td>2</td><td>一元运算符: ++ – ! ~ +  - * &amp; (type) sizeof _Alignof</td><td>&#x3D;&#x3D;&lt;—&#x3D;&#x3D;</td></tr><tr><td>3</td><td>乘除法运算符: *    &#x2F;    %</td><td>—&gt;</td></tr><tr><td>4</td><td>加减法运算符: +    -</td><td>—&gt;</td></tr><tr><td>5</td><td>移位运算符: &lt;&lt;    &gt;&gt;</td><td>—&gt;</td></tr><tr><td>6</td><td>关系运算符: &lt; &lt;&#x3D;  &gt; &gt;&#x3D;</td><td>—&gt;</td></tr><tr><td>7</td><td>相等运算符: &#x3D;&#x3D;    !&#x3D;</td><td>—&gt;</td></tr><tr><td>8</td><td>位运算符 AND: &amp;</td><td>—&gt;</td></tr><tr><td>9</td><td>位运算符 XOR: ^</td><td>—&gt;</td></tr><tr><td>10</td><td>位运算符 OR: |</td><td>—&gt;</td></tr><tr><td>11</td><td>逻辑运算符 AND: &amp;&amp;</td><td>—&gt;</td></tr><tr><td>12</td><td>逻辑运算符 OR: ||</td><td>—&gt;</td></tr><tr><td>13</td><td>条件运算符: ? :</td><td>&#x3D;&#x3D;&lt;—&#x3D;&#x3D;</td></tr><tr><td>14</td><td>赋值运算符: &#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D;</td><td>&#x3D;&#x3D;&lt;—&#x3D;&#x3D;</td></tr><tr><td>15</td><td>逗号运算符: ,</td><td>—&gt;</td></tr></tbody></table><ol><li><p>单目运算符</p><ul><li>单目运算符的优先级仅低于后缀运算符</li><li>结合顺序为从右到左.即 <code>*p++</code> 会被认为是 <code>*(p++)</code></li></ul></li><li><p>双目运算符</p><ul><li><p>算术 &gt; 移位 &gt; 关系 &gt; 位 &gt; 逻辑(&#x3D;&#x3D;算移关位逻&#x3D;&#x3D;)</p></li><li><p>关系运算符中: 比较 &gt; 判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判断 a,b 的相对大小是否和 c,d 相同</span><br>a &lt; b == c &lt; d<br></code></pre></td></tr></table></figure></li><li><p>位运算符中: ~ &gt; &amp; &gt; ^ &gt; | (&#x3D;&#x3D;反,与,异,或&#x3D;&#x3D;)</p></li><li><p>逻辑运算符中: ! &gt; &amp;&amp; &gt; || (&#x3D;&#x3D;非与或&#x3D;&#x3D;)</p></li></ul></li><li><p>三目运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">taxRate = income&gt;<span class="hljs-number">40000</span> &amp;&amp; residence&lt;<span class="hljs-number">5</span> ? <span class="hljs-number">3.5</span> : <span class="hljs-number">2.0</span>;<br></code></pre></td></tr></table></figure><ul><li>三目运算符优先级低于: 算术,移位,关系,位,逻辑运算符.因而允许在条件表达式中包括关系运算符的逻辑组合</li><li>三目运算符优先级高于: 赋值运算符.因而可以最后进行赋值操作</li></ul></li><li><p>逗号运算符</p><ul><li>优先级最低,其结果为最后一个表达式的值</li><li>在宏定义中作用明显</li></ul></li><li><p>C 语言采用短路求值: 当前一个运算数的无法确定逻辑运算的结果时,才会对第二个运算数求值.换言之,如果第一个运算数已经可以确实整个逻辑运算的结果,后一个运算数便不会计算</p></li></ol><h3 id="2-5-作用域"><a href="#2-5-作用域" class="headerlink" title="2.5 作用域"></a>2.5 作用域</h3><ol><li>对象, 函数, 宏, 标识符均有作用域(scope)<ul><li>标识符的作用域: 程序中该标识符可以被使用的区域</li><li>C 语言提供的作用域: 文件, 块, 函数原型, 函数</li><li>对象, 函数, 标识符的作用域由其声明位置决定</li></ul></li><li>文件作用域<ul><li>位于代码块之外的标识符具有文件作用域</li><li>从声明到源文件结尾均可被访问</li><li>函数名具有文件作用域</li></ul></li><li>代码块作用域<ul><li>代码块: 位于一对 <code>&#123;&#125;</code> 之间的所有语句</li><li>代码块中标识符具有代码块作用域</li><li>代码块嵌套时,外层无法用名字访问内层的标识符.如果内层有同名标识符,外层的将会被屏蔽</li></ul></li><li>原型作用域<ul><li>仅适用于函数原型中的参数名</li><li>函数参数名不是必需的,也不用与函数定义的形参名匹配</li></ul></li><li>函数作用域<ul><li>仅适用于语句标签.即 <code>label</code> 语句</li><li>一个函数中所有语句标签必须唯一</li><li>作用: 将标签限制在同一函数内部,防止标签重名</li></ul></li></ol><h3 id="2-6-存储期"><a href="#2-6-存储期" class="headerlink" title="2.6 存储期"></a>2.6 存储期</h3><ol><li>对象的存储期决定其生命周期.分为: 自动, 静态, 线程, 分配</li><li>自动存储期<ul><li>自动存储期对象将在语句块执行结束时被释放</li><li>在语句块或作为函数参数声明的对象将会具有自动存储期</li></ul></li><li>静态存储期<ul><li>静态存储期对象在程序整个执行期间都有效</li><li>文件作用域中声明的对象将会具有静态存储期</li><li><code>static</code> 可将具有自动存储期的变量(位于代码块中)改为静态存储期</li></ul></li><li>分配存储期<ul><li>动态分配内存具有分配存储期.从分配开始,直到释放结束</li><li>动态分配的内存取自堆(heap).由内存管理器管理</li><li>内存管理器负责分配内存和释放内存.分配后由调用者管理内存</li></ul></li><li>线程存储期暂不考虑</li></ol><h3 id="2-7-链接属性"><a href="#2-7-链接属性" class="headerlink" title="2.7 链接属性"></a>2.7 链接属性</h3><ol><li><p>标识符的链接属性决定如何处理在不同文件中出现的标识符</p><ul><li>外部(external): 无论在哪个源文件,声明多少次.均当作同一实体</li><li>内部(internal): 在同一源文件中被当作同一实体,不同源文件则被看作不同实体</li><li>无(none): 总是被当作不同的独立个体</li><li>具有文件作用域的标识符缺省的链接属性为: external</li><li>具有代码块作用域的标识符缺省的链接属性为: none</li></ul></li><li><p>修改链接属性</p><ul><li><code>static</code>: 将链接属性为 external 的标识符(位于代码块外)改为 internal<ul><li>可用于限制全局变量只能在单个源文件内部访问</li><li>可用于限制内部函数不被其他源文件调用</li></ul></li><li><code>extern</code>: 将链接属性为 none 的变量改为 external<ul><li>可用于访问其他文件中的链接属性为 external 的变量</li></ul></li></ul></li><li><p>作用域,链接属性,存储类型的总结</p><table><thead><tr><th>变量类型</th><th>声明的位置</th><th>是否存在于堆栈</th><th>作用域</th><th>加上 static</th></tr></thead><tbody><tr><td>全局</td><td>代码块外</td><td>否</td><td>文件作用域</td><td>不允许其他源文件访问</td></tr><tr><td>局部</td><td>代码块内</td><td>是</td><td>代码块作用域</td><td>静态变量</td></tr><tr><td>形参</td><td>函数头部</td><td>是</td><td>函数作用域</td><td>&#x2F;</td></tr></tbody></table></li><li><p>存储类别</p><table><thead><tr><th>存储类别</th><th>存储期</th><th>作用域</th><th>链接</th><th>声明方式</th></tr></thead><tbody><tr><td>自动</td><td>自动</td><td>块</td><td>无</td><td>块内</td></tr><tr><td>寄存器</td><td>自动</td><td>块</td><td>无</td><td>块内, register</td></tr><tr><td>静态外部链接</td><td>静态</td><td>文件</td><td>外部</td><td>所有函数外</td></tr><tr><td>静态内部链接</td><td>静态</td><td>文件</td><td>内部</td><td>所有函数外, static</td></tr><tr><td>静态无链接</td><td>静态</td><td>块</td><td>无</td><td>块内, static</td></tr></tbody></table></li></ol><h2 id="3-控制流"><a href="#3-控制流" class="headerlink" title="3 控制流"></a>3 控制流</h2><h3 id="3-1-分支"><a href="#3-1-分支" class="headerlink" title="3.1 分支"></a>3.1 分支</h3><ol><li><p><code>if</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (表达式<span class="hljs-number">1</span>) &#123;语句<span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (表达式<span class="hljs-number">2</span>) &#123;语句<span class="hljs-number">2</span>&#125;<br>...<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (表达式n) &#123;语句n&#125;<br><span class="hljs-keyword">else</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><ul><li><code>else if, else</code>语句是可选的</li><li><code>else</code> 只会和最近的 <code>if</code> 匹配,而与缩进无关</li></ul></li><li><p><code>switch</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (表达式) &#123;<br>    <span class="hljs-keyword">case</span> 常量表达式<span class="hljs-number">1</span>: 语句<span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 常量表达式<span class="hljs-number">2</span>: 语句<span class="hljs-number">2</span>; <span class="hljs-keyword">break</span>;<br>    ...<br>    <span class="hljs-keyword">case</span> 常量表达式n: 语句n; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: 语句<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>break</code> 语句是可选的,若没有 <code>break</code>,将发生 <code>break</code> 穿透</li><li><code>default</code> 语句是可选的,用于处理没有成功匹配的情况</li></ul></li></ol><h3 id="3-2-循环"><a href="#3-2-循环" class="headerlink" title="3.2 循环"></a>3.2 循环</h3><ol><li><p><code>while</code>: 先计算表达式的值,为真则执行语句.重复步骤,直到条件表达式为假</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (表达式)&#123;<br>    语句<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>do-while</code>: 先执行语句,再计算表达式的值,为真则循环再次执行语句.重复步骤,直到条件表达式为假</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br>    语句<br>&#125; <span class="hljs-keyword">while</span> (表达式);<br></code></pre></td></tr></table></figure></li><li><p><code>for</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(初始化; 循环条件; 调整) &#123;<br>    语句<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>开始时,先进行一次初始化.然后判断循环条件,执行语句,进行调整.重复步骤,直到循环条件为假</li><li><code>for</code> 语句的每一部分都是可选的<ul><li>初始化: 可在外部进行</li><li>循环条件: 省略后将默认为真(死循环)</li><li>调整: 可在内部语句进行</li></ul></li><li><code>for</code> 是 <code>while</code> 的语法糖,优点在于将决定迭代的条件整合到了一起</li></ul></li><li><p><code>goto</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">goto</span> lable;<br>lable: 语句<br></code></pre></td></tr></table></figure><ul><li><code>:</code> 表示这里有一个标记</li><li><code>label</code> 可以是任何除 C 关键字以外的纯文本.设置在 <code>goto</code> 语句的前后均可</li><li>可用于跳出多层循环</li></ul></li><li><p><code>break</code>: 跳出本层循环</p></li><li><p><code>continue</code>: 跳过本轮循环,进入下一轮</p></li></ol><h2 id="4-数组"><a href="#4-数组" class="headerlink" title="4 数组"></a>4 数组</h2><h3 id="4-1-一维数组"><a href="#4-1-一维数组" class="headerlink" title="4.1 一维数组"></a>4.1 一维数组</h3><ol><li><p>声明方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">数据类型 数组名[数量];<br><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><ul><li><code>[]</code>: 后缀运算符,表示声明的对象是数组</li><li>数据类型: 指明当对数组中的元素进行访问时得到的数据类型</li><li>数量: 编译器需要根据 <code>数组类型和数量</code> 确定要分配的内存大小</li><li><strong>数组名: 其本质上是一个常量指针,其值为数组首元素的地址</strong></li></ul></li><li><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><ul><li>若仅给部分元素进行初始化,则其他元素自动初始化为 0</li><li>若省略数组长度,则将由编译器自行计算数组长度</li></ul></li><li><p>访问数组元素: 数组名本质上是常量指针.<code>a[1]</code> 将被计算为 <code>*(a+1)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">数组名[下标] <span class="hljs-comment">//下标从 0 开始</span><br>a[<span class="hljs-number">1</span>]<span class="hljs-comment">//取出数组a的第2个元素的值</span><br></code></pre></td></tr></table></figure></li><li><p>获取数组长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> length = <span class="hljs-keyword">sizeof</span>(numbers) / <span class="hljs-keyword">sizeof</span>(numbers[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 计算方法</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LENGTH(array) (sizeof(array) / sizeof(array[0]))  <span class="hljs-comment">// 宏实现</span></span><br></code></pre></td></tr></table></figure></li><li><p>遍历数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>可变长数组: 指的是可以用变量指定数组的维度</p><ul><li>C99 标准前,定义数组时,数组的长度必须为常量表达式或 const 常量</li><li>从 C99 开始,支持可变长数组,即数组的长度在程序运行时才决定.但完成定义后,便不再支持修改长度</li></ul></li></ol><h3 id="4-2-二维数组"><a href="#4-2-二维数组" class="headerlink" title="4.2 二维数组"></a>4.2 二维数组</h3><ol><li><p>定义二维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">数据类型 数组名[行数][列数];<br><span class="hljs-type">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><ul><li>二维数组在内存中线性存储</li><li>根据后缀运算符的结合性<ul><li>从左到右,<code>a</code> 与 <code>[4]</code> 结合.因而 <code>a</code> 是一个拥有4个元素的数组</li><li><code>a[4]</code> 与 <code>[5]</code> 结合.因而<code>a[4]</code> 的每个元素都是一个拥有5个元素的一维数组</li></ul></li></ul></li><li><p>初始化二维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 根据 线性存放特性 进行初始化 */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;;<br><br><span class="hljs-comment">/* 根据 二维数组本质上是数组的数组特性 进行初始化 */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>    &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;,<br>    &#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;<br>&#125;;<br><span class="hljs-comment">/* 部分值初始化 */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;&#123;<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>&#125;&#125;;<br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;<br><span class="hljs-comment">/* 指定元素初始化(C99) */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, [<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>, [<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>&#125;;<br><span class="hljs-comment">/* 第一个维度元素可不写,交由编译器计算 */</span><br><span class="hljs-type">int</span> a[][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>访问二维数组元素</p><ul><li>数组名被理解为常量指针,而二维数组又是数组的数组</li><li>因而,<code>a[3][4]</code> 将被计算为 <code>*((a+3)+4)</code></li></ul></li><li><p>遍历二维数组: 采用嵌套循环的方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;row; ++i)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;column; ++j)&#123;<br>        ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多维数组: 形式上与二维数组类似,仅需在定义时增加下标数量</p></li></ol><h2 id="5-指针"><a href="#5-指针" class="headerlink" title="5 指针"></a>5 指针</h2><h3 id="5-1-指针与变量"><a href="#5-1-指针与变量" class="headerlink" title="5.1 指针与变量"></a>5.1 指针与变量</h3><ol><li><p>指针就是内存地址,指针变量是 存放内存地址的变量</p></li><li><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">类型名 *指针变量名<br><span class="hljs-type">int</span> *pa<br></code></pre></td></tr></table></figure><ul><li>类型名: 指明对指针变量解引用(<code>*</code>)后得到的数据类型</li></ul></li><li><p>初始化</p><ul><li><p><code>void</code> 指针</p><ul><li><code>void</code> 指针称为通用指针,可以指向任意类型的数据</li><li>不要对 <code>void</code> 指针解引用</li><li>任何类型的指针均可转换为 <code>void</code> 指针,而再转换回来需要强制类型转换</li></ul></li><li><p><code>NULL</code> 指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL ((void *)0)</span><br></code></pre></td></tr></table></figure><ul><li><code>(void *)</code>: 强制类型转换,将地址 0 强转为 <code>void</code> 指针</li><li>由于地址 0 通常不被使用,因此,<code>NULL</code> 是一个空指针,即不指向任何东西</li><li>为防止解引用未初始化的指针,经常将其初始化为 <code>NULL</code></li><li>解引用 <code>NULL</code> 会直接使得程序崩溃</li><li>在解引用指针时,应先判断是否为 <code>NULL</code></li></ul></li></ul></li><li><p>指针的运算</p><ul><li>加减: 相当于将指针的位置移动相应的位置.即 <code>p+1</code> 表示指向 <code>p</code> 的下一个元素</li><li>比较: 运用关系运算符进行比较时,可判断指针指向的前后关系</li></ul></li><li><p><code>*</code> 运算符</p><ul><li>在定义指针变量时,用于声明是指针</li><li>在对指针进行取值操作时,获取指针指向元素的值</li><li>定义指针和取值操作是不同的,属于符号的重用</li></ul></li><li><p><code>&amp;</code> 取址运算符: 对变量进行取址操作,获得变量的地址</p></li></ol><h3 id="5-2-指针的组合"><a href="#5-2-指针的组合" class="headerlink" title="5.2 指针的组合"></a>5.2 指针的组合</h3><ol><li><p>指向指针的指针(指针在定义就表明了如何解引用.定义时用到了多少 <code>*</code>,得到值就需要多少 <code>*</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">520</span>;<br><span class="hljs-type">int</span> *p = &amp;num;<br><span class="hljs-type">int</span> **pp = &amp;p;<br></code></pre></td></tr></table></figure></li><li><p>指针数组 和 指向指针的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *Book[] = &#123;<br>    <span class="hljs-string">&quot;C 程序设计语言&quot;</span>,<br>    <span class="hljs-string">&quot;C 专家编程&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>Book</code> 是指针数组,每个元素都是指针(字符串).现想要管理每个元素(字符串)</p></li><li><p>建立一个新数组,其中的每个元素都是指针,它们指向需要操作的对象(字符串).即:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> **CBook[<span class="hljs-number">2</span>];<br>CBook[<span class="hljs-number">0</span>] = &amp;Book[<span class="hljs-number">0</span>];<br>CBook[<span class="hljs-number">1</span>] = &amp;Book[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure></li></ul></li><li><p>指向常量的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> cnum = <span class="hljs-number">520</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;cnum;<br></code></pre></td></tr></table></figure><ul><li>指针可以指向被 <code>const</code> 修饰的变量,不能通过指针修改其值.指针指向可改变</li><li><code>const int</code> 表示指向的是一个整型常量</li></ul></li><li><p>常量指针: 指向的是一个变量,其值可以修改,但指针指向不允许修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">520</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p = &amp;num;<br></code></pre></td></tr></table></figure><ul><li><code>const p</code> 表示指针 <code>p</code> 是一个常量</li></ul></li><li><p>指向常量的常量指针: 指针自身不允许修改,其指向的值也不允许修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> cnum = <span class="hljs-number">520</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p = &amp;cnum;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><h3 id="6-1-函数定义"><a href="#6-1-函数定义" class="headerlink" title="6.1 函数定义"></a>6.1 函数定义</h3><ol><li><p>定义方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">类型名 函数名(参数列表) &#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>声明: 去掉函数体,加上分号即为声明语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">类型名 函数名(参数列表);<br></code></pre></td></tr></table></figure></li><li><p>参数的传递</p><ul><li>C 语言是按值调用的(call-by-value),也称按值传递(pass-by-value)</li><li>形参(parameter): 函数定义时的参数.仅在函数被调用时分配内存,调用结束后立即释放</li><li>实参(argument): 真实传递给函数的值.这种传值方式具有单向性</li><li>传址: 如果形参是指针,那么可以通过间接的方式修改地址存储的值</li><li>传数组: 本质上是传递数组首元素的地址</li></ul></li><li><p>可变参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span>  <span class="hljs-comment">// 可变参数需要的头文件</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n, ...)</span> &#123;  <span class="hljs-comment">// ... 是占位符,表明参数个数不确定</span><br>    <span class="hljs-type">int</span> i, sum = <span class="hljs-number">0</span>;<br>    va_list vap;  <span class="hljs-comment">// 定义参数列表</span><br>    va_start(vap, n);  <span class="hljs-comment">// 初始化参数列表, n 是第一个参数的名称</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        sum += va_arg(vap, <span class="hljs-type">int</span>);  <span class="hljs-comment">// 获取参数值,int表示参数类型</span><br>    &#125;<span class="hljs-comment">// va_arg()调用后,vap 指向下一个参数</span><br>    va_end(vap);  <span class="hljs-comment">// 关闭参数列表</span><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="6-2-函数与指针"><a href="#6-2-函数与指针" class="headerlink" title="6.2 函数与指针"></a>6.2 函数与指针</h3><ol><li><p>指针函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *<span class="hljs-title function_">pf</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// fp 是指针函数</span><br></code></pre></td></tr></table></figure><ul><li>函数的类型由返回值决定.当函数返回值为指针类型时,函数即为指针函数</li><li>指针函数的定义方式类似于定义指针: 在类型后面加上一个 <code>*</code></li><li>不要返回局部变量的地址.因为局部变量仅存在于函数内部</li></ul></li><li><p>函数指针</p><ul><li><p>函数指针是一个指针,它指向函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>);  <span class="hljs-comment">// fp 是函数指针</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>;  <span class="hljs-comment">// fun 是一个函数名,本质也是一个指针</span><br><br>fp = func;  <span class="hljs-comment">// 对函数指针的赋值方式.类型匹配可直接赋值</span><br>result = (*fp)(num);  <span class="hljs-comment">// K&amp;R C 的调用方式.从声明形式的等价得出</span><br>result = fp(num);  <span class="hljs-comment">// UNIX 推广者的调用方式.从赋值语句的等价得出</span><br></code></pre></td></tr></table></figure></li><li><p>函数名 <code>func</code> 是函数的首地址,类型为 <code>int (*)(int)</code></p></li><li><p>对于函数名而言: 它本身是一个指针,且对其取值或取址的值仍是其本身</p></li></ul></li><li><p>函数指针作为参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>), <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<span class="hljs-comment">//第一个参数为函数指针</span><br>result = calc(add, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><ul><li>函数名 <code>add</code> 作为实参传入 <code>calc</code>函数.形参为 <code>fp</code>,是一个函数指针</li></ul></li><li><p>函数指针作为返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>), <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> (*select(<span class="hljs-type">char</span> op))(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><span class="hljs-comment">//select 是一个函数.其参数为 char op.</span><br><span class="hljs-comment">//返回值为一个函数指针.指向的函数类型为 int (int, int)</span><br></code></pre></td></tr></table></figure><ul><li><code>select</code> 先与 <code>(char op)</code> 结合,成为一个函数,参数为 <code>char op</code></li><li>去掉 <code>*select(char op)</code> 后,剩余 <code>int (\*)(int, int)</code> 成为 <code>select</code> 的返回值</li></ul></li></ol><h3 id="6-3-动态内存管理"><a href="#6-3-动态内存管理" class="headerlink" title="6.3  动态内存管理"></a>6.3  动态内存管理</h3><ol><li><p>需要使用到 <code>&lt;stdlib.h&gt;</code> 头文件中的库函数</p><ul><li><code>malloc</code>:   申请动态空间内存</li><li><code>free</code>:       释放动态空间内存</li><li><code>calloc</code>:   申请并初始化一系列内存</li><li><code>realloc</code>:  重新分配内存空间</li></ul></li><li><p><code>malloc</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;  <span class="hljs-comment">// malloc 函数原型</span><br><span class="hljs-type">int</span> *ptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));  <span class="hljs-comment">// 申请内存而不初始化</span><br></code></pre></td></tr></table></figure><ul><li><code>malloc</code> 向系统申请分配 <code>size</code> 个字节的内存空间,返回一个指向该空间的指针</li><li>申请的内存空间不会被初始化</li><li>调用成功返回一个申请的内存空间指针,类型为 <code>void *</code></li><li>调用失败返回 <code>NULL</code>.若设置 <code>size = 0</code>,同样返回 <code>NULL</code></li></ul></li><li><p><code>calloc</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> nmemb, <span class="hljs-type">size_t</span> size)</span>;  <span class="hljs-comment">// calloc 函数原型</span><br><span class="hljs-type">int</span> *ptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">8</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));  <span class="hljs-comment">// 申请内存并初始化为0</span><br></code></pre></td></tr></table></figure><ul><li><code>calloc</code> 在内存中动态的申请 <code>nmemb</code> 个长度为 <code>size</code> 的连续内存空间,并全部初始化为0</li><li>如果调用成功,返回指向申请内存的指针</li><li>调用失败返回 <code>NULL</code>.参数为 0 时也会返回 <code>NULL</code></li></ul></li><li><p><code>realloc</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size)</span>;  <span class="hljs-comment">// realloc 函数原型</span><br><span class="hljs-type">int</span> *ptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">realloc</span>(ptr, count * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));  <span class="hljs-comment">// 重新分配内存</span><br></code></pre></td></tr></table></figure><ul><li>可以增大或减小已分配内存的大小</li><li>其实现通常为新分配内存,然后复制内容,最后释放原内存.注意新内存仍不会初始化</li><li><code>ptr</code> 指向先前分配的内存空间.当参数 <code>ptr==NULL</code> 时,等同于调用 <code>malloc</code></li></ul></li><li><p><code>free</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span>;  <span class="hljs-comment">// free 函数原型</span><br><span class="hljs-built_in">free</span>(ptr);  <span class="hljs-comment">// 释放空间</span><br></code></pre></td></tr></table></figure><ul><li><code>free</code> 释放的内存空间必须是由 <code>malloc,calloc,realloc</code> 函数申请.否则会导致未定义行为</li><li>若参数 <code>ptr==NULL</code>,则不执行任何操作.多次对同一指针调用 <code>free</code>,将导致未定义行为</li><li><code>free</code> 函数不改变参数 <code>ptr</code> 的值.为避免悬空指针,释放空间后需将指针的值置为 <code>NULL</code></li></ul></li><li><p>内存泄漏</p><ul><li>C 语言不具备垃圾回收机制,需要手动释放内存</li><li><code>malloc</code> 和 <code>free</code> 应该成对编写</li></ul></li><li><p>申请任意尺寸的内存空间</p><ul><li><p><code>malloc</code> 可以申请任意尺寸的内存空间.得到的空间是连续的,经常使用数组索引</p></li><li><p>初始化申请的内存空间有专门的库函数,声明于 <code>&lt;string.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">memset</span>(ptr, <span class="hljs-number">0</span>, num * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></table></figure><ul><li><code>memset</code>: 使用一个常量字节填充内存空间</li><li><code>memcpy</code>: 复制内存空间</li><li><code>memmove</code>: 复制内存空间</li><li><code>memcmp</code>: 比较内存空间</li><li><code>memchr</code>: 在内存空间中搜索一个字符</li></ul></li><li><p>与字符串处理函数相似,且开头的 <code>mem</code> 即表示内存</p></li></ul></li><li><p>内存池</p><ul><li>频繁使用 <code>malloc</code> 和 <code>free</code> 手动分配和释放内存很容易产生大量的内存碎片</li><li>调用 <code>malloc</code> 函数向操作系统申请堆内存经历了从应用层切入系统内核层的过程.造成时间浪费</li><li>内存池: 让程序额外维护一个缓存区域.当一块内存将要释放时,不调用 <code>free</code>,而将其放入内存池,下次需要分配内存空间时直接从内存池中获取</li><li>维护方式<ul><li>当用户申请一个内存块时,先在内存池中查找是否有合适的内存块<ul><li>若有: 则直接从内存池中取出使用</li><li>若无: 调用 <code>malloc</code> 函数申请</li></ul></li><li>当用户释放一个内存块时,先检查内存池是否已满<ul><li>不满: 则将指向内存块的指针存放到内存池</li><li>已满: 调用 <code>free</code> 函数释放</li></ul></li></ul></li><li>实现思路:<ul><li>使用单链表维护一个简单的内存池</li><li>将没用到的内存空间地址用单链表记录</li><li>需要使用时从单链表获取</li></ul></li></ul></li></ol><h3 id="6-4-内联函数"><a href="#6-4-内联函数" class="headerlink" title="6.4 内联函数"></a>6.4 内联函数</h3><ol><li><p>考虑下面的宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(x) ((x) * (x))</span><br></code></pre></td></tr></table></figure><ul><li><p>若以下述方式调用该宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">result = SQUARE(i++);<br></code></pre></td></tr></table></figure></li><li><p><code>SQUARE(i++)</code> 将展开为 <code>((i++) * (i++))</code>,进行了两次自增操作,与预期不同</p></li></ul></li><li><p>内联函数: 指定一个函数为内联函数,编译器像处理宏定义的方式,将整个内联函数直接在 <code>main</code> 函数中展开</p></li><li><p>内联函数的定义方式: 在函数定义的头前加上关键字 <code>inline</code></p></li><li><p>使用内联函数会导致代码编译的时间增加,但节省函数调用的时间消耗</p></li><li><p>编译器会自动将一些常用的函数优化为内联函数</p></li></ol><h2 id="7-结构体"><a href="#7-结构体" class="headerlink" title="7 结构体"></a>7 结构体</h2><h3 id="7-1-结构体定义"><a href="#7-1-结构体定义" class="headerlink" title="7.1 结构体定义"></a>7.1 结构体定义</h3><ol><li><p>结构体声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名称 &#123;</span><br>    结构体成员<span class="hljs-number">1</span>;<br>    结构体成员<span class="hljs-number">2</span>;<br>    ...<br>    结构体成员n;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>关键字 struct 是必要的,结构体的声明需要分号</li><li><strong>结构体名称约定第一个字符使用大写</strong></li></ul></li><li><p>结构体定义(关键字 <code>struct</code> 是必要的)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名称 结构体变量名;</span><br></code></pre></td></tr></table></figure></li><li><p>访问结构体成员: 使用 <code>.</code> 运算符访问结构体变量</p></li><li><p>初始化结构体</p><ul><li>在定义时即可对其初始化.形式与初始化数组一样: 用大括号包含所有成员值,逗号作为分隔符.此时需要将各个成员类型对号入座</li><li>C99 新增特性可以在初始化时指定成员值</li><li>数组初始化时指定成员方式为 <code>[下标]</code>.对应的,结构体初始化时使用 <code>.成员名</code>的方式指定成员值</li><li>未初始化的成员将被自动初始化.数值型初始化为 0 ,字符型初始化为 ‘\0’</li></ul></li><li><p>编译器会对结构体的成员进行内存对齐.让 CPU 可以更快地读取&#x2F;处理数据</p></li><li><p>结构体嵌套后仍使用 <code>.</code> 运算符访问结构体变量.只不过要用多次 <code>.</code> 运算符一直找到最底层的成员</p></li><li><p>结构体与数组</p><ul><li><p>结构体数组仍是数组,其成员为结构体类型的数据</p></li><li><p>结构体数组的定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名称 数组名[长度];</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="7-2-结构体与指针"><a href="#7-2-结构体与指针" class="headerlink" title="7.2 结构体与指针"></a>7.2 结构体与指针</h3><ol><li><p>结构体指针</p><ul><li><p>指向结构体的指针即为结构体指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Book</span> *<span class="hljs-title">pt</span>;</span><br></code></pre></td></tr></table></figure></li><li><p>数组名是指向第一个元素的地址,但结构体变量名并非指向该结构体的地址</p></li><li><p>结构体的地址需要通过 <code>&amp;</code> 运算符才能获取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">pt = &amp;book;<br></code></pre></td></tr></table></figure></li><li><p>结构体指针访问结构体成员有两种方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">(*结构体指针).成员名<span class="hljs-comment">//先解引用,再访问成员</span><br>结构体指针 -&gt; 成员名<span class="hljs-comment">//使用箭头符号,隐含这是一个指针</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>传递结构体信息: 结构变量可以直接赋值.作为参数传递时也可以直接传递</p></li><li><p>传递指向结构体变量的指针</p><ul><li>直接传递结构体时,如果结构体变量很大,将会导致函数调用过程中时间和空间的开销相对大</li><li>传递结构体指针可以避免这种开销</li></ul></li></ol><h3 id="7-3-typedef"><a href="#7-3-typedef" class="headerlink" title="7.3 typedef"></a>7.3 <code>typedef</code></h3><ol><li><p>给数据类型起别名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> integer;<br>integer a;<br></code></pre></td></tr></table></figure></li><li><p><code>typedef</code> 与 <code>#define</code> 的区别</p><ul><li><p>顺序并不一样(但可统一为前一个对象作为操作对象,后一个对象为操作后的结果)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> integer int <span class="hljs-comment">//将 integer 替换为 int</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> integer; <span class="hljs-comment">//给 int 起别名为 integer</span><br></code></pre></td></tr></table></figure></li><li><p>有修饰符时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//程序正常 integer 被替换为 int,a = 4294967295</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> integer int</span><br><span class="hljs-type">unsigned</span> integer a = <span class="hljs-number">-1</span>; <br><br><span class="hljs-comment">//程序报错</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> integer;<br><span class="hljs-type">unsigned</span> integer a = <span class="hljs-number">-1</span>; <br></code></pre></td></tr></table></figure></li><li><p>定义指针变量时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 该语句预处理后替换为 int *a, b</span><br><span class="hljs-comment">** 此时 a 类型为int *, b 类型为 int */</span><br>ptrInt a, b;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ptrInt int *</span><br><br><span class="hljs-comment">//a, b 类型均为 int*</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span>* ptrInt;<br>ptrInt a, b; <br></code></pre></td></tr></table></figure></li></ul></li><li><p>与结构体搭配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 将 struct Date   赋予别名 DATE</span><br><span class="hljs-comment">** 将 struct Date * 赋予别名 PDATE */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Date</span> &#123;</span><br>    <span class="hljs-type">int</span> year;<br>    <span class="hljs-type">int</span> month;<br>    <span class="hljs-type">int</span> day;<br>&#125; DATE, *PDATE;<br><br>DATE date;<span class="hljs-comment">//定义结构体不再需要关键字 struct</span><br>PDATE pdate;<span class="hljs-comment">//定义的是 结构体指针</span><br></code></pre></td></tr></table></figure></li><li><p>简化类型声明</p><ul><li><p>数组指针:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*ptr)[<span class="hljs-number">3</span>];<span class="hljs-comment">//数组指针</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*PTR2ARRAY)</span>[3];<br></code></pre></td></tr></table></figure></li><li><p>函数指针:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*PTR2FUN)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure></li><li><p>指针函数与数组指针:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *(*<span class="hljs-built_in">array</span>[<span class="hljs-number">3</span>])(<span class="hljs-type">int</span>);<br><span class="hljs-comment">// array 是一个指针数组,其元素指向指针函数.指针函数参数为 int,返回值为 int *</span><br><br><span class="hljs-comment">// 直接使用 typedef 会导致数组长度固定为3, 因此分成两句</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> *(*PRT2FUN)(<span class="hljs-type">int</span>);<span class="hljs-comment">//PRT2FUN 是一个指针,指向指针函数</span><br>PRT2FUN <span class="hljs-built_in">array</span>[<span class="hljs-number">3</span>];<span class="hljs-comment">//array 是一个拥有3个元素的数组,元素类型为 PRT2FUN</span><br></code></pre></td></tr></table></figure></li><li><p>参数为函数指针,返回值为函数指针:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*funA(<span class="hljs-type">int</span>, <span class="hljs-type">void</span> (*funB)(<span class="hljs-type">int</span>)))(<span class="hljs-type">int</span>);<br><span class="hljs-comment">/* funA 是一个指针函数.有两个参数 int, funB</span><br><span class="hljs-comment">** funB 是一个函数指针,指向的类型为 void (int)</span><br><span class="hljs-comment">** 分析 funA 的返回值: 先化简 void (*funA(参数))(int).</span><br><span class="hljs-comment">** 返回值类型为 void (int),即函数指针 */</span><br><br><span class="hljs-comment">/* 提取出共同点,可以有更为清晰的定义方式 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*PTR2FUN)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-comment">//PTR2FUN 是一个函数指针</span><br>PTR2FUN <span class="hljs-title function_">funA</span><span class="hljs-params">(<span class="hljs-type">int</span>, PTR2FUN)</span>;<br></code></pre></td></tr></table></figure></li><li><p>以显式的方式调用首地址为0的子例程:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(*( <span class="hljs-type">void</span> (*)() ) <span class="hljs-number">0</span>)()<br></code></pre></td></tr></table></figure><ul><li><p>考虑 <code>(* 0)();</code></p><ul><li>本意: 想对地址0进行解引用,然后调用函数</li><li>实际: 无法生效,因为 <code>*</code> 需要一个指针作为操作数,且这里还要求是函数指针</li><li>解决方法: 先将 0 强转为函数指针</li></ul></li><li><p>考虑 <code>(void(*)())</code>.这是就是需要的类型转换符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*funcptr)</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 函数指针</span><br>(*(funcptr)<span class="hljs-number">0</span>)();  <span class="hljs-comment">// 先将0强转为函数指针,然后调用该函数</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="7-4-共用体"><a href="#7-4-共用体" class="headerlink" title="7.4 共用体"></a>7.4 共用体</h3><ol><li><p>共用体可以将多个成员存储在同一空间中,它们拥有相同的起始地址.最终存储的值取决最后赋值的变量</p></li><li><p>声明方式: 与结构体类似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 共用体名称 &#123;</span><br>    共用体成员<span class="hljs-number">1</span>;<br>    共用体成员<span class="hljs-number">2</span>;<br>    ...<br>    共用体成员n;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>共用体的定义与访问方式均与结构体类似</p></li><li><p>初始化共用体: 不能同时对所有成员都初始化</p></li></ol><h3 id="7-5-枚举"><a href="#7-5-枚举" class="headerlink" title="7.5 枚举"></a>7.5 枚举</h3><ol><li><p>如果一个变量只有几种可能的值,可以将其定义为枚举类型</p></li><li><p>声明方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> 枚举类型名称 &#123;</span>枚举值名称, 枚举值名称...&#125;;<br></code></pre></td></tr></table></figure></li><li><p>定义方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> 枚举类型名称 枚举变量名;</span><br></code></pre></td></tr></table></figure><ul><li>枚举值名称可以直接像标识符那样命名,称为枚举常量</li><li>默认情况下 枚举常量的值从 0 开始,往后以此递增</li><li>如果不希望从 0 开始,可以在声明时赋值,往后依然递增</li><li>枚举变量允许自增运算,而 C++ 中不允许</li><li>枚举常量的值和名称在编译时已经指定,不再允许修改</li></ul></li></ol><h3 id="7-6-位域"><a href="#7-6-位域" class="headerlink" title="7.6 位域"></a>7.6 位域</h3><ol><li><p>位域将1字节(Byte)的二进制位划分为几个不同的区域,并指定每个区域的位数</p></li><li><p>每个域有一个域名,允许在程序中按域名进行单独的操作</p></li><li><p>使用位域的方法: 在定义结构体时,在结构体成员使用冒号: 和数字表示该成员所占的位数(type [member_name] : width;)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a:<span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> b:<span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> c:<span class="hljs-number">2</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>位域的宽度不能超过它所依附的数据类型的长度.成员变量是有类型的,位域的宽度被该类型所限制.</p></li><li><p>位域成员可以没有名称.但需要给出数据类型和位宽.用于填充或调整成员的位置,不能使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> :<span class="hljs-number">424</span>;<br></code></pre></td></tr></table></figure></li></ol><h2 id="8-位操作"><a href="#8-位操作" class="headerlink" title="8 位操作"></a>8 位操作</h2><ol><li>C 语言并未明确规定1字节(Byte)的尺寸.C 语言对字节的定义为<ul><li>可寻址的数据存储单位,其尺寸必须可以容纳运行环境的基本字符集的任何成员</li></ul></li><li>C 语言仅明确规定了 <code>char</code> 类型占用 1 Byte.其他类型仅给出相对的大小关系.具体尺寸由环境约束</li><li>编译器规定了 1 Byte 的位数.写在头文件 <code>&lt;limits.h&gt;</code> 中</li><li>C 语言允许通过位域的形式来按位存取,且允许精确到 位 的运算</li></ol><h3 id="8-1-移位运算符"><a href="#8-1-移位运算符" class="headerlink" title="8.1 移位运算符"></a>8.1 移位运算符</h3><ol><li><p>左移运算符</p><ul><li><p>左移运算符拥有两个操作数</p></li><li><p>左侧表示被移位的数据,右侧指定移动的位数</p></li><li><p>左移移出的位数全部舍弃.右侧用 0 填充</p></li><li><p>将整数左移 N 位相当于乘以 $2^N$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">result = <span class="hljs-number">11001010</span> &lt;&lt; <span class="hljs-number">2</span>;<br><span class="hljs-comment">//result=00101000</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>右移运算符</p><ul><li><p>右移运算符拥有两个操作数</p></li><li><p>左侧表示被移位的数据,右侧指定移动的位数</p></li><li><p>右移移出的位数全部舍弃.左侧用 0 填充</p></li><li><p>将整数右移 N 位相当于除以 $2^N$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">result = <span class="hljs-number">11001010</span> &gt;&gt; <span class="hljs-number">2</span>;<br><span class="hljs-comment">//result=00110010</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>左移运算符,右移运算符均可与赋值号结合</p></li><li><p>未定义行为</p><ul><li>左移&#x2F;右移运算符右侧指定移动的位数为 负数 时</li><li>右侧指定移动的位数 大于 左侧操作数的最大宽度时</li></ul></li></ol><h3 id="8-2-应用"><a href="#8-2-应用" class="headerlink" title="8.2 应用"></a>8.2 应用</h3><ol><li><p>掩码</p><ul><li>掩码是一串二进制数字,通过与目标数字的按位操作,达到屏蔽指定位实现需求</li><li>掩码本身的值一般将想要操作的对象位 置1,不变的对象位 置0</li></ul></li><li><p>判断指定位: 将源数据对指定的掩码进行按位与 <code>&amp;</code>.判断结果是否与掩码本身相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((value &amp; mask) == mask) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>打开位: 将源数据对指定的掩码进行按位或 <code>|</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">value |= mask;<br></code></pre></td></tr></table></figure></li><li><p>关闭位: 将源数据对取反后的掩码进行按位与 <code>&amp;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">value &amp;= ~mask;<br></code></pre></td></tr></table></figure></li><li><p>转置位: 将源数据对指定的掩码进行按位异或 ^</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">value ^= mask;<br></code></pre></td></tr></table></figure></li></ol><h2 id="9-文件操作"><a href="#9-文件操作" class="headerlink" title="9 文件操作"></a>9 文件操作</h2><h3 id="9-1-打开和关闭文件"><a href="#9-1-打开和关闭文件" class="headerlink" title="9.1 打开和关闭文件"></a>9.1 打开和关闭文件</h3><ol><li><p><code>fopen</code>: 打开一个文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *<span class="hljs-title function_">fopen</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode )</span>;  <span class="hljs-comment">// fopen 函数原型</span><br><span class="hljs-comment">/* filename: 指定将要打开的文件路径以及文件名</span><br><span class="hljs-comment">** mode: 指定文件的打开模式 */</span><br></code></pre></td></tr></table></figure><ul><li><p>调用成功返回一个指向 <code>FILE</code> 结构的文件指针.通过该指针对文件进行操作.失败返回 <code>NULL</code></p></li><li><p>打开模式</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>“r”</td><td>只读模式打开;  从文件头读取;  该文本文件必须存在</td></tr><tr><td>“w”</td><td>只写模式打开;  从文件头写入;  文本不存在时则先创建;  重新写入内容会覆盖所有内容</td></tr><tr><td>“a”</td><td>追加模式打开;  从文件末追加;  文本不存在时则先创建</td></tr><tr><td>“r+”</td><td>读写模式打开;  从文件头读写;  该文本文件必须存在; 只覆盖重写入内容,原有内容保留</td></tr><tr><td>“w+”</td><td>读写模式打开;  从文件头读写;  文本不存在时则先创建; 重新写入内容会覆盖所有内容</td></tr><tr><td>“a+”</td><td>读和追加模式打开;  读从头开始,写从末尾追加;  文本不存在时则先创建</td></tr><tr><td>b</td><td>可与以上6种模式结合(如 “rb, “r+b”); 含义相同,但操作对象为二进制文件</td></tr></tbody></table></li></ul></li><li><p><code>fclose</code> 函数: 关闭一个文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fclose</span><span class="hljs-params">( FILE *fp )</span>;  <span class="hljs-comment">// fclose 函数原型</span><br><span class="hljs-comment">/* fp: 使用 fopen 获取的文件指针</span><br><span class="hljs-comment">** 调用成功返回0,失败返回 EOF</span><br><span class="hljs-comment">** 调用 fopen 后系统才会将缓冲区的数据写入文件,并释放该文件的相关资源*/</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="9-2-顺序读写文件"><a href="#9-2-顺序读写文件" class="headerlink" title="9.2 顺序读写文件"></a>9.2 顺序读写文件</h3><ol><li><p>读取单个字符(下列函数均声明于 <code>&lt;stdio.h&gt;</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fgetc, getc 函数: 从文件流中读取下一个字符,并推进文件的位置指示器 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fgetc</span><span class="hljs-params">(FILE *stream)</span>;  <span class="hljs-comment">// 函数原型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getc</span><span class="hljs-params">(FILE *stream)</span>;  <span class="hljs-comment">// 通常实现为宏</span><br><span class="hljs-comment">/* stream: 指向一个待读取的文件流 */</span><br></code></pre></td></tr></table></figure></li><li><p>写入单个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fputc, putc 函数: 向文件流写入单个字符 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *stream)</span>;  <span class="hljs-comment">// 函数原型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *stream)</span>;  <span class="hljs-comment">// 通常实现为宏</span><br><span class="hljs-comment">/* c: 待写入的字符</span><br><span class="hljs-comment">** stream: 指向一个待写入的文件流</span><br><span class="hljs-comment">** 返回值: 遇到错误或文件结束时返回 EOF.否则返回已写入的字符本身 */</span><br></code></pre></td></tr></table></figure></li><li><p>读取字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fgets 函数: 从指定的文件中读取字符串 */</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> size, FILE *stream)</span>;<br><span class="hljs-comment">/* s: 指向存放读取得到字符串的位置</span><br><span class="hljs-comment">** size: 指定读取的字符数(包括自动添加的 &#x27;\0&#x27;).想读取10个字符,应令 size = 11</span><br><span class="hljs-comment">** stream: 指定一个待操作的数据流</span><br><span class="hljs-comment">** 返回值: 调用成功,返回 s 指向的地址.若发生错误,返回 NULL</span><br><span class="hljs-comment">** 当遇到换行符 &#x27;\n&#x27; 就会停止本次字符串的读取</span><br><span class="hljs-comment">** 注意 gets 函数不安全,已被 C99 弃用并从 C11 除名 */</span><br></code></pre></td></tr></table></figure></li><li><p>写入字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fputs 函数: 将字符串写入到指定的文件中,结尾的 &#x27;\0&#x27; 不会被写入 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, FILE *stream)</span>;<br><span class="hljs-comment">/* s: 指向存放待写入字符串的位置</span><br><span class="hljs-comment">** stream: 指定一个待操作的数据流 */</span><br><br><span class="hljs-comment">/* puts 函数: 将字符串写入 stdout 并自动追加换行符.方便打印消息 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">puts</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;<br></code></pre></td></tr></table></figure></li><li><p>格式化读写文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fscanf 函数: f 表示 file,对文件进行读取 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fscanf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br><br><span class="hljs-comment">/* fprintf 函数: f 表示 file,对文件进行写入 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br></code></pre></td></tr></table></figure></li><li><p>二进制读写文件</p><ul><li><p><code>fopen</code> 函数可以指定文件的打开模式(文本, 二进制).但后续对文件的操作并不一定是对应的形式</p><ul><li>无论以哪种模式打开文件,都不能决定写入数据的形式.它们只是影响换行符的表现形式.</li></ul></li></ul></li></ol><ul><li><p>真正决定数据写入模式的是 相关的文件读写函数</p><ul><li><code>fread</code> 函数: 从指定文件中读取指定尺寸的数据</li></ul></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">fread</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span>;<br><span class="hljs-comment">/* ptr:指向存放数据的内存块地址</span><br><span class="hljs-comment">** size:待读取的每个元素的尺寸 </span><br><span class="hljs-comment">** nmemb:指定待读取的元素个数</span><br><span class="hljs-comment">** stream:指向一个待读取的文件流</span><br><span class="hljs-comment">** 返回值:   调用成功返回实际读取到的元素个数,即 nmemb</span><br><span class="hljs-comment">** 如果返回值小于 nmemb,说明读取到文件末尾或发生错误 */</span><br></code></pre></td></tr></table></figure><ul><li><p><code>fwrite</code> 函数: 将指定数据写入到指定文件</p><pre><code class="hljs"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-type">size_t</span> <span class="hljs-title function_">fwrite</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span>;<br><br><span class="hljs-comment">/* ptr:指向存放数据的内存块地址</span><br><span class="hljs-comment">    ** size:待写入的每个元素的尺寸</span><br><span class="hljs-comment">    ** nmemb:指定待写入的元素个数</span><br><span class="hljs-comment">    ** stream:指向一个待写入的文件流 */</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><h3 id="9-3-随机读写文件"><a href="#9-3-随机读写文件" class="headerlink" title="9.3 随机读写文件"></a>9.3 随机读写文件</h3><ol><li><p>系统为每个打开的文件设置了一个位置指示器,用于表示当前的读写位置</p></li><li><p><code>ftell</code> 函数: 返回当前的读写位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">ftell</span><span class="hljs-params">(FILE *stream)</span>;<br><span class="hljs-comment">/* stream: 指定待操作的文件流</span><br><span class="hljs-comment">** 返回值: 指定文件的当前读写位置</span><br><span class="hljs-comment">** 如果将文件看作一个数组,那么 ftell 的返回值就是&quot;数组&quot;的下标 */</span><br></code></pre></td></tr></table></figure></li><li><p><code>fseek</code> 函数: 设置文件位置指示器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">long</span> <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> whence)</span>;<br><span class="hljs-comment">/* stream: 指定待操作的文件流</span><br><span class="hljs-comment">** offset: 指定偏移的字节数量</span><br><span class="hljs-comment">** whence: 指定开始偏移的位置 */</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>whence 的值</th><th>描述</th></tr></thead><tbody><tr><td>SEEK_SET</td><td>文件开头</td></tr><tr><td>SEEK_CUR</td><td>当前位置</td></tr><tr><td>SEEK_END</td><td>文件末尾</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">fseek(fp, <span class="hljs-number">100</span>, SEEK_SET);<span class="hljs-comment">// 定位到文件的第100字节位置</span><br>fseek(fp, <span class="hljs-number">-5</span>, SEEK_END);<span class="hljs-comment">// 定位到文件的倒数第5个字节位置</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>fseek</code> 需要考虑可移植性</p><ul><li>不同操作系统对换行符的处理不同,导致定位会出现误差</li><li>对于二进制模式打开的文件, <code>fseek</code> 在某些操作系统中可能不支持 SEEK_END</li><li>对于文本模式打开的文件, <code>whence</code> 参数只有取 SEEK_SET 才有意义.传递给 offset 的参数值要么为 0,要么是上一次对同一文件调用 <code>ftell</code> 函数获得的返回值</li></ul></li></ol><h3 id="9-4-标准流"><a href="#9-4-标准流" class="headerlink" title="9.4 标准流"></a>9.4 标准流</h3><ol><li><p>标准输入&#x2F;输出&#x2F;错误输出</p><ul><li><p>当一个程序被执行时, C 语言自动为其打开3个面向终端的文件流(在 <code>&lt;stdio.h&gt;</code> 中声明)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stdin</span>;  <span class="hljs-comment">// 标准输入(standard input)</span><br><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stdout</span>;  <span class="hljs-comment">// 标准输出(standard output)</span><br><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stderr</span>;  <span class="hljs-comment">// 标准错误输出(standard error output)</span><br></code></pre></td></tr></table></figure></li><li><p>C 语言对应提供3种文件指针: stdin, stdout, stderr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 若打开文件失败,则输出&quot;打开文件失败\n&quot;,并退出 */</span><br>FILE *fp;<br><span class="hljs-keyword">if</span>((fp = open(<span class="hljs-string">&quot;nonexistent.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>)) == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;打开文件失败\n&quot;</span>, <span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT FALLURE);<br>&#125;<br>fclose(fp);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>错误处理</p><ul><li><p>每个流对象内部都有2个指示器</p><ul><li>文件结束指示器: 遇到文件末尾时被设置</li><li>错误指示器: 当读写文件出错时被设置</li></ul></li><li><p>分别使用 <code>feof, ferror</code> 函数检查这两个指示器是否被设置(置1)</p></li><li><p>使用 <code>clearerr</code> 函数可以人为清除文件末尾指示器和错误指示器的状态</p></li><li><p><code>ferror</code> 函数只能检测是否出错,并不能提供出现错误的原因</p></li><li><p>大多数系统函数在出错时会将错误原因记录在 <code>errno</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开文件失败: %d\n&quot;</span>, errno);<br></code></pre></td></tr></table></figure><ul><li><p>各种错误原因都有对应的错误码记录在 <code>errno</code> 中,但仅打印 <code>errno</code> 的值很不直观</p></li><li><p>C 语言将各种错误码对应信息打包在 <code>perror</code> 函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">perror</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>s</code>: 指定在错误信息前输出的自定义内容.然后自动添加一个冒号</li></ul></li><li><p>如果只想要系统返回错误信息的本体.可使用 <code>stderror</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> errnum)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>errnum</code>: 指定的 <code>errno</code> 值</li><li>返回值: 错误码对应的错误信息</li></ul></li></ul></li></ul></li></ol><h3 id="9-5-I-O缓冲区"><a href="#9-5-I-O缓冲区" class="headerlink" title="9.5 I&#x2F;O缓冲区"></a>9.5 I&#x2F;O缓冲区</h3><ol><li><p>对于写入操作,程序会先将数据写入缓冲区,直到缓冲区被写满或文件关闭时才一次性写入设备中</p></li><li><p>对于读取操作,如果数据已经在缓冲区中,则立即返回给程序.否则,系统会将一大块数据从设备读入缓冲区</p></li><li><p>如果需要立即将数据写入设备中,可使用 <code>fflush</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fflush</span><span class="hljs-params">(FILE *stream)</span>;<br></code></pre></td></tr></table></figure></li><li><p>标准 I&#x2F;O 提供三种类型的缓冲模式</p><ul><li>按块缓存(全缓存): 在缓冲区填满后才进行实际的设备读写</li><li>按行缓存: 接受到换行符之前,数据缓存在缓冲区</li><li>xxxxxxxxxx unsigned int :424;c</li></ul></li><li><p>可以通过 <code>setvbuf</code> 函数自定义缓存的模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">setvbuf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> mode, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>stream</code>: 待操作的文件流</p></li><li><p><code>buf</code>: 指定一个用户分配的缓冲区.设置为 <code>NULL</code> 时,由函数自动分配</p></li><li><p><code>mode</code>: 缓存模式</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>_IOFBF</td><td>按块缓存</td></tr><tr><td>_IOLBF</td><td>按行缓存</td></tr><tr><td>_IONBF</td><td>不缓存</td></tr></tbody></table><ul><li><code>size</code>: 缓冲区的实际尺寸</li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法分析</title>
    <link href="/2024/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <url>/2024/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法分析"><a href="#数据结构与算法分析" class="headerlink" title="数据结构与算法分析"></a>数据结构与算法分析</h1><h2 id="0-算法分析"><a href="#0-算法分析" class="headerlink" title="0 算法分析"></a>0 算法分析</h2><h3 id="0-1-基础概念"><a href="#0-1-基础概念" class="headerlink" title="0.1 基础概念"></a>0.1 基础概念</h3><ol><li>概念<ul><li>数据结构: 组织大量数据的方法</li><li>算法分析: 对算法运行时间的评估</li><li><strong>算法(algorithm)</strong>: 为求解一个问题所需遵循的,被清楚指定的简单指令集合</li><li>当某种算法被给定时,则需要确定该算法所需的时间和空间等资源量</li></ul></li><li><strong>抽象数据类型(Abstract Data Type,ADT)</strong>: 是一些操作的集合,是数学上的抽象<ul><li>例如表,集合,图以及它们的操作可看作抽象数据类型</li><li>例如集合ADT,可以有 并(union), 交(intersection), 补(complement), 求大小(size)等操作</li><li>基本思路: 只在程序中编写一次,其他地方需要运行 ADT 上的操作时,可通过调用函数实现</li></ul></li><li>定义: 建立无穷大量之间的相对级别<ul><li>$\mathrm{if} \quad \exists c,n_0\in N_+,N\geq n_0\quad\mathrm{s.t.} T(N)\leq cf(N), \mathrm{then} \quad T(N)&#x3D;O(f(N))$</li><li>$\mathrm{if} \quad \exists c,n_0\in N_+,N\geq n_0  \quad  \mathrm{s.t.} T(N)\geq cg(N),\mathrm{then} \quad T(N)&#x3D;\Omega(g(N))$</li><li>$T(N)&#x3D;O(h(N))  \quad and\quad T(N)&#x3D;\Omega(h(N)) \iff T(N)&#x3D;\Theta(h(N))$</li><li>$T(N)&#x3D;O(p(N)) \quad and \quad T(N)\neq \Theta(p(N)), \mathrm{then} \quad T(N)&#x3D;o(f(N))$</li></ul></li><li>简要说明<ul><li>$O$: 高阶无穷大</li><li>$\Omega$: 低阶无穷大</li><li>$\Theta$: 同阶无穷大</li><li>$o$: 严格的高阶无穷大</li></ul></li><li><strong>一般采用大$O$记法</strong>.例如 $T(N)&#x3D;2N^2+N&#x3D;O(N^2)$<ul><li>不要将常数或低阶项放入大$O$,直接忽略即可</li><li>典型的增长率(递增排列): $C, \mathrm{log}N, \mathrm{log}^2N, N, N\mathrm{log}N, N^2, N^3, 2^N$</li><li>可以使用洛必达法则确定两个函数的相对级别</li></ul></li></ol><h3 id="0-2-计算方式"><a href="#0-2-计算方式" class="headerlink" title="0.2 计算方式"></a>0.2 计算方式</h3><ol><li>为在正式的框架中分析算法,需要一个计算模型<ul><li>假定一个标准计算机,它顺序执行指令.拥有简单的指令系统(如加减乘除,赋值等)</li><li>特别地,该模型机执行任意一条简单指令都恰好花费一个时间单元</li><li>该模型机具有无限内存</li></ul></li><li>待分析的问题<ul><li>最重要的资源一般为运行时间</li><li>在这里分析对运行时间的影响因素有: 使用的算法, 对该算法的输入(主要方面)</li><li>考虑两个函数<ul><li>$T_{avg}(N)$: 输入为 N 时算法所花费的平均时间</li><li>$T_{worst}(N)$: 输入为 N 时算法在最坏情况下花费的时间</li><li><strong>主要考虑 $T_{worst}(N)$.因为它为所有的输入提供了一个运行时间上界</strong></li></ul></li><li>当两个程序花费的时间大致相同时,判断运行速度的方法是将其编码并运行</li><li>为简化分析,系数,低阶项,常数项直接抛弃.只计算其上界: 大$O$</li></ul></li></ol><h3 id="0-3-运行时间计算"><a href="#0-3-运行时间计算" class="headerlink" title="0.3 运行时间计算"></a>0.3 运行时间计算</h3><ol><li><p>分析案例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 计算 1~n 的立方和 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> partialSum = <span class="hljs-number">0</span>;<span class="hljs-comment">// 声明不计时间,赋值计1个时间单元</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i &lt;= n, i++) &#123;<span class="hljs-comment">// 初始化赋值计1次,判断循环条件计n+1次,自增计n次</span><br>        partialSum += i * i * i;<span class="hljs-comment">// 乘法2次,加法1次,赋值1次.重复n次,共计4n个时间单元</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> partialSum;<span class="hljs-comment">// 返回计1个时间单元</span><br>&#125;  <span class="hljs-comment">// 本算法共计6n+4个时间单元,即 O(N)</span><br></code></pre></td></tr></table></figure></li><li><p>一般法则</p><ul><li><code>for</code>: 运行时间最多为循环语句的运行时间乘以迭代次数</li><li>嵌套 <code>for</code>: 由里向外分析循环.嵌套循环内部一条语句总运行时间为: 该语句运行时间乘以<code>for</code>循环大小的乘积</li><li>顺序语句: 对各语句的运行时间求和(事实上,只需考虑运行时间最长的语句)</li><li><code>if/else</code>: 判断语句运行时间加上分支语句中最长的运行时间</li><li><strong>分析的基本策略为从内部向外扩展.如果有函数调用,则应该首先分析</strong></li></ul></li><li><p>考虑 Fibonacci 数列递归求和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-1</span>) + fib(n<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>运行时间为: $T(N)&#x3D;T(N-1)+T(N-2)\quad (n\geq2)$.这是一个指数级增长</li><li>运行效率低下的原因为: 进行了大量的重复计算,且计算结果被抛弃</li><li>改进: 用一个数组将计算结果存储起来,将可以大大提高运行效率</li></ul></li><li><p>最大子序列和问题的四种算法</p><ul><li><p>问题: 给定整数 $A_1,A_2,\dots,A_n$, 求  $\sum\limits^j_{k&#x3D;i}A_k$ 的最大值(假定数组中均为负数,则最大子序列和为0)</p></li><li><p>穷举所有的可能 $\Theta(n^3)$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumN3</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i; j&lt;n; j++) &#123;<br>            <span class="hljs-type">int</span> thisSum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i; k&lt;=j; k++) &#123;<br>                thisSum += a[k];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(thisSum &gt; maxSum)<br>                maxSum = thisSum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分析可知,最内层的 for 冗余,将其去掉 $O(N^2)$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumN2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-type">int</span> thisSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i; j&lt;n; j++) &#123;<br>            thisSum += a[j];<br>            <span class="hljs-keyword">if</span>(thisSum &gt; maxSum)<br>                maxSum = thisSum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>递归 $O(N\mathrm{logN})$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumNlogN</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left == right) <span class="hljs-comment">// 参数为数组,左边界,右边界</span><br>        <span class="hljs-keyword">return</span> a[left] &gt; <span class="hljs-number">0</span> ? a[left] : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> center = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> maxLeftSum, maxRightSum;<br>    maxLeftSum = maxSubseqSumNlogN(a, left, center);  <span class="hljs-comment">// 递归调用</span><br>    maxRightSum = maxSubseqSumNlogN(a, center + <span class="hljs-number">1</span>, right);<br><br>    <span class="hljs-type">int</span> maxLeftBrdSum,  maxRightBrdSum,     leftBrdSum,     rightBrdSum;<br>    maxLeftBrdSum = <span class="hljs-number">0</span>;  maxRightBrdSum = <span class="hljs-number">0</span>; leftBrdSum = <span class="hljs-number">0</span>; rightBrdSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=center; i&gt;=left; i--) &#123;  <span class="hljs-comment">// 计算中值到左边界的最大和</span><br>        leftBrdSum += a[i];<br>        <span class="hljs-keyword">if</span>(leftBrdSum &gt; maxLeftBrdSum)<br>            maxLeftBrdSum = leftBrdSum;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=center+<span class="hljs-number">1</span>; i&lt;=right; i++) &#123;  <span class="hljs-comment">// 计算中值到右边界的最大和</span><br>        rightBrdSum += a[i];<br>        <span class="hljs-keyword">if</span>(rightBrdSum &gt; maxRightBrdSum)<br>            maxRightBrdSum = rightBrdSum;<br>    &#125;<br>    <span class="hljs-comment">// 返回三者的最大值</span><br>    <span class="hljs-keyword">if</span> (maxLeftSum &gt;= maxRightSum)<br>        <span class="hljs-keyword">return</span> maxLeftSum &gt;= maxLeftBrdSum + maxRightBrdSum ? maxLeftSum : maxLeftBrdSum + maxRightBrdSum;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> maxRightSum &gt;= maxLeftBrdSum + maxRightBrdSum ? maxRightSum : maxLeftBrdSum + maxRightBrdSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>线性算法 $O(N)$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumN</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> thisSum, maxSum;<br>    thisSum = <span class="hljs-number">0</span>; maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++) &#123;<br>        thisSum += a[j];<br>        <span class="hljs-keyword">if</span>(thisSum &gt; maxSum)<br>            maxSum = thisSum;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(thisSum &lt; <span class="hljs-number">0</span>)<br>            thisSum = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行代码(将上述代码置于一个文件下即可运行)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">-2</span>&#125;;<br>    <span class="hljs-type">int</span> arrLength = <span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(N^3)   = %d\n&quot;</span>,maxSubseqSumN3(a, arrLength));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(N^2)   = %d\n&quot;</span>,maxSubseqSumN2(a, arrLength));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(NlogN) = %d\n&quot;</span>,maxSubseqSumNlogN(a, <span class="hljs-number">0</span>, arrLength - <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(N)     = %d\n&quot;</span>,maxSubseqSumN(a, arrLength));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>运行时间中的对数</p><ul><li><p>对数经常出现的场景有</p><ul><li>若算法利用 $O(1)$ ,即在常数时间里将问题的规模削减一部分(如50%).则该算法为 $O(\mathrm{log}N)$</li><li>若算法利用 $O(1)$ ,即在常数时间里将问题的规模消减一个常数(如 -1).则该算法为 $O(N)$</li></ul></li><li><p>考虑到仅仅是将 N 个数据读入耗费的时间即为 $\Theta(N)$ .当谈及$O(\mathrm{log}N)$ 时均假定数据已读入</p></li><li><p>下面三个算法均为 $O(\mathrm{log}N)$</p><ul><li>二分查找(给定整数$X$,已排序数组 $A_0,A_1,\dots,A_{n-1}$ ,求满足$A_i&#x3D;X$的下标 $i$)</li></ul><pre><code class="hljs"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">float</span> elementType;<br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> elementType arr[], elementType x, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> low, mid, high;<br>    low = <span class="hljs-number">0</span>; high =n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>        mid = (low+high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(arr[mid] &lt; x)<br>            low = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; x)<br>            high = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><ul><li><p>欧几里得算法(计算最大公因数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> m,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rem;<br>    <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>) &#123;<br>        rem = m % n;<br>        m = n;<br>        n = rem;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>幂运算</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">int</span> x,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == n)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> == n % <span class="hljs-number">2</span> ? <span class="hljs-built_in">pow</span>(x * x, n / <span class="hljs-number">2</span>) : <span class="hljs-built_in">pow</span>(x * x, n / <span class="hljs-number">2</span>) * x;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1 线性表"></a>1 线性表</h2><h3 id="1-1-单链表"><a href="#1-1-单链表" class="headerlink" title="1.1 单链表"></a>1.1 单链表</h3><ol><li><p>表: 形如 $a_1, a_2,\dots ,a_n$ 的有限序列.其中 $a_i$ 为数据元素 </p><ul><li>其大小为 n (当 n&#x3D;&#x3D;0 称为空表,empty list)</li><li>表的操作: 创建空表(makeEmpty), 插入元素(Insert), 删除元素(Delete), 查找元素(find), 打印表(printList)</li><li>由于数组对于插入和删除元素的运行太慢,一般不用简单数组实现表</li></ul></li><li><p>链表: 由一系列的无需在内存中相连的结构组成</p><ul><li>每个结构含有表元素以及指向该元素后继元结构的指针(next 指针)</li><li>最后一个元素的 next 指针 指向 NULL</li><li><strong>预留一个标志节点作为表头(head).其位置为0</strong></li></ul></li><li><p>链表接口(具体实现见 <code>single_linked_list</code>.不考虑数组实现方式)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SINGLE_LINKED_LIST_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SINGLE_LINKED_LIST_H</span><br><br><span class="hljs-comment">/*********************************************************/</span><br><span class="hljs-comment">/* node:        结构体类型名,链表结点</span><br><span class="hljs-comment">** ptr2node:    结构体指针,指向链表结点的指针</span><br><span class="hljs-comment">** list:        结构体指针,一般将头结点声明为 list 类型</span><br><span class="hljs-comment">** position:    结构体指针,一般将其它结点声明为 position 类型</span><br><span class="hljs-comment">** elementType: 元素类型名 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr2node</span>;</span><br><span class="hljs-keyword">typedef</span> ptr2node <span class="hljs-built_in">list</span>;<br><span class="hljs-keyword">typedef</span> ptr2node position;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    elementType element;<br>    position next;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(elementType x, elementType y)</span>;<br><br><span class="hljs-comment">/*********************************************************/</span><br><span class="hljs-comment">/* 链表相关函数.除了创建空链表,其它函数都需要参数 list l,以指明操作对象 */</span><br><span class="hljs-comment">/********** 1.创建与销毁 **********/</span><br><span class="hljs-built_in">list</span> <span class="hljs-title function_">makeList</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">clearList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deleteList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><br><span class="hljs-comment">/********** 2.获取长度 **********/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmptyList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isLast</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, position p)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">lenList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><br><span class="hljs-comment">/********** 3.增删改查 **********/</span><br>position <span class="hljs-title function_">findPosition</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x)</span>;<br>position <span class="hljs-title function_">findPrevious</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">findIndex</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x, compare func)</span>;<br>elementType *<span class="hljs-title function_">findElem</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, <span class="hljs-type">int</span> index)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x, position p)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* SINGLE_LINKED_LIST_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p>常见错误</p><ul><li>未初始化指针: 如果不知道应将指针初始化为什么,则将其初始化为 NULL</li><li><code>malloc</code> 函数的使用<ul><li>声明一个结构体指针是并不创建该结构.仅留出足够容纳结构的空间</li><li>若只需要一个结构体指针沿着表前进(例: <code>printList</code> 函数中的 <code>tmp</code>),则不需要使用 <code>malloc</code></li><li>当空间不再需要时.应使用 <code>free</code> 函数回收</li><li>若链表未执行过删除操作,则 <code>malloc</code> 调用次数应等于表的大小.若有表头,调用次数会多一次</li></ul></li></ul></li></ol><h3 id="1-2-链表使用"><a href="#1-2-链表使用" class="headerlink" title="1.2 链表使用"></a>1.2 链表使用</h3><ol><li><p>双链表: 在数据结构中增加一个域,使其指向前一个单元</p><ul><li><p>增加空间需求.因为需要额外存储一个指针</p></li><li><p>使得插入和删除的开销增加一倍.因为需要对增加的指针进行定位</p></li><li><p>简化删除操作.因为不再需要定位前驱元</p></li></ul></li><li><p>循环链表: 令最后一个单元指向第一个单元(可以存在表头,令最后一个单元指向表头)</p></li><li><p><strong>基数排序(radix sort)</strong></p><ul><li>桶式排序(bucket sort)<ul><li>问题: 存在 $n$ 个整数 $a_i(0\leq x_i\leq M-1,1\leq i\leq n)$ 需要排序</li><li>预留一个大小为 $M$ 的 count 数组.即 count 有 $M$ 个单元(桶).初始情况下 count 内元素为空</li><li>当 $a_i$ 被读入时,$\mathrm{count}[a_i]$ 自增1;所有的输入被读入后,扫描数组 count,打印排好序的表</li><li>该算法的时间花费为 $O(M+N)$</li></ul></li><li>基数排序是桶式排序的推广<ul><li>考虑当桶的数量远大于数的个数时.桶式排序便不再适合</li><li>若存在 $n$ 个整数 $a_i(0\leq x_i\leq n^p-1,1\leq i\leq n)$ 需要排序.进行多次桶式排序</li><li>第一步以最低位进行桶式排序,依次按位数桶式排序,直到最高位完成进行桶式排序</li><li>该算法的时间花费为 $O(p(n+b))$.其中p为趟数,n为元素个数,b为桶数</li></ul></li><li>例: 对 0~9 的立方进行基数排序<ul><li>原始数组: [0, 1, 512, 343, 64, 125, 216, 27, 8, 729]</li><li>第一次排序结果: [0, 1, 512 ,343, 64, 125, 216, 27, 8, 729]</li><li>第二次排序结果: [8, 1, 0], [216, 512], [729,27,125],  [343], [64]</li><li>第三次排序结果: [64,27,8,1,0], [125], [216], [343], [512], [729]</li></ul></li></ul></li></ol><h3 id="1-3-栈"><a href="#1-3-栈" class="headerlink" title="1.3 栈"></a>1.3 栈</h3><ol><li><p>栈(stack): 限制插入和删除只能在一个位置(栈顶, top)进行的表</p><ul><li>栈的基本操作有: 入栈(push),出栈(pop)</li><li>栈的特点: 后进先出(LIFO),且只有栈顶元素可访问</li><li>栈的链表实现及其操作不涉及栈的大小,因此均为常数时间开销.缺点在于需要承担 <code>malloc,free</code> 的开销</li><li>当栈采用头插法进行入栈,则头节点的后继元即为栈顶,因此出栈只需删除头节点的后继元</li></ul></li><li><p>栈接口(具体实现见 <code>stack</code>.不考虑数组实现方式)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STACK_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr2node</span>;</span><br><span class="hljs-keyword">typedef</span> ptr2node <span class="hljs-built_in">stack</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    elementType element;<br>    ptr2node next;<br>&#125;;<br><br><span class="hljs-built_in">stack</span> <span class="hljs-title function_">makeStack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deleteStack</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s, elementType x)</span>;<br>elementType <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* STACK_H */</span></span><br></code></pre></td></tr></table></figure></li></ol><h3 id="1-4-队列"><a href="#1-4-队列" class="headerlink" title="1.4 队列"></a>1.4 队列</h3><ol><li><p>队列(queue): 限制插入(队尾, rear)和删除(队头, front)只能在两端分别进行的表</p><ul><li>队列的基本操作有入队(enqueue),出队(dequeue)</li><li>队列的特点: 先进先出(FIFO);只有队头元素可访问</li></ul></li><li><p>队列的链表实现的注意事项</p><ul><li>队列需要指向队头(front)和队尾(rear)的两个指针</li><li>当进行入队操作时,采用尾插法,且需要将 rear 指针向后移动一位</li><li>当进行出队操作时,需要先判断队列是否为空(front &#x3D;&#x3D; rear),然后删除 front 指针的后继元</li></ul></li><li><p>队列接口(具体实现见 <code>queue</code>.不考虑数组实现方式)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> QUEUE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUEUE_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr2node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    elementType element;<br>    ptr2node next;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ptr2node front;<br>    ptr2node rear;<br>&#125; *<span class="hljs-built_in">queue</span>;<br><br><span class="hljs-built_in">queue</span> <span class="hljs-title function_">makeQueue</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deleteQueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q, elementType e)</span>;<br>elementType <span class="hljs-title function_">dequeue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* QUEUE_H */</span></span><br></code></pre></td></tr></table></figure></li></ol><h2 id="2-树"><a href="#2-树" class="headerlink" title="2 树"></a>2 树</h2><h3 id="2-1-树的实现"><a href="#2-1-树的实现" class="headerlink" title="2.1 树的实现"></a>2.1 树的实现</h3><ol><li><p>树的递归定义: 一棵<strong>树</strong>是一些节点的集合(可以是空集).若非空,则一棵树由称为<strong>根</strong>(root)的节点 r,以及0个或多个非空的(子)树 $T_1,T_2,\dots,T_k$ 组成,这些<strong>子树</strong>中的每一颗的根都被来自根 r 的一条有向边所连接</p><ul><li><strong>叶</strong>(leaf): 没有子节点的节点</li><li><strong>兄弟</strong>(sibling): 具有相同父节点的节点</li><li><strong>路径</strong>(path): 从节点 $n_1$ 到 $n_k$ 的路径为 $n_1, n_2,\dots,n_k$ 的一个序列.且对于 $1\leq i&lt;k$,有 $n_i$ 是 $n_{i+1}$ 的父节点</li><li><strong>路径的长</strong>(length): 路径上 边的条数,即 $k-1$.每一节点到自身的路径长为0</li><li><strong>深度</strong>(depth): 对于任意节点 $n_i$,其深度为从根到 $n_i$ 的唯一路径的长</li></ul></li><li><p>树的实现</p><ul><li><p>在每一个节点除数据外,还需要的两个指针指向它的第一子节点(向下)及下一个兄弟节点(向右)</p></li><li><p>树的节点声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">prtToNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> &#123;</span><br>    elementType element;<br>    prtToNode firstChild;<br>    prtToNode nextSibling;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>树的遍历</p><ul><li><p>树经常用于操作系统中的目录结构</p><ul><li>例如 Unix 系统中的文件 <code>/usr/mark/book/ch1.r</code></li><li>第一个 &#x2F; 后的每个 &#x2F; 都表示一条边</li></ul></li><li><p>考虑以下述格式打印目录中的所有文件: 深度为 $d_i$ 的文件的名称前有 $d_i$ 个 <kbd>tab</kbd> 进行缩进,然后打印</p></li><li><p>实现思路: 以递归的方式打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">listDir</span><span class="hljs-params">(directoryOrFile d, <span class="hljs-type">int</span> depth)</span> &#123;<br>    <span class="hljs-keyword">if</span>(d is a legitimate entry) &#123;<br>        printName(d, depth);<br>        <span class="hljs-keyword">if</span>(d is a directory) &#123;<br>            <span class="hljs-keyword">for</span> each child, c, of d<br>                <span class="hljs-title function_">listDir</span><span class="hljs-params">(c, depth + <span class="hljs-number">1</span>)</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">listDirectory</span><span class="hljs-params">(directoryOrFile d)</span> &#123;<br>    listDir(d, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>算法核心函数 <code>listDir</code>: 参数为目录树的引用.如果是目录,则递归的处理子节点,文件名则被缩进后打印</li><li>驱动函数 <code>listDirectory</code>: 考虑到 <code>listDir</code> 的参数 <code>depth</code> 为内部递归变量.<br>因此需要驱动函数(这里赋值为0)</li></ul></li></ul></li></ol><h3 id="2-2-二叉树"><a href="#2-2-二叉树" class="headerlink" title="2.2 二叉树"></a>2.2 二叉树</h3><ol><li><p><strong>二叉树</strong>: 每个节点的子节点都不超过2个的树</p><ul><li>平均二叉树的深度通常比节点数 N 小得多,平均深度为 $O(\sqrt N)$</li><li><strong>二叉查找树</strong>(binary search tree)的平均深度为 $O(\log N)$.但在最坏的情况下可以为 N-1</li></ul></li><li><p>二叉树的实现</p><ul><li><p>由于二叉树最多有两个子节点,因此可以直接用指针指向它们</p></li><li><p>二叉树的节点声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">ptrToNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ptrToNode</span> <span class="hljs-title">tree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> &#123;</span><br>    elementType element;<br>    tree left;<br>    tree right;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="2-3-二叉查找树"><a href="#2-3-二叉查找树" class="headerlink" title="2.3 二叉查找树"></a>2.3 二叉查找树</h3><ol><li><p>二叉树经常用于查找.给树中的每个节点指定一个关键字值(假定为整数,且唯一)</p></li><li><p><strong>二叉查找树</strong>: 对于树中的每个节点 X,其左子树所有关键字值小于X关键字值,右子树所有关键字值大于X关键字值</p><ul><li>考虑到树的递归定义,对二叉查找树的操作通常采用递归处理</li><li>考虑到所有的元素都是有序的,因此假定运算符 <code>&lt;, =, &gt;</code> 均可用于这些元素</li></ul></li><li><p>二叉查找树的声明(<code>searchTree.h</code>文件中)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SEARCH_TREE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEARCH_TREE_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">position</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">searchTree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> &#123;</span><br>    elementType element;<br>    searchTree left;<br>    searchTree right;<br>&#125;<br><br>searchTree <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">(searchTree t)</span>;  <span class="hljs-comment">// 创建空树</span><br>position <span class="hljs-title function_">find</span><span class="hljs-params">(elementType x, searchTree t)</span>;  <span class="hljs-comment">// 查找元素位置</span><br>position <span class="hljs-title function_">findMin</span><span class="hljs-params">(searchTree t)</span>;  <span class="hljs-comment">// 查找最小值位置</span><br>position <span class="hljs-title function_">findMax</span><span class="hljs-params">(searchTree t)</span>;  <span class="hljs-comment">// 查找最大值位置</span><br>searchTree <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, searchTree t)</span>;  <span class="hljs-comment">// 插入元素</span><br>searchTree <span class="hljs-title function_">delete</span><span class="hljs-params">(elementType x, searchTree t)</span>;  <span class="hljs-comment">// 删除元素</span><br>elementType <span class="hljs-title function_">retrieve</span><span class="hljs-params">(position p)</span>;  <span class="hljs-comment">// 检索位置信息</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* SEARCH_TREE_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p>源文件 <code>searchTree.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c">searchTree <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">(searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t != <span class="hljs-literal">NULL</span>) &#123;<br>        makeEmpty(t-&gt;left);<br>        makeEmpty(t-&gt;right);<br>        <span class="hljs-built_in">free</span>(t);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>position <span class="hljs-title function_">find</span><span class="hljs-params">(elementType x, searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(x &lt; t-&gt;element)<br>        <span class="hljs-keyword">return</span> find(x, t-&gt;left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t-&gt;element)<br>        <span class="hljs-keyword">return</span> find(x, t-&gt;right);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> t;<br>&#125;<br><br>position <span class="hljs-title function_">findMin</span><span class="hljs-params">(searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;left == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> t;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> findMin(t-&gt;left);<br>&#125;<br><br>position <span class="hljs-title function_">findMax</span><span class="hljs-params">(searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t != <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">while</span>(t-&gt;right != <span class="hljs-literal">NULL</span>)<br>            t = t-&gt;right;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br>searchTree <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>) &#123;<br>        t = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> treeNode));<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">NULL</span>)<br>            fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            t-&gt;element = x;<br>            t-&gt;left = t-&gt;right = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; t-&gt;element)<br>        t-&gt;left = insert(x, t-&gt;left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t-&gt;element)<br>        t-&gt;right = insert(x, t-&gt;right);<br>    <span class="hljs-comment">/* else x已经在树中,不在执行任何操作 */</span><br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br>searchTree <span class="hljs-title function_">delete</span><span class="hljs-params">(elementType x, searchTree t)</span> &#123;<br>    position tmp;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)  <span class="hljs-comment">/* 空树 */</span><br>        Error(<span class="hljs-string">&quot;Element not found&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; t-&gt;element)  <span class="hljs-comment">/* 向左 */</span><br>        t-&gt;left = delete(x, t-&gt;left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t-&gt;element)  <span class="hljs-comment">/* 向右 */</span><br>        t-&gt;right = delete(x, t-&gt;right);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;left &amp;&amp; t-&gt;right) &#123; <span class="hljs-comment">/* 2个子节点 */</span><br>        tmp = findMin(t-&gt;right);<br>        t-&gt;element = tmp-&gt;element;<br>        t-&gt;right = delete(t-&gt;element, t-&gt;right);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        tmp = t;<br>        <span class="hljs-keyword">if</span>(t-&gt;left == <span class="hljs-literal">NULL</span>)<br>            t = t-&gt;right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;right == <span class="hljs-literal">NULL</span>)<br>            t = t-&gt;left;<br>        <span class="hljs-built_in">free</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-AVL-树"><a href="#2-4-AVL-树" class="headerlink" title="2.4 AVL 树"></a>2.4 AVL 树</h3><ol><li><strong>AVL树</strong>(Adelson-Velskii Landis): 带有平衡条件(需易保持)的二叉查找树.且保证树的深度为$O(\log N)$<ul><li>AVL 树要求每个节点的左子树和右子树的高度最多差1(空树的高度定义为-1)</li><li>AVL 树的高度最多为$1.44\log (N+2)-1.328$. 因此可以保证除插入外的操作(删除为惰性)均为 $O(\log N)$</li></ul></li><li><strong>旋转</strong>: AVL 树的插入操作可能会破坏平衡条件,因此隐含着困难.但总是可以经过修正使得性质恢复<ul><li>插入后,只有插入点到根节点路径上的节点的平衡可能被改变.沿着此路径向上找到一个破坏了 AVL 条件的节点,调整该节点重新平衡该树,将会使得整棵树满足 AVL 条件</li><li>设需要重新平衡的节点为 $\alpha$.导致不平衡出现的插入位置共有4种情况<ol><li>左子节点的左子树</li><li>左子节点的右子树</li><li>右子节点的左子树</li><li>右子节点的右子树</li></ol></li><li>情形1,4 与 情形2,3 为关于 $\alpha$节点的对称.分别通过单旋转和双旋转进行处理</li></ul></li></ol><h2 id="3-散列"><a href="#3-散列" class="headerlink" title="3 散列"></a>3 散列</h2><h3 id="3-1-散列函数"><a href="#3-1-散列函数" class="headerlink" title="3.1 散列函数"></a>3.1 散列函数</h3><ol><li><p>散列表(hash table)ADT: 仅支持二叉查找树所允许的一部分操作,其实现常称为<strong>散列</strong>(hashing)</p><ul><li>散列以常数平均时间执行 插入,删除,查找,但需要元素间任何排序信息的操作不会得到有效支持</li><li>理想的散列表数据结构是一个含有<strong>关键字</strong>的具有固定大小的数组</li><li>关键字的典型是带有信息的字符串,而表的大小记为 Table-Size</li></ul></li><li><p><strong>映射函数</strong>(hash function): 将关键字映射到 [0, Table-Size) 区间中的某个数,且放到适当的单元中</p><ul><li>理想的映射函数应运算简单,且保证不同的关键字映射到不同的单元</li><li>实际上不可能,因为关键字是无穷的,而单元的数量是有限的</li><li>因此要找一个散列函数,能在单元间均匀的分配关键字</li><li><strong>冲突</strong>(collision): 两个关键字散列到同一个值</li></ul></li><li><p>散列函数</p><ul><li><p>若输入的关键字为整数,一般采用返回 <code>key mod tableSize</code>.保证表的大小为素数时效果较好</p></li><li><p>若输入的关键字为字符串</p><ol><li><p>可以将字符串中的字符的 ASCII 码值之和作为关键字(简单,但当表很大时将会分配不均)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index;<br>index <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">int</span> tableSize)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashVal = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*key != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        hashVal += *key++;<br>    <span class="hljs-keyword">return</span> hashVal % tableSize;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>考虑计算 $\mathrm{\sum\limits_{i&#x3D;0}^{keySize&#x3D;1}key[keySize-i-1]}\cdot 32^i$(根据 Horner 法则计算 32 的多项式函数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">index <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">int</span> tableSize)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashVal = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*key != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        hashVal = (hashVal &lt;&lt; <span class="hljs-number">5</span>) + *key++;<br>    <span class="hljs-keyword">return</span> hashVal % tableSize;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如计算 $h_k &#x3D; k_1 + 32k_2 + 32^2k_3$ 的方式为 $h_k &#x3D; ((k_3) \times 32 + k_2) \times 32+k_1$ </li><li>关键行中的 <code>&lt;&lt; 5</code> 即为乘以32, 且其中的加法还可以使用按位异或 <code>^</code> 代替</li><li>该算法的优点在于极其简单,当允许溢出时速度很也快</li><li>如果关键字特别长,不仅时间花费大,而且前面的字符还会被移出.此时通常不采用全部字符</li></ul></li></ol></li></ul></li></ol><h3 id="3-2-消除冲突"><a href="#3-2-消除冲突" class="headerlink" title="3.2 消除冲突"></a>3.2 消除冲突</h3><ol><li><p>当一个元素被插入处已存在另一个元素(即不同关键字的散列值相同),此时将产生冲突</p><ul><li>解决冲突的方式有: 分离链接法(separate chaining), 开放定址法(open addressing)</li></ul></li><li><p>分离链接法: 将散列到同一个值的所有元素保存到一个表中</p><ul><li><p>示例: 关键字为前10个数的平方(0, 1, 4, 9, 16, 25, 36, 49, 64, 81).散列函数为 $hash(x) &#x3D; x \space mod \space 10$</p></li><li><p>则分离链接散列表形如</p><p><img src="/2024/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/assets/%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%95%A3%E5%88%97%E8%A1%A8.png" alt="1"></p></li><li><p>插入操作: 遍历相应的表以检查该元素是否以处于适当的位置.如果是新元素,则将其插入到表的前端&#x2F;末尾</p></li><li><p>分离链接散列表的的实现</p><ul><li><p>头文件 <code>hashSeq.h</code> 中(其中 listNode 的结构与链表相同)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HASH_SEQ_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HASH_SEQ_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTbl</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">position</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTbl</span> *<span class="hljs-title">hashTable</span>;</span><br><br>hashTable <span class="hljs-title function_">initializeTable</span><span class="hljs-params">(<span class="hljs-type">int</span> tableSize)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">destroyTable</span><span class="hljs-params">(hashTable h)</span>;<br>position <span class="hljs-title function_">find</span><span class="hljs-params">(elementType key, hashTable h)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType key, hashTable h)</span>;<br>elementType <span class="hljs-title function_">retrieve</span><span class="hljs-params">(position p)</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br>    elementType element;<br>    position next;<br>&#125;<br><span class="hljs-keyword">typedef</span> position <span class="hljs-built_in">list</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTbl</span> &#123;</span><br>    <span class="hljs-type">int</span> tableSize;<br>    <span class="hljs-built_in">list</span> *theLists;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>源文件 <code>hashSeq.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">hashTable <span class="hljs-title function_">initializeTable</span><span class="hljs-params">(<span class="hljs-type">int</span> tableSize)</span> &#123;<br>    hashTable h;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>(tableSize &lt; minTableSize) &#123;<br>        error(<span class="hljs-string">&quot;Table size too small&quot;</span>);<br>        retrun <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>    h = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> hashTbl));<br>    <span class="hljs-keyword">if</span>(h == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    h-&gt;tableSize = nextPrime(tableSize);<br>    <br>    h-&gt;theLists = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">list</span>) * h-&gt;tableSize);<br>    <span class="hljs-keyword">if</span>(h-&gt;theLists == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; h-&gt;tableSize; i++) &#123;<br>        h-&gt;theLists[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> listNode));<br>        <span class="hljs-keyword">if</span>(h-&gt;theLists[i] == <span class="hljs-literal">NULL</span>)<br>            fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            h-&gt;theLists[i]-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType key, hashTable h)</span> &#123;<br>    position pos, newCell;<br>    <span class="hljs-built_in">list</span> l;<br>    pos = find(key, h);<br>    <span class="hljs-keyword">if</span>(pos == <span class="hljs-literal">NULL</span>) &#123;<br>        newCell = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> listNode));<br>        <span class="hljs-keyword">if</span>(newCell == <span class="hljs-literal">NULL</span>)<br>            fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            l = h-&gt;thelists[hash(key, h-&gt;tableSize)];<br>            newCell-&gt;next = l-&gt;next;<br>            newCell-&gt;element = key;<br>            l-&gt;next = newCell;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>开放定址法: 当冲突发生时,尝试选择另外的单元,知道找出空的单元为止</p><ul><li>考虑单元 $h_0(X),h_1(X),h_2(X), \cdots,$相继试选.其中 $h_i(X) &#x3D; (hash(x)+F(i))\mod \mathrm{tableSize}$</li><li>函数 $F$ 是冲突解决方法,且 $F(0) &#x3D; 0$ </li><li>开放地址法需要将所有数据置于表内,因此散列表较大.但省去了给新单元分配地址的时间</li></ul></li></ol><h3 id="3-3-再散列"><a href="#3-3-再散列" class="headerlink" title="3.3 再散列"></a>3.3 再散列</h3><ol><li><p><strong>再散列</strong>(rehashing): 对于开放定址法,如果表的元素太满,则操作时间消耗增长,且插入可能失败.此时可以建立另外一个约两倍大的表(同时使用一个相关的新散列函数),扫描整个原始散列表,计算每个元素的新散列值并将其插入到新表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">hashTable <span class="hljs-title function_">rehash</span><span class="hljs-params">(hashTable h)</span> &#123;<br>    <span class="hljs-type">int</span> i, oldSize;<br>    cell *oldCell;<br>    oldCells = h-&gt;theCells;<br>    oldSize = h-&gt;tableSize;<br>    h = initializeTable(<span class="hljs-number">2</span> * oldSize);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; oldSize; i++) &#123;<br>        <span class="hljs-keyword">if</span>(oldCells[i].info == legitimate)<br>            insert(oldCells[i].element, h);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(oldCells);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-优先队列"><a href="#4-优先队列" class="headerlink" title="4 优先队列"></a>4 优先队列</h2><h3 id="4-1-优先队列"><a href="#4-1-优先队列" class="headerlink" title="4.1 优先队列"></a>4.1 优先队列</h3><ol><li><strong>优先队列</strong>(priority queue): 是允许至少插入(入队)和删除最小(出队:找出,返回,删除优先队列中的最小元素)的数据结构</li><li>优先队列的简单实现方式<ul><li>使用简单链表: 在表头进行插入$O(1)$,遍历链表以实现删除最小元$O(n)$</li><li>始终让表保持排序状态: 进行顺序插入$O(n)$和删除操作$O(1)$</li><li>二叉查找树: 对插入和删除操作均为 $O(\log n)$</li></ul></li></ol><h3 id="4-2-二叉堆"><a href="#4-2-二叉堆" class="headerlink" title="4.2 二叉堆"></a>4.2 二叉堆</h3><ol><li><p>二叉堆(binary heap) 具有两个性质: 结构性和堆序性.因此堆的操作需要堆的所有性质都被满足才终止</p></li><li><p>结构性质: <strong>堆</strong>(heap): 一颗被完全填满的二叉树(完全二叉树, complete binary tree),底层可以例外(从左到右填入)</p><ul><li>高为 h 的完全二叉树节点数为: $[2^h, 2^{h+1})$.因而完全二叉树的高是 $\lfloor \log N \rfloor$</li><li>完全二叉树可以用数组进行表示,而不需要指针</li><li>考虑位置为 i 的元素,其左子节点位于 2i,右子节点位于左子节点后的 2i+1,父节点位于 $\lfloor i&#x2F;2 \rfloor$ </li><li>堆数据结构将由 一个数组(无论关键为什么类型),一个代表最大值的整数,当前堆大小的整数 组成</li></ul></li><li><p>堆序性质: 使操作快速执行</p><ul><li>考虑需要找出最小元,因此最小元应该在根上</li><li>将任意子树也视为一个堆,则任意节点应小于其所有后裔</li><li><strong>堆序性质</strong>: 在一个堆中,对于任意节点 X, X父节点的关键字小于X的关键字(根节点除外)</li></ul></li><li><p>优先队列的声明(<code>binaryHeap.h</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BIN_HEAP_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIN_HEAP_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapStruct</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapStruct</span> *<span class="hljs-title">priorityQueue</span>;</span><br><br>priorityQueue <span class="hljs-title function_">initialize</span><span class="hljs-params">(<span class="hljs-type">int</span> maxElements)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, priorityQueue h)</span>;<br>elementType <span class="hljs-title function_">deleteMin</span><span class="hljs-params">(priorityQueue h)</span>;<br>elementType <span class="hljs-title function_">findMin</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">(priorityQueue h)</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapStruct</span> &#123;</span><br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> size;<br>    elementType *elements;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>优先队列的操作(<code>binaryHeap.c</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">priorityQueue <span class="hljs-title function_">initialize</span><span class="hljs-params">(<span class="hljs-type">int</span> maxElements)</span> &#123;<br>    priorityQueue h;<br>    <span class="hljs-keyword">if</span>( maxElements &lt; minPQSize )<br>        error(<span class="hljs-string">&quot;Priority queue size is too small&quot;</span>);<br>    h = <span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>( <span class="hljs-keyword">struct</span> heapStruct ) );<br>    <span class="hljs-keyword">if</span>(h == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    h-&gt;elements = <span class="hljs-built_in">malloc</span>( ( maxElements + <span class="hljs-number">1</span> ) * <span class="hljs-keyword">sizeof</span>(elementsType) );<br>    <span class="hljs-keyword">if</span>( h-&gt;elements == <span class="hljs-literal">NULL</span> )<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    h-&gt;capacity = maxElements;<br>    h-&gt;size = <span class="hljs-number">0</span>;<br>    h-&gt;elements[<span class="hljs-number">0</span>] = minData;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, priorityQueue h)</span> &#123;<br>    <span class="hljs-keyword">if</span>(isFull(h)) &#123;<br>        error(<span class="hljs-string">&quot;Priority queue is full&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = ++h-&gt;size; h-&gt;elements[ i / <span class="hljs-number">2</span> ] &gt; x; i /= <span class="hljs-number">2</span>)<br>        h-&gt;elements[ i ] = h-&gt;elements[ i / <span class="hljs-number">2</span> ];<br>    h-&gt;elements[i] = x;<br>&#125;<br><br>elementType <span class="hljs-title function_">deleteMin</span><span class="hljs-params">(priorityQueue h)</span> &#123;<br>    <span class="hljs-type">int</span> child;<br>    elementType minElement, lastElement;<br>    <span class="hljs-keyword">if</span>( isEmpty(h) ) &#123;<br>        error(<span class="hljs-string">&quot;Priority queue is full&quot;</span>);<br>        <span class="hljs-keyword">return</span> h-&gt;elements[<span class="hljs-number">0</span>];<br>    &#125;<br>    minElement = h-&gt;elements[<span class="hljs-number">1</span>];<br>    lastElement = h-&gt;elements[h-&gt;size--];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i * <span class="hljs-number">2</span> &lt;=  h-&gt;size; i = child) &#123;<br>        child = i * <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(child != h-&gt;size &amp;&amp; h-&gt;elements[child+<span class="hljs-number">1</span>] &lt; h-&gt;elements[child])<br>            child++;<br>        <span class="hljs-keyword">if</span>(lastElement &gt; h-&gt;elements[child])<br>            h-&gt;elements[i] = h-&gt;elements[child];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    h-&gt;elements[i] = lastElement;<br>    <span class="hljs-keyword">return</span> minElement;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-排序"><a href="#5-排序" class="headerlink" title="5 排序"></a>5 排序</h2><ol><li>排序算法接受的参数为: 数组首地址, 及一个表示数组元素个数的整数</li><li>基于比较的排序: 假定对于元素而言,运算符 <code>&lt;, &gt;</code> 是存在的</li><li>逆序(inversion): 与线性代数中的关于排列的逆序数定义类似<ul><li>n 个互异数的数组的平均逆序数为 $\frac{n(n-1)}4$</li><li>通过交换相邻元素进行排序的任何算法平均需要 $\Omega(N^2)$</li><li>排序算法通过删除逆序进行,为了有效运行,必须每次删除不止一个逆序</li></ul></li><li>间接排序(indirect sorting): 由于交换结构的操作是昂贵的,因而可以创建数组(其元素为指向结构的指针).通过比较指针指向的关键字,并在必要时交换指针来进行排序</li><li>排序的一般下界<ul><li>任何只用到比较的算法在最坏的情况下需要 $\Omega(N\log N)$ 次比较,因而归并排序和堆排序最优</li><li>任何只用到比较的算法在平均的情况下需要 $\Omega(N\log N)$ 次比较,因而快速排序是最优的</li></ul></li></ol><h3 id="5-1-插入排序"><a href="#5-1-插入排序" class="headerlink" title="5.1 插入排序"></a>5.1 插入排序</h3><ol><li><p>插入排序(insert sort)</p><ul><li><p>将数组假想为两部分: 前面的为已排序数组,后面的为待排序数组</p></li><li><p>初始状态为已排序数组只有第一个元素,剩余为待排序数组</p></li><li><p>遍历待排序数组,将每个未排序元素插入到已排序数组中恰当的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    elementType tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>; p &lt; n; ++p) &#123;<br>        tmp = arr[p];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = p; j&gt;<span class="hljs-number">0</span> &amp;&amp; arr[j<span class="hljs-number">-1</span>] &gt; tmp; --j)<br>            arr[j] = arr[j<span class="hljs-number">-1</span>];<br>        arr[j] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>时间复杂度: $O(N^2)$</p><ul><li>当输入数据为逆序时,达到此上界</li><li>当输入数据已排序时,运行时间为 $O(N)$</li><li>对于几乎已经排序的数据(逆序数 I 较小),插入排序很快,其时间为 $O(I+N)$</li></ul></li></ol><h3 id="5-2-希尔排序"><a href="#5-2-希尔排序" class="headerlink" title="5.2 希尔排序"></a>5.2 希尔排序</h3><ol><li><p>希尔排序(缩小增量排序, diminishing increment sort): 先将整个待排序的序列分割为若干子序列分别进行直接插入排序,待整个序列中的记录基本有序时,在对全体进行直接插入排序</p><ul><li><p>增量序列: $h_1, h_2, \dots,h_t$,其中 $h_1 &#x3D; 1$</p></li><li><p>$h_k$-排序数组: $\forall i,arr[i] \leq arr[i+h_k]$</p></li><li><p>希尔增量通常取 $h_t &#x3D; \lfloor n&#x2F;2 \rfloor, h_k &#x3D; \lfloor h_{k+1}&#x2F;2 \rfloor$ </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    elementType tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> increment = n/<span class="hljs-number">2</span>; increment &gt; <span class="hljs-number">0</span>; increment /= <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = increment; i &lt; n; ++i) &#123;<br>            tmp = arr[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &gt;= increment; j -= increment)<br>                <span class="hljs-keyword">if</span>(tmp &lt; arr[j - increment])<br>                    a[j] = a[j - increment];<br>            <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">break</span>;<br>                arr[j] = tmp;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>时间复杂度(希尔排序算法简单,但分析极其困难)</p><ul><li>希尔增量下的希尔排序的最坏情形运行时间 $\Theta(N^2)$</li><li>Hibbard 增量: 形如 $1, 3, 7, \dots , 2^k-1$.最坏情形运行时间 $\Theta(N^\frac32)$</li></ul></li></ol><h3 id="5-3-堆排序"><a href="#5-3-堆排序" class="headerlink" title="5.3 堆排序"></a>5.3 堆排序</h3><ol><li><p>堆排序(heap sort): 考虑建立二叉堆 $O(N)$,执行 N 次 <code>deleteMin</code> $O(N\log N)$.按照顺序,最小的元素将会先离开堆,将这些元素记录到第二个数组即可得到排序数组</p></li><li><p>上述算法需要额外的数组空间,可以每次在 <code>deleteMin</code> 操作后,将最后空出来的单元用于存放元素.此时得到的将是逆序的排序数组,因而可以构建具有 <code>deleteMax</code> 操作的二叉堆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> leftChild(i) (2 * (i) + 1)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">percDown</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> child;<br>    <span class="hljs-keyword">for</span>(elementType tmp = arr[i]; leftChild(i) &lt; n; i = child) &#123;<br>        <span class="hljs-keyword">if</span>(child != n - <span class="hljs-number">1</span> &amp;&amp; arr[child + <span class="hljs-number">1</span>] &gt; arr[child])<br>            child++;<br>        <span class="hljs-keyword">if</span>(tmp &lt; a[child])<br>            arr[i] = arr[child];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    arr[i] = tmp;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        percDown(arr, i, n);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>        swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[i]);<br>        percDown(arr, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>堆排序是非常稳定的算法: 平均使用的比较只比最坏情形略少</p></li></ol><h3 id="5-4-归并排序"><a href="#5-4-归并排序" class="headerlink" title="5.4 归并排序"></a>5.4 归并排序</h3><ol><li><p>考虑合并2个已排序的数组: 设定2个指针分别指向数组的起始位置.比较2个指针指向的元素,将较小的元素放入输出数组,并移动指针.重复这一过程,直到某一指针到达末尾</p></li><li><p>归并排序(merge sort): 以分治递归的形式合并已排序数组 $O(N\log N)$.使用的比较次数几乎最优</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mSort</span><span class="hljs-params">(elementType arr[], elementType tmpArr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> center;<br>    <span class="hljs-keyword">if</span>(left &lt; right) &#123;<br>        center = (left + right) / <span class="hljs-number">2</span>;<br>        mSort(arr, tmpArr, left, center);<br>        mSort(arr, tmpArr, center + <span class="hljs-number">1</span>, right);<br>        merge(arr, tmpArr, left, center + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mergeSord</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    elementType *tmpArr = <span class="hljs-built_in">malloc</span>( n * <span class="hljs-keyword">sizeof</span>(elementType) );<br>    <span class="hljs-keyword">if</span>(tmpArr != <span class="hljs-literal">NULL</span>) &#123;<br>        mSort(arr, tmpArr, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">free</span>(tmpArr);<br>    &#125; <span class="hljs-keyword">else</span><br>        fatalError(<span class="hljs-string">&quot;No space for tmp array!&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(elementType arr[], elementType tmpArr[], <span class="hljs-type">int</span> lpos, <span class="hljs-type">int</span> rpos, <span class="hljs-type">int</span> rightEnd)</span> &#123;<br>    <span class="hljs-type">int</span> leftEnd = rpos - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> tmpPos = lpos;<br>    <span class="hljs-type">int</span> numElements = rightEnd - lpos + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(lpos &lt;= leftEnd &amp;&amp; rpos &lt;= rightEnd)<br>        <span class="hljs-keyword">if</span>(arr[lpos] &lt;= arr[rpos])<br>            tmpArr[tmpPos++] = arr[lpos++];<br>    <span class="hljs-keyword">else</span><br>            tmpArr[tmpPos++] = arr[rpos++];<br>    <span class="hljs-keyword">while</span>(lpos &lt;= leftEnd)<br>        tmpArr[tmpPos++] = arr[lpos++];<br>    <span class="hljs-keyword">while</span>(rpos &lt;= rightEnd)<br>        tmpArr[tmpPos++] = arr[rpos++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numElements; ++i, --rightEnd) &#123;<br>        arr[rightEnd] = tmpArr[rightEnd];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-5-快速排序"><a href="#5-5-快速排序" class="headerlink" title="5.5 快速排序"></a>5.5 快速排序</h3><ol><li><p>快速排序(quick sort): 实践中最快的已知排序算法,平均运行时间 $O(N\log N)$</p><ul><li>若 S 中元素个数为 0 或 1,则直接返回</li><li>选取 S 中的任意元素 v,其称为基准(pivot)</li><li>分区并排序: 将 $S-{v}$ 分为两个不相交集合: $S_1 &#x3D;{x\in S-{v}|x\leq v},S_2 &#x3D;{x\in S-{v}|x\geq v} $ </li><li>递归地将小于基准元素的子数列和大于基准值元素的子数组排序</li></ul></li><li><p>选取基准</p><ul><li>错误的方式: 选取第一个元素作为基准.若输入是预排序或反序的,将会产生劣质的分割</li><li>安全的方式: 随机选取基准.但考虑到生成随机数是昂贵的,因而无法减少算法其余部分的平均运行时间</li><li>数中值分割法: 基准的最好选择是数组的中值,但这很难算出.因而可以考虑三个元素(左侧,中心,右侧位置)的中值作为基准.消除了预排序输入的坏情形,并减少约 5% 的时间</li></ul></li><li><p>分割策略</p><ul><li>将基准元与最后的元素进行交换,使得基准元离开要被分割的数据段</li><li>设置双指针 i, j. 初始时刻分别指向数组的第一个元素和倒数第二个元素(因为最后一个元素为基准)</li><li>当 i &lt; j 时,将 i 右移,直到遇到大于基准元的数.同理,将 j 左移,直到遇到小于基准元的数</li><li>若停止后的仍满足 i &lt; j,则将 i, j 指向的两个元素互换.重复该过程,直到 i, j 彼此交错</li><li>当 i, j 交错后,将基准元与 i 所指向的元素互换,即可完成分割</li></ul></li><li><p>对于小数组(n &lt; 20),快速排序不如插入排序好</p><ul><li>由于快速排序是递归的,因此小数组排序的情况经常发生</li><li>对小数组不进行递归排序,而进行插入排序将会节约15%的时间.截至范围可选择 n&#x3D;10</li></ul></li><li><p>快速排序的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    qSort(arr, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>&#125;<br><br>elementType <span class="hljs-title function_">median3</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> center = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(arr[left] &gt; arr[center])<br>        swap(&amp;arr[left], &amp;arr[center]);<br>    <span class="hljs-keyword">if</span>(arr[left] &gt; arr[right])<br>        swap(&amp;arr[left], &amp;arr[right]);<br>    <span class="hljs-keyword">if</span>(arr[center] &gt; arr[right])<br>        swap(&amp;arr[center], &amp;arr[right]);<br>    swap(&amp;arr[center], &amp;arr[right - <span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> arr[right - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">qSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    elementType pivot;<br>    <span class="hljs-keyword">if</span>(left + cutOff &lt;= right) &#123;<br>        pivot = median3(arr, left, right);<br>        <span class="hljs-type">int</span> i = left;<br>        <span class="hljs-type">int</span> j = right - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(;;) &#123;<br>            <span class="hljs-keyword">while</span>(arr[++i] &lt; pivot) &#123;&#125;<br>            <span class="hljs-keyword">while</span>(arr[--j] &lt; pivot) &#123;&#125;<br>            <span class="hljs-keyword">if</span>(i &lt; j)<br>                swap(&amp;arr[i], &amp;arr[j]);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        swap(&amp;arr[i], &amp;arr[right - <span class="hljs-number">1</span>]);<br>        qSort(arr, left, i - <span class="hljs-number">1</span>);<br>        qSort(arr, i + <span class="hljs-number">1</span>, right);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        insertSort(arr + left, right - left + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-图论算法"><a href="#6-图论算法" class="headerlink" title="6 图论算法"></a>6 图论算法</h2><h3 id="6-1-图的定义"><a href="#6-1-图的定义" class="headerlink" title="6.1 图的定义"></a>6.1 图的定义</h3><ol><li>图(graph): 由顶点(vertex)的集合 V,边(edge)的集合 E 组成<ul><li>每条边都是点对(v, w), 其中 $v,w\in V$</li><li>若点对是有序的,则图是有向(directed)的,称为有向图(digraph)</li><li>顶点 v, w 邻接等价于当 $(v,w)\in E$</li><li>边可以有第三种成分: 权(weight) 或 值(cost)</li></ul></li><li>图中的路径(path)<ul><li>路径是顶点序列: $w_1, w_2, \dots, w_N \space\space \mathrm{s.t.}(w_i,w_{i+1})\in E,1\leq i&lt;E$ </li><li>路径的长(length): 边的数量,即 N-1</li><li>环(loop): 从一个顶点到自身的边</li><li>简单路径: 所有的顶点都互异,但第一个和最后一个顶点可以相同</li></ul></li><li>图中的圈(cycle)<ul><li>有向图中的圈: 满足 $w_1 &#x3D; w_N$ 且长至少为1的一条路径</li><li>无向图中的圈则额外要求边是互异的</li></ul></li><li>连通(connected)<ul><li>在无向图中从每一个顶点到每个其他顶点都存在一条路径</li><li>在有向图中,这种性质称为强连通(strongly connected)</li><li>若有向图不是强连通的,但其基础图(underlying graph, 即去掉弧的方向)是连通的,则称为弱连通(weakly connected)</li><li>完全图(complete graph): 每个顶点间都存在一条边</li></ul></li><li>图的表示(有向图)<ul><li>使用一个二维数组,即**邻接矩阵(adjacent matrix)**表示<ul><li>对于每条边(u, v),置 <code>A[u][v] = 1</code>.其他元素为0</li><li>若该边有一个权,则可置 <code>A[u][v]</code> 等于该权.使用很大&#x2F;小的数表示不存在的边</li><li>若图是稀疏的(sparse), 该方法所需求的空间 $\Theta(|V|^2)$ 过大了</li></ul></li><li><strong>邻接表(adjacent list)</strong>: 对每一个顶点,使用一个表存放所有的邻接点<ul><li>空间需求为 $O(|E|+|V|)$</li><li>邻接表是图的标准表示方法</li></ul></li><li>考虑到实际中顶点都有名字,因此需要使用散列表建立名字到数字的映射<ul><li>散列表中对每个顶点存储一个名字和一个内部编号( 1 ~ |V| 之间)</li></ul></li></ul></li></ol><h3 id="6-2-最短路径算法"><a href="#6-2-最短路径算法" class="headerlink" title="6.2 最短路径算法"></a>6.2 最短路径算法</h3><ol><li><p>输入一个赋权图: 与每条边 $(v_i, v_j)$ 联系的是穿越该弧的代价 $c_{i,j}$</p><ul><li>赋权路径长(weighted path length): $v_1v_2\dots v_N$ 路径的值为 $\sum\limits^{N-1}<em>{i&#x3D;1}c</em>{i,j}$</li></ul></li><li><p>单源最短路径问题: 给定赋权图 $G&#x3D;(V,E)$ 和特定顶点 s 作为输入,找出 s 到 G 每个点的最短赋权路径</p></li><li><p>无权最短路径</p><ul><li><p>广度优先搜索(breadth-first search): 按层处理顶点,距离最近的先辈赋值,最远的最后赋值</p></li><li><p>显然顶点s到自身距离为0,然后考察与s邻接的点,其距离为1.然后考察邻接的邻接,直到完成所有点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unWeigted</span><span class="hljs-params">(table t)</span> &#123;<br>    vertex v, w;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> currDist = <span class="hljs-number">0</span>; currDist &lt; numVetex; ++currDist)<br>        <span class="hljs-keyword">for</span> each vertex v<br>            <span class="hljs-title function_">if</span><span class="hljs-params">(!t[v].known &amp;&amp; t[v].dist == currDist)</span> &#123;<br>                t[v].known = True;<br>                <span class="hljs-keyword">for</span> each w adjacent to v<br>                    <span class="hljs-title function_">if</span><span class="hljs-params">(t[w].dist == infinity)</span> &#123;<br>                        t[w].dist = currDist + <span class="hljs-number">1</span>;<br>                        t[w].path = v;<br>                    &#125;<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Dijkstra 算法: 考虑赋权图的单源最短路径问题.仍借鉴无权时的思路</p><ul><li>顶点 s 到自身的距离为0,将其标记为已知,因为此时多了一个已知点,则可以获得其到达邻接点的距离</li><li>选取距离最小的点(贪心法,greedy algorithm)标记为已知,则有可以更新其到达邻接点的距离</li><li>重复该过程,直到获得到达目标点的最短距离</li><li>对于没有负值边的图,该算法总能完成.一旦出现负值边,则可能出现错误的答案</li></ul></li></ol><h2 id="7-算法设计技巧"><a href="#7-算法设计技巧" class="headerlink" title="7 算法设计技巧"></a>7 算法设计技巧</h2><h3 id="7-1-贪婪算法"><a href="#7-1-贪婪算法" class="headerlink" title="7.1 贪婪算法"></a>7.1 贪婪算法</h3><ol><li>贪婪算法分阶段工作.在每一个阶段,认为所作的决定是最好的,而不考虑将来的后果(即局部最优)<ul><li>当算法终止时,若局部最优就是全局最优,则算法正确.否则将得到一个次优解(suboptimal solution)</li><li>若不要求绝对最佳答案,也可通过简单的贪婪算法生成近似答案</li></ul></li><li>Huffman 编码<ul><li>ASCII 编码有约100个可打印字符和控制字符组成,需要 $\lceil \log 128\rceil&#x3D;7$ 位表示,可添加第8位作为校验位<ul><li>现实中,许多文件都含有大量的数字,空格和换行,而 q, x 很少</li><li>采用非等长编码,使经常出现的字符代码较短,可以节约磁盘空间</li></ul></li><li>对于代表字符的二进制代码,可以用二叉树来表示<ul><li>只在树叶上有数据.且每个字符从根节点开始,用0指示向左分支,用1指示向右分支</li><li>若字符 $c_i$ 在深度 $d_i$ 处,且出现 $f_i$ 次.则该字符代码的值(cost)为 $\sum d_i f_i$</li></ul></li></ul></li><li>Huffman 算法<ul><li>假设字符数量为 C.算法开始时存在 C 棵单节点树(每个字符一颗)</li><li>任意选取有最小权(树的权等于其树叶频率的和)的两棵树,任意形成以这两棵树为子树的新树</li><li>将这样的过程进行 C-1 次.即可得到最优 Huffman 编码树</li></ul></li></ol><h3 id="7-2-分治算法"><a href="#7-2-分治算法" class="headerlink" title="7.2 分治算法"></a>7.2 分治算法</h3><ol><li>分治(divide and conquer)算法<ul><li>分: 递归解决较小的问题(基本情况除外)</li><li>治: 从子问题的解 构建原问题的解</li></ul></li><li>最近点问题: 找出平面上点列中最近(欧几里得距离)的一对点<ul><li>暴力算法: 计算每个点对之间的距离,找出最小值 $O(N^2)$</li><li>分治算法思路<ul><li>将平面上的点分为两半,最近点对存在三种可能: 均在左, 均在右, 一个在左一个在右</li><li>记不同情况的最近点对的最小距离为: 左侧点集 $d_l$,右侧点集 $d_r$,两侧点间的距离 $d_c$</li><li>对于 $d_l, d_r$,可以递归的进行计算.关键在于如何计算 $d_c$</li></ul></li><li>$d_c$ 的计算<ul><li>令 $\delta &#x3D; \min(d_l, d_r)$.如果 $d_c$ 对 $\delta$ 有改进,则只需计算 $d_c$</li><li>若 $d_c$ 是这样的距离,则定义 $d_c$ 的两个点必然在分割线的 $\delta$ 邻域内(一个带状区域).限制考察点的数量</li><li>对于均匀分布的点集,则平均有 $O(\sqrt N)$ 个点位于邻域内,此时可采用暴力求解 $O(N)$</li></ul></li></ul></li><li>选择问题: 找出含有 N 个元素的表 S 中的第 k 个最小的元素(对于中位数 $k &#x3D; \lceil N&#x2F;2 \rceil$ 特别关注)<ul><li>通过对元素的快速排序,此问题以 $O(N\log N)$ 的最坏情形时间解决</li><li>五分化中项的中项 选择快速排序的基准<ul><li>将 N 个元素分为 $\lfloor N&#x2F;5 \rfloor$ 组,每5个元素一组,最多忽略4个元素</li><li>找出每组的中项,得到 $\lfloor N&#x2F;5 \rfloor$ 个中项的表 M,找出 M 的中项并返回</li></ul></li><li>使用五分化中项的中项的快速选择算法的运行时间为 $O(N)$.但实践中该算法并不实用</li></ul></li></ol><h3 id="7-3-动态规划"><a href="#7-3-动态规划" class="headerlink" title="7.3 动态规划"></a>7.3 动态规划</h3><ol><li><p>动态规划(dynamic programming)</p><ul><li>数学递归公式均可直接翻译为递归算法,但现实中编译器往往不发正确对待递归算法,而导致低效</li><li>当这种情况发生时,便需要给编译器提供帮助.改写为非递归的算法,并将子问题的答案记录在一个表内</li></ul></li><li><p>使用表代替递归</p><ul><li><p>计算 Fibonacci 数的自然递归效率非常低,是指数级别的</p></li><li><p>使用一个表将中间的计算结果存储起来,则可避免大量的冗余计算,下面计算 $c_n &#x3D; \frac2n\sum\limits_{i&#x3D;0}^{n-1}c_i+n,\space c_0 &#x3D; 1$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">double</span> *c = <span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>( <span class="hljs-type">double</span> ) * ( n + <span class="hljs-number">1</span> ) );<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    c[<span class="hljs-number">0</span>] = <span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j)<br>            sum += c[j];<br>        c[i] = <span class="hljs-number">2.0</span> * sum / i + i;<br>    &#125;<br>    <span class="hljs-type">int</span> answer = c[n];<br>    <span class="hljs-built_in">free</span>(c);<br>    <span class="hljs-keyword">return</span> answer;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 编程快速上手—让繁琐工作自动化</title>
    <link href="/2024/10/30/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E2%80%94%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E2%80%94%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <url>/2024/10/30/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E2%80%94%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E2%80%94%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-编程快速上手—让繁琐工作自动化"><a href="#Python-编程快速上手—让繁琐工作自动化" class="headerlink" title="Python 编程快速上手—让繁琐工作自动化"></a>Python 编程快速上手—让繁琐工作自动化</h1><h2 id="0-口令保管箱"><a href="#0-口令保管箱" class="headerlink" title="0 口令保管箱"></a>0 口令保管箱</h2><h3 id="0-1-pyperclip-模块"><a href="#0-1-pyperclip-模块" class="headerlink" title="0.1 pyperclip 模块"></a>0.1 pyperclip 模块</h3><ol><li><p><code>pyperclip</code> 模块是第三方模块.可以向计算机的剪贴板发送 &#x2F; 接收文本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pyperclip<br>pyperclip.copy(<span class="hljs-string">&quot;Hello,world!&quot;</span>)  <span class="hljs-comment"># 将剪贴板的内容设为 &quot;Hello,world!&quot;</span><br><span class="hljs-built_in">print</span>(pyperclip.paste())  <span class="hljs-comment"># 获取打印剪贴板内容</span><br></code></pre></td></tr></table></figure></li><li><p>注意在 Windows 中, <code>pyperclip</code> 无需依赖其他包.但 ubuntu 中需要</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install xsel<br>sudo apt-get install xclip<br></code></pre></td></tr></table></figure></li></ol><h3 id="0-2-口令保管箱"><a href="#0-2-口令保管箱" class="headerlink" title="0.2 口令保管箱"></a>0.2 口令保管箱</h3><ol><li><p>数据结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">PASSWORDS = &#123;<span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;euyr8wuey89r3geidw&quot;</span>,<br>             <span class="hljs-string">&quot;blog&quot;</span>: <span class="hljs-string">&quot;wqeiy2398eghduk&quot;</span>,<br>             <span class="hljs-string">&quot;computer&quot;</span>: <span class="hljs-string">&quot;ewkwo][ke;w&quot;</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p>复制口令: 将命令行参数作为 <code>key</code> 获取对应的 <code>value</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys, pyperclip<br><br>account = sys.argv[<span class="hljs-number">1</span>]  <span class="hljs-comment"># sys.argv[0] 是脚本名.所以获取索引为 1 的参数</span><br><span class="hljs-keyword">if</span> account <span class="hljs-keyword">in</span> PASSWORDS:<br>    pyperclip.copy(PASSWORDS[account])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The password for &quot;</span> + account + <span class="hljs-string">&quot; copied to clipboard!&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;There is no account named &quot;</span> + account)<br></code></pre></td></tr></table></figure></li><li><p>演示效果: 在终端中执行 <code>python3 文件名 命令行参数</code></p><p><img src="/2024/10/30/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E2%80%94%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E2%80%94%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/assets/%E5%8F%A3%E4%BB%A4%E4%BF%9D%E7%AE%A1%E7%AE%B1.png"></p></li></ol><h2 id="1-正则表达式"><a href="#1-正则表达式" class="headerlink" title="1 正则表达式"></a>1 正则表达式</h2><h3 id="1-1-正则表达式"><a href="#1-1-正则表达式" class="headerlink" title="1.1 正则表达式"></a>1.1 正则表达式</h3><ol><li><p>**正则表达式(Regular Expression)**是一种文本模式</p><ul><li>包括普通字符(例如,a 到 z 之间的字母)和特殊字符(称为”元字符”)</li><li>可以用来描述和匹配字符串的特定模式</li><li>用于模式匹配和搜索文本的工具</li><li>用于查找, 替换, 验证和提取文本数据</li></ul></li><li><p>构造正则表达式的方法和创建数学表达式的方法一样</p><ul><li>用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式</li><li>组件可以是单个的字符, 字符集合, 字符范围, 字符间的选择或者所有这些组件的任意组合</li></ul></li><li><p>正则表达式的模式</p><ul><li>字面值字符: 例如字母, 数字, 空格等.可以直接匹配它们自身</li><li>特殊字符: 例如点号<code>.</code> 星号<code>*</code>  加号<code>+</code>  问号<code>?</code> 等.它们具有特殊的含义和功能</li><li>字符类: 用方括号 <code>[]</code> 包围的字符集合,用于匹配方括号内的任意一个字符</li><li>元字符: 例如 <code>\d, \w, \s</code> 等,用于匹配特定类型的字符,如数字, 字母, 空白字符等</li><li>量词: 例如 <code>&#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;</code> 等,用于指定匹配的次数或范围</li><li>边界符号: 例如 <code>^, $, \b, \B</code> 等,用于匹配字符串的开头, 结尾或单词边界位置</li></ul></li><li><p>示例</p><ul><li><p>考虑需求: 要求字符串只能使用 字母, 数字, 下划线.且长度为 3 ~ 15</p></li><li><p>正则表达式可设定为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">^[a-zA-Z0-9_-]&#123;<span class="hljs-number">3</span>,<span class="hljs-number">15</span>&#125;$<br></code></pre></td></tr></table></figure></li><li><p><code>^</code>: 表示匹配字符串的开头</p></li><li><p><code>[a-zA-Z0-9_-]</code>: 表示匹配字符集.包含 <code>a ~ z, A ~ Z, 0 ~ 9, _, -</code></p></li><li><p><code>&#123;3, 15&#125;</code>: 表示字符集最少出现3次,最多出现15次</p></li><li><p><code>$</code>: 表示匹配字符串的结尾</p></li></ul></li></ol><h3 id="1-2-字符"><a href="#1-2-字符" class="headerlink" title="1.2 字符"></a>1.2 字符</h3><ol><li><p>普通字符: 包括没有显式指定为元字符的所有可打印和不可打印字符</p></li><li><p>非打印字符: 也可以是正则表达式的组成部分</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\cx</td><td align="left">匹配由 x 指明的控制字符.x 的值必须为 A-Z 或 a-z 之一<br />否则,将 c 视为一个原义的 ‘c’ 字符</td></tr><tr><td align="left">\f</td><td align="left">匹配一个换页符.等价于 <code>\x0c</code> 和 <code>\cL</code></td></tr><tr><td align="left">\n</td><td align="left">匹配一个换行符.等价于 <code>\x0a</code> 和 <code>\cJ</code></td></tr><tr><td align="left">\r</td><td align="left">匹配一个回车符.等价于 <code>\x0d</code> 和 <code>\cM</code></td></tr><tr><td align="left">\s</td><td align="left">匹配任何空白字符.包括空格, 制表符, 换页符等.等价于 <code>[ \f\n\r\t\v]</code></td></tr><tr><td align="left">\S</td><td align="left">匹配任何非空白字符.等价于 <code>[^ \f\n\r\t\v]</code></td></tr><tr><td align="left">\t</td><td align="left">匹配一个制表符.等价于 <code>\x09</code> 和 <code>\cI</code></td></tr><tr><td align="left">\v</td><td align="left">匹配一个垂直制表符.等价于 <code>\x0b</code> 和 <code>\cK</code></td></tr></tbody></table></li><li><p>特殊字符(注意特殊字符想要匹配自身,需要加上 <code>\</code> 进行转义)</p><table><thead><tr><th align="left">特殊字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">$</td><td align="left">匹配输入字符串的结尾位置<br />如果设置了 RegExp 对象的 Multiline 属性,则 <code>$</code> 也匹配 ‘\n’ 或 ‘\r’</td></tr><tr><td align="left">()</td><td align="left">标记一个子表达式的开始和结束位置</td></tr><tr><td align="left">*</td><td align="left">匹配前面的子表达式 0 或 1 或 多次</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式 1 或 多次</td></tr><tr><td align="left">.</td><td align="left">匹配除换行符 \n 之外的任何单字符</td></tr><tr><td align="left">[</td><td align="left">标记一个中括号表达式的开始.可用于字符集</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式 0 或 1 次.或非贪婪限定符</td></tr><tr><td align="left">\</td><td align="left">将下一个字符标记为 特殊字符, 或原义字符, 或向后引用, 或八进制转义符</td></tr><tr><td align="left">^</td><td align="left">不在方括号中表示: 匹配输入字符串的开始位置<br />在方括号中时表示: 不接受该方括号表达式中的字符集合</td></tr><tr><td align="left">{</td><td align="left">标记限定符表达式的开始</td></tr><tr><td align="left">|</td><td align="left">指明两项之间的一个选择</td></tr></tbody></table></li><li><p>限定符: 指定正则表达式的一个给定组件必须要出现多少次才能满足匹配</p><ul><li><code>*</code>: 0次 或 1次 或 多次</li><li><code>+</code>: 1次 或 多次</li><li><code>?</code>: 0次 或 1次</li><li><code>&#123;n&#125;</code>: 恰好 n 次</li><li><code>&#123;n,&#125;</code>: 至少 n 次</li><li><code>&#123;n,m&#125;</code>: 至少 n 次且不超过 m 次</li><li>注意 <code>*, +</code> 都是贪婪的,它们会尽可能多的匹配符号.加上 <code>?</code> 即为非贪婪的</li></ul></li><li><p>定位符: 用来描述字符串或单词的边界(限定符与定位符不能一起使用)</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配输入字符串开始的位置</td></tr><tr><td>$</td><td>匹配输入字符串结尾的位置</td></tr><tr><td>\b</td><td>匹配一个单词边界.即字与空格间的位置</td></tr><tr><td>\B</td><td>非单词边界匹配</td></tr></tbody></table></li><li><p>选择</p><ul><li>圆括号 <code>()</code> 将所有选择项括起来,相邻的选择项之间用 <code>|</code> 分隔</li><li>如 <code>([1-9])([a-z]+)</code> 表示: 匹配以一个数字开头,多个字母结尾</li></ul></li><li><p>修饰符</p><ul><li><p>正则表达式的标记(修饰符)用于指定额外的匹配策略</p></li><li><p>标记不写在正则表达式里(位于表达式之外).格式为: <code>/pattern/flags</code></p><table><thead><tr><th align="left">修饰符</th><th align="left">含义</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">i</td><td align="left">ignore - 不区分大小写</td><td align="left">搜索时不区分大小写: A 和 a 没有区别</td></tr><tr><td align="left">g</td><td align="left">global - 全局匹配</td><td align="left">查找所有的匹配项</td></tr><tr><td align="left">m</td><td align="left">multi line - 多行匹配</td><td align="left">使边界字符 <code>^</code> 和 <code>$</code> 匹配每一行的开头和结尾</td></tr><tr><td align="left">s</td><td align="left">使 <code>.</code>  可以匹配 <code>\n</code></td><td align="left">默认情况下 <code>.</code> 匹配除 <code>\n</code> 之外的任何字符</td></tr></tbody></table></li></ul></li></ol><h3 id="1-3-re-模块"><a href="#1-3-re-模块" class="headerlink" title="1.3 re 模块"></a>1.3 re 模块</h3><ol><li><p><strong>re.match 方法</strong>: 从字符串的起始位置匹配一个模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">re.<span class="hljs-keyword">match</span>(pattern, string, flags=<span class="hljs-number">0</span>)<br><span class="hljs-comment"># pattern: 正则表达式的字符串形式</span><br><span class="hljs-comment"># string: 待匹配的字符串</span><br><span class="hljs-comment"># flags: 匹配模式,用于控制正则表达式的匹配方式</span><br><span class="hljs-comment"># 匹配成功时 re.match 方法返回一个匹配的对象,否则返回 None</span><br><br><span class="hljs-comment"># 示例</span><br><span class="hljs-keyword">import</span> re<br>re.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;www&#x27;</span>, <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>)  <span class="hljs-comment"># 在起始位置匹配.可以成功匹配</span><br></code></pre></td></tr></table></figure><ul><li><p>修饰符</p><table><thead><tr><th align="left">修饰符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">re.I</td><td align="left">使匹配对大小写不敏感</td></tr><tr><td align="left">re.L</td><td align="left">做本地化识别(locale-aware)匹配</td></tr><tr><td align="left">re.M</td><td align="left">多行匹配,影响 <code>^</code> 和 <code>$</code></td></tr><tr><td align="left">re.S</td><td align="left">使 <code>.</code> 匹配包括换行在内的所有字符</td></tr><tr><td align="left">re.U</td><td align="left">根据 Unicode 字符集解析字符.这个标志影响 <code>\w, \W, \b, \B</code></td></tr><tr><td align="left">re.X</td><td align="left">该标志通过给予你更灵活的格式,以便你将正则表达式写得更易于理解</td></tr></tbody></table></li><li><p>group 方法: 返回与正则表达式匹配的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">re_obj.group(num=<span class="hljs-number">0</span>)  <span class="hljs-comment"># num 用于指定返回匹配的子组</span><br><span class="hljs-comment"># 默认情况下返回整个匹配的字符串</span><br>re.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;www&#x27;</span>, <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>).group()  <span class="hljs-comment"># 返回 &#x27;www&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>span 方法: 返回匹配值的下标(左闭右开)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">re.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;www&#x27;</span>, <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>).span()  <span class="hljs-comment"># 返回 (0, 3).即下标区间 [0, 3)</span><br>re.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;www&#x27;</span>, <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>).start() <span class="hljs-comment"># 返回 0</span><br>re.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;www&#x27;</span>, <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>).end()   <span class="hljs-comment"># 返回 3</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>re.search 方法</strong>: 扫描整个字符串并返回第一个成功的匹配</p><ul><li>语法与 re.match 相同</li><li>re.match 方法从起始位置开始匹配.不符合则匹配失败,返回 None</li><li>re.search 方法则匹配整个字符串,直到找到一个匹配</li></ul></li><li><p><strong>re.sub 方法</strong>: 替换字符串中的匹配项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">re.sub(pattern, repl, string, count=<span class="hljs-number">0</span>, flags=<span class="hljs-number">0</span>)<br><span class="hljs-comment"># repl: 替换的字符串.也可以是一个函数,对匹配的结果进行处理后替换</span><br><span class="hljs-comment"># count: 替换的最大次数.默认 0 表示替换所有</span><br><br><span class="hljs-comment"># 示例: 将数字全部 *2</span><br>s = <span class="hljs-string">&#x27;A23G4HFD567&#x27;</span><br>re.sub(<span class="hljs-string">&#x27;(?P&lt;value&gt;\d+)&#x27;</span>, <span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(x.group(<span class="hljs-string">&#x27;value&#x27;</span>))*<span class="hljs-number">2</span>), s)<br><span class="hljs-comment"># 分析: &#x27;(?P&lt;value&gt;\d+)&#x27; 匹配一个或多个数字,并将匹配的数字序列命名为 value</span><br><span class="hljs-comment"># repl 参数为一个匿名函数.它的参数 x 为匹配返回的结果.有 group, span 方法</span><br><span class="hljs-comment"># x.group(&#x27;value&#x27;) 将会取出匹配结果 value.形式上为字符串,因此需要进行转换</span><br></code></pre></td></tr></table></figure></li><li><p><strong>re.compile 方法</strong>: 编译正则表达式,生成 Pattern 对象.供 match 和 search 使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">re.<span class="hljs-built_in">compile</span>(pattern[, flags])<br><br><span class="hljs-comment"># 示例: 查找限定范围内的所有数字,并返回 match 对象</span><br>pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;\d+&#x27;</span>)  <span class="hljs-comment"># 用于匹配至少一个数字</span><br>m = pattern.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;one12twothree34four&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>) <span class="hljs-comment"># 指定匹配的起始位置,并返回 match 对象</span><br><br><span class="hljs-comment"># findall 方法</span><br><span class="hljs-comment"># 在字符串中找到正则表达式所匹配的所有子串,并返回一个列表</span><br><span class="hljs-comment"># 如果有分组,则返回元组的列表.如果没有找到匹配的,则返回空列表</span><br>findall(string[, pos[, endpos]])<br><span class="hljs-comment"># pos: 默认为0,指定起始位置</span><br><span class="hljs-comment"># endpos: 默认为字符串的长度,指定结束位置</span><br><br><span class="hljs-comment"># 示例: 查找限定范围内的所有数字,并返回列表</span><br>pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;\d+&#x27;</span>)  <span class="hljs-comment"># 查找数字</span><br>result2 = pattern.findall(<span class="hljs-string">&#x27;run88oob123google456&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>)  <span class="hljs-comment"># [&#x27;88&#x27;, &#x27;12&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>re.finditer</strong> 方法: 和 findall 类似,在字符串中找到正则表达式所匹配的所有子串,作为一个迭代器返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">re.finditer(pattern, string, flags=<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 示例: 查找所有的数字,并作为列表返回</span><br>it = re.finditer(<span class="hljs-string">r&quot;\d+&quot;</span>,<span class="hljs-string">&quot;12a32bc43jf3&quot;</span>) <br><span class="hljs-keyword">for</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">in</span> it:<br>    <span class="hljs-built_in">print</span> (<span class="hljs-keyword">match</span>.group())<br></code></pre></td></tr></table></figure></li><li><p><strong>re.split</strong> 方法: 按照能够匹配的子串将字符串分割后返回列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">re.split(pattern, string[, maxsplit=<span class="hljs-number">0</span>, flags=<span class="hljs-number">0</span>])<br><span class="hljs-comment"># maxsplit: 分隔次数.默认为 0,不限制次数</span><br></code></pre></td></tr></table></figure></li><li><p>正则表达式对象</p><ul><li><p>re.RegexObject 对象: 由 re.compile() 方法返回</p></li><li><p>可使用的方法: <code>match, search, findall</code></p></li><li><p>re.MatchObject 对象: 由 re.match(), re.search() 方法返回</p></li><li><p>可使用的方法: <code>group, groups, start, end, span</code></p></li></ul></li><li><p>模式(大写字母与小写字母的作用相反)</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>(re)</td><td>对正则表达式分组并记住匹配的文本</td></tr><tr><td>(?imx: re)</td><td>包含三种可选标志: i, m, 或 x(只影响括号中的区域)</td></tr><tr><td>(?-imx: re)</td><td>关闭 i, m, 或 x 可选标志(只影响括号中的区域)</td></tr><tr><td>\w</td><td>字母数字及下划线</td></tr><tr><td>\s</td><td>匹配任意空白字符.等价于 <code>[ \t\n\r\f]</code></td></tr><tr><td>\d</td><td>匹配任意数字.等价于 <code>[0-9]</code></td></tr><tr><td>\1…\9</td><td>匹配第n个分组的内容</td></tr></tbody></table></li></ol><h3 id="1-4-输入验证"><a href="#1-4-输入验证" class="headerlink" title="1.4 输入验证"></a>1.4 输入验证</h3><ol><li><p><code>PyInputPlus</code> 模块</p><ul><li>这是一个第三方模块.需要先 <code>pip install PyInputPlus</code></li><li>该模块用于验证用户输入.如果输入的数据无效,则提示再次输入</li></ul></li><li><p><code>inputStr()</code>: 与内置的 input 函数类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pyinputplus <span class="hljs-keyword">as</span> pyip<br>result = pyip.inputStr(<span class="hljs-string">&#x27;prompt:&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>数字</p><ul><li><code>inputInt()</code>: 输入整数值,返回整数值</li><li><code>inputFloat()</code>: 输入浮点值,返回浮点值</li><li><code>inputNum()</code>: 输入整数或浮点数,返回 int 或 float</li></ul></li><li><p>菜单选择</p><ul><li><code>inputChoice()</code>: 输入提供的选项之一.以字符串形式返回选定的选项</li><li><code>inputMenu()</code>: 输入提供的选项之一.还显示带有项目符号, 编号或字母选项的小菜单.以字符串形式返回</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">x = pyip.inputChoice([<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>])<br><span class="hljs-comment"># 终端显示: Please select one of: apple, pear</span><br><br>x = pyip.inputMenu([<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>], numbered=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 终端显示小菜单,并且可以输入编号进行选择</span><br><span class="hljs-comment"># Please select one of the following:</span><br><span class="hljs-comment"># 1. apple</span><br><span class="hljs-comment"># 2. pear</span><br></code></pre></td></tr></table></figure><ul><li><code>inputMenu</code> 参数 <code>lettered=True</code>: 编号使用字母表示</li><li><code>inputMenu</code> 参数 <code>caseSensitive=True</code>: 大小写敏感</li></ul></li><li><p>时间</p><ul><li><code>inputDate()</code>: 在格式列表中输入指定格式的日期.返回 <code>datetime.date</code> 对象</li><li><code>inputTime()</code>: 在格式列表中输入指定格式的时间.返回 <code>datetime.time</code> 对象</li><li><code>inputDatetime()</code>: 在格式列表中输入指定格式的日期时间.返回 <code>datetime.datetime</code> 对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = pyip.inputDate()  <span class="hljs-comment"># 输入 2024/06/19.则 x = datetime.date(2024, 6, 19)</span><br>x = pyip.inputDatetime()  <span class="hljs-comment"># 示例 2024/06/19 10:15:08</span><br></code></pre></td></tr></table></figure></li><li><p><code>inputIP()</code>: 输入 IPv4 或 IPv6 地址,以字符串形式返回输入的 IP 地址</p></li><li><p><code>inputPassword</code>: 输入密码.将显示掩码字符而不是实际的字符(需要在控制台运行,而非终端)</p></li></ol><h2 id="2-读写文件"><a href="#2-读写文件" class="headerlink" title="2 读写文件"></a>2 读写文件</h2><h3 id="2-1-文件路径"><a href="#2-1-文件路径" class="headerlink" title="2.1 文件路径"></a>2.1 文件路径</h3><ol><li><p>Windows, OS X, Linux 差异</p><ul><li>在 Windows 中,根文件夹名为 <code>C:\</code>.在 OS X 和 Linux 中,根文件夹名为 <code>/</code></li><li>文件夹名称和文件名在 Windows 和 OS X 上是不区分大小写的.而 Linux 区分</li><li>在 Windows 中,路径使用 <code>\</code> 作为文件夹之间的分隔符.而 OS X 和 Linux 使用 <code>/</code></li></ul></li><li><p>根据使用环境获取路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>os.path.join(<span class="hljs-string">&#x27;usr&#x27;</span>, <span class="hljs-string">&#x27;bin&#x27;</span>, <span class="hljs-string">&#x27;spam&#x27;</span>)  <span class="hljs-comment"># 接收路径上的字符串,返回文件路径</span><br><span class="hljs-comment"># 在 Windows 下,返回 &#x27;usr\\bin\\spam&#x27;</span><br><span class="hljs-comment"># 在 OS X 或 Linux 下,返回 &#x27;usr/bin/spam&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>当前工作目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">os.getcwd()  <span class="hljs-comment"># 获取当前工作目录 &#x27;C:\\Python3.12&#x27;</span><br>os.chdir(<span class="hljs-string">&#x27;C:\\Windows&#x27;</span>)  <span class="hljs-comment"># 指定工作目录.不存在会报错</span><br></code></pre></td></tr></table></figure></li><li><p>相对路径</p><ul><li>使用 <code>.</code> 表示当前目录.使用 <code>..</code> 表示父文件夹</li><li>相对路径的 <code>.\</code> 是可选的.如 <code>.\spam.txt</code> 和 <code>spam.txt</code> 指的是同一个文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">os.path.abspath(<span class="hljs-string">&#x27;.&#x27;</span>)  <span class="hljs-comment"># 该函数将相对路径转化为绝对路径. &#x27;C:\\Python3.12&#x27;</span><br>os.path.isabs(<span class="hljs-string">&#x27;.&#x27;</span>)  <span class="hljs-comment"># 如果参数为绝对路径,则返回 True</span><br>os.path.relpath(<span class="hljs-string">&#x27;C:\\Windows&#x27;</span>, <span class="hljs-string">&#x27;C:\\spam\\eggs&#x27;</span>)  <span class="hljs-comment"># 计算后者到前者的相对路径</span><br>os.path.dirname(path)  <span class="hljs-comment"># 返回 path 中最后一个 \ 前的所有内容</span><br>os.path.basename(path) <span class="hljs-comment"># 返回 path 中最后一个 \ 后的所有内容</span><br>os.path.split()  <span class="hljs-comment"># 将路径名和文件名分割,返回它们的元组</span><br><span class="hljs-built_in">str</span>.split(os.path.sep)  <span class="hljs-comment"># 对路径字符串调用 split 方法可以按路径分隔符分为列表</span><br></code></pre></td></tr></table></figure></li><li><p>文件信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">os.path.getsize(path)  <span class="hljs-comment"># 获取文件字节数 Byte</span><br>os.listdir(path)  <span class="hljs-comment"># 返回文件字符串的列表.可以用来遍历文件</span><br></code></pre></td></tr></table></figure></li><li><p>检查路径有效性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">os.path.exists(path)  <span class="hljs-comment"># 当 path 指向的文件或文件夹存在时,返回 True</span><br>os.path.isfile(path)  <span class="hljs-comment"># 当 path 参数存在时,且为文件,返回 True</span><br>os.path.isdir(path)   <span class="hljs-comment"># 当 path 参数存在时,且为文件夹,返回 True</span><br></code></pre></td></tr></table></figure></li><li><p>目录操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">os.mkdir(path)  <span class="hljs-comment"># 创建空目录</span><br>os.rmdir(path)  <span class="hljs-comment"># 删除空目录</span><br>os.makedirs(path)  <span class="hljs-comment"># 递归创建空目录.自动创建中间目录</span><br>os.removedirs(path)  <span class="hljs-comment"># 递归删除空目录.自动删除中间目录</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-读写文件"><a href="#2-2-读写文件" class="headerlink" title="2.2 读写文件"></a>2.2 读写文件</h3><ol><li><p>Python 读写文件的步骤</p><ul><li>使用 <code>open()</code> 方法,获取 <code>File</code> 对象</li><li>使用 <code>File</code> 对象的 <code>read()</code> 或 <code>write()</code> 方法</li><li>使用 <code>File</code> 对象的 <code>close()</code> 方法,关闭文件</li></ul></li><li><p>打开文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">open</span>(file, mode=<span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-literal">None</span>)  <span class="hljs-comment"># 通常接收的参数,这并非完整语法格式</span><br><span class="hljs-comment"># file: 文件路径(相对或者绝对路径)</span><br><span class="hljs-comment"># mode: 指定文件打开模式.默认只读</span><br><span class="hljs-comment"># encoding: 一般使用 utf8</span><br></code></pre></td></tr></table></figure><ul><li><p><code>open()</code> 方法用于打开一个文件,并返回文件对象.若无法打开,抛出 <code>OSError</code></p></li><li><p>使用 <code>open()</code> 方法一定要保证关闭文件对象,即调用 <code>close()</code> 方法</p></li><li><p>mode 参数常使用的模式</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">t</td><td align="left">文本模式(默认)</td></tr><tr><td align="left">x</td><td align="left">写模式.新建一个文件,如果该文件已存在则会报错</td></tr><tr><td align="left">b</td><td align="left">二进制模式</td></tr><tr><td align="left">+</td><td align="left">打开一个文件进行更新(可读可写)</td></tr><tr><td align="left">r</td><td align="left">只读打开文件(默认).指针置于文件开头</td></tr><tr><td align="left">rb</td><td align="left">只读打开文件(二进制).指针置于文件开头.一般用于非文本文件</td></tr><tr><td align="left">rb+</td><td align="left">读写打开文件(二进制).指针置于文件开头.一般用于非文本文件</td></tr><tr><td align="left">w</td><td align="left">只写打开文件.若不存在,创建新文件.否则打开文件,并从开头编辑</td></tr><tr><td align="left">wb+</td><td align="left">读写打开文件(二进制).若不存在,创建新文件.否则打开文件,并从开头编辑</td></tr><tr><td align="left">a</td><td align="left">追加打开文件.若不存在,创建新文件.否则打开文件,并从结尾追加内容</td></tr><tr><td align="left">ab+</td><td align="left">追加打开文件(二进制).若不存在,创建新文件.否则打开文件,并从结尾追加内容</td></tr></tbody></table></li></ul></li><li><p>读取文件</p><ul><li>read 方法<ul><li>语法: <code>fileObject.read(size=-1)</code></li><li>作用: 从文件中读取指定字符数(文本模式)或字节数(二进制模式).默认为 -1,表示读取整个文件</li><li>返回: 读取到的字节数</li></ul></li><li>readline 方法<ul><li>语法: <code>fileObject.readline(size=-1)</code></li><li>作用: 从文件读取整行,包括 <code>&#39;\n&#39;</code></li><li>返回: 读取到的字节数</li></ul></li><li>readlines 方法<ul><li>语法: <code>fileObject.readlines()</code></li><li>作用: 读取文件中的所有行(直到EOF)</li><li>返回: 元素为每行的列表.可以由 Python 的 for… in … 结构进行处理</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">file_path = <span class="hljs-string">r&#x27;D:\大梦谁先觉.txt&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fileObj:<br>    <span class="hljs-comment"># fileObj.read()  # 读取内容: &#x27;大梦谁先觉?\n平生我自知.\n草堂春睡足,\n窗外日迟迟.&#x27;</span><br>    <span class="hljs-comment"># fileObj.readlines()  # 返回列表形式(按行分割,因此可以按行遍历文本)</span><br>    <span class="hljs-comment"># [&#x27;大梦谁先觉?\n&#x27;, &#x27;平生我自知.\n&#x27;, &#x27;草堂春睡足,\n&#x27;, &#x27;窗外日迟迟.&#x27;]</span><br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> fileObj:  <span class="hljs-comment"># 直接遍历文件对象,写法简便</span><br>        <span class="hljs-built_in">print</span>(line, end = <span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>写入文件</p><ul><li>write 方法<ul><li>语法: <code>fileObject.write([str])</code></li><li>作用: 将字符串写入文件,并返回写入字符串的长度</li></ul></li><li>writelines 方法<ul><li>语法: <code>fileObject.writelines(seq)</code></li><li>作用: 将字符串序列写入文件.换行需要自行使用 <code>\n</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">file_path = <span class="hljs-string">r&#x27;D:\大梦谁先觉.txt&#x27;</span>  <span class="hljs-comment"># 由于没有该文件,因此会新建空文件并从头写入</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;w&#x27;</span>, encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fileObj:<br>    fileObj.write(<span class="hljs-string">&#x27;大梦谁先觉?\n平生我自知.\n&#x27;</span>)  <span class="hljs-comment"># 写入内容,并返回写入字符个数</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;a&#x27;</span>, encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fileObj:<br>    fileObj.write(<span class="hljs-string">&#x27;草堂春睡足,\n窗外日迟迟.\n&#x27;</span>)  <span class="hljs-comment"># 追加内容,并返回写入字符个数</span><br></code></pre></td></tr></table></figure></li><li><p>随机读写</p><ul><li>tell 方法<ul><li>语法: <code>fileObject.tell()</code></li><li>作用: 获取文件指针的位置</li></ul></li><li>seek 方法<ul><li>语法: <code>fileObject.seek(offset, whence=0)</code></li><li>作用: 指定文件指针的位置.成功则返回新的文件位置,失败返回 -1</li><li><code>offset</code> 为偏移的字节数(负数表示倒数)</li><li><code>whence</code> 指定初始位置. 0表示文件开头, 1表示当前位置, 2表示文件末尾</li></ul></li><li>flush 方法<ul><li>语法: <code>fileObject.flush()</code></li><li>作用: 刷新缓冲区</li></ul></li></ul></li></ol><h3 id="2-3-保存变量"><a href="#2-3-保存变量" class="headerlink" title="2.3 保存变量"></a>2.3 保存变量</h3><ol><li><p>shelve 模块可以将 Python 程序中的变量保存到二进制的 shelf 文件中</p><ul><li><code>shelf</code> 是一种持久化的类似字典的对象.键为字符串,而值可以是任意对象</li><li>可以使用 <code>shelve.open()</code> 作为上下文管理器保证调用 <code>close()</code> 方法</li></ul></li><li><p>shelve 保存变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> shelve<br>cats = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]  <span class="hljs-comment"># 待保存的数据</span><br><span class="hljs-keyword">with</span> shelve.<span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;D:\mydata&#x27;</span>) <span class="hljs-keyword">as</span> db:  <span class="hljs-comment"># 读写方式打开文件</span><br>    db[<span class="hljs-string">&#x27;cats&#x27;</span>] = cats  <span class="hljs-comment"># shelve 对象赋值与字典类似.这里 &#x27;cats&#x27; 键关联了列表 cats</span><br></code></pre></td></tr></table></figure><ul><li>Windows 系统新建 <code>mydata.bak, mydata.dat, mydata.dir</code> 三个文件(OS X 只有 <code>mydata.db</code>)</li><li>这些二进制文件保存了程序中的数据</li></ul></li><li><p>shelve 读取变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> shelve.<span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;D:\mydata&#x27;</span>) <span class="hljs-keyword">as</span> db:<br>    <span class="hljs-built_in">print</span>(db[<span class="hljs-string">&#x27;cats&#x27;</span>])  <span class="hljs-comment"># 读取键值为 &#x27;cats&#x27; 的值,与字典取值类似</span><br></code></pre></td></tr></table></figure></li><li><p>使用 pprint.pformat 方法保存变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pprint<br>cats = [&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;weight&#x27;</span>: <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;weight&#x27;</span>: <span class="hljs-number">8</span>&#125;]  <span class="hljs-comment"># 待保存的数据</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;D:\myCats.py&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fileObj:  <span class="hljs-comment"># 只写方式打开文件</span><br>    fileObj.write(<span class="hljs-string">&#x27;cats = &#x27;</span> + pprint.pformat(cats) + <span class="hljs-string">&#x27;\n&#x27;</span>)  <span class="hljs-comment"># 写入数据</span><br></code></pre></td></tr></table></figure></li><li><p>生成脚本</p><ul><li>考虑到 import 语句导入的模块本身就是 Python 脚本</li><li>如果 pprint.pformat() 生成的字符串保存为 .py 文件,则该文件就是一个可以导入的模块</li><li>因此 Python 程序可以生成其他的 Python 的程序.然后将其导入到脚本中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> myCats  <span class="hljs-comment"># 将之前生成的文件作为模块导入</span><br>myCats.cats[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;name&#x27;</span>]  <span class="hljs-comment"># 访问模块中保存的数据. 结果为 &#x27;A&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="3-组织文件"><a href="#3-组织文件" class="headerlink" title="3 组织文件"></a>3 组织文件</h2><h3 id="3-1-shutil-模块"><a href="#3-1-shutil-模块" class="headerlink" title="3.1 shutil 模块"></a>3.1 shutil 模块</h3><ol><li><p>shutil(也称为 shell 工具)模块包含的函数可以用于在 Python 程序中移动,改名,删除文件</p></li><li><p>复制</p><ul><li>语法: <code>shutil.copy(src,dst)</code></li><li>作用: 将源文件 src 移动到目标文件夹 <code>dst</code>.并返回绝对路径的字符串<ul><li>当 dst 指向的文件夹存在时,执行预期的复制操作</li><li>当 dst 文件夹不存在时,则该路径会被解释为 路径 + 文件名.且复制后文件被自动重命名</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> shutil, os<br>os.chdir(<span class="hljs-string">&#x27;D:\\&#x27;</span>)  <span class="hljs-comment"># 注意 r&#x27;D:\&#x27; 最后的 \ 仍会被视为转义字符,因此不能使用</span><br><br><span class="hljs-comment"># 若存在z2文件夹,则将z1中的a.txt文件复制到z2文件夹下</span><br>shutil.copy(<span class="hljs-string">r&#x27;z1\a.txt&#x27;</span>, <span class="hljs-string">r&#x27;z2&#x27;</span>)<br><span class="hljs-comment"># 若不存在b.txt文件夹,则将z1中的a.txt文件复制到z2文件夹下.并重命名为b.txt</span><br>shutil.copy(<span class="hljs-string">r&#x27;z1\a.txt&#x27;</span>, <span class="hljs-string">r&#x27;z2\b.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>语法: <code>shutil.copytree(src,dst)</code></li><li>作用: 复制 <code>src</code> 整个文件夹里包含的文件夹和文件到 <code>dst</code> 文件夹(<code>dst</code> 原本不存在)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.copytree(<span class="hljs-string">r&#x27;z1&#x27;</span>, <span class="hljs-string">r&#x27;z2\z1&#x27;</span>)  <span class="hljs-comment"># 将 z1 下的文件和文件夹全部复制到 Z2\Z1 下</span><br></code></pre></td></tr></table></figure></li><li><p>移动</p><ul><li>语法: <code>shutil.move(src, dst)</code></li><li>作用: 将源文件 src 移动到目标文件夹 <code>dst</code>.并返回绝对路径的字符串</li><li>移动操作与复制操纵行为是类似的.区别在于移动后源文件消失</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.move(<span class="hljs-string">r&#x27;z1\a.txt&#x27;</span>, <span class="hljs-string">r&#x27;z2&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>删除</p><ul><li><p><code>shutil.rmtree(src)</code>: 删除 src 指向的文件夹(包括其中所有的文件和文件夹)</p></li><li><p><code>os.unlink(path)</code>: 删除 path 处的文件</p></li><li><p><code>os.rmdir(path)</code>: 删除 path 处的文件夹(必须为空文件夹)</p></li><li><p>send2trash 模块可以安全地删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> send2trash  <span class="hljs-comment"># 需要先 pip install send2trash</span><br>send2trash.send2trash(<span class="hljs-string">&#x27;a.txt&#x27;</span>)  <span class="hljs-comment"># 将文件发送到垃圾箱</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="3-2-遍历目录树"><a href="#3-2-遍历目录树" class="headerlink" title="3.2 遍历目录树"></a>3.2 遍历目录树</h3><ol><li><p>os.walk 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>path = <span class="hljs-string">r&#x27;D:\notes\computer\C-C++&#x27;</span><br><span class="hljs-comment"># os.walk 将会返回三个值: 当前文件夹名(str), 子文件夹列表(list[str]), 文件名(list[str])</span><br><span class="hljs-keyword">for</span> folderName, subfolders, filenames <span class="hljs-keyword">in</span> os.walk(path):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The current folder is &#x27;</span> + folderName)  <span class="hljs-comment"># 输出当前文件夹名称</span><br>    <span class="hljs-keyword">for</span> subfolder <span class="hljs-keyword">in</span> subfolders:  <span class="hljs-comment"># 遍历当前目录的子文件夹</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;SUBFOLDER OF &#x27;</span> + folderName + <span class="hljs-string">&#x27;: &#x27;</span> + subfolder)  <span class="hljs-comment"># 输出子文件夹名称</span><br>    <span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> filenames:  <span class="hljs-comment"># 遍历当前目录所有文件</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;FILE INSIDE &#x27;</span> + folderName + <span class="hljs-string">&#x27;: &#x27;</span>+ filename)  <span class="hljs-comment"># 输出文件名</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>os.walk()</code>: 返回一个生成器.因此需要使用循环遍历</li><li>每次遍历返回的是一个三元组: (root,dirs,files)<ul><li>root: 当前文件夹名(str)</li><li>dirs: 子文件夹列表,不包括子目录(list[str])</li><li>flies: 文件名,不包括子目录(list[str])</li></ul></li><li>遍历会自动改变 <code>root</code> 的值,从而遍历所有的子文件夹</li></ul></li></ol><h3 id="3-3-zipfile-模块"><a href="#3-3-zipfile-模块" class="headerlink" title="3.3 zipfile 模块"></a>3.3 zipfile 模块</h3><ol><li><p>创建压缩包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> zipfile<br><span class="hljs-keyword">import</span> os<br>file_list = os.listdir(os.getcwd())  <span class="hljs-comment"># 获取当前工作目录的所有文件,文件夹名称</span><br><span class="hljs-keyword">with</span> zipfile.ZipFile(<span class="hljs-string">r&quot;a.zip&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> zipobj:  <span class="hljs-comment"># &#x27;a&#x27; 模式可以追加</span><br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> file_list:  <span class="hljs-comment"># 将上述文件进行打包</span><br>        zipobj.write(file)<br></code></pre></td></tr></table></figure></li><li><p>读取文件信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> zipfile.ZipFile(<span class="hljs-string">&quot;a.zip&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> zipobj:<br>    <span class="hljs-built_in">print</span>(zipobj.namelist())  <span class="hljs-comment"># 打印 a.zip 中文件,文件夹名称</span><br></code></pre></td></tr></table></figure></li><li><p>解压单个文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> zipfile.ZipFile(<span class="hljs-string">&quot;a.zip&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> zipobj:<br>    zipobj.extract(<span class="hljs-string">&#x27;c.txt&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>)  <span class="hljs-comment"># 提取出 a.zip 中的 c.txt 文件到 b 文件夹</span><br></code></pre></td></tr></table></figure></li><li><p>解压所有文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> zipfile.ZipFile(<span class="hljs-string">&quot;a.zip&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> zipobj:<br>    zipobj.extractall(<span class="hljs-string">&#x27;b&#x27;</span>)  <span class="hljs-comment"># 提取出 a.zip 中的所有文件到 b 文件夹</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="4-调试"><a href="#4-调试" class="headerlink" title="4 调试"></a>4 调试</h2><h3 id="4-1-抛出异常"><a href="#4-1-抛出异常" class="headerlink" title="4.1 抛出异常"></a>4.1 抛出异常</h3><ol><li><p>当 Python 试图执行无效代码时,将会抛出异常</p></li><li><p>使用 <code>raise</code> 语句抛出异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;This is the error message.&#x27;</span>)  <span class="hljs-comment"># 抛出异常,并给出提示信息</span><br></code></pre></td></tr></table></figure></li><li><p>如果没有使用 <code>try</code> 语句捕获异常,则程序将会崩溃,并显示异常的错误信息</p></li><li><p>因此可以在函数中对于异常情况抛出异常,在调用该函数时进行捕获异常,并处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">box</span>(<span class="hljs-params">symbol:<span class="hljs-built_in">str</span>, width:<span class="hljs-built_in">int</span>, height:<span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(symbol) != <span class="hljs-number">1</span>:  <span class="hljs-comment"># 对于输入有误时,抛出异常</span><br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;symbol 必须是单个字符&#x27;</span>)<br>    <span class="hljs-keyword">if</span> width &lt;= <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;width 必须大于等于2&#x27;</span>)<br>    <span class="hljs-keyword">if</span> height &lt;= <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;height 必须大于等于2&#x27;</span>)<br>        <br>    <span class="hljs-built_in">print</span>(symbol * width)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(height - <span class="hljs-number">2</span>):<br>        <span class="hljs-built_in">print</span>(symbol + (<span class="hljs-string">&#x27; &#x27;</span> * (width - <span class="hljs-number">2</span>)) + symbol)<br>    <span class="hljs-built_in">print</span>(symbol * width)<br><br><span class="hljs-keyword">for</span> sym, w, h <span class="hljs-keyword">in</span> ((<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>), (<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">5</span>), (<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&#x27;zz&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)):<br>    <span class="hljs-keyword">try</span>:<br>        box(sym, w, h)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:  <span class="hljs-comment"># 捕获到异常(是因为输入有误)显示错误信息即可</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;An exception happened: &#x27;</span> + <span class="hljs-built_in">str</span>(e))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 终端输出:</span><br>****<br>*  *<br>*  *<br>****<br><span class="hljs-number">00000000000000000000</span><br><span class="hljs-number">0</span>                  <span class="hljs-number">0</span><br><span class="hljs-number">0</span>                  <span class="hljs-number">0</span><br><span class="hljs-number">0</span>                  <span class="hljs-number">0</span><br><span class="hljs-number">00000000000000000000</span><br>An exception happened: width 必须大于等于<span class="hljs-number">2</span><br>An exception happened: symbol 必须是单个字符<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-2-断言"><a href="#4-2-断言" class="headerlink" title="4.2 断言"></a>4.2 断言</h3><ol><li>断言是健全性检查,用于确保代码没有做明显错误的事情<ul><li>若 <code>assert</code> 语句检查失败,则抛出 <code>AssertionError</code> 异常</li><li>语法: <code>assert condition, &#39;错误信息&#39;</code></li><li>断言成功时,无作用.当断言失败时,说明程序出现 bug,应立即停止程序(快速失败)</li></ul></li><li><code>assert</code> 失败时,不应捕获并处理异常.而是应该使程序崩溃<ul><li>断言针对程序员的错误,而非用户</li><li>断言不能取代全面测试.因为断言进针对 明显错误</li></ul></li><li>禁用 <code>assert</code>: 使用 <code>python -0 tst.py</code> 运行 <code>tst.py</code> 脚本,则 <code>assert</code> 语句将被跳过</li></ol><h3 id="4-3-日志"><a href="#4-3-日志" class="headerlink" title="4.3 日志"></a>4.3 日志</h3><ol><li><p><code>logging</code> 模块</p><ul><li><code>logging</code> 模块可以创建自定义的消息记录</li><li>这些日志信息描述程序何时调用日志函数,并给出指定变量的当前值.而缺失日志代表有些代码未执行</li></ul></li><li><p>实例: 调试 <code>factorial</code> 阶乘函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-comment"># 该语句需要位于程序上方,而无需关注其原理</span><br>logging.basicConfig(level=logging.DEBUG,<br>                    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>)<br><span class="hljs-comment"># logging.disable(logging.CRITICAL)  # 该语句可禁用日志</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>):<br>    logging.debug(<span class="hljs-string">f&#x27;进入 factorial(<span class="hljs-subst">&#123;n&#125;</span>)&#x27;</span>)<br>    total = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        total *= i<br>        logging.debug(<span class="hljs-string">f&#x27;i = <span class="hljs-subst">&#123;i&#125;</span>, total = <span class="hljs-subst">&#123;total&#125;</span>&#x27;</span>)<br>    logging.debug(<span class="hljs-string">f&#x27;结束 factorial(<span class="hljs-subst">&#123;n&#125;</span>)&#x27;</span>)<br>    <span class="hljs-keyword">return</span> total<br><br><span class="hljs-built_in">print</span>(factorial(<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 终端输出:</span><br><span class="hljs-number">2024</span>-06-<span class="hljs-number">20</span> <span class="hljs-number">00</span>:<span class="hljs-number">12</span>:<span class="hljs-number">32</span>,<span class="hljs-number">424</span> - DEBUG - 进入 factorial(<span class="hljs-number">5</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">20</span> <span class="hljs-number">00</span>:<span class="hljs-number">12</span>:<span class="hljs-number">32</span>,<span class="hljs-number">439</span> - DEBUG - i = <span class="hljs-number">1</span>, total = <span class="hljs-number">1</span><br><span class="hljs-number">2024</span>-06-<span class="hljs-number">20</span> <span class="hljs-number">00</span>:<span class="hljs-number">12</span>:<span class="hljs-number">32</span>,<span class="hljs-number">449</span> - DEBUG - i = <span class="hljs-number">2</span>, total = <span class="hljs-number">2</span><br><span class="hljs-number">2024</span>-06-<span class="hljs-number">20</span> <span class="hljs-number">00</span>:<span class="hljs-number">12</span>:<span class="hljs-number">32</span>,<span class="hljs-number">457</span> - DEBUG - i = <span class="hljs-number">3</span>, total = <span class="hljs-number">6</span><br><span class="hljs-number">2024</span>-06-<span class="hljs-number">20</span> <span class="hljs-number">00</span>:<span class="hljs-number">12</span>:<span class="hljs-number">32</span>,<span class="hljs-number">469</span> - DEBUG - i = <span class="hljs-number">4</span>, total = <span class="hljs-number">24</span><br><span class="hljs-number">2024</span>-06-<span class="hljs-number">20</span> <span class="hljs-number">00</span>:<span class="hljs-number">12</span>:<span class="hljs-number">32</span>,<span class="hljs-number">479</span> - DEBUG - i = <span class="hljs-number">5</span>, total = <span class="hljs-number">120</span><br><span class="hljs-number">2024</span>-06-<span class="hljs-number">20</span> <span class="hljs-number">00</span>:<span class="hljs-number">12</span>:<span class="hljs-number">32</span>,<span class="hljs-number">488</span> - DEBUG - 结束 factorial(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure></li><li><p>日志级别</p><table><thead><tr><th>级别</th><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>DEBUG</td><td>logging.debug()</td><td>最低级别.用于细节</td></tr><tr><td>INFO</td><td>logging.info()</td><td>记录一般事件,或确认工作正常</td></tr><tr><td>WARNING</td><td>logging.warning()</td><td>记录可能的问题</td></tr><tr><td>ERROR</td><td>logging.error()</td><td>记录错误</td></tr><tr><td>CRITICAL</td><td>logging.critical()</td><td>最高级别.用于致命错误</td></tr></tbody></table><ul><li>日志级别仅是建议,归根到底是由程序员决定的</li><li>向 <code>logging.basicConfig</code> 函数传入 <code>level</code> 参数可决定展示日志的优先级</li><li><code>level=logging.ERROR</code> 表示: 只显示 <code>ERROR, CRITICAL</code> 级别消息,其他忽略</li></ul></li><li><p>禁用日志</p><ul><li>向 <code>logging.disable</code> 函数传入日志级别表示: 禁用该级别及更低级别的日志</li></ul></li><li><p>记录到文件</p><ul><li><code>logging.basicConfig</code> 函数接收 <code>filename</code> 关键字参数</li><li>此时,日志文件将会写入文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">logging.basicConfig(level=logging.DEBUG,<br>                    filename=<span class="hljs-string">r&#x27;D:\test.log&#x27;</span>,<br>                    filemode=<span class="hljs-string">&#x27;a&#x27;</span>,<br>                    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#x27;</span>,)<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-处理-Excel"><a href="#5-处理-Excel" class="headerlink" title="5 处理 Excel"></a>5 处理 Excel</h2><h3 id="5-1-读取-Excel"><a href="#5-1-读取-Excel" class="headerlink" title="5.1 读取 Excel"></a>5.1 读取 Excel</h3><ol><li><p><code>openpyxl</code> 模块是第三方模块,需要安装: <code>pip install openpyxl</code></p></li><li><p>以 <code>example.xlsx</code> 文件为例.其内容如下</p><p><img src="/2024/10/30/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E2%80%94%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E2%80%94%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/assets/%E5%A4%84%E7%90%86excel.png" alt="1"></p></li><li><p>打开 excel 文档(<code>Workbook</code> 对象)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openpyxl<br><span class="hljs-comment"># 打开 excel 文件.wb 是一个 Workbook 对象,它代表了这个 excel 文件</span><br>wb = openpyxl.load_workbook(<span class="hljs-string">r&#x27;D:\example.xlsx&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>从工作簿中取得工作表(<code>Worksheet</code> 对象)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(wb.sheetnames)  <span class="hljs-comment"># sheetnames 属性存储工作簿中所有表名的列表: [&#x27;Sheet1&#x27;, &#x27;Sheet2&#x27;, &#x27;Sheet3&#x27;]</span><br>sheet = wb[<span class="hljs-string">&#x27;Sheet1&#x27;</span>]  <span class="hljs-comment"># sheet 是一个 Worksheet 对象,表示一个表.取出它的方法类似于字典</span><br></code></pre></td></tr></table></figure></li><li><p>从表中取得单元格(<code>Cell</code> 对象)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">cell = sheet[<span class="hljs-string">&#x27;A1&#x27;</span>]  <span class="hljs-comment"># 使用 key 的方式访问.cell 是一个 Cell 对象</span><br>date1 = cell.value  <span class="hljs-comment"># 取出 A1 单元格的值: datetime.datetime(2015, 4, 5, 13, 34, 2)</span><br>s = sheet[<span class="hljs-string">&#x27;B1&#x27;</span>].value  <span class="hljs-comment"># 取出 B1 单元格的值: &#x27;Apples&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><code>Cell</code> 对象的属性有<ul><li><code>value</code>: 单元格的值</li><li><code>row</code>: 当前行数(整数值)</li><li><code>column</code>: 当前列数(大写字母)</li><li><code>coordinate</code>: 行列的组合</li></ul></li><li><code>Worksheet</code> 对象的 <code>cell</code> 方法同样可以获得 <code>Cell</code> 对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># sheet.cell(row=1, column=2)  # 返回一个 Cell 对象</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, sheet.max_row+<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, sheet.max_column+<span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(sheet.cell(row=i, column=j).value, end=<span class="hljs-string">&#x27;\t\t&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 输出</span><br><span class="hljs-number">2015</span>-04-05 <span class="hljs-number">13</span>:<span class="hljs-number">34</span>:02Apples<span class="hljs-number">73</span><br><span class="hljs-number">2015</span>-04-05 03:<span class="hljs-number">41</span>:<span class="hljs-number">23</span>Cherries<span class="hljs-number">85</span><br><span class="hljs-number">2015</span>-04-06 <span class="hljs-number">12</span>:<span class="hljs-number">46</span>:<span class="hljs-number">51</span>Pears<span class="hljs-number">14</span><br><span class="hljs-number">2015</span>-04-08 08:<span class="hljs-number">59</span>:<span class="hljs-number">43</span>Oranges<span class="hljs-number">52</span><br><span class="hljs-number">2015</span>-04-<span class="hljs-number">10</span> 02:07:<span class="hljs-number">00</span>Apples<span class="hljs-number">152</span><br><span class="hljs-number">2015</span>-04-<span class="hljs-number">10</span> <span class="hljs-number">18</span>:<span class="hljs-number">10</span>:<span class="hljs-number">37</span>Bananas<span class="hljs-number">23</span><br><span class="hljs-number">2015</span>-04-<span class="hljs-number">10</span> 02:<span class="hljs-number">40</span>:<span class="hljs-number">46</span>Strawberries<span class="hljs-number">98</span><br></code></pre></td></tr></table></figure></li><li><p>对 <code>Worksheet</code> 对象切片: 获取区域中的所有 <code>Cell</code> 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 切片: 形如 ((A1, B1, C1), (A2, B2, C2), (A3, B3, C3)).行主序进行排列</span><br>sheet[<span class="hljs-string">&#x27;A1&#x27;</span>:<span class="hljs-string">&#x27;C3&#x27;</span>]  <span class="hljs-comment"># 返回一个元组.可用于遍历</span><br><br><span class="hljs-comment"># 获取整行或整列</span><br><span class="hljs-built_in">list</span>(sheet.columns)  <span class="hljs-comment"># 返回与切片类似的列表.列主序.然后索引即为某一列</span><br><span class="hljs-built_in">list</span>(sheet.rows)  <span class="hljs-comment"># 返回与切片类似的列表.行主序.然后索引即为某一行</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="5-2-写入-Exel"><a href="#5-2-写入-Exel" class="headerlink" title="5.2 写入 Exel"></a>5.2 写入 Exel</h3><ol><li><p>创建并保存 Excel 文档</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openpyxl<br>wb = openpyxl.Workbook()  <span class="hljs-comment"># 创建一个空的 Workbook 对象</span><br>sheet = wb.active  <span class="hljs-comment"># 激活 Worksheet. active 是一个方法,但被 @property 修饰</span><br>sheet.title = <span class="hljs-string">&#x27;my sheet&#x27;</span>  <span class="hljs-comment"># 给工作簿命名</span><br>wb.save(<span class="hljs-string">&#x27;table.xlsx&#x27;</span>)  <span class="hljs-comment"># 保存表格</span><br></code></pre></td></tr></table></figure></li><li><p>将值写入单元格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sheet[<span class="hljs-string">&#x27;A1&#x27;</span>] = <span class="hljs-string">&#x27;Hello,world&#x27;</span>  <span class="hljs-comment"># 给单元格赋值与操作字典类似</span><br></code></pre></td></tr></table></figure></li><li><p>创建 &#x2F; 删除工作表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">wb.create_sheet(index=<span class="hljs-number">0</span>, title=<span class="hljs-string">&#x27;First Sheet&#x27;</span>)  <span class="hljs-comment"># 创建一个新的工作簿</span><br><span class="hljs-keyword">del</span> wb[<span class="hljs-string">&#x27;First Sheet&#x27;</span>]  <span class="hljs-comment"># 删除工作簿</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="5-3-单元格样式"><a href="#5-3-单元格样式" class="headerlink" title="5.3 单元格样式"></a>5.3 单元格样式</h3><ol><li><p>定义单元格样式,需要 <code>Font</code> 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl.styles <span class="hljs-keyword">import</span> Font<br></code></pre></td></tr></table></figure></li><li><p>将 <code>A1</code> 单元格设置为: 字体大小24, 斜体</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sheet[<span class="hljs-string">&#x27;A1&#x27;</span>].font = Font(size=<span class="hljs-number">24</span>, italic=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure></li><li><p><code>Font</code> 函数的关键字参数</p><table><thead><tr><th>关键字参数</th><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>str</td><td>字体名称.如 ‘Consolas’</td></tr><tr><td>size</td><td>int</td><td>字体大小</td></tr><tr><td>bold</td><td>bool</td><td>True 表示粗体</td></tr><tr><td>italic</td><td>bool</td><td>True 表示斜体</td></tr></tbody></table></li></ol><h3 id="5-4-调整行列"><a href="#5-4-调整行列" class="headerlink" title="5.4 调整行列"></a>5.4 调整行列</h3><ol><li><p>设置行高 &#x2F; 列宽</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">sheet.row_dimensions[<span class="hljs-number">1</span>].height = <span class="hljs-number">70</span>  <span class="hljs-comment"># 将 1 行的高设为 70(0 ~ 409)</span><br>sheet.column_dimensions[<span class="hljs-string">&#x27;B&#x27;</span>].width = <span class="hljs-number">20</span>  <span class="hljs-comment"># 将 &#x27;B&#x27; 列的宽设为 20(0~255)</span><br></code></pre></td></tr></table></figure></li><li><p>合并 &#x2F; 拆分单元格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">sheet.merge_cells(<span class="hljs-string">&#x27;A1:D3&#x27;</span>)  <span class="hljs-comment"># 将 A1 到 D3 的单元格合并</span><br>sheet.unmerge_cells(<span class="hljs-string">&#x27;A1:D3&#x27;</span>)  <span class="hljs-comment"># 将 A1 到 D3 的单元格拆分</span><br></code></pre></td></tr></table></figure></li><li><p>冻结窗格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sheet.freeze_panes = <span class="hljs-string">&#x27;A2&#x27;</span>  <span class="hljs-comment"># A2 表示可活动单元格起始位置.即冻结第一行</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>freeze_panes 的值(可活动单元格起始位置)</th><th>冻结的行列</th></tr></thead><tbody><tr><td>‘A2’</td><td>行1</td></tr><tr><td>‘B1’</td><td>列A</td></tr><tr><td>‘A1’ 或 None</td><td>没有冻结</td></tr></tbody></table></li></ol><h3 id="5-5-使用公式"><a href="#5-5-使用公式" class="headerlink" title="5.5 使用公式"></a>5.5 使用公式</h3><ol><li><p>导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl.utils <span class="hljs-keyword">import</span> FORMULAE<br></code></pre></td></tr></table></figure><ul><li><code>FORMULAE</code> 中声明了许多 excel 函数</li></ul></li><li><p>判断函数是否存在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;SUM&quot;</span> <span class="hljs-keyword">in</span> FORMULAE)  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure></li><li><p>写入公式的方式: 将公式本身视作字符串写入即可</p></li><li><p>翻译公式: 类似于 excel 中自动填充公式的效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl.formula.translate <span class="hljs-keyword">import</span> Translator<br>translator = Translator(formula=<span class="hljs-string">&quot;=SUM(A2:B2)&quot;</span>, origin=<span class="hljs-string">&quot;C2&quot;</span>)  <span class="hljs-comment"># 获取公式对象</span><br>sheet[<span class="hljs-string">&quot;C3&quot;</span>] = translator.translate_formula(<span class="hljs-string">&quot;C3&quot;</span>)  <span class="hljs-comment"># 翻译到 C3 单元格</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python 编程快速上手—让繁琐工作自动化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>流畅的 Python-控制流</title>
    <link href="/2024/10/30/%E6%B5%81%E7%95%85%E7%9A%84Python/4.%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
    <url>/2024/10/30/%E6%B5%81%E7%95%85%E7%9A%84Python/4.%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="流畅的-Python-控制流"><a href="#流畅的-Python-控制流" class="headerlink" title="流畅的 Python-控制流"></a>流畅的 Python-控制流</h1><hr><h2 id="14-迭代器与生成器"><a href="#14-迭代器与生成器" class="headerlink" title="14 迭代器与生成器"></a>14 迭代器与生成器</h2><h3 id="14-1-迭代器"><a href="#14-1-迭代器" class="headerlink" title="14.1 迭代器"></a>14.1 迭代器</h3><ol><li><p>迭代是数据处理的基石</p><ul><li><p>迭代器: 当数据在内存中放不下时,需要惰性获取数据,按需一次获取一项</p></li><li><p><strong>Python 中所有的容器都是可迭代对象.对于可迭代对象提供的迭代器,可支持以下操作:</strong><br><strong>for 循环, 列表, 字典, 集合推导式, 拆包赋值, 构造容器实例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;ABC&#x27;</span><br><span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:<span class="hljs-comment"># 使用 for 循环进行取值.本质在于字符串是可迭代的</span><br>    <span class="hljs-built_in">print</span>(char)<br>    <br>it = <span class="hljs-built_in">iter</span>(s)<span class="hljs-comment"># 获取迭代器</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<span class="hljs-comment"># 等价的 while 循环处理迭代器</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))<span class="hljs-comment"># 使用 next 获取迭代器指向的值</span><br>    <span class="hljs-keyword">except</span> StopIteration:<span class="hljs-comment"># 当 next 没有内容可取时,抛出该异常</span><br>        <span class="hljs-keyword">del</span> it<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>迭代器可迭代的原因: <code>iter</code> 函数</p><ul><li>当需要迭代对象 x 时,Python 自动调用 <code>iter(x)</code></li><li>内置函数 <code>iter()</code> 执行的操作<ul><li>检查对象是否实现 <code>__iter__()</code> 方法,实现了就调用,获取迭代器</li><li>若没有实现 <code>__iter__()</code> 方法,但实现了 <code>__getitem__</code> 方法.则创建迭代器,并尝试按索引(从0开始)获取项</li><li>若尝试失败,抛出 TypeError 异常.提示 <code>&#39;ClassName&#39; object is not iterable</code></li></ul></li><li>Python 中所有序列都可迭代,因为序列都实现了 <code>__getitem__</code> 方法,实际上也还实现了 <code>__iter__</code> 方法</li></ul></li><li><p>使用 iter 处理可调用对象</p><ul><li><p>给 iter 传入两个参数时,可为 <code>函数或可迭代对象</code> 创建迭代器</p><ul><li>第一个参数: 必须为可迭代对象,其将被重复调用(不传入参数)而产生值</li><li>第二个参数: 哨符(一种标记值),若可调用对象返回哨符,则迭代器抛出 <code>StopIteration</code>,且不产出哨符</li></ul></li><li><p>示例: 使用 iter 函数掷一个6面骰子,直到点数为1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">d6</span>():<br>    <span class="hljs-keyword">return</span> randint(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)<br><br><span class="hljs-keyword">for</span> roll <span class="hljs-keyword">in</span> <span class="hljs-built_in">iter</span>(d6, <span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(roll)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>可迭代对象与迭代器: Python 从可迭代对象中获取迭代器</p><ul><li><strong>可迭代对象</strong>: 对其调用内置函数 iter 即可获取迭代器的对象.即 iter(Iterable) -&gt; Iterator</li><li>如果对象实现了能返回迭代器的 <code>__iter__</code> 方法,则对象是可迭代的</li><li>如果对象实现了 <code>__getitem__</code> 方法,且接受从 0 开始索引,则对象是可迭代的</li></ul></li><li><p>标准迭代器接口: 2个魔法方法</p><ul><li><p><code>__next__</code>: 返回序列中的下一项,若没有项,则抛出 StopIteration 异常</p></li><li><p><code>__iter__</code>: 返回 self.以便在预期可迭代对象的地方使用迭代器,如 for 循环</p></li></ul></li><li><p>抽象基类 Iterable 与 Iterator</p><p>  <img src="/2024/10/30/%E6%B5%81%E7%95%85%E7%9A%84Python/4.%E6%8E%A7%E5%88%B6%E6%B5%81/assets/Iterable_and_Iterator.png" alt="Iterable and Iterator"></p></li><li><p>迭代器特性</p><ul><li>检查是否存在剩余项的唯一方法: 调用<code>next()</code>并捕获 StopIteration 异常</li><li>无法重置迭代器.再次迭代只能再次调用<code>iter(Iterable)</code></li></ul></li></ol><h3 id="14-2-生成器"><a href="#14-2-生成器" class="headerlink" title="14.2 生成器"></a>14.2 生成器</h3><ol><li><p>考虑一个简单的生成器函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen_123</span>():<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>  <span class="hljs-comment"># yield 关键字会使得函数变为生成器</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><ul><li><p>调用 <code>gen_123()</code> 会返回一个生成器对象.由于生成器对象实现了<code>Iterator</code>接口,因此可迭代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> gen_123():<br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-comment"># 这里会依次输出 1, 2, 3 </span><br></code></pre></td></tr></table></figure></li><li><p>对 <code>gen_123()</code> 返回的生成器对象,可以调用 <code>next()</code> 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">g = gen_123()  <span class="hljs-comment"># 注意这不是函数调用.而是获取生成器对象,是一种特殊的迭代器</span><br><span class="hljs-built_in">next</span>(g) <span class="hljs-comment"># 产出 1</span><br><span class="hljs-built_in">next</span>(g) <span class="hljs-comment"># 产出 2</span><br><span class="hljs-built_in">next</span>(g) <span class="hljs-comment"># 产出 3</span><br><span class="hljs-built_in">next</span>(g) <span class="hljs-comment"># 抛出 StopIteration 异常</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>生成器函数创建一个生成器对象,包装生成器函数的主体</p><ul><li>当将生成器对象传给 <code>next()</code> 函数时,生成器函数将执行函数内容,直到 <code>yield</code> 语句</li><li>然后将计算产出的值返回,此时将在函数主体的执行到的位置处暂停</li><li>当函数主体遇到 <code>return</code> 时,Python 创建的外层生成器对象抛出 <code>StopIteration</code> 异常</li></ul></li><li><p>迭代器与生成器的对比</p><ul><li>迭代器: 泛指实现了 <code>__next__</code> 方法的对象<ul><li>一般通过 for 循环或在迭代器上调用 <code>next(it)</code> 驱动迭代器</li><li>实际使用中迭代器多数都是生成器</li></ul></li><li>生成器: 由 Python 编译器构建的迭代器<ul><li>为创建生成器,并不实现 <code>__next__</code> 方法,而是使用 <code>yield</code> 关键字得到生成器函数</li><li>生成器表达式是构建生成器对象的另一种方式</li><li><strong>生成器对象提供了 <code>__next__</code> 方法,因此生成器对象是迭代器</strong></li></ul></li></ul></li><li><p>迭代器与生成器示例对比</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> reprlib<br><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br><br><span class="hljs-comment"># 使用序列来支持 for 循环</span><br>RE_WORD = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;\w+&#x27;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sentence</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, text</span>):<br>        <span class="hljs-variable language_">self</span>.text = text<br>        <span class="hljs-variable language_">self</span>.words = RE_WORD.findall(text)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, index</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.words[index]<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.words)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="hljs-built_in">repr</span>(<span class="hljs-variable language_">self</span>.text)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Sentence(<span class="hljs-string">&quot;Simple is better than complex.&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(s, Iterable))  <span class="hljs-comment"># False.但其实该对象是可迭代的.使用 iter() 获取</span><br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<br>        <span class="hljs-built_in">print</span>(c)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用迭代器来支持 for 循环</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sentence</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;可迭代对象本身&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, text</span>):<br>        <span class="hljs-variable language_">self</span>.text = text<br>        <span class="hljs-variable language_">self</span>.words = RE_WORD.findall(text)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;Sentence(<span class="hljs-subst">&#123;reprlib.<span class="hljs-built_in">repr</span>(self.text)&#125;</span>)&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> SentenceIterator(<span class="hljs-variable language_">self</span>.words)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SentenceIterator</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;迭代器&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, words</span>):<br>        <span class="hljs-variable language_">self</span>.words = words<br>        <span class="hljs-variable language_">self</span>.index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">try</span>:<br>            word = <span class="hljs-variable language_">self</span>.words[<span class="hljs-variable language_">self</span>.index]<br>        <span class="hljs-keyword">except</span> IndexError:<br>            <span class="hljs-keyword">raise</span> StopIteration()<br>        <span class="hljs-variable language_">self</span>.index += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> word<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用生成器来支持 for 循环</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sentence</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, text</span>):<br>        <span class="hljs-variable language_">self</span>.text = text<br>        <span class="hljs-variable language_">self</span>.words = RE_WORD.findall(text)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="hljs-built_in">repr</span>(<span class="hljs-variable language_">self</span>.text)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.words:<br>            <span class="hljs-keyword">yield</span> word<br></code></pre></td></tr></table></figure></li><li><p>标准库中的生成器函数</p><ul><li><p>用于筛选的生成器函数</p><table><thead><tr><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>itertools</td><td>compress(it, selector_it)</td><td>并行处理两个可迭代对象.若 selector_it 中的项为真值,<br />那么产出 it 中对应的项</td></tr><tr><td>itertools</td><td>dropwhile(predicate, it)</td><td>处理 it, 跳过 predicate 的计算结果为真值的项,<br />然后产出剩下的项(不再进一 步检查)</td></tr><tr><td>内置</td><td>filter(predicate, it)</td><td>把 it 各元素传给 predicate, 若 predicate(item) 返回真,<br />则产出对应的元素, 若 predicate 是 None,那么只产出真值元素</td></tr><tr><td>itertools</td><td>filterfalse(predicate, it)</td><td>与 filter 函数的作用类似, 不过 predicate 的逻辑是相反的</td></tr><tr><td>itertools</td><td>islice(it, stop)<br />islice (it, start, stop, step&#x3D;1)</td><td>产出 it 的切片, 作用类似于 s[:stop] 或 s[start:stop:step].<br />不过 it 可以是任何可迭代对象,而且这个函数惰性执行操作</td></tr><tr><td>itertools</td><td>takewhile(predicate, it)</td><td>predicate 返回真值时产出对应的项,然后立即停止,不再继续检查</td></tr></tbody></table></li><li><p>用于映射的生成器函数</p><table><thead><tr><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>itertools</td><td>ccumulate(it, [func])</td><td>产出累计求和.如果提供了 func,那么把前两个项传给它,<br />然后把计算结果和下一项传给它,以此类推,产出最后结果</td></tr><tr><td>内置</td><td>enumerate(iterable, start&#x3D;0)</td><td>产出 (index, item) 形式的二元组.其中 index 从 start 开始计数,<br />item 则从 iterable 中 获取</td></tr><tr><td>内置</td><td>map(func, it1, [it2, …, itN])</td><td>把 it 中的各项依次传给 func,产出结果. 若传入 N 个可迭代对象,<br />那么 func 必须接受 N 个参数,而且并行处理各个可迭代对象</td></tr><tr><td>itertools</td><td>starmap(func, it)</td><td>把 it 中的各项依次传给 func,产出结果.输入的可迭代对象应该产出可迭代的项 iit, 然后以 func(*iit) 形式调用 func 继续处理</td></tr></tbody></table></li><li><p>合并多个可迭代对象的生成器函数</p><table><thead><tr><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>itertools</td><td>chain(it1, …, itN)</td><td>先产出 it1 中的所有项,然后产出 it2 中的所有项,以此类推</td></tr><tr><td>itertools</td><td>chain.from_iterable(it)</td><td>产出 it 生成的各个可迭代对象中的项</td></tr><tr><td>itertools</td><td>product(it1, …, itN, repeat&#x3D;1)</td><td>计算笛卡儿积.从输入的各个可迭代对象中获取项,合并成 N 元组.repeat 指明重复处理多少次输入的可迭代对象</td></tr><tr><td>内置</td><td>zip(it1, …, itN, strict&#x3D;False)</td><td>从输入的可迭代对象中并行获取项,产出构成的 N 元组,<br />只要有一个可迭代对象耗尽,就静默停止,除非指定了 strict&#x3D;True</td></tr><tr><td>itertools</td><td>zip_longest(it1, …, itN, fillvalue&#x3D;None)</td><td>从输入的可迭代对象中并行获取项,产出构成的 N 元组,<br />直到最长的可迭代对象耗尽才停止,空缺的值使用 fillvalue 填充</td></tr></tbody></table></li><li><p>把输入的各项扩充成多个输出项的生成器函数</p><table><thead><tr><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>itertools</td><td>combinations(it, out_len)</td><td>把 it 产出的 out_len 个项组合在一起, 然后产出</td></tr><tr><td>itertools</td><td>count(start&#x3D;0, step&#x3D;1)</td><td>从 start 开始不断产出数值,按 step 指定的步幅增加</td></tr><tr><td>itertools</td><td>cycle(it)</td><td>从 it 中产出各项,存储各项的副本,然后按顺序重复产出整个序列</td></tr><tr><td>itertools</td><td>pairwise(it)</td><td>返回输入的可迭代对象中连续的重叠对</td></tr><tr><td>itertools</td><td>permutations(it, out_len&#x3D;None)</td><td>把 out_len 个 it 产出的项排列在一起,然后产出这些排列</td></tr><tr><td>itertools</td><td>repeat(item, [times])</td><td>重复不断地产出指定的项,除非 times 指定次数</td></tr></tbody></table></li><li><p>用于重新排列元素的生成器函数</p><table><thead><tr><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>itertools</td><td>groupby(it, key&#x3D;None)</td><td>产出 (key, group) 形式的二元组,<br />其中 key 是分组标准,group 是生成器,用于产出分组内的项</td></tr><tr><td>内置</td><td>reversed(seq)</td><td>从后向前,倒序产出 seq 中的项,<br />seq 必须是序列,或者是实现了特殊方法 reversed 的对象</td></tr><tr><td>itertools</td><td>tee(it, n&#x3D;2)</td><td>产出一个由 n 个生成器组成的元组,<br />每个生成器单独产出输入的可迭代对象中的项</td></tr></tbody></table></li></ul></li><li><p>可迭代的归约函数: 接受一个可迭代对象,返回单个结果</p><table><thead><tr><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>内置</td><td>all(it)</td><td>it 中的所有项都为真值时返回 True, 否则返回 False. all([]) 返回 True</td></tr><tr><td>内置</td><td>any(it)</td><td>只要 it 中有为真值的项就返回 True,否则返回 False. any([]) 返回 False</td></tr><tr><td>内置</td><td>max(it, [key&#x3D;,] [default&#x3D;])</td><td>返回 it 中值最大的项. key 是排序函数.可迭代对象为空时返回 default</td></tr><tr><td>内置</td><td>min(it, [key&#x3D;,] [default&#x3D;])</td><td>返回 it 中值最小的项. key 是排序函数.可迭代对象为空时返回 default</td></tr><tr><td>内置</td><td>sum(it, start&#x3D;0)</td><td>it 中所有项的总和</td></tr><tr><td>functools</td><td>reduce(func, it, [initial])</td><td>把前两项传给 func,然后把结果和第三项传给 func.<br />以此类推,返回最后的结果.initial 会被当作第一组值的第一项</td></tr></tbody></table></li><li><p><code>yield from</code>: 从子生成器中产出.此时由子生成器接受,产出的值直接返回给外部,直到子生成器耗尽</p></li></ol><h3 id="14-3-经典协程"><a href="#14-3-经典协程" class="headerlink" title="14.3 经典协程"></a>14.3 经典协程</h3><ol><li><p><strong>协程实际就是生成器函数,通过主体中含有 yield 关键字的函数创建.因而协程对象就是生成器对象</strong></p><ul><li>生成器生产供迭代的数据</li><li>协程是数据的消费者,与迭代无关</li></ul></li><li><p>使用协程计算累计平均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Generator<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">averager</span>() -&gt; Generator[<span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>, <span class="hljs-literal">None</span>]:<br>    <span class="hljs-string">&quot;&quot;&quot;该函数返回一个生成器,该生成器产出 float值. send()方法接受 flaot值,且不返回有用的值&quot;&quot;&quot;</span><br>    total = <span class="hljs-number">0.0</span><br>    count = <span class="hljs-number">0</span><br>    average = <span class="hljs-number">0.0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        term = <span class="hljs-keyword">yield</span> average<span class="hljs-comment"># yield 将会暂停执行协程,将结果 average 发给用户</span><br>        total += term<span class="hljs-comment"># yield 还会接收调用方之后发给协程的值,其值赋给 term</span><br>        count += <span class="hljs-number">1</span><br>        average = total / count<br>        <br>coro_avg = averager()<span class="hljs-comment"># 创建协程对象</span><br><span class="hljs-built_in">next</span>(coro_avg)<span class="hljs-comment"># 开始执行协程.将会产出 average 的初值 0.0</span><br>coro_avg.send(<span class="hljs-number">10</span>)<span class="hljs-comment"># 调用 .send() 方法,产出当前平均值</span><br>coro_avg.send(<span class="hljs-number">20</span>)<br>coro_avg.close()<span class="hljs-comment"># 终止协程</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="15-上下文管理"><a href="#15-上下文管理" class="headerlink" title="15 上下文管理"></a>15 上下文管理</h2><ol><li><code>with</code> 语句设置一个临时上下文,交给上下文管理器对象控制.并且负责上下文<ul><li>优点: 避免错误,减少样板代码.使 API 更安全,易用</li><li><code>with</code> 语句的目的是简化常用的 <code>try/finally</code> 结构.尤其是确保关闭文件</li></ul></li><li>上下文管理器对象: 管理 <code>with</code> 语句.如同迭代器的存在是为了管理 <code>for</code> 循环<ul><li>上下文管理器接口包含 <code>__enter__, __exit__</code> 两个方法</li><li>当 <code>with</code> 语句开始时,Python 调用 <code>__enter__</code> 方法</li><li>当 <code>with</code> 语句结束或出于其他原因终止时,Python 在对象上调用 <code>__exit__</code> 方法</li></ul></li><li><code>else</code> 子句: 帮助表达意图<ul><li>在 <code>for</code> 语句中: 当 <code>for</code> 循环结束时(未被 <code>break</code> 终止)运行 <code>else</code> 块</li><li>在 <code>while</code> 语句中: 当 <code>while</code> 因条件为假退出循环时(未被 <code>break</code> 终止)运行 <code>else</code> 块</li><li>在 <code>try</code> 语句中: 当 <code>try</code> 没有抛出异常时才运行 <code>else</code> 块</li></ul></li></ol><h2 id="16-并发"><a href="#16-并发" class="headerlink" title="16 并发"></a>16 并发</h2><ol><li>基本概念<ul><li>并发: 处理多个待定任务.一次处理一个或并行处理多个,直到所有任务最终都成功或失败</li><li>并行: 同时执行多个计算任务.需要多核CPU</li><li>执行单元: 并发执行代码对象的统称,每个对象的状态和调用栈是独立的(Python原生支持进程,线程,协程)</li><li>进程: 计算机程序运行时的一个实例,消耗内存和部分CPU时间.每个进程隔离在自己的私有内存空间.进程通过管道,套接字或内存映射文件进行通信(只能携带原始字节,Python 对象需先序列化为原始字节)</li><li>线程: 单个进程中的执行单元.一个进程启动后只使用一个线程(主线程).通过调用系统API,进程可以创建更多线程,执行并发操作.同一进程内的线程共享相同的内存空间</li><li>协程:可以挂起自身并在以后恢复的函数(Python 中经典协程由生成器函数构建,原生协程使用 async def 定义)</li><li>锁: 一种供执行单元用来同步操作和避免数据损坏的对象.更新共享数据结构时,当前代码持有相应的锁,并告诉程序的其他部分等到锁被释放后在访问这个数据结构</li></ul></li><li><strong>GIL(Global Interpreter Lock,全局解释器锁): 对象引用计数和解释器其他内部状态的访问受其控制</strong><ul><li>任意时间节点上只有一个 Python 线程可以持有 GIL.因而任意时间节点只有一个线程能执行 Python 代码</li><li>自己编写的 Python 代码无法控制 GIL.但耗时的任务可由内置函数或C语言扩展释放GIL</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>流畅的 Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>流畅的 Python-类和协议</title>
    <link href="/2024/10/30/%E6%B5%81%E7%95%85%E7%9A%84Python/3.%E7%B1%BB%E5%92%8C%E5%8D%8F%E8%AE%AE/"/>
    <url>/2024/10/30/%E6%B5%81%E7%95%85%E7%9A%84Python/3.%E7%B1%BB%E5%92%8C%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="流畅的-Python-类和协议"><a href="#流畅的-Python-类和协议" class="headerlink" title="流畅的 Python-类和协议"></a>流畅的 Python-类和协议</h1><hr><h2 id="10-Python-风格的对象"><a href="#10-Python-风格的对象" class="headerlink" title="10 Python 风格的对象"></a>10 Python 风格的对象</h2><h3 id="10-1-构建二维向量类"><a href="#10-1-构建二维向量类" class="headerlink" title="10.1 构建二维向量类"></a>10.1 构建二维向量类</h3><ol><li><p>以开发一个二维向量类 <code>Vector2d</code> 的例子(<code>vector2d.py</code>)说明 <strong>Python风格的对象(能够简单,自然地执行任务)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> array <span class="hljs-keyword">import</span> array<br><span class="hljs-keyword">import</span> math<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector2d</span>:<br>    typecode = <span class="hljs-string">&#x27;d&#x27;</span>  <span class="hljs-comment"># 类属性 typecode.标识转换成实例字节时,存储为 C 语言的数据类型</span><br>    __match_args__ = (<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>)<span class="hljs-comment"># 类属性 __match_args__ 使其支持位置匹配模式,而关键字模式已得到支持</span><br>    __slots__ = (<span class="hljs-string">&#x27;__x&#x27;</span>, <span class="hljs-string">&#x27;__y&#x27;</span>)<span class="hljs-comment"># 类属性 __slots__ 列出实例属性名,同时类属性 __dict__ 将被屏蔽</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):<br>        <span class="hljs-variable language_">self</span>.__x = <span class="hljs-built_in">float</span>(x)  <span class="hljs-comment"># 2个前导下划线,表示属性为私有的</span><br>        <span class="hljs-variable language_">self</span>.__y = <span class="hljs-built_in">float</span>(y)  <span class="hljs-comment"># 私有属性 __x, __y 为向量分量,只读</span><br><br><span class="hljs-meta">    @property</span><span class="hljs-comment"># @property 装饰器将读值方法标记为特性</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">x</span>(<span class="hljs-params">self</span>):<span class="hljs-comment"># 读值方法,该方法与属性同名</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__x<span class="hljs-comment"># 在其他地方读取分量时,仍可使用self.x</span><br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">y</span>(<span class="hljs-params">self</span>):<span class="hljs-comment"># 同样给予 y 为读值方法.在外部使用 object.y 即可获取值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__y<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 将实例变为可迭代对象,因而支持拆包</span><br>        <span class="hljs-keyword">return</span> (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-variable language_">self</span>.x, <span class="hljs-variable language_">self</span>.y))  <span class="hljs-comment"># 调用生成器表达式依次产出分量</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 提供对象的字符串表示形式</span><br>        class_name = <span class="hljs-built_in">type</span>(<span class="hljs-variable language_">self</span>).__name__  <span class="hljs-comment"># 获取类名 Vector2d</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)&#x27;</span>.<span class="hljs-built_in">format</span>(class_name, *<span class="hljs-variable language_">self</span>)  <span class="hljs-comment"># 形如 Vector2d(3.0, 4.0)</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># print()函数: 形如(3.0, 4.0)</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(<span class="hljs-built_in">tuple</span>(<span class="hljs-variable language_">self</span>))  <span class="hljs-comment"># 因存在__iter__方法成为可迭代对象,则可调用 tuple()</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">angle</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> math.atan2(<span class="hljs-variable language_">self</span>.y, <span class="hljs-variable language_">self</span>.x)  <span class="hljs-comment"># 使用 atan2 计算极坐标形式的角度 θ</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__format__</span>(<span class="hljs-params">self, fmt_spec=<span class="hljs-string">&#x27;&#x27;</span></span>):  <span class="hljs-comment"># 供 f字符串, format(), str.format() 调用</span><br>        <span class="hljs-string">&quot;&quot;&quot;根据用户输入的格式说明符 输出对象的字符串表示形式&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> fmt_spec.endswith(<span class="hljs-string">&#x27;p&#x27;</span>):<span class="hljs-comment"># 当格式说明符以 &#x27;p&#x27; 结尾时,显示极坐标形式 &lt;r, θ&gt;</span><br>            fmt_spec = fmt_spec[:-<span class="hljs-number">1</span>]<span class="hljs-comment"># 去掉 &#x27;p&#x27;</span><br>            coords = (<span class="hljs-built_in">abs</span>(<span class="hljs-variable language_">self</span>), <span class="hljs-variable language_">self</span>.angle())  <span class="hljs-comment"># 构建极坐标元组</span><br>            outer_fmt = <span class="hljs-string">&#x27;&lt;&#123;&#125;, &#123;&#125;&gt;&#x27;</span>  <span class="hljs-comment"># 外层设为 &lt;&gt;</span><br>        <span class="hljs-keyword">else</span>:<span class="hljs-comment"># 格式说明符不以 &#x27;p&#x27; 结尾,正常格式化 (x, y)</span><br>            coords = <span class="hljs-variable language_">self</span>  <span class="hljs-comment"># 构建直角坐标元组</span><br>            outer_fmt = <span class="hljs-string">&#x27;(&#123;&#125;, &#123;&#125;)&#x27;</span>  <span class="hljs-comment"># 外层设为 ()</span><br>        components = (<span class="hljs-built_in">format</span>(c, fmt_spec) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> coords)  <span class="hljs-comment"># 遍历实例的分量,并将其格式化</span><br>        <span class="hljs-keyword">return</span> outer_fmt.<span class="hljs-built_in">format</span>(*components)  <span class="hljs-comment"># 返回格式化后的字符串</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__bytes__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># bytes()函数: 获取实例的二进制表示形式</span><br>        <span class="hljs-comment"># 形如 b&#x27;d\x00\x00\x00\x00\x00\x00\x08@\x00\x00\x00\x00\x00\x00\x10@&#x27;</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">bytes</span>([<span class="hljs-built_in">ord</span>(<span class="hljs-variable language_">self</span>.typecode)])) + <span class="hljs-built_in">bytes</span>(array(<span class="hljs-variable language_">self</span>.typecode, <span class="hljs-variable language_">self</span>))<br><br><span class="hljs-meta">    @classmethod  </span><span class="hljs-comment"># classmethod 装饰的方法可直接在类上调用</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">frombytes</span>(<span class="hljs-params">cls, octets</span>):  <span class="hljs-comment"># 参数 cls: 类自身, 参数 octets: 实例的二进制表示形式</span><br>        <span class="hljs-string">&quot;&quot;&quot;使用 bytes()函数生成的二进制形式重建实例&quot;&quot;&quot;</span><br>        typecode = <span class="hljs-built_in">chr</span>(octets[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 获取实例类型</span><br>        memv = <span class="hljs-built_in">memoryview</span>(octets[<span class="hljs-number">1</span>:]).cast(typecode)  <span class="hljs-comment"># 按照 typecode 类型转换</span><br>        <span class="hljs-keyword">return</span> cls(*memv)  <span class="hljs-comment"># 对 memv 进行拆包,获得构造函数所需的参数</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):  <span class="hljs-comment"># 重载 ==</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">tuple</span>(<span class="hljs-variable language_">self</span>) == <span class="hljs-built_in">tuple</span>(other)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 实现了 __eq__, __hash__. 因而对象可哈希</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>((<span class="hljs-variable language_">self</span>.x, <span class="hljs-variable language_">self</span>.y))  <span class="hljs-comment"># 文档建议 __hash__ 方法根据元组的分量计算哈希值</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__abs__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># abs()函数: 获取二维向量的模</span><br>        <span class="hljs-keyword">return</span> math.hypot(<span class="hljs-variable language_">self</span>.x, <span class="hljs-variable language_">self</span>.y)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__bool__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># bool()函数: 判断是否为零向量</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bool</span>(<span class="hljs-built_in">abs</span>(<span class="hljs-variable language_">self</span>))<br></code></pre></td></tr></table></figure></li><li><p>测试代码(<code>test_vector2d.py</code>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">from</span> vector2d <span class="hljs-keyword">import</span> Vector2d<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClassVector2d</span>:<br><span class="hljs-meta">    @pytest.fixture</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">vector2d_object_test</span>(<span class="hljs-params">self</span>):<br>        v = Vector2d(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>        <span class="hljs-keyword">return</span> v<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_vector2d_func</span>(<span class="hljs-params">self, vector2d_object_test</span>):<br>        <span class="hljs-keyword">assert</span> (vector2d_object_test.x, vector2d_object_test.y) == (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)  <span class="hljs-comment"># 测试读取属性</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">abs</span>(vector2d_object_test) == <span class="hljs-number">5</span>  <span class="hljs-comment"># __abs__</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">bool</span>(vector2d_object_test) <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>  <span class="hljs-comment"># __bool__</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">tuple</span>(_<span class="hljs-built_in">property</span> <span class="hljs-keyword">for</span> _<span class="hljs-built_in">property</span> <span class="hljs-keyword">in</span> vector2d_object_test) == (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)  <span class="hljs-comment"># __iter__</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">repr</span>(vector2d_object_test) == <span class="hljs-string">&#x27;Vector2d(3.0, 4.0)&#x27;</span>  <span class="hljs-comment"># __repr__</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">str</span>(vector2d_object_test) == <span class="hljs-string">&#x27;(3.0, 4.0)&#x27;</span>  <span class="hljs-comment"># __str__</span><br>        <span class="hljs-keyword">assert</span> vector2d_object_test.angle() == math.atan(<span class="hljs-number">4.0</span> / <span class="hljs-number">3</span>)  <span class="hljs-comment"># angle</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">format</span>(vector2d_object_test, <span class="hljs-string">&#x27;.2f&#x27;</span>) == <span class="hljs-string">&#x27;(3.00, 4.00)&#x27;</span>  <span class="hljs-comment"># __format__ 直角坐标</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">format</span>(vector2d_object_test, <span class="hljs-string">&#x27;.2p&#x27;</span>) == <span class="hljs-string">&#x27;&lt;5.0, 0.93&gt;&#x27;</span>  <span class="hljs-comment"># __format__ 极坐标</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;vector2d_object_test&#125;</span>&#x27;</span> == <span class="hljs-string">&#x27;(3.0, 4.0)&#x27;</span>  <span class="hljs-comment"># __format__ f字符串</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">bytes</span>(vector2d_object_test) == \<br>               <span class="hljs-string">b&#x27;d\x00\x00\x00\x00\x00\x00\x08@\x00\x00\x00\x00\x00\x00\x10@&#x27;</span>  <span class="hljs-comment"># __bytes__</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(&#123;Vector2d(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), Vector2d(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)&#125;) == <span class="hljs-number">2</span>  <span class="hljs-comment"># __hash__</span><br><br>        octets = <span class="hljs-built_in">bytes</span>(vector2d_object_test)<br>        v = Vector2d.frombytes(octets)<br>        <span class="hljs-keyword">assert</span> v == vector2d_object_test  <span class="hljs-comment"># frombytes</span><br><br>        <span class="hljs-keyword">match</span> vector2d_object_test:  <span class="hljs-comment"># 关键字模式匹配</span><br>            <span class="hljs-keyword">case</span> Vector2d(x=<span class="hljs-number">3</span>, y=<span class="hljs-number">4</span>):<br>                <span class="hljs-keyword">assert</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">case</span> _:<br>                <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-keyword">match</span> vector2d_object_test:  <span class="hljs-comment"># 位置匹配模式</span><br>            <span class="hljs-keyword">case</span> Vector2d(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>):<br>                <span class="hljs-keyword">assert</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">case</span> _:<br>                <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure></li><li><p>私有属性</p><ul><li>Python 中并不能像 Java 中 <code>private</code> 修饰符那样创建私有属性,但存在<strong>受保护的属性</strong></li><li><strong>名称改写(name mangling)</strong>: 对于双下划线开头的属性(<code>__property</code>)<br>Python 会将属性名处理为 <code>_ClassName__property</code>,然后存入实例属性 <code>__dict__</code> 中</li><li>尽量不要使用双下划线开头.<strong>大多约定以单下划线开头表示私有属性</strong>,但 Python 解释器并不对其进行特殊处理</li></ul></li><li><p>类属性 <code> __slots__</code>: 改变存储实例属性的方式,节约内存</p><ul><li>Python 默认将各实例的属性存储于名为 <code>__dict__</code> 的字典,消耗内存较多</li><li>若在定义类时声明 <code>__slots__</code> 属性,则 Python 将使用其他模型存储实例属性(<code>__dict__</code> 属性消失)</li><li>在继承时,子类需要重新声明 <code>__slots__</code>属性.形如: <code>__slots__ = (&#39;p1&#39;, &#39;p2&#39;)</code><ul><li>若子类只需接收基类的 <code>__slots__</code>,则可声明 <code>__slots__ = ()</code></li><li>若子类需要额外属性,则须在 <code>__slots__</code> 中列出</li></ul></li><li>为支持弱引用,类默认有 <code>__weakref__</code> 属性.若需要类实例成为弱引用的目标,需将 <code>__weakref__</code> 添加到 <code>__slots__</code></li><li>实例只能拥有 <code>__slots__</code> 列出的属性,也不能使用 <code>@cached_property</code> 装饰器,除非将 <code>__dict__</code> 加入 <code>__slots__</code></li></ul></li></ol><h3 id="10-2-格式化显示"><a href="#10-2-格式化显示" class="headerlink" title="10.2 格式化显示"></a>10.2 格式化显示</h3><ol><li><p>每个面向对象的语言都至少有一种获取对象字符串表示形式的标准方式(Python有2种)</p><ul><li><p><code>__repr__</code> 方法供内置函数 <code>repr()</code> 调用.用于获取对象的字符串形式(开发者友好,显示于控制台,调试器)</p></li><li><p><code>__str__</code> 方法供内置函数 <code>print()</code> 调用.用于输出用户友好的字符串</p></li><li><p><code>__bytes__</code> 方法供内置函数 <code>bytes()</code>函数调用.该方法获取对象的字节序列表示形式</p></li></ul></li><li><p><code>classmethod</code> 装饰器</p><ul><li>作用: 被 <code>@classmethod</code> 装饰的方法成为 操作类的方法,而非操作实例的方法</li><li>方法调用方式改为: <code>ClassName.methodName(paramList)</code></li><li>方法接收的参数改为: 第一个参数不再是实例(<code>self</code>),而是类本身(<code>cls</code>)</li></ul></li><li><p><code>staticmethod</code> 装饰器</p><ul><li>作用: 被 <code>@staticmethod</code> 装饰的方法成为<strong>静态方法</strong>(本质就是位于类中的普通函数)</li><li>参数: 第一个参数将不存在特殊的地方,仅为普通参数</li></ul></li><li><p>格式化显示</p><ul><li><p><code>__format__</code>方法供 &lt;f 字符串, 内置函数<code>format(), str.format()</code>方法&gt; 调用</p></li><li><p>若类中没有定义 <code>__format__</code>方法,则从 object 继承: 返回 <code>str(my_object)</code> </p></li><li><p>通过调用<code>obj.__format__(format_spec)</code> 以特殊的格式化代码显示对象的字符串表示形式</p><ul><li><p>其中<code>format_spec</code> 是<strong>格式说明符</strong>.也是 <code>format(my_obj, format_spec)</code> 的第二个参数</p></li><li><p>如下例所示: <code>&#39;0.6f&#39;, 0.2f</code> 即为格式说明符<code>format_spec</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># format_spec 是 &#123;&#125; 内代换字段中冒号后的部分</span><br>cny = <span class="hljs-number">1</span> / <span class="hljs-number">7.3168</span>              <span class="hljs-comment"># 0.13667176907937897</span><br><span class="hljs-built_in">format</span>(cny, <span class="hljs-string">&#x27;0.6f&#x27;</span>)           <span class="hljs-comment"># &#x27;0.136672&#x27;</span><br><span class="hljs-string">f&#x27;1 USD = <span class="hljs-subst">&#123;<span class="hljs-number">1</span> / cny:<span class="hljs-number">0.2</span>f&#125;</span> CNY&#x27;</span> <span class="hljs-comment"># &#x27;1 USD = 7.32 CNY&#x27;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="10-3-构建多维向量类"><a href="#10-3-构建多维向量类" class="headerlink" title="10.3 构建多维向量类"></a>10.3 构建多维向量类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;使用组合模式实现 Vector 类(vector.py),而非继承&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> functools<br><span class="hljs-keyword">import</span> itertools<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> operator<br><span class="hljs-keyword">import</span> reprlib<br><span class="hljs-keyword">from</span> array <span class="hljs-keyword">import</span> array<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>:<br>    typecode = <span class="hljs-string">&#x27;d&#x27;</span><br>    __match_args__ = (<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>)  <span class="hljs-comment"># 支持位置模式匹配</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, components</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;序列类型的构造函数最好接受可迭代对象为参数,如 Vector([3, 4])&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>._components = array(<span class="hljs-variable language_">self</span>.typecode, components)  <span class="hljs-comment"># _components 以数组形式存储Vector分量</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;本质上通过 array对象存储数据,直接返回该对象的可迭代形式&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>(<span class="hljs-variable language_">self</span>._components)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;由于分量可以很多,因此显示时需要对长度作出限制&quot;&quot;&quot;</span><br>        components = reprlib.<span class="hljs-built_in">repr</span>(<span class="hljs-variable language_">self</span>._components)  <span class="hljs-comment"># &quot;array(&#x27;d&#x27;, [0.0, 1.0, 2.0, 3.0, 4.0, ...])&quot;</span><br>        components = components[components.find(<span class="hljs-string">&#x27;[&#x27;</span>):-<span class="hljs-number">1</span>]  <span class="hljs-comment"># [0.0, 1.0, 2.0, 3.0, 4.0, ...]</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;Vector(<span class="hljs-subst">&#123;components&#125;</span>)&#x27;</span>  <span class="hljs-comment"># 形如 Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...])</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;转为元组后显示&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(<span class="hljs-built_in">tuple</span>(<span class="hljs-variable language_">self</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__bytes__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 与 Vector2d 中一致</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">bytes</span>([<span class="hljs-built_in">ord</span>(<span class="hljs-variable language_">self</span>.typecode)])) + <span class="hljs-built_in">bytes</span>(<span class="hljs-variable language_">self</span>._components)<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">frombytes</span>(<span class="hljs-params">cls, octets</span>):  <span class="hljs-comment"># 与 Vector2d 中几乎一致</span><br>        typecode = <span class="hljs-built_in">chr</span>(octets[<span class="hljs-number">0</span>])<br>        memv = <span class="hljs-built_in">memoryview</span>(octets[<span class="hljs-number">1</span>:].cast(typecode))<br>        <span class="hljs-keyword">return</span> cls(memv)  <span class="hljs-comment"># 由于构造函数现在接受可迭代对象,因此不需要拆包</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):  <span class="hljs-comment"># 更快地判断相等性</span><br>        <span class="hljs-comment"># return len(self) == len(other)  and \</span><br>        <span class="hljs-comment">#        all(a == b for a, b in zip(self, other))  # 一行流</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>) != <span class="hljs-built_in">len</span>(other):  <span class="hljs-comment"># 长度不一样时,提前返回不相等</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<span class="hljs-variable language_">self</span>, other):  <span class="hljs-comment"># zip 可并行迭代多个对象,返回元组的生成器</span><br>            <span class="hljs-keyword">if</span> a != b:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 规约映射:将函数作用于各分量,形成新序列,然后计算值</span><br>        hashes = (<span class="hljs-built_in">hash</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._components)  <span class="hljs-comment"># 创建生成器,惰性计算各分量的 hash</span><br>        <span class="hljs-comment"># hashes = map(hash, self._components)</span><br>        <span class="hljs-keyword">return</span> functools.reduce(operator.xor, hashes, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 对各分量进行异或,初值为0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__abs__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 与 Vector2d 中几乎一致</span><br>        <span class="hljs-keyword">return</span> math.hypot(*<span class="hljs-variable language_">self</span>)  <span class="hljs-comment"># Python 3.8 开始,hypot 接受 N 维坐标(需要先拆包)</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__bool__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 与 Vector2d 中一致</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bool</span>(<span class="hljs-built_in">abs</span>(<span class="hljs-variable language_">self</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 支持 len()</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._components)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, key</span>):  <span class="hljs-comment"># 支持 [] 运算符和切片</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(key, <span class="hljs-built_in">slice</span>):  <span class="hljs-comment"># 若传入的是 slice对象,则调用构造函数创建对象</span><br>            cls = <span class="hljs-built_in">type</span>(<span class="hljs-variable language_">self</span>)<br>            <span class="hljs-keyword">return</span> cls(<span class="hljs-variable language_">self</span>._components[key])<br>        index = operator.index(key)  <span class="hljs-comment"># 否则认为,传入的是单个索引值.背后调用__index__魔法方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._components[index]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;支持前4个分量使用 .x .y .z .t 方式获取&quot;&quot;&quot;</span><br>        cls = <span class="hljs-built_in">type</span>(<span class="hljs-variable language_">self</span>)  <span class="hljs-comment"># 获取类</span><br>        <span class="hljs-keyword">try</span>:<br>            pos = cls.__match_args__.index(key)  <span class="hljs-comment"># 获取key在__match_arg__中的位置</span><br>        <span class="hljs-keyword">except</span> ValueError:<br>            pos = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= pos &lt; <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._components):  <span class="hljs-comment"># 索引正确时返回对应分量</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._components[pos]<br>        msg = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;cls.__name__!r&#125;</span> object has no attribute <span class="hljs-subst">&#123;key!r&#125;</span>&#x27;</span><br>        <span class="hljs-keyword">raise</span> AttributeError(msg)  <span class="hljs-comment"># 索引不正确时抛出属性错误</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, key, value</span>):  <span class="hljs-comment"># 禁止将单个小写字母设为属性</span><br>        <span class="hljs-string">&quot;&quot;&quot;实现了__getattr__方法,则需要实现__setattr__方法,以防对象行为不一致&quot;&quot;&quot;</span><br>        cls = <span class="hljs-built_in">type</span>(<span class="hljs-variable language_">self</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(key) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> cls.__match_args__:  <span class="hljs-comment"># 如果想设置的属性名为 x,y,z,t.提示这些是只读的</span><br>                error = <span class="hljs-string">&#x27;readonly attribute &#123;attr_name!r&#125;&#x27;</span><br>            <span class="hljs-keyword">elif</span> key.islower():  <span class="hljs-comment"># 其他小写字母也不许设为属性</span><br>                error = <span class="hljs-string">&quot;can&#x27;t set attribute &#x27;a&#x27; to &#x27;z&#x27; in &#123;cls_name!r&#125;&quot;</span><br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 大写字母允许设置</span><br>                error = <span class="hljs-string">&#x27;&#x27;</span><br>            <span class="hljs-keyword">if</span> error:  <span class="hljs-comment"># 当 error 非空时,抛出错误</span><br>                msg = error.<span class="hljs-built_in">format</span>(cls_name=cls.__name__, attr_name=key)<br>                <span class="hljs-keyword">raise</span> AttributeError(msg)<br>        <span class="hljs-built_in">super</span>().__setattr__(key, value)  <span class="hljs-comment"># 非小写设为属性时,允许设置</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">angle</span>(<span class="hljs-params">self, n</span>):<br>        r = math.hypot(*<span class="hljs-variable language_">self</span>[n:])<br>        a = math.atan2(r, <span class="hljs-variable language_">self</span>[n-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>) - <span class="hljs-number">1</span>) <span class="hljs-keyword">and</span> (<span class="hljs-variable language_">self</span>[-<span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>):<br>            <span class="hljs-keyword">return</span> math.pi * <span class="hljs-number">2</span> - a<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> a<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">angles</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">self</span>.angle(n) <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>)))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__format__</span>(<span class="hljs-params">self, fmt_spec=<span class="hljs-string">&#x27;&#x27;</span></span>):  <span class="hljs-comment"># 供 &lt; f 字符串, format(), str.format() &gt; 调用</span><br>        <span class="hljs-string">&quot;&quot;&quot;根据用户输入的格式说明符 输出对象的字符串表示形式&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> fmt_spec.endswith(<span class="hljs-string">&#x27;h&#x27;</span>):  <span class="hljs-comment"># 当格式说明符以 &#x27;h&#x27; 结尾时,显示极坐标形式 &lt;r, θ1, θ2, θ3&gt;</span><br>            fmt_spec = fmt_spec[:-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 去掉 &#x27;h&#x27;</span><br>            coords = itertools.chain([<span class="hljs-built_in">abs</span>(<span class="hljs-variable language_">self</span>)], <span class="hljs-variable language_">self</span>.angles())  <span class="hljs-comment"># 构建极坐标生成器表达式</span><br>            outer_fmt = <span class="hljs-string">&#x27;&lt;&#123;&#125;&gt;&#x27;</span>  <span class="hljs-comment"># 外层设为 &lt;&gt;</span><br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 格式说明符不以 &#x27;h&#x27; 结尾,正常格式化 (x, y, z, t)</span><br>            coords = <span class="hljs-variable language_">self</span>  <span class="hljs-comment"># 构建直角坐标元组</span><br>            outer_fmt = <span class="hljs-string">&#x27;(&#123;&#125;)&#x27;</span>  <span class="hljs-comment"># 外层设为 ()</span><br>        components = (<span class="hljs-built_in">format</span>(c, fmt_spec) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> coords)  <span class="hljs-comment"># 遍历实例的分量,并将其格式化</span><br>        <span class="hljs-keyword">return</span> outer_fmt.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;,&#x27;</span>.join(components))  <span class="hljs-comment"># 返回格式化后的字符串</span><br></code></pre></td></tr></table></figure><h2 id="11-协议"><a href="#11-协议" class="headerlink" title="11 协议"></a>11 协议</h2><h3 id="11-1-协议"><a href="#11-1-协议" class="headerlink" title="11.1 协议"></a>11.1 协议</h3><ol><li><p>**协议是非正式的接口,不具有强制性.**只在文档中定义,不在代码中定义</p><ul><li><strong>序列协议</strong>: Python 对象想要表现得像序列,就需实现 <code>__len__, __getitem__</code> 方法</li><li><strong>可变序列协议</strong>: 想要表现得像可变序列,需额外提供 <code>__setitem__, __delitem___, insert</code>方法</li><li><strong>可迭代</strong>: 想要表现得像可迭代对象,就需实现 <code>__iter__</code> 方法</li><li><code>__getitem__</code> 方法: 按索引获取项,支持迭代,支持<code>in</code>运算符,因而是序列协议的核心<ul><li>支持迭代的方式: 当没有<code>__iter__</code>时,Python 传入索引 0,并尝试迭代</li><li>支持<code>in</code>运算符的方式: 当没有 <code>__contains__</code> 时,全面检查序列,判断元素是否存在</li></ul></li></ul></li><li><p>动&#x2F;静态协议</p><ul><li>对象可以只实现动态协议的部分,但静态协议要求提供协议类中的每个方法</li><li>类无须通过名称(如继承)声明支持什么协议</li></ul></li><li><p>实例属性的设置</p><ul><li>读取属性: 当读取对象不存在的属性名时,Python 会先对实列属性进行查找<ul><li>对于 <code>obj.attr</code> 表达式,Python 首先查找 <code>obj</code> 实例是否拥有名为 <code>attr</code> 的属性</li><li>若没有该属性,则在类属性 <code>obj.__class__</code> 中查找(类属性为实例属性提供默认值)</li><li>若没有找到,则沿着继承图继续向上查找(超类中的属性为实例提供属性值)</li><li>若还没找到,则调用实例 <code>obj</code> 所属类中的 <code>__getattr__</code> 魔法方法,并将属性名以字符串形式(<code>&#39;attr&#39;</code>)传入</li></ul></li><li>设置属性: Python 先调用 <code>__setattr__</code> 魔法方法,对实例属性进行设置<ul><li>当没有 <code>__setattr__</code> 魔法方法,设置对象不存在的属性名时,Python 将为实例创建一个新属性</li></ul></li></ul></li><li><p><code>__hash__</code>方法: 适合使用<code>functools.reduce</code> 函数将异或运算符<code>^</code>应用到各分量的哈希值</p></li><li><p>切片原理</p><ul><li><p>形如 <code>s[start, stop, step]</code>,其背后调用的方法为 <code>s.__getitem__(self, key)</code></p><ul><li>其中 <code>key</code> 将接收参数成为 <code>slice</code> 对象.即 <code>key = slice(start, stop, step)</code></li><li>形如 <code>s[1:4:2, 7:9]</code>,则 <code>key = (slice(1, 4, 2), slice(7, 9, None))</code></li></ul></li><li><p><code>slice</code> 的 <code>indices</code> 方法: 可以优雅处理 <code>start, stop, step</code> 为非负数,且落于指定长度序列的边界内</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">S.indices(<span class="hljs-built_in">len</span>) -&gt; (start, stop, step)<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="11-2-类型"><a href="#11-2-类型" class="headerlink" title="11.2 类型"></a>11.2 类型</h3><ol><li><p>类型图</p><p><img src="/2024/10/30/%E6%B5%81%E7%95%85%E7%9A%84Python/3.%E7%B1%BB%E5%92%8C%E5%8D%8F%E8%AE%AE/assets/Type_diagram.png" alt="Type diagram"></p><ul><li><strong>鸭子类型</strong>: Python 默认的类型实现方式.不必检查对象的类型,而是直接执行操作.若抛出异常,则处理异常</li><li>大鹅类型: 由抽象基类支持的方式.在运行时检查对象是否符合抽象基类的要求</li><li>静态类型: C 语言采用的方式.从Python 3.5开始由 <code>typing</code> 模块支持</li><li><strong>静态鸭子类型</strong>: 实现协议,但不是其子类.由 <code>typing.Protocol</code> 的子类支持</li><li>静态类型由外部类型检查工具检查,动态类型由 Python 解释器在运行时检查</li></ul></li><li><p>静态协议实例: 为 double 函数添加类型提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">double</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span><br><span class="hljs-comment"># double(1.5) = 3.0, double(&#x27;A&#x27;) = &#x27;AA&#x27;</span><br><span class="hljs-comment"># 因此,double 函数接收那些支持 *2 运算的参数</span><br><br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypeVar, Protocol<br>T = TypeVar(<span class="hljs-string">&#x27;T&#x27;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Repeatable</span>(<span class="hljs-title class_ inherited__">Protocol</span>):  <span class="hljs-comment"># 定义 Repeatable 协议,__mul__ 是协议的核心方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__mul__</span>(<span class="hljs-params">self: T, repeat_count: <span class="hljs-built_in">int</span></span>) -&gt; T: ...  <span class="hljs-comment"># 乘数限制为 int 类型</span><br>RT = TypeVar(<span class="hljs-string">&#x27;RT&#x27;</span>, bound=Repeatable)  <span class="hljs-comment"># RT 的上界限定为 Repeatable 协议</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">double</span>(<span class="hljs-params">x: RT</span>) -&gt; RT:  <span class="hljs-comment"># 类型检查工具将了解: double 函数的参数x可以乘以整数, 返回值类型与x相同</span><br>    <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p><code>typing.Protocol</code> 位于静态检查区域(类型图中的下半部分)</p><ul><li>运行时可检查的静态协议: 定义 <code>typing.Protocol</code> 的子类时:<br>可以通过 <code>@runtime_checkable</code> 装饰器支持运行时使用 <code>isinstance/issubclass</code> 检查</li></ul></li><li><p>设计静态协议时,窄协议(narrow protocol)更有用,即只有一个方法的协议</p><ul><li>命名方式: 对于窄协议的方法,若其名称为动词,而在末尾加上<code>-er</code>或<code>-or</code></li><li>接口隔离原则(Interface Segregation Principle): 不应强迫客户依赖用不到的接口</li><li>拓展协议: 若协议需要多个方法,不要直接添加新方法,而应衍生原协议,创建新协议</li></ul></li></ol><h3 id="11-3-大鹅类型"><a href="#11-3-大鹅类型" class="headerlink" title="11.3 大鹅类型"></a>11.3 大鹅类型</h3><ol><li><p><strong>大鹅类型: 只要 cls 是抽象基类(cls 元类是 abc.ABCMeta),就可以使用 <code>isinstance(obj, cls)</code></strong></p><ul><li><p><strong>虚拟子类</strong>: 不继承其他类而成为抽象基类的子类,能被<code>isinstance(), issubclass()</code>识别</p></li><li><p>将类注册为抽象基类的虚拟子类时,Python 不会检查是否实现了抽象基类的接口</p></li><li><p>注册方式: 在抽象基类上调用 <code>register</code> 类方法.且注册的类不会从抽象基类中继承方法或属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">AbstractClass.register(ClassName)  <span class="hljs-comment"># 调用register类方法</span><br><span class="hljs-meta">@AbstractClass.register  </span><span class="hljs-comment"># 使用装饰器标记虚拟子类</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>抽象基类</p><ul><li><p>抽象类表示接口: Python 没有 interface 关键字,使用抽象基类定义接口,在运行时显示类型检查</p></li><li><p>抽象基类是对鸭子类型的补充,提供一种定义接口的方式</p></li><li><p>声明抽象基类的方式: 继承<code>abc.ABC</code> 或 其他抽象基类</p></li><li><p>抽象基类的本质就是几个特殊方法,只要实现了相应的特殊方法,就能识别为子类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> abc<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Struggle</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>): <span class="hljs-keyword">return</span> <span class="hljs-number">23</span><br><br><span class="hljs-built_in">isinstance</span>(Struggle(), abc.Sized)  <span class="hljs-comment"># True.实现了__len__(),就是 Sized 的子类</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>抽象方法</p><ul><li>抽象方法使用 <code>@abc.abstractmethod</code> 装饰器标记(装饰器叠放时需位于最里层),其主体通常只有文档字符串</li><li>抽象方法可以有实现代码,但子类仍需将其覆盖.通过 <code>super()</code> 函数可以在其基础上添加功能</li></ul></li><li><p>标准库中的抽象基类: 大多在 <code>collections.abc</code> 模块中定义.<code>io, numbers</code> 包中也有一些</p><ul><li><p><code>collections.abc</code> 模块的17个抽象基类的 UML 类图</p><p><img src="/2024/10/30/%E6%B5%81%E7%95%85%E7%9A%84Python/3.%E7%B1%BB%E5%92%8C%E5%8D%8F%E8%AE%AE/assets/collections_abc.png" alt="collections_abc"></p></li><li><p>每个容器都继承 <code>Iterable, Container, Sized</code> 三个抽象基类或实现相应的协议</p><ul><li><code>Iterable</code> 通过实现 <code>__iter__</code> 方法支持迭代</li><li><code>Container</code> 通过实现 <code>__contains__</code> 方法支持 <code>in</code> 运算符</li><li><code>Sized</code> 通过实现 <code>__len__</code> 方法支持 <code>len()</code> 函数</li></ul></li><li><p><code>Collection</code> 本身没有方法,其目的是为了方便子类化 <code>Iterable, Container, Sized</code></p></li><li><p><code>Sequence, Mapping, Set</code> 是主要的不可变容器类型,且各自有其可变的子类</p></li><li><p>映射方法 <code>item(), keys(), values()</code> 返回的对象分别实现 <code>ItemsView, KeysView, ValuesView</code></p></li></ul></li></ol><h2 id="12-继承"><a href="#12-继承" class="headerlink" title="12 继承"></a>12 继承</h2><h3 id="12-1-super-函数"><a href="#12-1-super-函数" class="headerlink" title="12.1 super 函数"></a>12.1 super 函数</h3><ol><li><p>子类中覆盖超类的方法通常要调用超类中相应的方法</p><ul><li><p>内置类型(如list, dict, str)的原生方法使用C语言实现,它们不会调用子类中覆盖的方法(极少数例外)</p></li><li><p>Java 构造方法会自动调用超类不接受参数的构造方法,而Python不会,因而经常需要</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, a, b</span>):<br>    <span class="hljs-built_in">super</span>().__init__(a, b) ...<br></code></pre></td></tr></table></figure></li></ul></li><li><p>使用 super 函数而非直接调用超类方法的好处</p><ul><li>避免了硬编码基类的名称</li><li>super 实现的逻辑能处理多重继承涉及的类层次结构</li></ul></li><li><p>super 函数的可选参数: <code>super(type, object_or_type)</code></p><ul><li><code>type</code>: 从哪里开始向上搜索实现所需方法的超类.默认为 super() 调用所在的方法所属的类</li><li><code>object_or_type</code>: 接收调用方法的对象(调用实例方法时,默认为<code>self</code>)或类(调用类方法时)</li></ul></li><li><p><strong>多重继承的 super 函数</strong></p><ul><li>多重继承需要处理潜在的命名冲突,这种冲突由超类实现同名方法引起</li><li>每个类都有名为<code>__mro__</code>的属性(元组),按照方法解析顺序列出各个超类,从当前类一直到 object 类</li><li>调用的 super 函数时,Python 将按<code>__mro__</code>的顺序调用超类中的方法(与声明基类时的顺序有关)</li><li>super 函数沿着<code>__mro__</code>元组的顺序,直到 object 类,或者基类方法中不在出现 super 函数</li></ul></li></ol><h3 id="12-2-多重继承"><a href="#12-2-多重继承" class="headerlink" title="12.2 多重继承"></a>12.2 多重继承</h3><ol><li>混入类<ul><li>混入类在多重继承中会连同其他类一起被子类化</li><li>混入类不能作为具体类的唯一基类,且在类声明继承时需要位于第一位,建议在名称后加上<code>Mixin</code></li><li>混入类不为具体对象提供全部功能,而是增加或定制子类或同级类的行为</li></ul></li><li>由于多重继承中的 super 函数会按顺序调取超类的方法,因而可以在继承时,额外继承一个混入类<ul><li>此时,当方法重名,super() 函数先调用混入类的方法,然后调用后面基类的方法</li><li>先调用的混入类方法就可以对数据预处理,供后面基类方法使用.起到增加功能的作用</li></ul></li><li>多重继承: Python 中多重继承最明显的用途在于 collections.abc 包,即对接口多重继承<ul><li><strong>优先使用对象组合,而不是类继承</strong>: 使用继承容易得出令人费解和脆弱的设计</li><li>当继承接口,创建子类型,实现’是什么’关系时,最好使用抽象基类</li><li>当继承实现,通过重用避免代码重复时,可以利用混入类</li><li>若类的作用是定义接口,则应显式地将其定义为抽象基类或 <code>typing.Protocol</code> 的子类</li></ul></li></ol><h2 id="13-运算符重载"><a href="#13-运算符重载" class="headerlink" title="13 运算符重载"></a>13 运算符重载</h2><ol><li>运算符重载的作用<ul><li>让用户定义的对象可以使用中缀运算符或一元运算符</li><li>以及函数调用<code>()</code>, 属性访问<code>.</code>, 访问和切片<code>[]</code></li></ul></li><li>Python 对函数重载的限制<ul><li>不能改变内置类型的运算符表达的意思</li><li>不能新建运算符,只能重载现有运算符</li><li>有些运算符不能重载: <code>is, and, or, not</code></li></ul></li><li>一元运算符: <code>-, +, ~, abs()</code><ul><li>对于一元运算符,其背后支持的方法只有一个参数 self</li><li>遵守运算符的基本规则: 始终返回新对象,而不要修改 self</li></ul></li><li>重载加法运算符 <code>+</code>: 需要实现 <code>__add__</code> 或 <code>__radd__</code> 魔法方法</li><li>对于中缀运算符,Python解释器的执行步骤为(以<code>a+b</code>为例)<ul><li>尝试调用 <code>a.__add__()</code>,若没有该方法,尝试调用 <code>b.__radd__()</code>,若还没有,抛出 <code>TypeError</code></li><li>若调用特殊方法的结果是 <code>NotImplemented</code>(表示不能处理给定的操作数),也会抛出 <code>TypeError</code></li></ul></li><li><code>@</code>作为中缀运算符<ul><li><code>@</code> 是函数装饰器的前缀,先也可用作中缀运算符,NumPy 数组的点积可以写作<code>a @ b</code></li><li><code>@</code> 运算符由 <code>__matmul__, __rmatmul__, __imatmul__</code> 支持,即矩阵乘法(matrix multiplication)</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>流畅的 Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>流畅的 Python-函数即对象</title>
    <link href="/2024/10/30/%E6%B5%81%E7%95%85%E7%9A%84Python/2.%E5%87%BD%E6%95%B0%E5%8D%B3%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/10/30/%E6%B5%81%E7%95%85%E7%9A%84Python/2.%E5%87%BD%E6%95%B0%E5%8D%B3%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="流畅的-Python-函数即对象"><a href="#流畅的-Python-函数即对象" class="headerlink" title="流畅的 Python-函数即对象"></a>流畅的 Python-函数即对象</h1><hr><h2 id="7-函数"><a href="#7-函数" class="headerlink" title="7 函数"></a>7 函数</h2><h3 id="7-1-函数为一等对象"><a href="#7-1-函数为一等对象" class="headerlink" title="7.1 函数为一等对象"></a>7.1 函数为一等对象</h3><ol><li><p>创建函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;return n!&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> n * factorial(n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><ul><li>在控制台中可以直接调用该函数</li><li>控制台中输入 <code>factorial.__doc__</code>: 将会输出 <code>&#39;return n!&#39;</code> </li><li>控制台中输入 <code>type(factorial)</code>: 将会输出 <code>&lt;class &#39;function&#39;&gt;</code></li></ul></li><li><p><strong>函数满足一等对象的要求</strong></p><ul><li><strong>可在运行时创建</strong>: Python 可在交互模式中创建函数</li><li><strong>可赋值给变量</strong>: <code>fact = factorial</code></li><li><strong>可作为参数传递</strong>: <code>map(factorial, range(11))</code><br>   这将得到一个可迭代对象,所含的项为 <code>factorial(0),factorial(1),...,factorial(10)</code></li><li><strong>可作为返回值</strong>: <code>return factorial</code></li></ul></li><li><p>高阶函数(函数式编程的特色之一)</p><ul><li><strong>高阶函数: 接受函数为参数或将函数作为结果返回的函数</strong>(如 map, sorted)</li><li>map, filter 函数因为列表推导式和生成器表达式的引入,而变得不再重要</li></ul></li><li><p>匿名函数</p><ul><li><code>lambda</code> 关键字使用 Python 表达式创建匿名函数(本质是<code>def</code>语句的语法糖)</li><li>匿名函数的主体只能是纯粹的表达式(不能有 <code>while,try</code> 等)</li><li>匿名函数除了作为高阶函数的参数,很少使用</li></ul></li></ol><h3 id="7-2-可调用对象"><a href="#7-2-可调用对象" class="headerlink" title="7.2 可调用对象"></a>7.2 可调用对象</h3><ol><li>9种可调用对象<ul><li>用户定义的<strong>函数</strong>(<code>def, lambda</code>)</li><li><strong>内置函数</strong>: 使用 C 实现的函数(如 len)</li><li><strong>内置方法</strong>: 使用 C 实现的方法(如 dict.get)</li><li><strong>方法</strong>: 类中定义的函数</li><li><strong>类</strong>: 调用类时将运行<code>__new__</code>方法创建一个实例,然后运行<code>__init__</code>方法初始化实例</li><li><strong>类的实例</strong>: 如果类中定义了<code>__call__</code>方法,则其实例可作为函数调用</li><li><strong>生成器函数</strong>: 主体中有 <code>yield</code> 关键字的函数或方法.调用生成器函数将返回一个生成器对象</li><li><strong>原生协程函数</strong>: 使用 <code>async def</code> 定义的函数或方法.调用原生协程函数返回一个协程对象</li><li><strong>异步生成器函数</strong>: 使用 <code>async def</code> 定义,且主体中有 <code>yield</code> 关键字的函数或方法.<br> 调用异步生成器函数将返回一个异步生成器.供<code>async def</code> 使用</li></ul></li><li>判断对象能否调用的方法: <code>callable()</code> 函数</li><li>用户定义的可调用类型<ul><li>Python 中函数是对象(有属性).对象也可以表现得像函数(只需实现<code>__call__</code>方法)</li><li>对于拥有<code>__call__</code>方法的对象实例,在其后面加上<code>()</code>即可调用<code>__call__</code>方法</li></ul></li></ol><h2 id="8-类型提示"><a href="#8-类型提示" class="headerlink" title="8 类型提示"></a>8 类型提示</h2><h3 id="8-1-渐进式类型系统"><a href="#8-1-渐进式类型系统" class="headerlink" title="8.1 渐进式类型系统"></a>8.1 渐进式类型系统</h3><ol><li><p>渐进式类型系统(gradual type system)</p><ul><li><strong>可选</strong>: 类型检查工具不对没有类型提示的代码发出警告.无法确认时假定为Any类型(与其他所有类型兼容)</li><li><strong>不在运行时捕获类型错误</strong>: 类型提示相关问题由静态类型检查工具, lint 程序, IDE 捕获</li><li><strong>不能改善性能</strong>: 理论上类型注解提供的数据可以优化生成的字节码,但 Python 并未优化</li></ul></li><li><p>Mypy</p><ul><li>安装 Python 类型检查工具 Mypy: <code>pip install mypy</code></li><li>让 Mypy 进行类型检查: <code>mypy pythonFile.py</code></li><li>让 Mypy 严格要求: <code>mypy --disallow-untyped-defs pythonFile.py</code></li></ul></li><li><p>函数的类型提示示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 函数注解示例:第一个参数为 int 类型,第二个参数为 str 类型,默认值为&#x27;&#x27;.返回值为 str 类型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">count: <span class="hljs-built_in">int</span>, word: <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;&#x27;</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>None</code> 表示默认值: 如果一个可选的参数是可变类型,则 <code>None</code> 是唯一合理的默认值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">count: <span class="hljs-built_in">int</span>, word: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br><span class="hljs-comment"># Optional[str] 表示 word 可以是 str 或 None</span><br></code></pre></td></tr></table></figure></li><li><p>对局部变量的注解示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">var: <span class="hljs-built_in">int</span> = <span class="hljs-number">32</span>  <span class="hljs-comment"># 局部变量 var 的类型为 int,并赋值为32</span><br></code></pre></td></tr></table></figure></li><li><p><strong>类型的关键特征: 受支持的操作</strong></p><ul><li>对象被当作什么类型取决于它支持什么样的操作</li><li><strong>鸭子类型</strong>(Python, JavaScript): 对象有类型,但变量(包括参数)没有类型.只要对象支持嘎嘎叫,它就是鸭子</li><li>名义类型(C&#x2F;C++, Java, C#): 对象和变量都有类型.较为严格,可以更早地捕获 bug</li></ul></li></ol><h3 id="8-2-注解中可用的类型"><a href="#8-2-注解中可用的类型" class="headerlink" title="8.2 注解中可用的类型"></a>8.2 注解中可用的类型</h3><ol><li><p>Any 类型(<code>typing.Any</code>)</p><ul><li><strong>Any 是一种魔法类型,同时位于类型层次结构的顶部和底部</strong></li><li>Any 接受任何类型的值(是最一般的类型),又支持所有可能的操作(是最特定的类型)</li><li>对于没有类型提示信息的函数,类型检查工具假定其类型为 Any</li></ul></li><li><p>**相容性(consistent-with)**规则</p><ul><li>对于 T1 及其子类型 T2, T2 与 T1 相容(因为 T2 继承了 T1 支持的所有操作)</li><li>任何类型都与 Any 相容(声明为 Any 类型的参数接受任何类型的对象)</li><li>Any 与任何类型都相容(始终可以把 Any 类型的对象传给预期其他类型的参数)</li></ul></li><li><p>简单的类型和类</p><ul><li><code>int, float, str, bytes</code>这些简单的类型可以直接在类型提示中使用</li><li>标准库,外部包中的具体类,用户定义的具体类也可以在类型提示中使用</li><li>int 与 complex 相容, int 与 float 相容, float 与 complex 相容</li></ul></li><li><p><code>typing.Optional</code> 与 <code>typing.Union</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">param: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 参数 param 可以是 str 或 None(默认值)</span><br>param: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">bytes</span>]  <span class="hljs-comment"># 参数 param 可以是 str 或 bytes 类型</span><br>param: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Python 3.10 的 Union 句法(不用导入Union)</span><br></code></pre></td></tr></table></figure></li><li><p>泛化容器</p><ul><li><p>支持泛化类型提示的容器: </p><ul><li><code>list, set, frozenset, collections.deque</code></li><li><code>abc</code>模块中的 <code>Container, Collection, Sequence, Set, MutableSequence, MutableSet</code></li></ul></li><li><p>列表注解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">param: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>]:  <span class="hljs-comment"># 表示(Python3.9 及以上版本)返回一个元素均为 str 的 list</span><br></code></pre></td></tr></table></figure></li><li><p>元组注解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">param: <span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>]  <span class="hljs-comment"># 用作记录的元组.参数 param 是一个含有2个 float 字段的元组</span><br>param: <span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">int</span>, ...]  <span class="hljs-comment"># 用作可变序列的元组.参数 param 是一个长度可变的元组,且元素均为 int</span><br></code></pre></td></tr></table></figure></li><li><p>字典注解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">param: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">set</span>[<span class="hljs-built_in">str</span>]]  <span class="hljs-comment"># 参数 param 是一个字典:key为str类型,value为元素是str的集合</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>抽象基类</p><ul><li><strong>稳健性法则: 发送时要保守,接收时要大方</strong></li><li>对于参数类型提示,使用 <code>abc.Mapping</code> 或 <code>abc.MutableMapping</code> 好于 dict.因为 dict 对于受支持的操作要求更多</li><li>对于函数返回值的类型提示,应当越具体越好</li></ul></li><li><p>泛化可迭代对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">FromTo = <span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>]  <span class="hljs-comment"># FromTo 是一个类型别名</span><br>param: Iterable[FromTO]  <span class="hljs-comment"># 参数 param 是一个可迭代对象,其元素类型为 tuple[str, str]</span><br></code></pre></td></tr></table></figure></li><li><p>参数化泛型和 <code>typing.TypeVar</code></p><ul><li><p>参数化泛型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> <span class="hljs-type">Sequence</span><br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypeVar<br><br>T = TypeVar(<span class="hljs-string">&#x27;T&#x27;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">param: <span class="hljs-type">Sequence</span>[T]</span>) -&gt; <span class="hljs-built_in">list</span>[T]:<br></code></pre></td></tr></table></figure><ul><li>如果传入函数 <code>func</code> 的参数为 <code>tuple[int, ...]</code>类型,T 会被推断为 int 类型,则返回类型为 <code>list[int]</code></li><li>如果传入函数 <code>func</code> 的参数为 str,与 <code>Sequence[str]</code>相容,T 会被推断为 str,则返回类型为 <code>list[str]</code></li></ul></li><li><p>受限的 <code>TypeVar</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">NumberT = TypeVar(<span class="hljs-string">&#x27;NumberT&#x27;</span>, <span class="hljs-built_in">float</span>, Decimal, Fraction)  <span class="hljs-comment"># NumberT 接收的参数类型被限制</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mode</span>(<span class="hljs-params">data: Iterable[NumberT]</span>) -&gt; NumberT:  <span class="hljs-comment"># 参数接收可迭代对象的 NumberT</span><br></code></pre></td></tr></table></figure></li><li><p>有界的 <code>TypeVar</code>(参数 <code>bound</code> 指定上界)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">HashableT = TypeVar(<span class="hljs-string">&#x27;HashableT&#x27;</span>, bound=Hashable)  <span class="hljs-comment"># 参数类型可以是 Hashable 及其子类</span><br></code></pre></td></tr></table></figure></li><li><p>预定义的类型变量 <code>AnyStr</code>(接收<code>bytes, str</code>类型)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">AntStr = TypeVar(<span class="hljs-string">&#x27;AnyStr&#x27;</span>, <span class="hljs-built_in">bytes</span>, <span class="hljs-built_in">str</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>typing.Protocol</code></p><ul><li><p><strong>协议是非正式的接口.对于类型提示,协议指 <code>typing.Protocol</code> 的子类</strong></p></li><li><p>考虑问题: 所接受的参数需要满足可以使用 <code>sorted()</code> 函数进行排序,该如何限制其类型</p></li><li><p><code>sorted()</code> 函数对可迭代对象排序需要满足元素拥有 <code>&lt;</code> 运算符,即实现 <code>__lt__</code> 魔法方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Protocol, <span class="hljs-type">Any</span>, TypeVar, Iterable<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SupportsLessThan</span>(<span class="hljs-title class_ inherited__">Protocol</span>):  <span class="hljs-comment"># 作为协议子类,关键在于它实现了 &lt; 运算符</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other: <span class="hljs-type">Any</span></span>) -&gt; <span class="hljs-built_in">bool</span>: ...  <span class="hljs-comment"># 方法体仅为...,并未真正实现</span><br>LT = TypeVar(<span class="hljs-string">&#x27;LT&#x27;</span>, bound=SupportsLessThan)  <span class="hljs-comment"># LT 限定为实现了 __lt__() 方法的对象</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">series: Iterable[LT], length: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>[LT]:<br>    <span class="hljs-string">&quot;&quot;&quot;返回可迭代对象中的排名在前的 length 个对象&quot;&quot;&quot;</span><br>    ordered = <span class="hljs-built_in">sorted</span>(series, reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># series 是可迭代的 LT,因而可以使用 sorted 排序</span><br>    <span class="hljs-keyword">return</span> ordered[:length]  <span class="hljs-comment"># 返回逆序排序后的前 length 个元素</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>typing.Callable</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> <span class="hljs-type">Callable</span><br><span class="hljs-comment"># Callable 类型参数化形式: </span><br><span class="hljs-type">Callable</span>[[paramType1, paramType2], returnType]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">  <span class="hljs-comment"># func 函数的参数是两个函数</span></span><br><span class="hljs-params">    func1: <span class="hljs-type">Callable</span>[[], <span class="hljs-built_in">float</span>],  <span class="hljs-comment"># func1 是一个无参,返回值为 float 的函数</span></span><br><span class="hljs-params">    func2: <span class="hljs-type">Callable</span>[[<span class="hljs-built_in">float</span>], <span class="hljs-literal">None</span>]  <span class="hljs-comment"># func2 是一个参数为 float,无返回值的函数</span></span><br><span class="hljs-params"></span>)<br></code></pre></td></tr></table></figure></li><li><p><code>typing.NoReturn</code>: 仅用于注解绝不返回的函数的返回值类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">exit</span>(<span class="hljs-params">__status: <span class="hljs-built_in">object</span> = ...</span>) -&gt; NoReturn: ...  <span class="hljs-comment"># sys.exit() 函数的签名</span><br></code></pre></td></tr></table></figure><ul><li><code>__status</code> 是仅限位置参数,且有默认值.但默认值由<code>...</code>代替,并未给出</li></ul></li><li><p>注解仅限位置参数和变长参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span><br><span class="hljs-params">name: <span class="hljs-built_in">str</span>,</span><br><span class="hljs-params">    /,  <span class="hljs-comment"># 前面的参数仅限位置参数</span></span><br><span class="hljs-params">    *content: <span class="hljs-built_in">str</span>,  <span class="hljs-comment"># contenet 接收余下的所有位置参数,其类型为 tuple[str, ...]</span></span><br><span class="hljs-params">    class_: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>,  <span class="hljs-comment"># class_ 是关键字参数,接收 str 或 None</span></span><br><span class="hljs-params">    **attrs: <span class="hljs-built_in">float</span>,  <span class="hljs-comment"># attr 以 dict 形式接收参数,其类型为 dict[str, float]</span></span><br><span class="hljs-params"></span>) -&gt; <span class="hljs-built_in">str</span>:<br></code></pre></td></tr></table></figure></li></ol><h3 id="8-3-函数重载的签名"><a href="#8-3-函数重载的签名" class="headerlink" title="8.3 函数重载的签名"></a>8.3 函数重载的签名</h3><ol><li><p>Python 函数可接受不同的参数组合,进行函数重载,此时可使用<code>@typing.overload</code>装饰器注解</p><ul><li>类型检查工具根据参数按顺序匹配各个重载的签名</li><li>符合 Python 风格的 API 往往难以注解,利用 Python 强大动态功能的函数往往难以添加类型提示</li><li>务实一点,部分代码没有类型提示也没关系</li></ul></li><li><p>内置函数 sum 为例,<code>help(sum)</code>将输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sum</span>(iterable, /, start=<span class="hljs-number">0</span>)<br>Return the <span class="hljs-built_in">sum</span> of a <span class="hljs-string">&#x27;start&#x27;</span> value (default: <span class="hljs-number">0</span>) plus an iterable of numbers<br></code></pre></td></tr></table></figure><p>其重载的类型提示为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@overload</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">__iterable: Iterable[_T]</span>) -&gt; <span class="hljs-type">Union</span>[_T, <span class="hljs-built_in">int</span>]: ...<br><span class="hljs-meta">@overload</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">__iterable: Iterable[_T], start: _S</span>) -&gt; <span class="hljs-type">Union</span>[_T, _S]: ...<br></code></pre></td></tr></table></figure><ul><li>其中双前置下划线 <code>__iterable</code> 表示仅限位置参数</li><li><code>...</code> 仅为函数提供主体,满足句法要求,没有实质上的意义</li></ul></li></ol><h3 id="8-4-类型校正"><a href="#8-4-类型校正" class="headerlink" title="8.4 类型校正"></a>8.4 类型校正</h3><ol><li><p>任何类型系统都不完美</p><ul><li><code>typing.cast()</code>函数可处理不受控制的 代码中存在的类型检查问题或不正确的类型提示</li><li><strong>类型校正用于消除类型检查工具发出的虚假警告,在类型检查工具无法完全理解事态时提供帮助</strong></li></ul></li><li><p><code>typing.cast</code></p><ul><li><p>在运行时,<code>typing.cast</code>函数什么也不做,函数实现如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">cast</span>(<span class="hljs-params">typ, val</span>):<br>    <span class="hljs-keyword">return</span> val<br></code></pre></td></tr></table></figure></li><li><p>cast 函数可用于指引类型检查工具,提示返回值的类型为 <code>typ</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">return</span> cast(<span class="hljs-built_in">str</span>, a[index])  <span class="hljs-comment"># Mypy 将分析出返回值类型为 str</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>在代码中编写注释信息: <code># type: ignore[code]</code>句法,告诉类型检查工具忽略特定行,函数,文件的类型错误</p></li><li><p>Python 在导入时会读取函数,类,模块中的类型提示,然后将类型提示存储于<code>__annotations__</code>属性中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">clip</span>(<span class="hljs-params">text: <span class="hljs-built_in">str</span>, max_len: <span class="hljs-built_in">int</span> = <span class="hljs-number">80</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br><span class="hljs-comment"># clip.__annotations__: &#123;&#x27;text&#x27;: &lt;class &#x27;str&#x27;&gt;, &#x27;max_len&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;return&#x27;: &lt;class &#x27;str&#x27;&gt;&#125;</span><br><span class="hljs-comment"># 因此类型提示使用的增加将会导致: 导入模块使用的CPU和内存资源增加</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="9-装饰器和闭包"><a href="#9-装饰器和闭包" class="headerlink" title="9 装饰器和闭包"></a>9 装饰器和闭包</h2><h3 id="9-1-装饰器"><a href="#9-1-装饰器" class="headerlink" title="9.1 装饰器"></a>9.1 装饰器</h3><ol><li><p><strong>装饰器是一种可调用对象.其参数是一个函数(被装饰的函数)</strong></p><ul><li><p>假设有一个装饰器名为 <code>decorate</code>,则</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@decorate</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;running target()&#x27;</span>)<br></code></pre></td></tr></table></figure><p>与下面的代码效果一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;running target()&#x27;</span>)<br>    <br>target = decorate(target)<br></code></pre></td></tr></table></figure></li><li><p><code>@decorate</code> 对 <code>target()</code> 函数进行了处理,然后绑定回 <code>target</code></p></li></ul></li><li><p>装饰器的性质</p><ul><li><strong>装饰器的本质是一个函数或其他可调用对象,是一种语法糖</strong></li><li>可将被装饰的函数替换为其他函数.事实上仅要求为可调用对象</li><li>在加载(导入)模块时立即执行.而被装饰的函数只在显式调用时运行</li></ul></li><li><p>装饰器的使用</p><ul><li>通常,装饰器和被装饰函数在不同的模块中定义</li><li>通常,装饰器接收函数作为参数,然后会在内部定义另一个函数,然后将其返回</li></ul></li><li><p>变量作用域</p><ul><li>Python 不要求声明变量,但会假定函数主体中赋值的变量是局部变量</li><li><code>global</code>关键字: 将变量(函数级别)声明为全局变量(模块级别)</li></ul></li></ol><h3 id="9-2-闭包"><a href="#9-2-闭包" class="headerlink" title="9.2 闭包"></a>9.2 闭包</h3><ol><li><p>只有涉及嵌套函数时才有闭包问题</p><ul><li><strong>闭包: 延伸了作用域的函数,保留了定义函数时对自由变量的绑定</strong></li><li>在函数 f 主体中引用的非全局变量和局部变量.其作用域为: 包含了函数 f 的 外层函数的局部作用域</li><li>闭包好似一个拥有多个属性,但只有一个方法的对象.简化的对象</li></ul></li><li><p>考虑问题: 求平均值的函数.要求每次调用它时计算 <code>以往输入的数据 + 本次输入数据</code> 的平均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_averager</span>():<br>    series = []  <span class="hljs-comment"># series 是自由变量(free variable: 未在局部作用域中绑定)</span><br>    <span class="hljs-comment"># average()函数的闭包延伸到自身定义之外,包括了对自由变量 series 的绑定</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">average</span>(<span class="hljs-params">newValue</span>):  <br>        series.append(newValue)<br>        total = <span class="hljs-built_in">sum</span>(series)<br>        <span class="hljs-keyword">return</span> total / <span class="hljs-built_in">len</span>(series)<br><span class="hljs-keyword">return</span> average<br></code></pre></td></tr></table></figure></li><li><p>测试方式(Python 控制台): </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">avg = make_averager()  <span class="hljs-comment"># avg 成为一个函数</span><br>avg(<span class="hljs-number">10</span>)  <span class="hljs-comment"># 输出10</span><br>avg(<span class="hljs-number">34</span>)  <span class="hljs-comment"># 输出22</span><br></code></pre></td></tr></table></figure></li><li><p><code>nonlocal</code>关键字: 将变量标记为自由变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 由于求平均值仅需 总和,项数 信息,可以改进如下: </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_averager</span>():<br>    count = <span class="hljs-number">0</span><br>    total = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">average</span>(<span class="hljs-params">new_value</span>):<br>        <span class="hljs-keyword">nonlocal</span> count, total  <span class="hljs-comment"># 将 count, total 标记为自由变量</span><br>        count += <span class="hljs-number">1</span>  <span class="hljs-comment"># 若没有 nonlocal 语句将导致 count,total 因在函数内赋值,而变为局部变量</span><br>        total += new_value  <span class="hljs-comment"># count,total 在函数内部对其值进行修改时,也会对闭包中的绑定进行更新</span><br>        <span class="hljs-keyword">return</span> total / count<br><span class="hljs-keyword">return</span> average<br></code></pre></td></tr></table></figure></li><li><p>Python 变量作用域分析逻辑</p><ul><li><code>global x</code>: 说明 <code>x</code> 来自模块全局作用域,且 <code>x</code> 的值与其相同</li><li><code>nonlocal x</code>: 说明 <code>x</code> 是来自外层函数的局部变量,且 <code>x</code> 的值与其相同</li><li><code>x</code>是函数参数或 <code>x</code> 在函数主体中进行了赋值,则 <code>x</code> 成为局部变量</li><li>引用 <code>x</code>(既不是参数,也没有赋值)<ul><li>首先在外层函数主体的局部作用域查找 <code>x</code></li><li>若未找到,则在模块全局作用域查找.若还没找到,则从<code>__builtins__.dict__</code>中读取</li></ul></li></ul></li></ol><h3 id="9-3-装饰器实例"><a href="#9-3-装饰器实例" class="headerlink" title="9.3 装饰器实例"></a>9.3 装饰器实例</h3><ol><li><p><strong>装饰器的典型行为(动态地给一个对象添加某些额外的职责)</strong></p><ul><li>将被装饰的函数替换为新函数</li><li>新函数接受的参数与原函数一致,且返回原函数应返回的值</li><li>加入一些额外的操作(如下面的计算运行时间)</li></ul></li><li><p>创建一个显示函数运行时间的简单装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> functools<br><br>DEFAULT_FMT = <span class="hljs-string">&#x27;[&#123;elapsed: 0.8f&#125;]s &#123;name&#125;(&#123;arg_str&#125;) -&gt; &#123;result!r&#125;&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">clock</span>(<span class="hljs-params">fmt=DEFAULT_FMT</span>):<span class="hljs-comment"># 参数fmt: 格式化输出字符串</span><br>    <span class="hljs-string">&quot;&quot;&quot;参数化装饰器的工厂函数 clock: 每当被装饰的函数被调用时: 打印其运行时间,传入参数,调用结果</span><br><span class="hljs-string">       这是一个含参装饰器.装饰的函数是含参的,且有返回值的函数&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorate</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;decorate 才是真正的装饰器,其参数为一个函数.clock 用于接收装饰器的参数&quot;&quot;&quot;</span><br><span class="hljs-meta">        @functools.wraps(<span class="hljs-params">func</span>)</span><span class="hljs-comment"># 将相关的属性从 func 复制到 clocked 中.建议装饰器均使用</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">clocked</span>(<span class="hljs-params">*args, **kwargs</span>):<span class="hljs-comment"># 接收位置参数及关键字参数</span><br>            <span class="hljs-string">&quot;&quot;&quot;clocked 是真正被持有的函数对象.真正承担工作&quot;&quot;&quot;</span><br>            t0 = time.perf_counter()<span class="hljs-comment"># 获取初始时间</span><br>            result = func(*args, **kwargs)<span class="hljs-comment"># 调用原函数,计算结果</span><br>            elapsed = time.perf_counter() - t0<span class="hljs-comment"># 获取运行时间</span><br>            name = func.__name__<span class="hljs-comment"># 获取函数名</span><br>            arg_lst = [<span class="hljs-built_in">repr</span>(arg) <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> args]<br>            arg_lst.extend(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;k&#125;</span>=<span class="hljs-subst">&#123;v!r&#125;</span>&#x27;</span> <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> kwargs.items())<br>            arg_str = <span class="hljs-string">&#x27;,&#x27;</span>.join(arg_lst)  <span class="hljs-comment"># 获取参数列表,使用逗号将其分隔</span><br>            <span class="hljs-built_in">print</span>(fmt.<span class="hljs-built_in">format</span>(**<span class="hljs-built_in">locals</span>()))<span class="hljs-comment"># locals() 函数以字典形式返回所有局部变量</span><br>            <span class="hljs-comment"># 格式化输出形如: [0.00015620]s factorial(10) -&gt; 3628800</span><br>            <span class="hljs-keyword">return</span> result<span class="hljs-comment"># 由于 clocked 将取代被装饰的函数,因此需要返回真正的计算结果</span><br>        <span class="hljs-keyword">return</span> clocked<span class="hljs-comment"># 返回内部函数,取代被装饰的函数</span><br>    <span class="hljs-keyword">return</span> decorate<br></code></pre></td></tr></table></figure></li><li><p>使用装饰器(每次调用 <code>factorial</code> 函数时装饰器也会发挥作用)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@clock(<span class="hljs-params">fmt=<span class="hljs-string">&#x27;&#123;name&#125;(&#123;arg_str&#125;):\t &#123;elapsed: 0.7f&#125;s&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> n * factorial(n-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li><li><p>类装饰器示例(相对于装饰器函数而言,明显减少了嵌套的层数)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>DEFAULT_FMT = <span class="hljs-string">&#x27;[&#123;elapsed:0.8f&#125;s] &#123;name&#125;(&#123;args&#125;) -&gt; &#123;result&#125;&#x27;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, fmt=DEFAULT_FMT</span>):<br>        <span class="hljs-variable language_">self</span>.fmt = fmt<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, func</span>):  <span class="hljs-comment"># __call__ 魔法方法专注于添加功能即可</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">clocked</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            t0 = time.perf_counter()<br>            result = func(*args, **kwargs)<br>            elapsed = time.perf_counter() - t0<br>            name = func.__name__<br>            arg_lst = [<span class="hljs-built_in">repr</span>(arg) <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> args]<br>            arg_lst.extend(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;k&#125;</span>=<span class="hljs-subst">&#123;v!r&#125;</span>&#x27;</span> <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> kwargs.items())<br>            arg_str = <span class="hljs-string">&#x27;,&#x27;</span>.join(arg_lst)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-variable language_">self</span>.fmt.<span class="hljs-built_in">format</span>(**<span class="hljs-built_in">locals</span>()))<br>            <span class="hljs-keyword">return</span> result<br>        <span class="hljs-keyword">return</span> clocked<br>    <br><span class="hljs-meta">@Clock(<span class="hljs-params">fmt=<span class="hljs-string">&#x27;&#123;name&#125;(&#123;arg_str&#125;):\t &#123;elapsed: 0.7f&#125;s&#x27;</span></span>)  </span><span class="hljs-comment"># 使用类装饰器时用类名</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> n * factorial(n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li><li><p>装饰器 <code>@cache</code>(Python 3.9)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@functools.cache</span><span class="hljs-comment"># 要求被装饰函数的参数 可哈希</span><br><span class="hljs-meta">@clock()</span><span class="hljs-comment"># 该装饰器有参数,因而需要加上小括号,类似于函数调用</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> n <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> fibonacci(n-<span class="hljs-number">2</span>) + fibonacci(n-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><ul><li>叠放装饰器: <code>@</code> 只是一种语法糖,叠放多个装饰器的行为与嵌套函数类似</li><li><code>fibonacci</code> 函数运行缓慢的根本在于进行了多次重复计算</li><li><code>@cache</code> 装饰器可以将耗时函数的计算结果保存起来,从而避免传入相同参数的重复计算</li></ul></li><li><p>装饰器 <code>@lru_cache</code>: 可以通过 <code>maxsize</code> 参数设置内存用量上限</p><ul><li><p>LRU(Least Reccently Used): 一段时间不用的缓存条目</p></li><li><p><code>@cache</code> 是对 <code>@lru_cache</code> 的简单封装.<code>@lru_cache</code> 更加灵活,且兼容 Python 3.8 及之前的版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@lru_cache(<span class="hljs-params">maxsize=<span class="hljs-number">2</span>**<span class="hljs-number">20</span>, typed=<span class="hljs-literal">True</span></span>)  </span><span class="hljs-comment"># typed=True: 不同类型参数的计算结果分开存放</span><br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>流畅的 Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>流畅的 Python-数据模型</title>
    <link href="/2024/10/30/%E6%B5%81%E7%95%85%E7%9A%84Python/1.Python%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/10/30/%E6%B5%81%E7%95%85%E7%9A%84Python/1.Python%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="流畅的-Python-数据模型"><a href="#流畅的-Python-数据模型" class="headerlink" title="流畅的 Python-数据模型"></a>流畅的 Python-数据模型</h1><hr><h2 id="1-Python-风格"><a href="#1-Python-风格" class="headerlink" title="1 Python 风格"></a>1 Python 风格</h2><h3 id="1-1-Python-风格的纸牌"><a href="#1-1-Python-风格的纸牌" class="headerlink" title="1.1 Python 风格的纸牌"></a>1.1 Python 风格的纸牌</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br><br>Card = collections.namedtuple(<span class="hljs-string">&#x27;Card&#x27;</span>, [<span class="hljs-string">&#x27;rank&#x27;</span>, <span class="hljs-string">&#x27;suit&#x27;</span>])<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FrenchDeck</span>:<br>    ranks = [<span class="hljs-built_in">str</span>(n) <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">11</span>)] + <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;JQKA&#x27;</span>)<br>    suits = <span class="hljs-string">&#x27;spades diamonds clubs hearts&#x27;</span>.split()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>._cards = [Card(rank, suit) <span class="hljs-keyword">for</span> suit <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.suits<br>                                        <span class="hljs-keyword">for</span> rank <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.ranks]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 获取纸牌的数量(52).委托给内置函数 _cards 的 len() 函数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._cards)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, position</span>):  <span class="hljs-comment"># 获取某张纸牌.委托给 _cards 的 [] 操作符</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._cards[position]<br></code></pre></td></tr></table></figure><ol><li><p>代码说明</p><ul><li><code>Card</code>: 是一个具名元组,其名为<code>Card</code>,拥有2个字段 <code>rank</code>(大小) 和 <code>suit</code>(花色)</li><li><code>FrenchDeck</code>类具有<ul><li>属性<code>ranks</code>(2~10,J,Q,K,A), <code>suits</code>(4种纸牌的花色)</li><li>私有属性<code>_cards</code>: 13*4&#x3D;52张 <code>Card</code> 的列表</li></ul></li></ul></li><li><p>功能说明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choice<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    deck = FrenchDeck()  <span class="hljs-comment"># 实例化一副牌.Python 解释器将会调用 __init__ 方法</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;deck 的总数量为: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(deck)&#125;</span>&quot;</span>)  <span class="hljs-comment"># len 函数将会调用 __len__ 方法</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;随机抽的牌为: <span class="hljs-subst">&#123;choice(deck)&#125;</span>&quot;</span>)  <span class="hljs-comment"># choice 函数需要 __getitem__ 方法</span><br></code></pre></td></tr></table></figure></li><li><p>Python 风格</p><ul><li>为什么获取容器大小是内置函数 <code>len(collection)</code>, 而非 <code>collection.len()</code><ul><li><code>len</code> 作为内置函数可以在任何地方调用,而无需依赖特定的对象类型</li><li>性能: 内置函数的调用开销较低.如 CPython 内置长度会直接读取结构体中的字段</li><li>简洁性: 前缀比后缀更容易阅读和理解</li></ul></li><li>Python 解释器会调用特殊方法来执行基本对象操作.使操作方式获得统一</li></ul></li></ol><h3 id="1-2-容器-API-概括"><a href="#1-2-容器-API-概括" class="headerlink" title="1.2 容器 API 概括"></a>1.2 容器 API 概括</h3><p><img src="/2024/10/30/%E6%B5%81%E7%95%85%E7%9A%84Python/1.Python%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/assets/Container_API.png" alt="Container API"></p><ol><li><em>斜体</em>表示抽象方法,必须由其具体子类实现</li><li>顶部的3个抽象基类<code>Iterable, Sized, Container</code>均只有一个抽象方法</li><li>Python 不强制要求具体类继承这些抽象基类(如只要实现了<code>__len__</code>方法,就满足Sized接口)</li><li>Collection 具有三个重要的专用接口<ul><li><strong>Sequence</strong>: 规范 <code>list, str</code> 等内置类型的接口.也只有它实现了<code>__reversed__</code>方法</li><li><strong>Mapping</strong>: 被 <code>dict, collection.defaultdict</code> 等实现</li><li><strong>Set</strong>: 内置类型 <code>set, frozenset</code> 的接口</li></ul></li></ol><h3 id="1-3-魔法方法总览"><a href="#1-3-魔法方法总览" class="headerlink" title="1.3 魔法方法总览"></a>1.3 魔法方法总览</h3><ol><li><p>魔法方法(magic method)</p><ul><li>魔法方法命名形式为 <code>__*__</code>(使用前后双下划线,dunder)</li><li>魔法方法供 Python 解释器调用,而非自行调用</li></ul></li><li><p>魔法方法名称(应该有前后双下划线,这里省略了)</p><table><thead><tr><th>分类</th><th>方法名称</th></tr></thead><tbody><tr><td>字符串(字节)表示形式</td><td><strong>repr</strong>, <strong>str</strong>, format, bytes, fspath</td></tr><tr><td>转换为数值</td><td>bool, complex, int, float, hash, index</td></tr><tr><td>模拟容器</td><td><strong>len</strong>, <strong>getitem</strong>, setitem, delitem, contains</td></tr><tr><td>迭代</td><td><strong>iter</strong>, aiter, <strong>next</strong>, anext, reversed</td></tr><tr><td>可调用对象或执行协程</td><td>call, await</td></tr><tr><td>上下文管理</td><td>enter, exit, aexit, aenter</td></tr><tr><td>构造和析构</td><td>new, init, del</td></tr><tr><td>属性管理</td><td>getattr, getattribute, setattr, delattr, dir</td></tr><tr><td>属性描述符</td><td>get, set, delete, set_name</td></tr><tr><td>抽象基类</td><td>instancecheck, subclasscheck</td></tr><tr><td>类元编程</td><td>prepare, init_subclass, class_getitem, mro_entries</td></tr></tbody></table><ul><li><code>__len__()</code>: 供 <code>len()</code> 方法调用</li><li><code>__iter()</code>: 返回一个可迭代对象(如 <code>for i in x:</code>).一般和<code>__next()__</code>一起使用</li><li><code>__getitem__()</code>: 返回数据.将操作委托给 <code>[]</code> 操作符,还可以支持切片,则该对象成为可迭代对象</li></ul></li><li><p>运算符及其背后的特殊方法</p><table><thead><tr><th>一元运算符</th><th>正向方法</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td><code>__pos__</code></td><td>取正算术运算</td></tr><tr><td>-</td><td><code>__neg__</code></td><td>取反算术运算.x &#x3D;&#x3D; +x</td></tr><tr><td>~</td><td><code>__invert__</code></td><td>按位取反整数.~x &#x3D;&#x3D; -(x+1)</td></tr><tr><td>abs()</td><td><code>__abs__</code></td><td>取绝对值</td></tr></tbody></table><table><thead><tr><th>中缀运算符</th><th>正向方法</th><th>反向方法</th><th>就地方法</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td><code>__add__</code></td><td><code>__radd__</code></td><td><code>__iadd__</code></td><td>加法或拼接</td></tr><tr><td>-</td><td><code>__sub__</code></td><td><code>__rsub__</code></td><td><code>__isub__</code></td><td>减法</td></tr><tr><td>*</td><td><code>__mul__</code></td><td><code>__rmul__</code></td><td><code>__imul__</code></td><td>乘法或重复</td></tr><tr><td>&#x2F;</td><td><code>__truediv__</code></td><td><code>__rtruediv__</code></td><td><code>__itruediv__</code></td><td>除法</td></tr><tr><td>&#x2F;&#x2F;</td><td><code>__floordiv__</code></td><td><code>__rfloordiv__</code></td><td><code>__ifloordiv__</code></td><td>整除</td></tr><tr><td>%</td><td><code>__mod__</code></td><td><code>__rmod__</code></td><td><code>__imod__</code></td><td>求模</td></tr><tr><td>divmod()</td><td><code>__divmod__</code></td><td><code>__rdivmod__</code></td><td><code>__idivmod__</code></td><td>带余除法</td></tr><tr><td>**, pow()</td><td><code>__pow__</code></td><td><code>__rpow__</code></td><td><code>__ipow__</code></td><td>幂</td></tr><tr><td>@</td><td><code>__matmul__</code></td><td><code>__rmatmul__</code></td><td><code>__imatmul__</code></td><td>矩阵乘法</td></tr><tr><td>&amp;</td><td><code>__and__</code></td><td><code>__rand__</code></td><td><code>__iand__</code></td><td>位与</td></tr><tr><td>|</td><td><code>__or__</code></td><td><code>__ror__</code></td><td><code>__ior__</code></td><td>位或</td></tr><tr><td>^</td><td><code>__xor__</code></td><td><code>__rxor__</code></td><td><code>__ixor__</code></td><td>位异或</td></tr><tr><td>&lt;&lt;</td><td><code>__lshift__</code></td><td><code>__rlshift__</code></td><td><code>__ilshift__</code></td><td>按位左移</td></tr><tr><td>&gt;&gt;</td><td><code>__rshift__</code></td><td><code>__rrshift__</code></td><td><code>__irshift__</code></td><td>按位右移</td></tr></tbody></table><table><thead><tr><th>分组</th><th>比较运算符</th><th>正向方法调用</th><th>反向方法调用</th><th>后备机制</th></tr></thead><tbody><tr><td>相等性</td><td>a &#x3D;&#x3D; b</td><td><code>a.__eq__(b)</code></td><td><code>b.__eq__(a)</code></td><td>返回 id(a) &#x3D;&#x3D; id(b)</td></tr><tr><td></td><td>a !&#x3D; b</td><td><code>a.__ne__(b)</code></td><td><code>b.__ne__(a)</code></td><td>返回 not(a &#x3D;&#x3D; b)</td></tr><tr><td>排序</td><td>a &gt; b</td><td><code>a.__gt__(b)</code></td><td><code>b.__lt__(a)</code></td><td>抛出 TypeError</td></tr><tr><td></td><td>a &lt; b</td><td><code>a.__lt__(b)</code></td><td><code>b.__gt__(a)</code></td><td>抛出 TypeError</td></tr><tr><td></td><td>a &gt;&#x3D; b</td><td><code>a.__ge__(b)</code></td><td><code>b.__le__(a)</code></td><td>抛出 TypeError</td></tr><tr><td></td><td>a &lt;&#x3D; b</td><td><code>a.__le__(b)</code></td><td><code>b.__ge__(a)</code></td><td>抛出 TypeError</td></tr></tbody></table></li></ol><h2 id="2-序列"><a href="#2-序列" class="headerlink" title="2 序列"></a>2 序列</h2><h3 id="2-1-内置序列类型"><a href="#2-1-内置序列类型" class="headerlink" title="2.1 内置序列类型"></a>2.1 内置序列类型</h3><ol><li><p>序列类型</p><ul><li><strong>容器序列存放的是对象的引用(指针).扁平序列存放值</strong></li><li><strong>容器序列</strong>: 元素类型可以不同,可嵌套容器.如 <code>list, tuple, collections.deque</code> </li><li><strong>扁平序列</strong>: 元素类型只能有一种.如 <code>string, bytes, array.array</code></li><li>任何 Python 对象在内存中都有一个<strong>包含元数据的标头</strong><ul><li>如最简单的 Python 对象 float.内存标头有一个值字段,两个元数据字段</li><li><code>ob_refcnt</code>: 对象引用计数</li><li><code>ob_type</code>: 指向对象类型的指针</li><li><code>ob_fval</code>: C语言的 <code>double</code> 类型值,存放 <code>float</code> 的值</li></ul></li></ul></li><li><p>按可变性序列可分为</p><ul><li><p><strong>可变序列</strong>: 如 <code>list</code>, <code>bytearray</code>, <code>array.array</code>, <code>collection.deque</code> </p></li><li><p><strong>不可变序列</strong>: 如 <code>tuple</code>, <code>str</code>, <code>bytes</code> </p></li><li><p><strong>可变序列继承不可变序列的所有方法,且额外还实现其他方法</strong></p><p><img src="/2024/10/30/%E6%B5%81%E7%95%85%E7%9A%84Python/1.Python%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/assets/Sequence.png" alt="image-20231230141211275"></p></li></ul></li><li><p><strong>列表推导式</strong>: 可筛选和转换可迭代类中的项,并以此构建列表.提高代码可读性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">l = [表达式 <span class="hljs-keyword">for</span> 变量 <span class="hljs-keyword">in</span> 列表 <span class="hljs-keyword">if</span> 条件] <span class="hljs-comment"># 其中条件语句是可选的</span><br>l = [ out_exp_res <span class="hljs-keyword">for</span> out_exp <span class="hljs-keyword">in</span> input_list <span class="hljs-keyword">if</span> condition ]<br></code></pre></td></tr></table></figure></li><li><p><strong>生成器表达式</strong>: 句法与列表表达式类似,区别在于用 <code>()</code> 代替 <code>[]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> array<br><br>symbols = <span class="hljs-string">&#x27;$¢£¥€¤&#x27;</span><br>tup = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">ord</span>(symbol) <span class="hljs-keyword">for</span> symbol <span class="hljs-keyword">in</span> symbols)  <span class="hljs-comment"># (36, 162, 163, 165, 8364, 164)</span><br>arr = array.array(<span class="hljs-string">&#x27;I&#x27;</span>, (<span class="hljs-built_in">ord</span>(symbol) <span class="hljs-keyword">for</span> symbol <span class="hljs-keyword">in</span> symbols))<br></code></pre></td></tr></table></figure><ul><li>生成器表达式使用迭代器协议逐个产出项,而不是构建整个列表提供给其他构造函数</li><li>当生成器表达式作为函数的唯一参数时,可以省略 <code>()</code></li></ul></li><li><p>元组与列表</p><ul><li>元组通常用于<ul><li><strong>不可变列表</strong>: 意图清晰,其长度不可变; 相对于列表占用内存更少</li><li><strong>无需字段名称的记录</strong>: 使用位置信息决定数据的意义.使用拆包获取数据</li></ul></li><li>元组支持的方法: 所有不进行增删项的列表方法</li><li>元组没有 <code>__reversed__</code> 方法.但仍可运行 <code>reversed(myTuple)</code></li></ul></li></ol><h3 id="2-2-可迭代对象拆包"><a href="#2-2-可迭代对象拆包" class="headerlink" title="2.2 可迭代对象拆包"></a>2.2 可迭代对象拆包</h3><ol><li><p>拆包(不用手动通过索引获得元素)</p><ul><li><p>目标: 任何可迭代对象.包括不支持索引表示法的迭代器</p></li><li><p>要求: 一次仅产出一项,将其提供给接收端变量(除了 <code>*</code>)</p></li><li><p>并行赋值: 将可迭代对象中的项赋值给变量元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">vector = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>x, y = vector <span class="hljs-comment"># x=10, y=20</span><br></code></pre></td></tr></table></figure></li><li><p>交换变量的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a, b = b, a<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用<code>*</code> 获取余下的项</strong></p><ul><li><p>函数定义时使用 <code>*arg</code> 可捕获余下任意数量的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a, b, c, d, *rest</span>):  <span class="hljs-comment"># 在函数调用时,可以多次使用 *</span><br>    <span class="hljs-keyword">return</span> a, b, c, d, rest<br>func(*[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">3</span>, *<span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>, <span class="hljs-number">7</span>))  <span class="hljs-comment"># (1, 2, 3, 4, (5, 6))</span><br></code></pre></td></tr></table></figure></li><li><p>相似的,<code>*</code> 也可用于并行赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a, b, *rest, d = <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)  <span class="hljs-comment"># a=0, b=1, rest=[2, 3], d=4</span><br></code></pre></td></tr></table></figure></li><li><p>区别: <code>*</code> 并行赋值时只有一个变量可被 <code>*</code> 装饰.而该变量的位置并不强制要求在最后</p></li></ul></li><li><p>定义列表, 元组, 集合字面量时也可使用 <code>*</code> </p></li><li><p>拆包可以嵌套</p></li></ol><h3 id="2-3-切片-slice"><a href="#2-3-切片-slice" class="headerlink" title="2.3 切片 slice"></a>2.3 切片 slice</h3><ol><li><p><strong>形如 <code>seq[start, end, step]</code> 将会返回一个切片对象</strong></p><ul><li><p>Python 调用<code>seq.__getitem__(slice(start, stop, step))</code>求解切片 <code>seq[start:stop,step]</code></p></li><li><p>为切片起名可提高代码可读性</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">sliceName = <span class="hljs-built_in">slice</span>(start, end, step)<br>seq[slicename]<br></code></pre></td></tr></table></figure></li></ul></li><li><p>多维切片</p><ul><li><code>__getitem__</code>和<code>__setitem__</code> 是负责处理 <code>[]</code> 运算符的特殊方法</li><li>为求解 <code>a[i, j]</code>,Python 将调用 <code>a.__getitem__((i,j))</code> </li><li>若 a 为二维数组,可用 <code>a[m:n, k:l]</code> 获取二维切片</li></ul></li></ol><h3 id="2-4-排序-sort"><a href="#2-4-排序-sort" class="headerlink" title="2.4 排序 sort"></a>2.4 排序 sort</h3><ol><li><p>**<code>list.sort()</code> 方法就地排序,不创建副本.**返回值为 <code>None</code>(Python 约定: 就地更改的函数返回 <code>None</code>)</p></li><li><p><strong>内置函数 <code>sorted</code> 返回创建的新列表</strong></p></li><li><p>二者均接受两个可选的关键字参数</p><ul><li><code>reverse</code>: 默认为 <code>False</code>.当其值为 <code>Ture</code> 时反向排序</li><li><code>key</code>: 仅接收一个参数的函数.作用于每一项,作为排序的依据<ul><li><code>key=str.lower</code>将执行不区分大小写的排序</li><li><code>key=len</code>按字符长度排序各个字符串</li></ul></li><li>默认情况下,Python 按字符代码的字典顺序排序字符串</li><li>ASCII 大写字母将排在小写字母之前</li></ul></li><li><p>示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&#x27;grape&#x27;</span>, <span class="hljs-string">&#x27;raspberry&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>]<br><span class="hljs-built_in">sorted</span>(fruits)<span class="hljs-comment"># 默认排序 [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;grape&#x27;, &#x27;raspberry&#x27;]</span><br><span class="hljs-built_in">sorted</span>(fruits, reverse = <span class="hljs-literal">True</span>)<span class="hljs-comment"># 反向排序 [&#x27;raspberry&#x27;, &#x27;grape&#x27;, &#x27;banana&#x27;, &#x27;apple&#x27;]</span><br><span class="hljs-built_in">sorted</span>(fruits, key = <span class="hljs-built_in">len</span>)    <span class="hljs-comment"># 长度排序 [&#x27;grape&#x27;, &#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;raspberry&#x27;]</span><br>fruits.sort()   <span class="hljs-comment"># 就地排序 [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;grape&#x27;, &#x27;raspberry&#x27;]</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-5-列表的替代"><a href="#2-5-列表的替代" class="headerlink" title="2.5 列表的替代"></a>2.5 列表的替代</h3><ol><li><p>数组</p><ul><li><p>若列表中只包含数值,则使用 <code>array.array</code> 更高效</p><ul><li>数组支持所有可变序列操作(包括 <code>pop, insert, extend</code>)</li><li>此外数组还有快速加载项和保存项方法.如 <code>frombytes, tofile</code></li></ul></li><li><p>创建 <code>array</code> 对象需要提供类型代码,用来确定底层 C 如何存储数组元素</p><table><thead><tr><th>类型码</th><th>C 类型</th><th>Python 类型</th><th>最小尺寸(字节)</th></tr></thead><tbody><tr><td>‘b’</td><td>signed char</td><td>int</td><td>1</td></tr><tr><td>‘B’</td><td>unsigned char</td><td>int</td><td>1</td></tr><tr><td>‘u’</td><td>wchar_t</td><td>Unicode 字符</td><td>2</td></tr><tr><td>‘h’</td><td>signed short</td><td>int</td><td>2</td></tr><tr><td>‘H’</td><td>unsigned short</td><td>int</td><td>2</td></tr><tr><td>‘i’</td><td>signed int</td><td>int</td><td>2</td></tr><tr><td>‘I’</td><td>unsigned int</td><td>int</td><td>2</td></tr><tr><td>‘l’</td><td>signed long</td><td>int</td><td>4</td></tr><tr><td>‘L’</td><td>unsigned long</td><td>int</td><td>4</td></tr><tr><td>‘q’</td><td>signed long long</td><td>int</td><td>8</td></tr><tr><td>‘Q’</td><td>unsigned long long</td><td>int</td><td>8</td></tr><tr><td>‘f’</td><td>float</td><td>float</td><td>4</td></tr><tr><td>‘d’</td><td>double</td><td>float</td><td>8</td></tr></tbody></table></li><li><p>示例: 创建, 保存, 加载大型浮点数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> array <span class="hljs-keyword">import</span> array<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> random<br><br><span class="hljs-comment"># floats: 拥有 10^7 个 double 类型元素的数组</span><br>floats = array(<span class="hljs-string">&#x27;d&#x27;</span>, ( random() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>**<span class="hljs-number">7</span>) )) <br>fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;float.bin&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>)<br>floats.tofile(fp)  <span class="hljs-comment"># 将数组存入二进制文件</span><br>fp.close()<br>   <br>floats2 = array(<span class="hljs-string">&#x27;d&#x27;</span>)<br>fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;float.bin&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-comment"># 从二进制文件中读出数据</span><br>floats2.fromfile(fp, <span class="hljs-number">10</span>**<span class="hljs-number">7</span>)<br>fp.close()<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>memoryview</code> </p><ul><li><p>内置类 <code>memoryview</code> 是一种共享内存的序列类型,可在不复制字节的情况下处理数组的切片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> array <span class="hljs-keyword">import</span> array<br>octets = array(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>))   <span class="hljs-comment"># 拥有6个 unsigned char 类型元素的数组</span><br>matrix1 = <span class="hljs-built_in">memoryview</span>(octets)    <span class="hljs-comment"># 将 array 转化为 memoryview 类型.使其共享内存</span><br>matrix2 = m1.cast(<span class="hljs-string">&#x27;B&#x27;</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>])  <span class="hljs-comment"># 将 内存视图 转为新形状(2*3 矩阵)</span><br>matrix3 = m1.cast(<span class="hljs-string">&#x27;B&#x27;</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>NumPy</code> </p><ul><li><p>属于第三方库,需要 <code>pip install NumPy</code> </p><ul><li>实现了多维同构数组和矩阵类型</li><li>除存放数值,还可以存放用户定义的记录</li><li>提供高效的元素层面操作</li></ul></li><li><p>在 <code>NumPy</code> 基础上编写的 <code>SciPy</code> 提供了很多科学计算算法(线性代数,数值积分,统计学)</p><ul><li>速度快,运算可靠</li><li>沿用了 Netlib Repository 的 C 语言和 Fortran 基准代码</li></ul></li><li><p>基础功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.arange(<span class="hljs-number">12</span>) <span class="hljs-comment"># 创建一个 numpy.ndarray 对象</span><br>a.sharp = <span class="hljs-number">3</span>, <span class="hljs-number">4</span>    <span class="hljs-comment"># 改变维度</span><br>a.transpose()  <span class="hljs-comment"># 转置</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>队列</p><ul><li><p>列表的 <code>append, pop</code> 方法使其可以作为栈或队列使用,但在列表头部插入和删除项有一定开销</p></li><li><p><code>collections.deque</code> 实现了一种线程安全的双端队列</p></li><li><p>处理 <code>deque</code> 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>dq = deque( <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>), maxlen=<span class="hljs-number">10</span> ) <span class="hljs-comment"># maxlen 指定deque实例中允许存放的项数</span><br>dq.rotate(<span class="hljs-number">3</span>)                       <span class="hljs-comment"># 轮换,参数大于0时将右端放到左端</span><br>dq.rotate(-<span class="hljs-number">4</span>)                      <span class="hljs-comment">#</span><br>dq.appendleft(-<span class="hljs-number">1</span>)                  <span class="hljs-comment"># 在左端追加项,此时项数已满,右端对应数量的项将被挤掉</span><br>dq.extend([<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>])            <span class="hljs-comment"># 在右端追加项,左端对应数量的项将被挤掉</span><br>dq.extendleft([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>])        <span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="3-字典和集合"><a href="#3-字典和集合" class="headerlink" title="3 字典和集合"></a>3 字典和集合</h2><h3 id="3-1-字典"><a href="#3-1-字典" class="headerlink" title="3.1 字典"></a>3.1 字典</h3><ol><li><p>字典推导式: <code>&#123; key_expr: value_expr for key, value in collection if condition &#125;</code> </p></li><li><p><strong>映射拆包</strong></p><ul><li><p>调用函数时,允许多个参数使用 <code>**</code>.但 <code>key</code> 必须是字符串,且该参数唯一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dump</span>(<span class="hljs-params">**kwargs</span>):<br>    <span class="hljs-keyword">return</span> kwargs<br>dump( **&#123;<span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-number">1</span>&#125;, y=<span class="hljs-number">2</span>, **&#123;<span class="hljs-string">&#x27;z&#x27;</span>: <span class="hljs-number">3</span>&#125; ) <span class="hljs-comment"># 结果为 &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2, &#x27;z&#x27;: 3&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><code>**</code> 可在 <code>dict</code> 字面量中多次使用(此时允许 <code>key</code> 重复,靠前的将被覆盖)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123; <span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">0</span>, **&#123;<span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-number">1</span>&#125;, <span class="hljs-string">&#x27;y&#x27;</span>: <span class="hljs-number">2</span>, **&#123;<span class="hljs-string">&#x27;z&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-number">4</span>&#125; &#125;<br><span class="hljs-comment"># 其值为 &#123;&#x27;a&#x27;: 0, &#x27;x&#x27;: 4, &#x27;y&#x27;: 2, &#x27;z&#x27;: 3&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>使用 <code>|</code> 合并映射(Python 3.9 支持)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">d1 = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>&#125;<br>d2 = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">6</span>&#125;<br><span class="hljs-comment"># 则 d1 | d2 = &#123;&#x27;a&#x27;: 2, &#x27;b&#x27;: 4, &#x27;c&#x27;: 6&#125;</span><br></code></pre></td></tr></table></figure><ul><li>通常新映射类型与左操作数相同</li><li>使用 <code>|=</code> 可以合并后立即赋值</li></ul></li><li><p>映射类型的标准 API</p><p><img src="/2024/10/30/%E6%B5%81%E7%95%85%E7%9A%84Python/1.Python%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/assets/Mapping_API.png" alt="Mapping API"></p></li></ol><h3 id="3-2-映射模式匹配"><a href="#3-2-映射模式匹配" class="headerlink" title="3.2 映射模式匹配"></a>3.2 映射模式匹配</h3><ol><li><p><code>match/case</code> 语句匹配的对象可以是映射</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_creators</span>(<span class="hljs-params">record: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">list</span>: <span class="hljs-comment"># -&gt; list 表示提示这个函数返回值为 list 类型</span><br>    <span class="hljs-keyword">match</span> record:<br>        <span class="hljs-comment"># 匹配的映射对象为 &#x27;type&#x27;: &#x27;book&#x27;, &#x27;api&#x27;: 2, 且 &#x27;author&#x27; 键值映射一个序列</span><br>        <span class="hljs-keyword">case</span> &#123;<span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;book&#x27;</span>, <span class="hljs-string">&#x27;api&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;authors&#x27;</span>: [*names]&#125;:<br>            <span class="hljs-keyword">return</span> names<br>        <span class="hljs-comment"># 匹配的映射对象为 &#x27;type&#x27;: &#x27;book&#x27;, &#x27;api&#x27;: 1, 且 &#x27;author&#x27; 键值映射任何对象</span><br>        <span class="hljs-keyword">case</span> &#123;<span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;book&#x27;</span>, <span class="hljs-string">&#x27;api&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;authors&#x27;</span>: name&#125;:<br>            <span class="hljs-keyword">return</span> [name]<br>        <span class="hljs-comment"># 匹配的映射对象为 包含&#x27;type&#x27;: &#x27;book&#x27;的所有映射对象</span><br>        <span class="hljs-keyword">case</span> &#123;<span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;book&#x27;</span>&#125;:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;Invalid &#x27;book&#x27; record: <span class="hljs-subst">&#123;record!r&#125;</span>&quot;</span>)<br>        <span class="hljs-comment"># 匹配的映射对象为 &#x27;type&#x27;: &#x27;movie&#x27;,且 &#x27;director&#x27; 键值映射任何对象</span><br>        <span class="hljs-keyword">case</span> &#123;<span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;movie&#x27;</span>, <span class="hljs-string">&#x27;director&#x27;</span>: name&#125;:<br>            <span class="hljs-keyword">return</span>[name]<br>        <span class="hljs-comment"># _ 在匹配时表示通配符</span><br>        <span class="hljs-keyword">case</span> _:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;Invalid record: <span class="hljs-subst">&#123;record!r&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>模式中 <code>key</code> 的顺序无关紧要<ul><li><code>OrderedDict</code> 也可以作为匹配对象</li><li>与序列模式匹配不同,映射就算只有部分匹配也算成功匹配</li></ul></li></ul></li><li><p><strong>可 Hash</strong>: 对象的哈希码在整个生命周期不变(<code>__hash__</code>方法),且可与其他对象比较(<code>__eq__</code>方法)</p><ul><li>可 Hash 对象的相等 $\iff$ 哈希码相等</li><li>数值类型及不可变的扁平类型(<code>str</code>,<code>bytes</code>) $\Rightarrow$ 可Hash</li><li>若容器本身不可变,且其元素也全为不可变的.$\Rightarrow$ 可Hash</li></ul></li></ol><h3 id="3-3-字典视图"><a href="#3-3-字典视图" class="headerlink" title="3.3 字典视图"></a>3.3 字典视图</h3><ol><li><p><code>dict</code> 的方法 <code>.key(), .values(), .items()</code> 分别返回 <code>dict_keys</code>,<code>dict_values</code>,<code>dict_items</code>类的实例</p><ul><li><p>这些字典视图是 <code>dict</code> 内部实现使用的数据结构的只读投影</p></li><li><p>视图对象是动态代理的: 当原 <code>dict</code> 对象更新后,现有视图对象立即变化</p></li><li><p>字典视图的基本操作</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">d = <span class="hljs-built_in">dict</span>(a=<span class="hljs-number">10</span>, b=<span class="hljs-number">20</span>, c=<span class="hljs-number">30</span>)<span class="hljs-comment"># d = &#123;&#x27;a&#x27;: 10, &#x27;b&#x27;: 20, &#x27;c&#x27;: 30&#125;</span><br>values = d.values()         <span class="hljs-comment"># values = dict_values([10, 20, 30])</span><br><span class="hljs-built_in">len</span>(values)                 <span class="hljs-comment"># 获取长度</span><br><span class="hljs-built_in">list</span>(values)                <span class="hljs-comment"># 视图是可迭代对象,可将其转换为列表</span><br><span class="hljs-built_in">reversed</span>(values)            <span class="hljs-comment"># 有__reversed__方法,返回一个自定义迭代器</span><br>values[<span class="hljs-number">0</span>]                   <span class="hljs-comment"># TypeError: &#x27;dict_values&#x27; object is not subscriptable</span><br></code></pre></td></tr></table></figure></li><li><p><code>dict_values</code> 仅实现了 <code>__len__</code>, <code>__iter__</code>, <code>__reversed__</code> 三个特殊方法.是最简单的字典视图</p></li></ul></li><li><p>Python 使用哈希表实现 <code>dict</code></p><ul><li><code>key</code> 必须可 Hash.必须正确实现 <code>__hash__</code>, <code>__eq__</code> </li><li>通过 <code>key</code> 访问项的速度非常快.通过计算 <code>key</code> 的哈希码直接定位</li><li>为节省内存,不要在 <code>__init__</code> 之外创建实例属性</li></ul></li></ol><h3 id="3-4-集合"><a href="#3-4-集合" class="headerlink" title="3.4 集合"></a>3.4 集合</h3><ol><li><p><code>set</code>: 一组唯一的对象,基本作用是去除重复项</p><ul><li><p>集合元素必须 可 Hash.但 <code>set</code> 本身不可 Hash,因此不可嵌套.而 <code>frozenset</code> 可Hash</p></li><li><p>集合可以使用运算符 <code>|, &amp;, -, ^</code> 进行 并, 交, 差, 对称差操作</p></li><li><p>计算两个集合的重复元素个数的示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">found = <span class="hljs-built_in">len</span>(needles &amp; haystack)             <span class="hljs-comment"># 需要 needles, haystack 是集合</span><br>found = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(needles) &amp; <span class="hljs-built_in">set</span>(haystack))   <span class="hljs-comment"># 仅要求 needles, haystack 是可迭代对象</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>set</code> 字面量</p><ul><li><code>set</code> 字面量的写法与数学写法类似( 如<code>&#123;1, 2&#125;</code> ).空集需要写为 <code>set()</code> </li><li><code>frozenset</code> 没有字面量写法,必须调用构造函数( 如<code>frozenset(range(10))</code>)</li></ul></li><li><p><code>set</code> 实现</p><ul><li>底层用哈希表实现.成员测试效率非常高</li><li>向集合添加元素后,现有元素的顺序可能发生变化</li></ul></li><li><p>集合谓词</p><ul><li>$\in$: in</li><li>$\subseteq$: <code>&lt;=</code>  $\subset$: <code>&lt;</code></li><li>$\supseteq$: <code>&gt;=</code>  $\supset$: <code>&gt;</code></li><li>不相交: <code>isdisjoint</code></li></ul></li><li><p>集合类型的标准 API</p><p><img src="/2024/10/30/%E6%B5%81%E7%95%85%E7%9A%84Python/1.Python%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/assets/Set_API.png" alt="Set API"></p></li><li><p>集合视图</p><ul><li><code>dict_keys, dict_items</code> 和 <code>frozenset</code> 非常相似</li><li>相较于 <code>dict_values</code>,它们拥有的方法更多.支持很多集合方法</li><li>字典视图的集合运算符兼容 <code>set</code> 实例</li><li>仅当 <code>dict</code> 中的所有 <code>value</code> 可 Hash 时, <code>dict_items</code> 视图才可当作集合使用</li><li>由于所有的 <code>key</code> 均可 Hash.<code>dict_keys</code> 视图天然可作为集合使用</li></ul></li></ol><h2 id="4-字节序列"><a href="#4-字节序列" class="headerlink" title="4 字节序列"></a>4 字节序列</h2><h3 id="4-1-字符"><a href="#4-1-字符" class="headerlink" title="4.1 字符"></a>4.1 字符</h3><ol><li><p>Unicode 字符的标识(码点)</p><ul><li>Python3 默认采用 utf-8 编码源码</li><li>范围为 0 ~ 1114111.在 Unicode 中以4~6个十六进制数表示</li><li>前缀为 U+,取值范围为 U+0000 ~ U+10FFFF.如 A 的码点为 U+0041</li><li>字符的具体表述取决于所用的编码<ul><li><strong>编码</strong>: 将码点转换为字节序列的过程</li><li><strong>解码</strong>: 将字节序列转换为码点的过程</li></ul></li></ul></li><li><p>编码与解码示例(<code>bytes</code> 字面量以 <code>b</code> 开头)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;Café&#x27;</span><br>b = s.encode(encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<span class="hljs-comment"># 将 str 对象编码为 bytes 对象</span><br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># b := b&#x27;Caf\xc3\xa9&#x27;</span><br>b.decode(encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span>)    <span class="hljs-comment"># &#x27;Café&#x27;.将 bytes 对象解码为 str 对象</span><br></code></pre></td></tr></table></figure></li><li><p>字节</p><ul><li>Python 内置2种基本的二进制序列类型: <code>bytes, bytearray</code> </li><li><code>bytes, bytearray</code> 中元素为 0~255 的整数</li><li>对 <code>bytes</code> 进行切片仍为<code>bytes</code>对象.但通过索引取出其元素则为 <code>int</code> 对象</li></ul></li><li><p><strong>ASCII 是所有编码的共同子集</strong></p><ul><li>若文本全为 ASCII 字符,编码一定会成功</li><li><code>str.isascii</code> 方法(Python 3.7)可以测试文本是否全由 ASCII 字符组成</li></ul></li></ol><h3 id="4-2-文本文件处理"><a href="#4-2-文本文件处理" class="headerlink" title="4.2 文本文件处理"></a>4.2 文本文件处理</h3><ol><li>Unicode 三明治原则<ul><li>尽早将输入的 <code>bytes</code> 解码为 <code>str</code> </li><li><strong>程序的业务只处理 <code>str</code> 对象</strong>.在其他处理过程中,不能编码或解码</li><li>尽晚将 <code>str</code> 编码成 <code>bytes</code></li></ul></li><li>二进制模式<ul><li>不要以二进制模式打开文本文件.就算是为了判断编码,也应使用 <code>Chardet</code> </li><li>二进制模式只适合打开二进制文件.如光栅图像</li></ul></li><li>默认编码<ul><li>GNU&#x2F;Linux,macOS 始终使用 UTF-8</li><li>Windows 不仅同一系统中使用不同的编码,一些代码页往往只支持 ACSII</li><li><strong>不要依赖默认编码,在程序中应显式地指定编码</strong></li></ul></li></ol><h3 id="4-3-规范化-Unicode"><a href="#4-3-规范化-Unicode" class="headerlink" title="4.3 规范化 Unicode"></a>4.3 规范化 Unicode</h3><ol><li><p>Unicode</p><ul><li><p>Unicode 组合字符: 变音符和附加到前一字符上的记号,而打印时作为一个整体</p></li><li><p><code>Café</code> 的表示法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;Café&#x27;</span>                            <span class="hljs-comment"># len(s1) = 4</span><br>s2 = <span class="hljs-string">&#x27;Cafe\u0301&#x27;</span><span class="hljs-comment"># len(s2) = 5 </span><br>s3 = <span class="hljs-string">&#x27;Cafe\N&#123;COMBINING ACUTE ACCENT&#125;&#x27;</span>  <span class="hljs-comment"># len(s3) = 5 </span><br></code></pre></td></tr></table></figure><ul><li><code>COMBINING ACUTE ACCENT</code>(U+0301) 会将 <code>e</code> 打印为 <code>é </code> </li><li>根据 Unicode 标准: <code>é</code> 等价于 <code>e\u0301</code>.因此程序应将其视为相等,但 Python 并不这么认为</li></ul></li><li><p><strong>使用 <code>unicodedata.normalize()</code> 函数规范化字符串</strong></p><ul><li>第1个参数的值为: <code>&#39;NFC&#39;, &#39;NFD&#39;, &#39;NFKC&#39;, &#39;NFKD&#39;</code> 中的某个</li><li>NFC(Normalization From C): 使用最少的码点构成等价的字符串</li><li>NFD: 把合成字符分解成基字符和单独的组合字符</li><li>NFKC, NFKD 中的 K 表示 兼容性(compatibility).规范性形式较严格</li></ul></li><li><p>用户输入的文本默认为 NFC 形式.但仍应在保存文本前 使用 <code>normalize(&#39;NFC&#39;, user_text)</code> 规范化字符串</p><ul><li>规范化时,电阻单位<code>Ω</code> 将被保存为希腊大写字母 Omega: <code>Ω</code> </li><li>它们看起来完全一样,但在比较时并不相等</li></ul></li></ul></li><li><p>大小写同一化</p><ul><li><p><strong>将所有的文本变成小写,再进行其他转换.使用 <code>str.casefold()</code> 实现</strong></p></li><li><p>NFC 是最好的规范化形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> unicodedata <span class="hljs-keyword">import</span> normalize<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">nfc_equal</span>(<span class="hljs-params">str1, str2</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;规范化后进行比较字符串,区分大小写&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> normalize(<span class="hljs-string">&#x27;NFC&#x27;</span>, str1) == normalize(<span class="hljs-string">&#x27;NFC&#x27;</span>, str2)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fold_equal</span>(<span class="hljs-params">str1, str2</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;规范化后进行比较字符串,大小写同一化&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> ( normalize(<span class="hljs-string">&#x27;NFC&#x27;</span>, str1).casefold() == <br>             normalize(<span class="hljs-string">&#x27;NFC&#x27;</span>, str2).casefold() )<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="5-数据类构建器"><a href="#5-数据类构建器" class="headerlink" title="5 数据类构建器"></a>5 数据类构建器</h2><h3 id="5-1-类构建器"><a href="#5-1-类构建器" class="headerlink" title="5.1 类构建器"></a>5.1 类构建器</h3><ol><li><p>数据类: 仅是字段的容器,几乎没有额外功能.可简化数据类构建过程的容器</p><ul><li><code>collections.namedtuple</code>: 是工厂方法,根据指定的名称和字段创建 tuple 的子类</li><li><code>typing.NameTuple</code>: 还可以为各个字段添加类型注解</li><li><code>@dataclasses.dataclass</code>: 类装饰器,可定制更多功能</li></ul></li><li><p><code>collections.namedtuple</code> 示例.具有自定义自动提供的 <code>__init__, __repr__, __eq__</code> 等方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br>Coordinate = namedtuple(<span class="hljs-string">&#x27;Coordinate&#x27;</span>, <span class="hljs-string">&#x27;lat lon&#x27;</span>)  <span class="hljs-comment"># Coordinate 是具名元组类</span><br><span class="hljs-built_in">issubclass</span>(Coordinate, <span class="hljs-built_in">tuple</span>)  <span class="hljs-comment"># True. Coordinate 是 tuple 的子类</span><br>moscow = Coordinate(<span class="hljs-number">55.756</span>, <span class="hljs-number">37.617</span>)  <span class="hljs-comment"># 创建数据对象</span><br></code></pre></td></tr></table></figure></li><li><p><code>typing.NameTuple</code> 示例: 可以添加注解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> typing<br>Coordinate = typing.NamedTuple(<span class="hljs-string">&#x27;Coordinate&#x27;</span>,<br>                               [(<span class="hljs-string">&#x27;lat&#x27;</span>, <span class="hljs-built_in">float</span>), (<span class="hljs-string">&#x27;lon&#x27;</span>, <span class="hljs-built_in">float</span>)])<br>Coordinate = typing.NamedTuple(<span class="hljs-string">&#x27;Coordinate&#x27;</span>, lat=<span class="hljs-built_in">float</span>, lon=<span class="hljs-built_in">float</span>)  <span class="hljs-comment"># 更好的可读性</span><br>typing.get_type_hints(Coordinate)  <span class="hljs-comment"># &#123;&#x27;lat&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;lon&#x27;: &lt;class &#x27;float&#x27;&gt;&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><code>@dataclasses.dataclass</code> 示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass<br><span class="hljs-meta">@dataclass(<span class="hljs-params">frozen=<span class="hljs-literal">True</span></span>)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>:<br>    lat: <span class="hljs-built_in">float</span><br>    lon: <span class="hljs-built_in">float</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        ns = <span class="hljs-string">&#x27;N&#x27;</span> <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.lat &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;S&#x27;</span><br>        we = <span class="hljs-string">&#x27;E&#x27;</span> <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.lon &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;W&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">abs</span>(self.lat):<span class="hljs-number">.1</span>f&#125;</span>°<span class="hljs-subst">&#123;ns&#125;</span>, <span class="hljs-subst">&#123;<span class="hljs-built_in">abs</span>(self.lon):<span class="hljs-number">.1</span>f&#125;</span>°<span class="hljs-subst">&#123;we&#125;</span>&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>比较3个数据类构建器</p><table><thead><tr><th></th><th><code>namedtuple</code></th><th>Namedtuple</th><th>dataclass</th></tr></thead><tbody><tr><td>可变实例</td><td><code>tuple</code> 子类,不可变</td><td><code>tuple</code> 子类,不可变</td><td>默认构建可变的类</td></tr><tr><td>class 语句句法</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>构建字典</td><td><code>x.asdict()</code></td><td><code>x.asdict()</code></td><td><code>dataclasses.asdict()</code></td></tr><tr><td>获取字段名称</td><td><code>x._fields</code></td><td><code>x._fields</code></td><td><code>[f.name for f in dataclasses.fields(x)]</code></td></tr><tr><td>获取默认值</td><td><code>x._field_defaults</code></td><td><code>x._field_defaults</code></td><td><code>[f.default for f in dataclasses.fields(x)]</code></td></tr><tr><td>获取字段类型</td><td>N&#x2F;A</td><td><code>x.__annotations__</code></td><td><code>x.__annotations__</code></td></tr><tr><td>更改后创建实例</td><td><code>x._replace(...)</code></td><td><code>x.replace(...)</code></td><td><code>dataclasses.replace(x, ...)</code></td></tr><tr><td>运行时定义新类</td><td><code>namedtuple(...)</code></td><td><code>NamedTuple(...)</code></td><td><code>dataclasses.make_dataclass(...)</code></td></tr></tbody></table></li></ol><h3 id="5-2-具名元组"><a href="#5-2-具名元组" class="headerlink" title="5.2 具名元组"></a>5.2 具名元组</h3><ol><li><p><strong><code>collections.namedtuple</code> 是一个工厂函数.用于构建增强的 <code>tuple</code> 子类</strong></p><ul><li>具有字段名称,类名,提供有用信息的 <code>__repr__</code> 方法</li><li>可在任何需要元组的地方使用</li></ul></li><li><p>示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br>City = namedtuple(<span class="hljs-string">&#x27;City&#x27;</span>, <span class="hljs-string">&#x27;name country population coordinates&#x27;</span>)<br>tokyo = City(<span class="hljs-string">&#x27;Tokyo&#x27;</span>, <span class="hljs-string">&#x27;JP&#x27;</span>, <span class="hljs-number">36.933</span>, (<span class="hljs-number">35.689722</span>, <span class="hljs-number">139.691667</span>))<br></code></pre></td></tr></table></figure><ul><li><code>namedtuple</code> 具有2个参数: 类名 和 字段名称列表<ul><li>字段名称列表: 可以是产生字符串的可迭代对象或用空格分隔的字符串</li><li>字段的值: 必须由单个位置参数传给构造函数( tuple 接受可迭代对象)</li><li>访问字段的方式: <code>.field</code> 或 <code>[index]</code></li></ul></li><li><code>namedtuple</code> 继承了 tuple 的方法</li><li><code>namedtuple</code> 的额外属性和方法<ul><li><code>._fields</code> 属性: 一个元组.存储类的字段名称</li><li><code>._make()</code> 方法: 根据可迭代对象创建实例.与构造函数作用相同</li><li><code>._asdict()</code> 方法: 返回根据具名元组实例创建的 dict 对象</li></ul></li></ul></li><li><p>带类型的具名元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> NamedTuple<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>(<span class="hljs-title class_ inherited__">NamedTuple</span>):<br>    lat:<span class="hljs-built_in">float</span>  <span class="hljs-comment"># 进行类型注解</span><br>    lon:<span class="hljs-built_in">float</span><br>    reference: <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;WGS84&#x27;</span>  <span class="hljs-comment"># 指定默认值</span><br></code></pre></td></tr></table></figure><ul><li><strong>每一个字段都需要注解类型</strong></li><li>可以指定默认值</li><li>使用 <code>typing.NamedTuple</code> 构建的类与 <code>collections.namedTuple</code> 拥有的方法相同<ul><li>同样从 <code>tuple</code> 继承方法</li><li>区别: 多了类属性 <code>__annotations__</code></li></ul></li></ul></li><li><p>类型提示</p><ul><li>目的: 声明 <code>函数参数, 返回值, 变量, 属性</code> 的预期类型</li><li><strong>实际上 Python 解释器并不强制提供类型信息.即使实际类型与预期不符,也不影响运行</strong></li><li>作用: 给 IDE和类型检查工具 验证类型的文档</li></ul></li><li><p>变量注解(在 <code>class</code> 语句中定义属性的注解句法)</p><ul><li>基础语法: <code>var_name: type</code> </li><li>为变量指定初始值: <code>var_name: type = value</code> </li><li>作用: 在导入模块时进行类型读取,构建 <code>__annotations__</code> 字典,供 <code>typing.NamedTuple</code> 和 <code>@dataclass</code> 使用</li><li>特殊属性<code>__annotations__</code>由解释器创建,记录源码中出现的类型提示</li></ul></li></ol><h3 id="5-3-dataclass"><a href="#5-3-dataclass" class="headerlink" title="5.3 @dataclass"></a>5.3 <code>@dataclass</code></h3><ol><li><p><code>@dataclass</code> 装饰器接受多个关键字参数,其完整签名为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclass(<span class="hljs-params">*, init=<span class="hljs-literal">True</span>, <span class="hljs-built_in">repr</span>=<span class="hljs-literal">True</span>, eq=<span class="hljs-literal">True</span>, order=<span class="hljs-literal">False</span>,</span></span><br><span class="hljs-params"><span class="hljs-meta">              unsafe_hash=<span class="hljs-literal">False</span>, frozen=<span class="hljs-literal">False</span></span>)</span><br><span class="hljs-comment"># 第一个参数 * 表示后面的均为关键字参数</span><br></code></pre></td></tr></table></figure></li><li><p>参数说明</p><table><thead><tr><th>参数</th><th>作用</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>init</td><td>生成<code>__init__</code></td><td>True</td><td>若用户实现,则忽略该参数</td></tr><tr><td>repr</td><td>生成 <code>__repr__</code></td><td>True</td><td>若用户实现,则忽略该参数</td></tr><tr><td>eq</td><td>生成 <code>__eq__</code></td><td>True</td><td>若用户实现,则忽略该参数</td></tr><tr><td>order</td><td>生成 <code>__lt__, __le__, __gt__, __ge__</code></td><td>False</td><td>若 order&#x3D;False,eq&#x3D;False 抛出异常</td></tr><tr><td>unsafe_hash</td><td>生成 <code>__hash__</code></td><td>False</td><td>详见文档</td></tr><tr><td>frozen</td><td>使实例不可变</td><td>False</td><td>防止意外更改</td></tr></tbody></table></li></ol><h3 id="5-4-模式匹配类实例"><a href="#5-4-模式匹配类实例" class="headerlink" title="5.4 模式匹配类实例"></a>5.4 模式匹配类实例</h3><ol><li><p>简单类模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 匹配项数为4的序列, 第一项为 str,最后一项为二元组,且为 float</span><br><span class="hljs-keyword">case</span> [<span class="hljs-built_in">str</span>(name), _, _, (<span class="hljs-built_in">float</span>(lat), <span class="hljs-built_in">float</span>(lon))]:<br></code></pre></td></tr></table></figure></li><li><p>匹配 float 值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">match</span> x:<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">float</span>():<br>        do_something_with(x)<br></code></pre></td></tr></table></figure><ul><li>注意,如果去掉 <code>()</code>,改为 <code>case float</code> 则表示匹配任何对象.而 <code>float</code> 视为匹配对象绑定的变量</li><li><code>float</code> 可替换为 <code>bytes, dict, float, frozenset, int, list, set, str, tuple</code></li></ul></li><li><p><strong>关键字类模式</strong></p><ul><li><p>以举例的方式说明(定义 City 类,并创建5个实例)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> typing<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">City</span>(typing.NamedTuple):<br>    continent: <span class="hljs-built_in">str</span><br>    name: <span class="hljs-built_in">str</span><br>    country: <span class="hljs-built_in">str</span><br><br>cities = [<br>    City(<span class="hljs-string">&#x27;Asia&#x27;</span>, <span class="hljs-string">&#x27;Tokyo&#x27;</span>, <span class="hljs-string">&#x27;JP&#x27;</span>),<br>    City(<span class="hljs-string">&#x27;Asia&#x27;</span>, <span class="hljs-string">&#x27;Delhi&#x27;</span>, <span class="hljs-string">&#x27;IN&#x27;</span>),<br>    City(<span class="hljs-string">&#x27;North America&#x27;</span>, <span class="hljs-string">&#x27;Meico City&#x27;</span>, <span class="hljs-string">&#x27;MX&#x27;</span>),<br>    City(<span class="hljs-string">&#x27;North America&#x27;</span>, <span class="hljs-string">&#x27;New York&#x27;</span>, <span class="hljs-string">&#x27;US&#x27;</span>),<br>    City(<span class="hljs-string">&#x27;South America&#x27;</span>, <span class="hljs-string">&#x27;Sao Paulo&#x27;</span>, <span class="hljs-string">&#x27;BR&#x27;</span>),<br>]<br></code></pre></td></tr></table></figure></li><li><p>找出 Asia 的城市</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">matchAsiaCity</span>():<br>    results = []<br>    <span class="hljs-keyword">for</span> city <span class="hljs-keyword">in</span> cities:<br>        <span class="hljs-keyword">match</span> city:<br>            <span class="hljs-keyword">case</span> City(continent=<span class="hljs-string">&#x27;Asia&#x27;</span>, country=country):<br>                results.append(country)<br>    <span class="hljs-keyword">return</span> results<br></code></pre></td></tr></table></figure><ul><li><code>case City(continent=&#39;Asia&#39;, country=country):</code> 按关键字匹配 City 实例</li><li><code>continent=&#39;Asia&#39;</code>: 将变量 city 作为 City 类的实例,需满足其 <code>continent</code> 属性为 <code>&#39;Asia&#39;</code> </li><li><code>country=country</code>: 赋值语句.前面的 <code>country</code> 是模式变量,后面的 <code>country</code> 实际为 <code>city.country</code></li></ul></li></ul></li><li><p><strong>位置类模式</strong></p><ul><li><p>找出找出 Asia 的城市</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">matchAsiaCityPos</span>():<br>    results = []<br>    <span class="hljs-keyword">for</span> city <span class="hljs-keyword">in</span> cities:<br>        <span class="hljs-keyword">match</span> city:<br>            <span class="hljs-keyword">case</span> City(<span class="hljs-string">&#x27;Asia&#x27;</span>, _, country):<br>                results.append(country)<br>    <span class="hljs-keyword">return</span> results<br></code></pre></td></tr></table></figure></li><li><p><code>case City(&#39;Asia&#39;, _, country):</code> 中按位置匹配 City 实例</p><ul><li><code>&#39;Asia&#39;</code>: 需满足第一个属性的值为 <code>&#39;Asia&#39;</code> </li><li><code>_, country</code>: 忽略第二个属性的值,将第三个属性的值绑定到模式变量 <code>country</code></li></ul></li></ul></li></ol><h2 id="6-对象引用"><a href="#6-对象引用" class="headerlink" title="6 对象引用"></a>6 对象引用</h2><ol><li><p>Python 的变量是<strong>引用式变量</strong>,可理解为 <strong>附加在对象上的标注</strong></p><ul><li>在对象创建后才能绑定变量(使用 <code>=</code> 运算符)</li><li>对象可以有多个标识(别名).对象一旦创建,标识始终不可变(标识类似对象在内存中的地址)</li></ul></li><li><p><code>==</code>与<code>is</code></p><ul><li><p><code>==</code> 运算符比较对象的值,值相等则返回 True</p></li><li><p><strong><code>is</code> 运算符比较对象的标识,指向同一对象时返回 True</strong></p></li><li><p><code>id()</code> 函数返回对象标识的整数表示.在 CPython 中返回对象的内存地址</p></li><li><p><strong>通常编程时关注的是值(相等性),而不是标识(同一性),因此<code>==</code>出现的频率高于<code>is</code></strong> </p></li><li><p><code>is</code> 的速度比 <code>==</code> 快.因为<code>is</code>不能重载.一般在比较变量和单例时,才使用<code>is</code>.如<code>x is None</code></p></li><li><p><code>a == b</code>本质是语法糖,等同于<code>a.__eq__(b)</code>.继承自 object 的<code>__eq__</code>方法.将比较两个对象的 ID,结果与 <code>is</code> 相同</p></li></ul></li><li><p>默认浅拷贝</p><ul><li><p>复制列表(或其他内置可变容器)的简单方法为使用内置的构造函数,如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">l2 = <span class="hljs-built_in">list</span>(l1) <span class="hljs-comment"># list(l1)是 list类 的复制构造函数,使用 l1 创建一个新的副本</span><br></code></pre></td></tr></table></figure></li><li><p><strong>浅拷贝仅单纯地复制各项的值,若有一项为引用,也仅仅是复制引用,而不会深入复制引用对象的值</strong></p></li><li><p>若 l1 中的元素存在可变对象,则当其发生变化时,l2 中也会相应的改变</p></li></ul></li><li><p>对任意对象进行深浅拷贝</p><ul><li><strong>深拷贝: 副本不共享内部对象的引用</strong></li><li><code>copy</code>模块中的<code>copy/deepcopy</code>函数分别对任意对象进行浅拷贝&#x2F;深拷贝</li></ul></li><li><p>函数传参</p><ul><li><strong>Python 仅支持共享传参(call by sharing): 函数的形参获得实参引用的副本(即传递对象的指针)</strong><ul><li>因此,函数内部可能会对修改传入的对象.但无法修改对象的标识</li><li><code>+=</code> 这类增量复制,在对可变对象操作时,将原地修改,使得传入的对象也被修改<br>在对不可变对象操作时,将生成新的副本,传入的对象并未被修改</li></ul></li><li>不要使用可变类型作为参数的默认值<ul><li>如果默认值被修改,后续的函数调用都将收到影响</li><li>如列表作为函数参数默认值时,每次调用该函数都会使用同一列表</li><li>通常使用 <code>None</code> 作为 接收可变值的参数的默认值</li></ul></li></ul></li><li><p><code>del</code> 和垃圾回收</p><ul><li><code>del</code> 是语句,而非函数.<code>del</code> 删除的是引用,而非对象</li><li>当<code>del</code> 删除的是对象的最后一个引用时,将导致对象被当作垃圾回收</li><li>重新绑定也可能导致对象的引用数量归零,进而使得对象被销毁</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>流畅的 Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 项目</title>
    <link href="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="项目1-外星人入侵"><a href="#项目1-外星人入侵" class="headerlink" title="项目1-外星人入侵"></a>项目1-外星人入侵</h2><h3 id="1-1-pygame"><a href="#1-1-pygame" class="headerlink" title="1.1 pygame"></a>1.1 pygame</h3><ol><li><p>pygame: 基于 Python 的游戏开发库.提供了一系列的工具和接口<br>使开发人员能够轻松地创建各种类型的游戏(包括2D游戏和简单的3D游戏)</p></li><li><p>安装 pygame: <code>pip install pygame</code></p></li><li><p>pygame 基本概念</p><ul><li>Surface(表面)<ul><li>Pygame 中的所有图形均绘制在 Surface对象上</li><li>Surface 是游戏中最基本的图形对象.可以是窗口,图像,按钮…</li></ul></li><li>Rect(矩形)<ul><li>Pygame 中的所有图形都是使用矩形表示的.而非期望的图像形状</li><li>Rect 是游戏中常用的对象.可以表示 Surface 的位置,大小等信息</li></ul></li><li>Event(事件)<ul><li>Pygame 中的所有操作都是通过事件来实现的</li><li>事件可以是鼠标点击,键盘按下等用户操作,也可以是游戏中的自定义事件</li></ul></li><li>Clock(时钟)<ul><li>Pygame 中的所有动画都是使用时钟实现的</li><li>时钟可以控制游戏的帧率,动画速度…</li></ul></li><li>Sprite(精灵)<ul><li>Pygame 中 Sprite 是一个抽象概念.可表示游戏中的可移动对象.如人物,怪物…</li><li>Sprite 可以方便地进行移动,碰撞检测…</li></ul></li></ul></li><li><p>pygame 实现步骤</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 初始化 pygame</span><br><span class="hljs-keyword">import</span> pygame <span class="hljs-comment"># 导包</span><br>pygame.init() <span class="hljs-comment"># 初始化</span><br><br><span class="hljs-comment"># 2. 创建窗口</span><br>size = (<span class="hljs-number">700</span>, <span class="hljs-number">500</span>)<br>screen = pygame.display.set_mode(size) <span class="hljs-comment"># 设置窗口大小</span><br>pygame.display.set_caption(<span class="hljs-string">&quot;My Game&quot;</span>)  <span class="hljs-comment"># 设置窗口标题</span><br><br><span class="hljs-comment"># 3. 绘制图形</span><br>pygame.draw.rect(screen, (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), [<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>])<br><br><span class="hljs-comment"># 4. 处理事件</span><br>done = <span class="hljs-literal">False</span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> done:<br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():  <span class="hljs-comment"># 获取所有事件,依次处理</span><br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT: <span class="hljs-comment"># pygame.QUIT事件触发则退出循环</span><br>            done = <span class="hljs-literal">True</span><br><br><span class="hljs-comment"># 5. 更新窗口</span><br>pygame.display.update()<br><br><span class="hljs-comment"># 6. 控制帧率</span><br>clock = pygame.time.Clock() <span class="hljs-comment"># 创建时钟对象</span><br>clock.tick(<span class="hljs-number">60</span>)              <span class="hljs-comment"># 控制游戏帧率</span><br><br><span class="hljs-comment"># 7. 创建 Sprite(通过继承 pygame.sprite.Sprite)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySprite</span>(pygame.sprite.Sprite):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.image = pygame.Surface([<span class="hljs-number">50</span>, <span class="hljs-number">50</span>])<br>        <span class="hljs-variable language_">self</span>.image.fill((<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>        <span class="hljs-variable language_">self</span>.rect = <span class="hljs-variable language_">self</span>.image.get_rect()<br>        <span class="hljs-variable language_">self</span>.rect.x = <span class="hljs-number">50</span><br>        <span class="hljs-variable language_">self</span>.rect.y = <span class="hljs-number">50</span><br>        <br>my_group = pygame.sprite.Group()<br>my_sprite = MySprite()  <span class="hljs-comment"># 实例化精灵</span><br>my_group.add(my_sprite) <span class="hljs-comment"># 添加精灵到组中</span><br>my_group.draw(screen)   <span class="hljs-comment"># 绘制精灵</span><br><br><span class="hljs-comment"># 8. 碰撞检测</span><br>collision_list = pygame.sprite.spritecollide(my_sprite, other_group, <span class="hljs-literal">False</span>)<br><br><span class="hljs-comment"># 9. 声音</span><br>pygame.mixer.music.load(<span class="hljs-string">&quot;music.mp3&quot;</span>) <span class="hljs-comment"># 加载音乐</span><br>pygame.mixer.music.play(-<span class="hljs-number">1</span>)          <span class="hljs-comment"># 播放音乐</span><br><br><span class="hljs-comment"># 10. 键盘鼠标输入</span><br><span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.KEYDOWN:     <span class="hljs-comment"># 检测键盘输入</span><br>    <span class="hljs-keyword">if</span> event.key == pygame.K_LEFT:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;向左移动&quot;</span>)<br>    <span class="hljs-keyword">elif</span> event.key == pygame.K_RIGHT:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;向右移动&quot;</span>)<br><br><span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.MOUSEBUTTONDOWN: <span class="hljs-comment"># 检测鼠标输入</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;鼠标点击&quot;</span>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-2-项目规划"><a href="#1-2-项目规划" class="headerlink" title="1.2 项目规划"></a>1.2 项目规划</h3><ol><li>游戏&lt;外星人入侵&gt;的玩法<ul><li>玩家控制一艘武装飞船(初始位于屏幕底部).方向键可以左右移动飞船.空格键设计</li><li>游戏开始时,外星舰队出现于天空,并开始向屏幕下方移动</li><li>玩家的任务: 消灭这些外星人.当消灭干净后,出现一队新的移动更快的舰队</li><li>失败条件: 每当外星人碰到玩家或到达屏幕下边缘,损失一艘飞船,损失三艘飞船后结束</li></ul></li><li>版本管理<ul><li>使用 Git 进行版本管理,每完成一个新功能,都将提交修改</li><li>V0.1: 创建 Pygame 窗口.为黑屏状态,可以最小化,在点击右上角的关闭图标时,退出游戏<ul><li>V0.2: 设置背景颜色; 控制游戏帧率; 新增 Setting 类,用于游戏的设置</li><li>V0.3: 添加 Ship 类.在屏幕上绘制飞船图像</li><li>V0.3.1: 重构.添加 <code>_check_events(), _update_screen()</code>方法</li></ul></li><li>V0.4: 添加左右移动飞船的方法<ul><li>V0.4.1: 调整飞船的速度</li><li>V0.4.2: 限制飞船移动的范围</li><li>V0.4.3: 再次重构<code>_check_events()</code>方法,分解为两部分</li><li>V0.4.4: 添加退出方式: 按<kbd>Q</kbd>键退出</li><li>V0.4.5: 可选分支: 全屏模式</li></ul></li><li>V0.5: 增加 Bullet类<ul><li>V0.5.1: 增加发送子弹功能</li><li>V0.5.2: 删除应该消失的子弹</li><li>V0.5.3: 限制子弹数量</li><li>V0.5.4: 重构,添加<code>_update_bullets()</code>方法</li></ul></li><li>V0.6: 添加 alien类<ul><li>V0.6.1: 第一个外星人现身</li><li>V0.6.2: 添加一行外星人</li><li>V0.6.3: 添加多行外星人</li><li>V0.6.4: 移动外星舰队</li><li>V0.6.5: 击落外星舰队</li><li>V0.6.6: 生成新舰队.重构代码</li></ul></li><li>V0.7: 添加结束游戏的条件</li><li>V0.8: 添加 Play 按钮<ul><li>V0.8.1: 提高难度</li></ul></li><li>V0.9: 添加计分功能</li></ul></li></ol><h3 id="1-3-显示游戏图像"><a href="#1-3-显示游戏图像" class="headerlink" title="1.3 显示游戏图像"></a>1.3 显示游戏图像</h3><ol><li><p>游戏素材的版权: OpenGameArt 等网站可以提供免费图形</p><ul><li>Pygame 默认加载位图(.bmp),使用位图文件最为简单</li><li>选择图像时,需要注意背景颜色.最好是透明或纯色,以便修改为不同的背景色</li><li>在游戏项目中创建 <code>images</code> 目录,统一管理图像</li></ul></li><li><p>Pygame 的坐标系</p><ul><li><p>原点(0, 0) 位于窗口的左上角.点向 右&#x2F;下 移动,坐标值将增大</p></li><li><p>可以通过设置 rect 对象的属性来决定显示图像的位置(如V0.3 Ship类的代码)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-variable language_">self</span>.rect.midbottom = <span class="hljs-variable language_">self</span>.screen_rect.midbottom <span class="hljs-comment"># 设置位置</span><br><span class="hljs-variable language_">self</span>.screen.blit(<span class="hljs-variable language_">self</span>.image, <span class="hljs-variable language_">self</span>.rect) <span class="hljs-comment"># 绘制图像</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>重构</p><ul><li>重构的目的在于简化既有代码的结构,增强扩展性</li><li>增加<strong>辅助方法</strong>是一种重构手段.一般由单下划线开头,且只在类中调用</li><li>在 Pycharm 中,可以方便地重构代码: 右击编辑区 -&gt; <kbd>重构</kbd> -&gt; <kbd>提取方法</kbd></li></ul></li><li><p>按键控制飞船移动</p><ul><li>检测按下方向的左右键事件,来控制飞船的左右移动(操作 rect 对象的 x 属性)</li><li>如果想要按下键后,持续移动.可以采取标志位的方式.初始标志为0(False), <ul><li>当检测到按下时置1(True),开始移动</li><li>检测到松开时置0,停止移动</li></ul></li><li>控制移动速度: 通过控制每次对 rect.x 自增&#x2F;自减的值决定移动的速度</li><li>限制活动范围: 移动前先检查是否到达边界,未到达边界时才允许移动</li></ul></li><li><p>全屏运行</p><ul><li><p>Pygame 不提供全屏时退出游戏的默认方式.注意要设计一个退出游戏的方式</p></li><li><p>创建游戏的 <code>surface</code> 时传入<code>pygame.FULLSCREEN</code>参数,注意要将 宽&#x2F;高参数 传给Setting类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-variable language_">self</span>.screen = pygame.display.set_mode((<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), pygame.FULLSCREEN)<br><span class="hljs-variable language_">self</span>.setting.screen_width = <span class="hljs-variable language_">self</span>.screen.get_rect().width<br><span class="hljs-variable language_">self</span>.setting.screen_height = <span class="hljs-variable language_">self</span>.screen.get_rect().height<br></code></pre></td></tr></table></figure></li></ul></li><li><p>发射子弹</p><ul><li>子弹对象可以通过继承 Sprite 类实现,便于管理(移动,碰撞检测,销毁…)</li><li>按下空格键后,在飞船的上中部(midtop)生成一颗子弹,添加到组中,并绘制</li><li>子弹在到达屏幕边缘后并不会自动删除,因而需要手动将其手动删除,节约资源</li></ul></li><li><p>绘制按钮</p><ul><li>Pygame 没有内置的创建按钮方法.通过需要创建实心矩形(rect)的方法来绘制按钮</li><li>将需要显示的信息(message)通过 font.render() 方法渲染成图形,且居中显示</li></ul></li></ol><h2 id="项目2-可视化"><a href="#项目2-可视化" class="headerlink" title="项目2-可视化"></a>项目2-可视化</h2><h3 id="2-1-折线图-plot"><a href="#2-1-折线图-plot" class="headerlink" title="2.1 折线图(plot)"></a>2.1 折线图(plot)</h3><ol><li><p>安装 <code>Matplotlib</code>: 在命令行中执行<code>python -m pip install --user matplotlib</code></p></li><li><p>简单折线图(以平方数序列为例)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt  <span class="hljs-comment"># 导包</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_square</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;绘制 x^2 的图像.自变量范围为[0, n]&quot;&quot;&quot;</span><br>    values = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>))          <span class="hljs-comment"># x轴数据</span><br>    squares = [i * i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> values]  <span class="hljs-comment"># y轴数据</span><br>    plt.style.use(<span class="hljs-string">&#x27;seaborn-v0_8&#x27;</span>)      <span class="hljs-comment"># 设置绘图风格</span><br>    fig, ax = plt.subplots(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">9</span>), dpi=<span class="hljs-number">300</span>)<br>    <span class="hljs-comment"># subplots(): 获取绘图对象.绘制 a figure and a set of subplots</span><br>    <span class="hljs-comment"># fig: 生成的整个图形  ax: 图形中的 plot</span><br>    <span class="hljs-comment"># figsize: 指定图像比例  dpi: 指定图像 dpi</span><br>    <br>    ax.set_title(<span class="hljs-string">&quot;Square&quot;</span>, fontsize=<span class="hljs-number">24</span>)   <span class="hljs-comment"># 设置图题</span><br>    ax.set_xlabel(<span class="hljs-string">&quot;x&quot;</span>, fontsize=<span class="hljs-number">14</span>)       <span class="hljs-comment"># 设置 x 轴标签</span><br>    ax.set_ylabel(<span class="hljs-string">&quot;y&quot;</span>, fontsize=<span class="hljs-number">14</span>)       <span class="hljs-comment"># 设置 y 轴标签</span><br>    ax.tick_params(labelsize=<span class="hljs-number">14</span>)          <span class="hljs-comment"># 设置 刻度标记的样式</span><br>    ax.ticklabel_format(style=<span class="hljs-string">&#x27;plain&#x27;</span>)    <span class="hljs-comment"># 使用常规表示法,而非科学计数法</span><br>    ax.axis([<span class="hljs-number">0</span>, n, <span class="hljs-number">0</span>, n*n])               <span class="hljs-comment"># 指定刻度的最大,最小值</span><br>    <span class="hljs-comment"># ax.set_aspect(&#x27;equal&#x27;)              # 保持两轴刻度间距相等</span><br>    <span class="hljs-comment"># 隐藏坐标轴.get_xaxis()获取坐标轴,然后链式调用set_visible()使其隐藏</span><br>    <span class="hljs-comment"># ax.get_xaxis().set_visible(False)</span><br>    <span class="hljs-comment"># ax.get_yaxis().set_visible(False)</span><br>    ax.plot(values, squares, linewidth=<span class="hljs-number">3</span>, color=(<span class="hljs-number">0.8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) <br>    <span class="hljs-comment"># 指定绘图采用的横/纵坐标,线条宽度,线条颜色(0~1的三元组,值越小颜色越深)</span><br>    <span class="hljs-comment"># color 可以直接赋值为 &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;</span><br>    <br>    plt.show()  <span class="hljs-comment"># 打开 Matplotlib 查看器显示绘图</span><br></code></pre></td></tr></table></figure></li><li><p>内置样式</p><ul><li><p>在 Python控制台输入<code>plt.style.available</code>即可查看所有样式</p></li><li><p>运行<code>plot_all_style()</code>,可以绘制出所有的样式.挑选一个顺眼的样式即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_all_style</span>():<br>    squares = [i*i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>)]<br>    <span class="hljs-keyword">for</span> style <span class="hljs-keyword">in</span> plt.style.available:<br>        plt.style.use(style)<br>        fig, ax = plt.subplots()<br>        ax.set_title(style, fontsize=<span class="hljs-number">24</span>)<br>        ax.plot(squares)<br>        plt.show()<br></code></pre></td></tr></table></figure></li></ul></li><li><p>执行 <code>plot_square(5)</code> 将会得到</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/plot_square.png" alt="plot_square"></p></li></ol><h3 id="2-2-散点图-scatter"><a href="#2-2-散点图-scatter" class="headerlink" title="2.2 散点图(scatter)"></a>2.2 散点图(scatter)</h3><ol><li><p>散点图调整样式的方式与折线图一致</p></li><li><p>折线图绘图使用<code>plot()</code>方法,散点图使用<code>scatter()</code>方法.且可以画在同一张图中</p></li><li><p>保存图形</p><ul><li><p>若需要将绘图存储到文件中,只需将<code>plt.show()</code>替换为<code>plt.savefig()</code></p></li><li><p>使用<code>Path</code>对象,可将图片保存到任意地方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.savefig(<span class="hljs-string">&#x27;square_plot.png&#x27;</span>, bbox_inches=<span class="hljs-string">&#x27;tight&#x27;</span>, dpi=<span class="hljs-number">400</span>)<br><span class="hljs-comment"># bbox_inches=&#x27;tight&#x27;: 裁剪掉多余的空白部分</span><br><span class="hljs-comment"># dpi: 提高图片质量</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>散点图可以指定颜色映射: 从起始颜色到结束颜色的颜色序列,突出数据的规律</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">ax.scatter(values, squares, c=squares, cmap=plt.cm.Blues, edgecolors=<span class="hljs-string">&#x27;none&#x27;</span>, s=<span class="hljs-number">3</span>)<br><span class="hljs-comment"># c: 指定染色的依据   # s: 指定点的大小</span><br><span class="hljs-comment"># cmap=plt.cm.Blues: 指定颜色映射的样式</span><br><span class="hljs-comment"># edgecolors=&#x27;none&#x27;: 删除点的轮廓</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-交互式图形"><a href="#2-3-交互式图形" class="headerlink" title="2.3 交互式图形"></a>2.3 交互式图形</h3><ol><li><p>安装<code>Plotly</code>: 在命令行中执行<code>python -m pip install --user ployly</code></p></li><li><p><code>Plotly</code>可以用于生成交互式图形</p><ul><li>生成的图形可以自动缩放,适合显示在浏览器中</li><li>当用户的鼠标指向特定元素时,将显示有关信息</li></ul></li><li><p>绘制直方图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px<br><br>value = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]  <span class="hljs-comment"># 横轴取值</span><br>frequency = [<span class="hljs-number">155</span>, <span class="hljs-number">167</span>, <span class="hljs-number">168</span>, <span class="hljs-number">170</span>, <span class="hljs-number">159</span>, <span class="hljs-number">181</span>]  <span class="hljs-comment"># 对应的频率</span><br><br>title = <span class="hljs-string">&quot;Results of Rolling One D6 1,000 Times&quot;</span>  <span class="hljs-comment"># 标题信息</span><br>labels = &#123;<span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-string">&#x27;Result&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>: <span class="hljs-string">&#x27;Frequency of Result&#x27;</span>&#125;  <span class="hljs-comment"># 坐标轴标签</span><br>fig = px.bar(x=value, y=frequency, title=title, labels = labels)  <span class="hljs-comment"># 绘制直方图</span><br>fig.update_layout(xaxis_dtick=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 为每个条形都加上标签</span><br>fig.show()  <span class="hljs-comment"># 将直方图渲染成 HTML 文件,并在浏览器中展示</span><br></code></pre></td></tr></table></figure><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/Plotly_Bar_Chart.png" alt="Plotly Bar Chart"></p></li><li><p><code>Plotly</code> 同样可以绘制折线图和散点图.只需将<code>bar</code>改为<code>line</code>或<code>scatter</code></p></li><li><p>保存图形: 将<code>fig.show()</code>替换为<code>fig.write_html(&#39;filename.html&#39;)</code>即可</p></li></ol><h3 id="2-4-CSV-文件"><a href="#2-4-CSV-文件" class="headerlink" title="2.4 CSV 文件"></a>2.4 CSV 文件</h3><ol><li><p>CSV(comma-separated values): 将数据组织为一系列以<code>,</code>分隔的值<br>如: <code>&quot;USW00025333&quot;,&quot;SITKA AIRPORT, AK US&quot;,&quot;2021-01-01&quot;,,&quot;44&quot;,&quot;40&quot;</code></p></li><li><p>解析 CSV 文件头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">import</span> csv  <span class="hljs-comment"># csv 模块包含于 Python标准库</span><br><br><span class="hljs-comment"># 创建Path对象,指向待使用的文件</span><br>path = Path(<span class="hljs-string">&#x27;weather_data/sitka_weather_2021_simple.csv&#x27;</span>)  <br>lines = path.read_text().splitlines()  <span class="hljs-comment"># 读取文件并按行分隔</span><br>reader = csv.reader(lines)  <span class="hljs-comment"># 创建reader对象</span><br>header_row = <span class="hljs-built_in">next</span>(reader)   <span class="hljs-comment"># 获取第一行的数据,即 CSV 文件头</span><br><span class="hljs-comment"># header_row = [&#x27;STATION&#x27;, &#x27;NAME&#x27;, &#x27;DATE&#x27;, &#x27;TAVG&#x27;, &#x27;TMAX&#x27;, &#x27;TMIN&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p>提取并读取数据.经过对CSV文件头的解析,明晰了每列存储的数据内容(根据下标获取)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br>dates, highs, lows = [], [], []   <span class="hljs-comment"># 用于存储待读取的数据,本例中是最高温度 TMAX</span><br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader:      <span class="hljs-comment"># 在每行中循环读取</span><br>    <span class="hljs-comment"># 读取日期信息 并将其由字符串转化为数据</span><br>    current_date = datetime.strptime(row[<span class="hljs-number">2</span>], <span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>)<br>    dates.append(current_date)  <span class="hljs-comment"># 将读取到的数据加入存储数据的列表</span><br>    high = <span class="hljs-built_in">int</span>(row[<span class="hljs-number">4</span>])  <span class="hljs-comment"># 待读取的数据位于每行的第5列,因而下标为4</span><br>    highs.append(high)  <br>    low = <span class="hljs-built_in">int</span>(row[<span class="hljs-number">5</span>])<br>    lows.append(low)<br></code></pre></td></tr></table></figure></li><li><p>绘制温度图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.style.use(<span class="hljs-string">&#x27;seaborn-v0_8&#x27;</span>)<br>fig, ax = plt.subplots()<br><span class="hljs-comment"># 绘制最低及最高温度的曲线图,alpha指定透明度(0为完全透明)</span><br>ax.plot(dates, highs, color=<span class="hljs-string">&#x27;red&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)<br>ax.plot(dates, lows, color=<span class="hljs-string">&#x27;blue&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)<br>ax.fill_between(dates, highs, lows, facecolor=<span class="hljs-string">&#x27;blue&#x27;</span>, alpha=<span class="hljs-number">0.1</span>)<br><span class="hljs-comment"># 设置图题,坐标轴信息</span><br>ax.set_title(<span class="hljs-string">&quot;Daily High and Low Temperatures,2021&quot;</span>, fontsize=<span class="hljs-number">24</span>)<br>ax.set_xlabel(<span class="hljs-string">&quot;&quot;</span>, fontsize=<span class="hljs-number">14</span>)<br>ax.set_ylabel(<span class="hljs-string">&quot;Temperature(F)&quot;</span>, fontsize=<span class="hljs-number">14</span>)<br>ax.tick_params(labelsize=<span class="hljs-number">14</span>)<br>fig.autofmt_xdate()<br>plt.show()<br></code></pre></td></tr></table></figure></li><li><p>最终效果</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/CSV_Line_Chart.png" alt="CSV Line Chart"></p></li></ol><h3 id="2-5-JSON-文件"><a href="#2-5-JSON-文件" class="headerlink" title="2.5 JSON 文件"></a>2.5 JSON 文件</h3><ol><li><p>GeoJSON 格式基于 JSON 的地理空间信息数据交换格式存储.使用 json 模块处理</p></li><li><p>解析 GeoJSON 数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-comment"># 将数据作为字符串读取并转换为 Python 对象</span><br>path = Path(<span class="hljs-string">&#x27;eq_data/eq_data_1_day_m1.geojson&#x27;</span>)<br>contents = path.read_text()<br>all_eq_data = json.loads(contents)<br><span class="hljs-comment"># 将数据文件转换为更易于阅读的版本</span><br><span class="hljs-comment"># path = Path(&#x27;eq_data/eq_data_1_day_m1.geojson&#x27;)</span><br><span class="hljs-comment"># readable_contents = json.dumps(all_eq_data, indent=4)</span><br><span class="hljs-comment"># path.write_text(readable_contents)</span><br></code></pre></td></tr></table></figure></li><li><p>提取数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">all_eq_dicts = all_eq_data[<span class="hljs-string">&#x27;features&#x27;</span>]<br>mags, titles, lons, lats = [], [], [], []  <span class="hljs-comment"># 存储数据的列表</span><br><span class="hljs-comment"># 地震震级 mag 存储于 properties部分的 mag键下</span><br><span class="hljs-keyword">for</span> eq_dict <span class="hljs-keyword">in</span> all_eq_dicts:<br>    mags.append(eq_dict[<span class="hljs-string">&#x27;properties&#x27;</span>][<span class="hljs-string">&#x27;mag&#x27;</span>])<br>    titles.append(eq_dict[<span class="hljs-string">&#x27;properties&#x27;</span>][<span class="hljs-string">&#x27;title&#x27;</span>])<br>    lons.append(eq_dict[<span class="hljs-string">&#x27;geometry&#x27;</span>][<span class="hljs-string">&#x27;coordinates&#x27;</span>][<span class="hljs-number">0</span>])<br>    lats.append(eq_dict[<span class="hljs-string">&#x27;geometry&#x27;</span>][<span class="hljs-string">&#x27;coordinates&#x27;</span>][<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure></li><li><p>绘制震级散点图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>data = pd.DataFrame(<br>    data=<span class="hljs-built_in">zip</span>(lons,lats,titles,mags), columns=[<span class="hljs-string">&#x27;经度&#x27;</span>,<span class="hljs-string">&#x27;纬度&#x27;</span>,<span class="hljs-string">&#x27;位置&#x27;</span>,<span class="hljs-string">&#x27;震级&#x27;</span>]<br>)<br>data.head()<br>fig = px.scatter(<br>    data, x=<span class="hljs-string">&#x27;经度&#x27;</span>, y=<span class="hljs-string">&#x27;纬度&#x27;</span>,<br>    range_x=[-<span class="hljs-number">200</span>, <span class="hljs-number">200</span>], range_y=[-<span class="hljs-number">90</span>, <span class="hljs-number">90</span>],  <span class="hljs-comment"># x,y的取值范围</span><br>    width=<span class="hljs-number">800</span>, height=<span class="hljs-number">800</span>,  <span class="hljs-comment"># 图像的尺寸</span><br>    title=<span class="hljs-string">&quot;全球地震散点图&quot;</span>,<br>    size_max=<span class="hljs-number">10</span>,  <span class="hljs-comment"># 默认标记尺寸为20</span><br>    size=<span class="hljs-string">&#x27;震级&#x27;</span>,  <span class="hljs-comment"># 点的尺寸</span><br>    color=<span class="hljs-string">&#x27;震级&#x27;</span>,  <span class="hljs-comment"># 点的颜色.视觉映射图默认渐变色为 蓝-&gt;红-&gt;黄</span><br>    <span class="hljs-comment"># px.colors.named_colorscales() 可以查看所有的颜色映射</span><br>    color_continuous_scale=<span class="hljs-string">&#x27;bluered&#x27;</span>,  <span class="hljs-comment"># 配置颜色映射. 蓝-&gt;紫-&gt;红</span><br>    hover_name=<span class="hljs-string">&#x27;位置&#x27;</span>,  <span class="hljs-comment"># 设置鼠标悬停时的显示信息</span><br>)<br><span class="hljs-comment"># fig.write_html(&quot;global_earthquakes.html&quot;)</span><br>fig.show()<br></code></pre></td></tr></table></figure></li><li><p>最终效果</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/JSON_Scatter_Chart.png" alt="JSON Scatter Chart"></p></li></ol><h3 id="2-5-可视化仓库"><a href="#2-5-可视化仓库" class="headerlink" title="2.5 可视化仓库"></a>2.5 可视化仓库</h3><ol><li><p>API(application program interface,应用程序接口)是网站的一部分,用于与程序进行交互<br>API 调用: 程序使用具体的 URL 请求特定的信息(这些数据以JSON 或 CSV 的形式返回)<br>使用外部数据源的应用程序大多依赖API调用</p></li><li><p>Git 与 Github</p><ul><li>Git: 分布式版本控制系统.可以跟踪对每个文件的修改,也可以回退到任意一个版本</li><li>Github: 一个让程序员可以协作开发项目的网站,其中的项目都存储于仓库(repository)</li></ul></li><li><p>安装<code>Requests</code>: 在命令行中执行<code>python -m pip install --user requests</code></p></li><li><p>执行 API 调用并查看响应</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px<br><br><span class="hljs-comment"># url的主要部分: 让api搜索Github上的所有仓库</span><br>url = <span class="hljs-string">&quot;https://api.github.com/search/repositories&quot;</span><br>url += <span class="hljs-string">&quot;?q=language:python+sort:stars+stars:&gt;10000&quot;</span><br><br>headers = &#123;<span class="hljs-string">&quot;Accept&quot;</span>: <span class="hljs-string">&quot;application/vnd.github.v3+json&quot;</span>&#125;  <span class="hljs-comment"># 指定api的版本</span><br>r = requests.get(url, headers=headers)  <span class="hljs-comment"># 调用 api</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Status code: <span class="hljs-subst">&#123;r.status_code&#125;</span>&quot;</span>)  <span class="hljs-comment"># 打印状态码,200表示成功</span><br><br>response_dict = r.json()  <span class="hljs-comment"># 将返回的 JSON 对象转换为 python字典</span><br><span class="hljs-comment"># print(response_dict.keys())  # dict_keys([&#x27;total_count&#x27;, &#x27;incomplete_results&#x27;, &#x27;items&#x27;])</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Complete results: <span class="hljs-subst">&#123;<span class="hljs-keyword">not</span> response_dict[<span class="hljs-string">&#x27;incomplete_results&#x27;</span>]&#125;</span>&quot;</span>)  <span class="hljs-comment"># 查看是否响应完成</span><br><br><span class="hljs-comment"># 处理返回的结果.提取项目链接(包含项目名),stars数</span><br>repo_dicts = response_dict[<span class="hljs-string">&#x27;items&#x27;</span>]<br>repo_links, stars, hover_texts = [], [], []<br><span class="hljs-keyword">for</span> repo_dict <span class="hljs-keyword">in</span> repo_dicts:<br>    repo_name = repo_dict[<span class="hljs-string">&#x27;name&#x27;</span>]  <span class="hljs-comment"># 提取项目名</span><br>    repo_url = repo_dict[<span class="hljs-string">&#x27;html_url&#x27;</span>]  <span class="hljs-comment"># 提取项目链接</span><br>    repo_link = <span class="hljs-string">f&quot;&lt;a href=&#x27;<span class="hljs-subst">&#123;repo_url&#125;</span>&#x27;&gt;<span class="hljs-subst">&#123;repo_name&#125;</span>&lt;/a&gt;&quot;</span>  <span class="hljs-comment"># 格式化链接</span><br>    repo_links.append(repo_link)  <span class="hljs-comment"># 添加链接信息</span><br>    stars.append(repo_dict[<span class="hljs-string">&#x27;stargazers_count&#x27;</span>])  <span class="hljs-comment"># 添加 stars信息</span><br>    <span class="hljs-comment"># 创建悬停文本</span><br>    owner = repo_dict[<span class="hljs-string">&#x27;owner&#x27;</span>][<span class="hljs-string">&#x27;login&#x27;</span>]  <span class="hljs-comment"># 添加拥有者信息</span><br>    description = repo_dict[<span class="hljs-string">&#x27;description&#x27;</span>]  <span class="hljs-comment"># 创建描述信息</span><br>    hover_text = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;owner&#125;</span>&lt;br /&gt;<span class="hljs-subst">&#123;description&#125;</span>&quot;</span>  <span class="hljs-comment"># 格式化提示文本</span><br>    hover_texts.append(hover_text)  <span class="hljs-comment"># 添加描述信息</span><br><br><span class="hljs-comment"># 可视化处理.指定标题,横纵坐标,字体大小,颜色</span><br>title = <span class="hljs-string">&quot;Most-Starred Python Project on Github&quot;</span><br>labels = &#123;<span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-string">&#x27;Repository&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>: <span class="hljs-string">&#x27;Stars&#x27;</span>&#125;<br>fig = px.bar(x=repo_links, y=stars, title=title,<br>             labels=labels, hover_name=hover_texts)<br>fig.update_layout(title_font_size=<span class="hljs-number">28</span>, xaxis_title_font_size=<span class="hljs-number">20</span><br>                  yaxis_title_font_size=<span class="hljs-number">20</span>)<br>fig.update_traces(marker_color=<span class="hljs-string">&#x27;SteelBlue&#x27;</span>, marker_opacity=<span class="hljs-number">0.6</span>)<br>fig.show()<br></code></pre></td></tr></table></figure></li><li><p>最终效果</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/Most-Starred_Python_Project_on_Github.png" alt="Most-Starred Python Project on Github"></p></li></ol><h2 id="项目3-Web应用程序"><a href="#项目3-Web应用程序" class="headerlink" title="项目3-Web应用程序"></a>项目3-Web应用程序</h2><h3 id="3-1-Django"><a href="#3-1-Django" class="headerlink" title="3.1 Django"></a>3.1 Django</h3><ol><li><p>Django 是一个开放源代码的 Web 应用框架,由 Python 写成</p><ul><li>Django 是一个高级的 Python Web 框架,用于快速开发可维护和可扩展的 Web 应用程序</li><li>Python + Django 是快速开发,设计,部署网站的最佳组合</li><li>安装 Django: 在命令行中执行<code>pip install django</code></li></ul></li><li><p>特点</p><ul><li><strong>ORM(对象关系映射)</strong>: Django 提供了一个强大的 ORM.允许开发者通过 Python 代码来定义和操作数据库模型,而无需直接使用 SQL.这使得数据库操作更加抽象和易于管理</li><li><strong>MVC 架构</strong>: Django 遵循 MVC的软件设计模式,但它使用了稍微不同的术语.在 Django 中,模型(Model)表示数据结构,视图(View)负责呈现用户界面,而控制器(Controller)的职责被称为视图(View)</li><li><strong>模板引擎</strong>: Django 使用模板引擎来生成 HTML.使得前端和后端的代码分离更加容易.Django 的模板语言允许开发者在模板中嵌入动态内容</li><li><strong>自动化 admin 界面</strong>: Django 自动生成管理后台.使得管理和操作数据库的过程变得非常简单.开发者可以轻松地创建,修改,删除数据库记录,而无需编写自定义的管理界面</li><li><strong>表单处理:</strong> Django 提供了强大的表单处理工具.使得用户输入的验证和处理变得更加简单.这对于开发 Web 表单和处理用户提交的数据非常有用</li><li><strong>安全性</strong>: Django 内置了一些安全性功能.例如防止常见的 Web 攻击(如 CSRF 攻击)并提供了方便的用户身份验证和授权系统</li><li><strong>可扩展性</strong>: Django 的组件是松耦合的.允许开发者使用现有的组件或编写自己的应用程序来扩展框架功能</li><li><strong>社区支持</strong>: Django 拥有庞大的社区支持.提供了大量的文档,教程,第三方包.使得学习和使用 Django 变得更加容易</li></ul></li><li><p>Django 项目</p><ul><li><p><strong>在 Pycharm 中创建 Django 项目</strong>: 只需在创建项目时选择<code>Django</code>即可</p></li><li><p>在创建 Django 目录时在<code>应用名称</code>栏输入内容后还将创建应用</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/Create_Django_Project.png" alt="Create Django Project"></p></li><li><p>项目目录</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/Django_Project_Directory.png" alt="Django Project Directory"></p></li><li><p>直接运行该项目,并访问 <a href="http://127.0.0.1:8000/.%E7%9C%8B%E5%88%B0">http://127.0.0.1:8000/.看到</a> django 页面表示成功创建项目</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/Django.png" alt="Django"></p></li></ul></li></ol><h3 id="3-2-管理网站"><a href="#3-2-管理网站" class="headerlink" title="3.2 管理网站"></a>3.2 管理网站</h3><ol><li><p>制定项目规范</p><ul><li>这是一个在线日志系统,可以记录针对某些主题学到的知识</li><li>用户能够记录感兴趣的<strong>主题(topic)</strong>,并在学习每个主题的过程中添加<strong>日志条目(entry)</strong></li><li>网站的主页对自身进行描述,邀请用户<strong>注册</strong>或<strong>登录</strong></li><li>用户登录后,可以创建新主题,添加新条目,阅读既有条目</li></ul></li><li><p>基础模型: 主题(Topic)</p><ul><li><p><strong>模型(model): 告诉 Django 如何处理应用程序中存储的数据,其本身是一个类</strong></p></li><li><p>打开<code>models.py</code>文件并添加内容: 创建<code>Topic</code>类,管理<strong>主题名称</strong>和<strong>添加时间</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Topic</span>(models.Model):<br>    <span class="hljs-string">&quot;&quot;&quot;用户学习的主题&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 存储主题名称.charField 用于存储少量文本,且必需指出字符最大长度</span><br>    text = models.CharField(max_length=<span class="hljs-number">200</span>)<br>    <span class="hljs-comment"># 存储添加的日期和时间,在此设为:自动保存为当前的日期和时间</span><br>    date_added = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.text<br></code></pre></td></tr></table></figure></li><li><p><strong>激活模型</strong>.打开<code>settings.py</code>文件.在<code>INSTALLED_APPS</code>中添加下面内容<br>(如果使用 PyCharm 创建的应用则会自动包含,而无需手动添加)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">INSTALLED_APPS = [<br>    <span class="hljs-string">&#x27;learning_log&#x27;</span>  <span class="hljs-comment"># 自己创建的应用程序名</span><br>]<br></code></pre></td></tr></table></figure></li><li><p>每当需要修改项目管理的数据时,都需要进行的步骤</p><ul><li>修改<code>models.py</code>文件</li><li><strong>创建迁移文件</strong>: 在命令行执行<code>python manage.py makemigrations learning_log</code></li><li><strong>创建&#x2F;修改数据库</strong>: 在命令行执行<code>python manage.py migrate</code></li></ul></li></ul></li><li><p>Django 管理网站</p><ul><li><p>Django 提供<strong>管理网站(admin site)</strong>: 便于处理模型.管理网站仅供管理员使用</p></li><li><p>创建<strong>超级用户(superuser)</strong></p><ul><li><p>在命令行执行<code>python manage.py createsuperuser</code></p></li><li><p>然后按照提示信息输入 用户名,邮箱(可以为空),密码(需要输入2次,且输入时不可见)</p></li><li><p>当提示<code>Superuser created successfully.</code>表示成功</p></li></ul></li><li><p><strong>向管理网站注册模型</strong>: 在<code>admin.py</code>文件中添加代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin  <span class="hljs-comment"># 导入admin</span><br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Topic  <span class="hljs-comment"># .表示就在本目录下查找包.导入Topic类</span><br>admin.site.register(Topic)  <span class="hljs-comment"># 让 Django 通过管理网站管理模型Topic</span><br></code></pre></td></tr></table></figure></li><li><p>再次运行 Django项目,访问 <a href="http://localhost:8000/admin/.%E5%8D%B3%E5%8F%AF%E8%BF%9B%E5%85%A5%E7%AE%A1%E7%90%86%E7%BD%91%E7%AB%99">http://localhost:8000/admin/.即可进入管理网站</a></p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/Admin_Site.png" alt="Admin Site"></p></li><li><p>登陆后界面</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/Django_Administration.png" alt="Django Administration"></p></li><li><p>添加主题:点击 <code>Topic</code> 栏的 <code>Add</code>.可以多次添加主题(此时手动添加 Chess 和 Rock Climbing 主题)</p></li></ul></li><li><p>基础模型: 条目(Entry)</p><ul><li><p>在 <code>model.py</code> 中添加代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>(models.Model):<br>    <span class="hljs-string">&quot;&quot;&quot;学到的有关某个主题的具体知识&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 从 Topic 处读取外键,并设置级联删除</span><br>    topic = models.ForeignKey(Topic, on_delete=models.CASCADE)<br>    text = models.TextField()  <span class="hljs-comment"># 创建一个长度不受限的文本</span><br>    date_added = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 放置时间戳</span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:  <span class="hljs-comment"># Meta 类用于管理模型的额外信息</span><br>        verbose_name_plural = <span class="hljs-string">&#x27;entries&#x27;</span>  <span class="hljs-comment"># 使用 Entries 表示多个条目</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.text[:<span class="hljs-number">50</span>]&#125;</span>...&quot;</span>  <span class="hljs-comment"># 返回 前50个字符</span><br></code></pre></td></tr></table></figure></li><li><p>每次添加模型后都需要再次迁移数据库(命令行中执行)<br><code>python manage.py makemigrations learning_log</code><br><code>python manage.py migrate</code></p></li><li><p>同样还要再次向管理网站注册 <code>Entry</code>(在<code>admin.py</code>中添加代码)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Topic, Entry<br>admin.site.register(Entry)<br></code></pre></td></tr></table></figure></li><li><p>再次访问<a href="http://localhost:8000/admin/.%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E7%AE%A1%E7%90%86%E7%BD%91%E7%AB%99%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%BA%86%E9%80%89%E9%A1%B9%60Entries%60.%E5%8F%AF%E4%BB%A5%E6%B7%BB%E5%8A%A0%E5%86%85%E5%AE%B9">http://localhost:8000/admin/.即可看到管理网站中增加了选项`Entries`.可以添加内容</a></p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/Entry.png" alt="Entry"></p></li><li><p>添加下面 Entries 条目:</p><ul><li>Chess: 国际象棋的第⼀个阶段是开局，⼤概是前 10 步左右。在开局阶段，最好做三件事情：将象和⻢调出来，努⼒控制棋盘的中间区域，以及⽤⻋将王护住。当然，这些只是指导原则。学习在什么情况下遵守、在什么情况下不⽤遵守这些原则很重要。</li><li>Chess: 在国际象棋的开局阶段，将象和⻢调出来很重要。这些棋⼦威⼒⼤、机动性强，在开局阶段扮演着重要的⾓⾊。</li><li>Rock Climbing: 最重要的攀岩概念之⼀是，尽可能让双脚承受体重。有⼈误认为攀岩者能依靠⼿臂的⼒量坚持攀岩⼀整天。实际上，优秀的攀岩者都经过专门训练，能够尽可能让双脚承受体重。</li></ul></li></ul></li><li><p><strong>Django shell</strong>: 在添加数据后可以通过交互式终端以编程的方式查看这些数据</p><ul><li><p>启动 Django shell: 在终端中执行<code>python manage.py shell</code>.接下来的代码就可在Python控制台执行</p></li><li><p>首先导入<code>Topic</code>类: <code>from learning_log.models import Topic</code></p></li><li><p>获取<code>Topic</code>类中的所有实例: <code>Topic.objects.all()</code></p><ul><li><p>这里将返回一个**查询集(queryset)**列表: <code>&lt;QuerySet [&lt;Topic: Chess&gt;, &lt;Topic: Rock Climbing&gt;]&gt;</code></p></li><li><p>遍历查询集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> topic <span class="hljs-keyword">in</span> Topic.objects.<span class="hljs-built_in">all</span>():<br>    <span class="hljs-built_in">print</span>(topic.<span class="hljs-built_in">id</span>, topic)  <span class="hljs-comment"># topic.id 可以获取对象的 ID</span><br><span class="hljs-comment"># 输出为:</span><br><span class="hljs-comment"># 1 Chess</span><br><span class="hljs-comment"># 2 Rock Climbing</span><br></code></pre></td></tr></table></figure></li><li><p>了解对象的 ID 后,可以通过<code>Topic.objects.get()</code>方法获取对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">t = Topic.objects.get(<span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 获取 Chess 主题对象</span><br>t.text  <span class="hljs-comment"># 获取对象的text属性 &#x27;Chess&#x27;</span><br>t.date_added  <span class="hljs-comment"># 获取对象的data_added属性</span><br><span class="hljs-comment"># datetime.datetime(2023, 12, 20, 7, 48, 48, 152087, tzinfo=datetime.timezone.utc)</span><br></code></pre></td></tr></table></figure></li><li><p>通过外键获取数据(Topic 通过外键与 entry关联): 使用相关模型的 <code>小写名 _set</code>(如<code>entry_set</code>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">t.entry_set.<span class="hljs-built_in">all</span>()<br></code></pre></td></tr></table></figure></li></ul></li><li><p>退出shell: 按 Ctrl + Z,然后 Enter</p></li></ul></li></ol><h3 id="3-3-创建网页"><a href="#3-3-创建网页" class="headerlink" title="3.3 创建网页"></a>3.3 创建网页</h3><ol><li><p>使用 Django 创建网页的过程分为三阶段: <strong>定义 URL,编写视图,编写模板</strong></p><ul><li><strong>URL 模式</strong>: 描述 URL的构成,让 Django 了解如何将浏览器请求与网站 URL匹配,确定返回的网页</li><li>每个 URL 都被映射到特定的视图.<strong>视图函数</strong>获取并处理网页所需的数据</li><li>视图函数通常使用模板渲染网页.而<strong>模板</strong>定义网页的总体结构</li></ul></li><li><p>创建主页</p><ul><li><p>基础 URL(<a href="http://localhost:8000/)%E5%B0%86%E8%BF%94%E5%9B%9E%E9%BB%98%E8%AE%A4%E7%9A%84">http://localhost:8000/)将返回默认的</a> Django ⽹站.表示正确地创建了项目</p></li><li><p>映射 URL: 在文件<code>myDjangoProject/urls.py</code>中添加代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path, include<br><br>urlpatterns = [  <span class="hljs-comment"># 存储项目中应用程序的URL</span><br>    path(<span class="hljs-string">&#x27;admin/&#x27;</span>, admin.site.urls),  <span class="hljs-comment"># 定义可在管理网站中请求的所有URL</span><br>    path(<span class="hljs-string">&#x27;&#x27;</span>, include(<span class="hljs-string">&#x27;learning_log.urls&#x27;</span>)),  <span class="hljs-comment"># 包含 learning_log app 的 URL</span><br>]<br></code></pre></td></tr></table></figure></li><li><p>编写自己项目中的 URL(在<code>learning_log</code>目录中新建<code>urls.py</code>文件,并添加代码)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;定义learning_log的 URL模式&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>app_name = <span class="hljs-string">&#x27;learning_log&#x27;</span>  <span class="hljs-comment"># 表示当前的 urls.py文件 位于哪个目录</span><br>urlpatterns = [  <span class="hljs-comment"># 包含所有可在应用程序 learning_log 中请求的网页</span><br>    <span class="hljs-comment"># 主页路径: 指定空字符串 route 请求.因为Django会忽略基础url(http://localhost:8000/)</span><br>    <span class="hljs-comment"># 匹配成功后将会自动调用 views.py 文件中的 index 函数; 同时指定 URL模式名为 &#x27;index&#x27;</span><br>    path(<span class="hljs-string">&#x27;&#x27;</span>, views.index, name=<span class="hljs-string">&#x27;index&#x27;</span>),<br>]<br></code></pre></td></tr></table></figure></li><li><p>编写视图(在<code>view.py</code>文件中添加代码)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;学习笔记的主页&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 将请求request作为参数传入.render函数将会根据&lt;request和模板文件&gt;创建网页</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;index.html&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>编写模板(在项目初始创建的<code>templates</code>中新建文件<code>index.html</code>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Learning Log<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Learning Log helps you keep track of your learning, for any topic you&#x27;re interested in.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>此时访问<a href="http://127.0.0.1:8000/.%E9%BB%98%E8%AE%A4%E7%9A%84">http://127.0.0.1:8000/.默认的</a> Django 页面将被替换为</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/Django_Default_Page.png" alt="Django Default Page"></p></li></ul></li><li><p>创建其他网页</p><ul><li><p>在创建网站时,可以抽象一个包含通用元素的父模板.然后让其他网页继承父模板</p></li><li><p>创建网页时主要专注于两方面: 显示所有主题的网页,显示特定主题中条目的网页</p></li><li><p>创建父模板(该模板<code>base.html</code> 与主页模板<code>index.html</code> 位于同一目录)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;</span>&gt;</span>Learning Log<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 生成一个与 index 模式匹配的URL.作为主页网址一直显示 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>&#123;% block content %&#125;&#123;% endblock content %&#125;<br></code></pre></td></tr></table></figure></li><li><p>重写子模版<code>index.html</code>(继承自父模板<code>base.html</code>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &#x27;base.html&#x27; %&#125;<br>&#123;% block content %&#125;<br><span class="hljs-comment">&lt;!-- 重写名为 content 块标签的内容 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Learning Log helps you keep track of your learning, for any topic you&#x27;re interested in.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>显示所有主题的页面</p><ul><li><p>URL 模式: 通常使用一个简单的URL片段来指出网页显示的信息(可用<code>topics</code>)<br>在 <code>learning_log/urls.py</code> 中增加代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 显示所有主题的页面</span><br>path(<span class="hljs-string">&#x27;topics/&#x27;</span>, views.topics, name=<span class="hljs-string">&#x27;topics&#x27;</span>),<br></code></pre></td></tr></table></figure></li><li><p>视图: 在<code>views.py</code> 中增加代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Topic<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">topics</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;显示所有的主题&quot;&quot;&quot;</span><br>    topics = Topic.objects.order_by(<span class="hljs-string">&#x27;date_added&#x27;</span>)<br>    <span class="hljs-comment"># topics是一个查询集.包括了所有的Topic实例</span><br>    context = &#123;<span class="hljs-string">&#x27;topics&#x27;</span>: topics&#125;<br>    <span class="hljs-comment"># context对象将会作为参数传递给模板文件topics.html</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;topics.html&#x27;</span>, context)<br></code></pre></td></tr></table></figure></li><li><p>模板: 在<code>templates</code>目录下新建文件<code>topics.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &#x27;base.html&#x27; %&#125;<br>&#123;% block content %&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Topics<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        &#123;% for topic in topics %&#125;<br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;&#123; topic.text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        &#123;% empty %&#125;<br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>No topics have been added yet.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        &#123;% endfor %&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改父模板: 在<code>base.html</code>文件中添加代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;</span>&gt;</span>Learning Log<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> -<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:topics&#x27; %&#125;&quot;</span>&gt;</span>Topics<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>此时访问 <a href="http://127.0.0.1:8000/topics/">http://127.0.0.1:8000/topics/</a> 即可看到所有主题</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/Topics.png" alt="Topics"></p></li></ul></li><li><p>显示特定主题的页面</p><ul><li><p>URL 模式: 在 <code>learning_log/urls.py</code> 中增加代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 显示特定主题的详细页面</span><br>path(<span class="hljs-string">&#x27;topics/&lt;int:topic_id&gt;/&#x27;</span>, views.topic, name=<span class="hljs-string">&#x27;topic&#x27;</span>),<br></code></pre></td></tr></table></figure></li><li><p>视图: 在<code>views.py</code> 中增加代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">topic</span>(<span class="hljs-params">request, topic_id</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;显示单个主题及其所有条目&quot;&quot;&quot;</span><br>    topic = Topic.objects.get(<span class="hljs-built_in">id</span>=topic_id)<br>    entries = topic.entry_set.order_by(<span class="hljs-string">&#x27;-date_added&#x27;</span>)<br>    context = &#123;<span class="hljs-string">&#x27;topic&#x27;</span>: topic, <span class="hljs-string">&#x27;entries&#x27;</span>: entries&#125;<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;topic.html&#x27;</span>, context)<br></code></pre></td></tr></table></figure></li><li><p>模板: 在<code>templates</code>目录下新建文件<code>topic.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &#x27;base.html&#x27; %&#125;<br>&#123;% block content %&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Topics: &#123;&#123; topic.text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Entries:<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        &#123;% for entry in entries %&#125;<br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; entry.date_added|date:&#x27;M d, Y H:i&#x27; &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; entry.text|linebreaks &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        &#123;% empty %&#125;<br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>There are no entries for this topic yet.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        &#123;% endfor %&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>&#123;% endblock content %&#125;<br></code></pre></td></tr></table></figure></li><li><p>将显示所有主题的页面链接到特定主题的页面: 在<code>topics.html</code>添加代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id %&#125;&quot;</span>&gt;</span>&#123;&#123; topic.text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>此时访问 <a href="http://127.0.0.1:8000/topics/1/">http://127.0.0.1:8000/topics/1/</a> 即可看到 <code>Chess</code> 主题的内容</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/Topic_Chess.png" alt="Topic Chess"></p></li></ul></li></ol><h3 id="3-4-修改数据"><a href="#3-4-修改数据" class="headerlink" title="3.4 修改数据"></a>3.4 修改数据</h3><ol><li><p>本节将创建一些表单,让用户可以添加主题和条目,并可以编辑现有条目</p></li><li><p><strong>添加新主题</strong>: 创建基于表单的页面方法与创建网页一样(定义URL,编写视图函数,编写模板)</p><ul><li><p>表单(form): 在<code>learning_log</code>目录下创建<code>forms.py</code>文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django <span class="hljs-keyword">import</span> forms<br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Topic<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TopicForm</span>(forms.ModelForm):<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:  <span class="hljs-comment"># 内嵌的 Meta 类</span><br>        model = Topic  <span class="hljs-comment"># 根据模型Topic创建表单</span><br>        fields = [<span class="hljs-string">&#x27;text&#x27;</span>]  <span class="hljs-comment"># 字段列表.只有 text 字段</span><br>        labels = &#123;<span class="hljs-string">&#x27;text&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;  <span class="hljs-comment"># 标签为空字符串表示不要为text字段生成标签</span><br></code></pre></td></tr></table></figure></li><li><p>URL 模式: 在 <code>learning_log/urls.py</code> 中增加代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用于添加新主题的网页</span><br>path(<span class="hljs-string">&#x27;new_topic/&#x27;</span>, views.new_topic, name=<span class="hljs-string">&#x27;new_topic&#x27;</span>),<br></code></pre></td></tr></table></figure></li><li><p>视图: 在<code>views.py</code> 中增加代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render, redirect<br><span class="hljs-keyword">from</span> .forms <span class="hljs-keyword">import</span> TopicForm<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">new_topic</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;添加新主题&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> request.method != <span class="hljs-string">&#x27;POST&#x27;</span>:<br>        <span class="hljs-comment"># 未提交数据:创建一个新表单</span><br>        form = TopicForm()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># POST 提交的数据:对数据进行处理</span><br>        form = TopicForm(data=request.POST)<br>        <span class="hljs-keyword">if</span> form.is_valid():<br>            form.save()<br>            <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&#x27;learning_log:topics&#x27;</span>)  <span class="hljs-comment"># 重定向到网页 topics</span><br><br>    <span class="hljs-comment"># 显示空表单或指出表单数据无效</span><br>    context = &#123;<span class="hljs-string">&#x27;form&#x27;</span>: form&#125;<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;new_topic.html&#x27;</span>, context)<br></code></pre></td></tr></table></figure></li><li><p>模板: 在<code>templates</code>目录下新建文件<code>new_topic.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &#x27;base.html&#x27; %&#125;<br>&#123;% block content %&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Add a new topic:<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:new_topic&#x27; %&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        &#123;% csrf_token %&#125;<br>        &#123;&#123; form.as_div &#125;&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Add topic<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>&#123;% endblock content %&#125;<br></code></pre></td></tr></table></figure></li><li><p>将<code>new_topic</code>页面链接到<code>topics</code>页面: 在<code>topics.html</code>添加代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:new_topic&#x27; %&#125;&quot;</span>&gt;</span>Add a new topic<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>访问 <a href="http://127.0.0.1:8000/new_topic/">http://127.0.0.1:8000/new_topic/</a> 即可看到添加新主题的页面</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/Add_New_Topic.png" alt="Add New Topic"></p></li></ul></li><li><p><strong>添加新条目</strong></p><ul><li><p>表单(form): 在<code>forms.py</code>文件中增加代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Topic, Entry<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EntryForm</span>(forms.ModelForm):<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        model = Entry<br>        fields = [<span class="hljs-string">&#x27;text&#x27;</span>]<br>        labels = &#123;<span class="hljs-string">&#x27;text&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;<br>        widgets = &#123;<span class="hljs-string">&#x27;text&#x27;</span>: forms.Textarea(attrs=&#123;<span class="hljs-string">&#x27;cols&#x27;</span>: <span class="hljs-number">80</span>&#125;)&#125;<br></code></pre></td></tr></table></figure></li><li><p>URL 模式: 在 <code>learning_log/urls.py</code> 中增加代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用于添加新条目的页面</span><br>path(<span class="hljs-string">&#x27;new_entry/&lt;int:topic_id&gt;/&#x27;</span>, views.new_entry, name=<span class="hljs-string">&#x27;new_entry&#x27;</span>),<br></code></pre></td></tr></table></figure></li><li><p>视图: 在<code>views.py</code> 中增加代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .forms <span class="hljs-keyword">import</span> TopicForm, EntryForm<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">new_entry</span>(<span class="hljs-params">request, topic_id</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;在特定主题中添加新条目&quot;&quot;&quot;</span><br>    topic = Topic.objects.get(<span class="hljs-built_in">id</span>=topic_id)<br>    <span class="hljs-keyword">if</span> request.method != <span class="hljs-string">&#x27;POST&#x27;</span>:<br>        <span class="hljs-comment"># 未提交数据:创建一个新表单</span><br>        form = EntryForm()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># POST 提交的数据:对数据进行处理</span><br>        form = EntryForm(data=request.POST)<br>        <span class="hljs-keyword">if</span> form.is_valid():<br>            new_entry = form.save(commit=<span class="hljs-literal">False</span>)<br>            new_entry.topic = topic<br>            new_entry.save()<br>            <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&#x27;learning_log:topic&#x27;</span>, topic_id=topic_id)<br><br>    <span class="hljs-comment"># 显示空表单或指出表单数据无效</span><br>    context = &#123;<span class="hljs-string">&#x27;topic&#x27;</span>: topic, <span class="hljs-string">&#x27;form&#x27;</span>: form&#125;<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;new_entry.html&#x27;</span>, context)<br></code></pre></td></tr></table></figure></li><li><p>模板: 在<code>templates</code>目录下新建文件<code>new_entry.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &#x27;base.html&#x27; %&#125;<br>&#123;% block content %&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id%&#125;&quot;</span>&gt;</span>&#123;&#123; topic &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Add a new entry:<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:new_entry&#x27; topic.id %&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        &#123;% csrf_token %&#125;<br>        &#123;&#123; form.as_div &#125;&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Add entry<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>&#123;% endblock content %&#125;<br></code></pre></td></tr></table></figure></li><li><p>将<code>new_entry</code>页面链接到<code>topic</code>页面: 在<code>topic.html</code>添加代码(<code>ul</code>标签前)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:new_entry&#x27; topic.id %&#125;&quot;</span>&gt;</span>Add new entry<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>访问 <a href="http://127.0.0.1:8000/new_entry/1/">http://127.0.0.1:8000/new_entry/1/</a> 即可看到添加新条目的页面</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/Add_New_Entry.png" alt="Add New Entry"></p></li></ul></li><li><p>编辑条目</p><ul><li><p>URL 模式: 在 <code>learning_log/urls.py</code> 中增加代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用于编辑条目的页面</span><br>path(<span class="hljs-string">&#x27;edit_entry/&lt;int:entry_id&gt;/&#x27;</span>, views.edit_entry, name=<span class="hljs-string">&#x27;edit_entry&#x27;</span>),<br></code></pre></td></tr></table></figure></li><li><p>视图函数: 在<code>views.py</code> 中增加代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Topic, Entry<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit_entry</span>(<span class="hljs-params">request, entry_id</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;编辑既有条目&quot;&quot;&quot;</span><br>    entry = Entry.objects.get(<span class="hljs-built_in">id</span>=entry_id)<br>    topic = entry.topic<br><br>    <span class="hljs-keyword">if</span> request.method != <span class="hljs-string">&#x27;POST&#x27;</span>:<br>        <span class="hljs-comment"># 初次请求:使用当前条目填充表单</span><br>        form = EntryForm(instance=entry)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># POST 提交的数据: 对数据进行处理</span><br>        form = EntryForm(instance=entry, data=request.POST)<br>        <span class="hljs-keyword">if</span> form.is_valid():<br>            form.save()<br>            <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&#x27;learning_log:topic&#x27;</span>, topic_id=topic.<span class="hljs-built_in">id</span>)<br>    context = &#123;<span class="hljs-string">&#x27;entry&#x27;</span>: entry, <span class="hljs-string">&#x27;topic&#x27;</span>: topic, <span class="hljs-string">&#x27;form&#x27;</span>: form&#125;<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;edit_entry.html&#x27;</span>, context)<br></code></pre></td></tr></table></figure></li><li><p>模板: 在<code>templates</code>目录下新建文件<code>edit_entry.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &#x27;base.html&#x27; %&#125;<br>&#123;% block content %&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id%&#125;&quot;</span>&gt;</span>&#123;&#123; topic &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Edit entry:<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:edit_entry&#x27; entry.id %&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        &#123;% csrf_token %&#125;<br>        &#123;&#123; form.as_div &#125;&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Add entry<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>&#123;% endblock content %&#125;<br></code></pre></td></tr></table></figure></li><li><p>将<code>edit_entry</code>页面链接到<code>topic</code>页面: 在<code>topic.html</code>添加代码(<code>li</code>标签中)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:edit_entry&#x27; entry.id %&#125;&quot;</span>&gt;</span>Edit entry<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>访问 <a href="http://127.0.0.1:8000/edit_entry/1/">http://127.0.0.1:8000/edit_entry/1/</a> 即可看到编辑条目的页面</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/Edit_Entry.png" alt="Edit Entry"></p></li></ul></li></ol><h3 id="3-5-用户账户"><a href="#3-5-用户账户" class="headerlink" title="3.5 用户账户"></a>3.5 用户账户</h3><ol><li><p>Web 应用程序的核心是让任何地方的任何用户都可以注册账户来使用它</p></li><li><p>应用程序 accounts</p><ul><li><p>在终端中执行<code>python manage.py startapp accounts</code></p><ul><li>Python 将会创建一个与<code>learning_log</code>平行的应用程序<code>accounts</code></li><li><code>accounts</code>的目录结构也与<code>learning_log</code>最初的形态一致</li></ul></li><li><p>将<code>accounts</code>添加到<code>myDjangoProject/setting.py</code>中找到 <code>INSTALLED_APPS</code>列表,在其中添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;accounts.apps.AccountsConfig&#x27;</span>,<br></code></pre></td></tr></table></figure></li><li><p>包含 accounts 的 URL.在<code>myDjangoProject/urls.py</code>中添加代码(管理网站路径后)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">path(<span class="hljs-string">&#x27;accounts/&#x27;</span>, include(<span class="hljs-string">&#x27;accounts.urls&#x27;</span>)),  <span class="hljs-comment"># 包含 accounts 的 URL</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>登录页面</p><ul><li><p>URL 模式: 在<code>accounts</code>目录下新建<code>urls.py</code>文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;定义accounts的 URL 模式&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path, include<br><br>app_name = <span class="hljs-string">&#x27;accounts&#x27;</span><br>urlpatterns = [<br>    <span class="hljs-comment"># 包含默认的身份验证 URL.与http://localhost:8000/accounts/login/匹配</span><br>    path(<span class="hljs-string">&#x27;&#x27;</span>, include(<span class="hljs-string">&#x27;django.contrib.auth.urls&#x27;</span>)),<br>]<br></code></pre></td></tr></table></figure></li><li><p>视图函数: 当用户请求登录页面时,Django将使用默认的视图函数.但仍需要为其建立模板</p></li><li><p>模板: 默认的身份验证视图函数 会在<code>registration</code>目录中查找模板<br>新建<code>accounts/templates/registration/login.html</code>文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &#x27;base.html&#x27; %&#125;<br>&#123;% block content %&#125;<br>    &#123;% if form.errors %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Your username and password didn&#x27;t match. Please try again.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    &#123;% endif %&#125;<br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        &#123;% csrf_token %&#125;<br>        &#123;&#123; form.as_div &#125;&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>log in<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>&#123;% endblock content %&#125;<br></code></pre></td></tr></table></figure></li><li><p>设置 LOGIN_REDIRECT_URL: 当用户成功登陆后,需要给用户重定向<br>在<code>myDjangoProject/setting.py</code>的末尾添加代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 我的设置</span><br>LOGIN_REDIRECT_URL = <span class="hljs-string">&#x27;learning_log:index&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>链接到登录页面(调整<code>base.html</code>代码)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;</span>&gt;</span>Learning Log<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> -<br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:topics&#x27; %&#125;&quot;</span>&gt;</span>Topics<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> -<br>    &#123;% if user.is_authenticated %&#125;<br>        Hello, &#123;&#123; user.username &#125;&#125;.<br>    &#123;% else %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot;</span>&gt;</span>Log in<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    &#123;% endif %&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>&#123;% block content %&#125;&#123;% endblock content %&#125;<br></code></pre></td></tr></table></figure></li><li><p>先进入<a href="http://127.0.0.1:8000/admin/">管理网站</a>注销登录,然后进入<a href="http://127.0.0.1:8000/accounts/login/">登录页面</a>进行登录</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/Login.png" alt="Login"></p></li></ul></li><li><p>注销</p><ul><li><p>在<code>base.html</code>中添加注销表单</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% if user.is_authenticated %&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&#123;% url &#x27;accounts:logout&#x27; %&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        &#123;% csrf_token %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;submit&#x27;</span>&gt;</span>Log out<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure></li><li><p>设置 LOGOUT_REDIRECT_URL: 当用户成功注销后,需要给用户重定向<br>在<code>myDjangoProject/setting.py</code>的末尾添加代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">LOGOUT_REDIRECT_URL = <span class="hljs-string">&#x27;learning_log:index&#x27;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>注册页面</p><ul><li><p>URL 模式: 在<code>accounts/urls.py</code>中添加代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><span class="hljs-comment"># 注册页面</span><br>path(<span class="hljs-string">&#x27;register/&#x27;</span>, views.register, name=<span class="hljs-string">&#x27;register&#x27;</span>),<br></code></pre></td></tr></table></figure></li><li><p>视图函数: 在<code>account/views.py</code>中添加代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render, redirect<br><span class="hljs-keyword">from</span> django.contrib.auth <span class="hljs-keyword">import</span> login<br><span class="hljs-keyword">from</span> django.contrib.auth.forms <span class="hljs-keyword">import</span> UserCreationForm<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;注册新用户&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> request.method != <span class="hljs-string">&#x27;POST&#x27;</span>:<br>        <span class="hljs-comment"># 显示空的注册表单</span><br>        form = UserCreationForm()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 处理填好的表单</span><br>        form = UserCreationForm(data=request.POST)<br>        <span class="hljs-keyword">if</span> form.is_valid():<br>            new_user = form.save()<br>            <span class="hljs-comment"># 自动登录,然后重定向到主页</span><br>            login(request, new_user)<br>            <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&#x27;learning_log:index&#x27;</span>)<br>    <span class="hljs-comment"># 显示空表单或指出表单无效</span><br>    context = &#123;<span class="hljs-string">&#x27;form&#x27;</span>: form&#125;<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;register.html&#x27;</span>, context)<br></code></pre></td></tr></table></figure></li><li><p>模板: 在<code>templates</code>目录下新建文件<code>register.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &quot;base.html&quot; %&#125;<br>&#123;% block content %&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        &#123;% csrf_token %&#125;<br>        &#123;&#123; form.as_div &#125;&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Register<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>&#123;% endblock content %&#125;<br></code></pre></td></tr></table></figure></li><li><p>链接到注册页面(在<code>base.html</code>的第7行增加)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot;</span>&gt;</span>Register<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><a href="http://127.0.0.1:8000/accounts/register/">注册界面</a></p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/2.%E9%A1%B9%E7%9B%AE/assets/Register.png" alt="Register"></p></li></ul></li></ol><h3 id="3-6-用户数据"><a href="#3-6-用户数据" class="headerlink" title="3.6 用户数据"></a>3.6 用户数据</h3><ol><li><p>装饰器<code>@login_required</code>可以限制对指定页面的访问</p><ul><li><p>限制对 topics 页面的访问(在<code>learning_log/views.py</code>文件中添加代码)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib.auth.decorators <span class="hljs-keyword">import</span> login_required<br></code></pre></td></tr></table></figure></li><li><p>限制对页面的访问: 在<code>topics, topic, new_topic, new_entry, edit_entry</code>视图前加上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@login_required</span><br></code></pre></td></tr></table></figure></li><li><p>对于未登录但请求<code>@login_required</code>保护的页面,使其重定向到登录页面(在<code>settings.py</code>末尾添加)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">LOGIN_URL = <span class="hljs-string">&#x27;accounts:login&#x27;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>将数据关联到用户</p><ul><li><p>只需将最高层的数据(在这里是主题)关联到用户,则底层的数据也将自动关联到该用户</p></li><li><p>给模型 Topic 添加属性 owner (<code>learning_log/models.py</code>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib.auth.models <span class="hljs-keyword">import</span> User<br><br>owner = models.ForeignKey(User, on_delete=models.CASCADE)<br></code></pre></td></tr></table></figure></li><li><p>确定当前有哪些用户</p><ul><li><p>启动Django shell: 在终端执行<code>python manage.py shell</code></p></li><li><p>在 python 控制台依次执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib.auth.models <span class="hljs-keyword">import</span> User<br>User.objects.<span class="hljs-built_in">all</span>()  <span class="hljs-comment"># &lt;QuerySet [&lt;User: fxs&gt;, &lt;User: 888&gt;]&gt;</span><br><span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> User.objects.<span class="hljs-built_in">all</span>():<br>    <span class="hljs-built_in">print</span>(user.username, user.<span class="hljs-built_in">id</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>迁移数据库(在终端中执行)</p><ul><li><p><code>python manage.py makemigrations learning_log</code></p><ul><li>由于将数据关联到了用户而未指定默认用户.Python 将会询问:<br>将其关联到特定用户 还是 在models.py文件中指定默认用户.这里输入1即可</li><li>接下来就要指定想要关联到的用户id.这里同样输入1,使得数据与管理用户关联</li></ul></li><li><p><code>python manage.py migrate</code></p></li><li><p>验证迁移完成(在Django shell中执行)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> learning_log.models <span class="hljs-keyword">import</span> Topic<br><span class="hljs-keyword">for</span> topic <span class="hljs-keyword">in</span> Topic.objects.<span class="hljs-built_in">all</span>():<br>    <span class="hljs-built_in">print</span>(topic, topic.owner)<br><span class="hljs-comment"># Chess fxs</span><br><span class="hljs-comment"># Rock Climbing fxs</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>只允许用户访问自己的主题(修改<code>learning_log/views.py</code>的<code>topics</code>视图)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">topics = Topic.objects.<span class="hljs-built_in">filter</span>(owner=request.user).order_by(<span class="hljs-string">&#x27;date_added&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>保护用户的主题: 对于请求不存在的资源,标准做法是返回404(修改<code>learning_log/views.py</code>的<code>topic</code>视图)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> Http404<br><span class="hljs-comment"># 确认请求的主题属于当前用户(添加到topic属性的后面)</span><br><span class="hljs-keyword">if</span> topic.owner != request.user:<br>    <span class="hljs-keyword">raise</span> Http404<br></code></pre></td></tr></table></figure></li><li><p>保护 edit_entry 页面: 防止用户通过访问编辑条目的网页获取其他用户的数据<br>(修改<code>learning_log/views.py</code>的<code>edit_entry</code>视图)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> topic.owner != request.user:<br>    <span class="hljs-keyword">raise</span> Http404<br></code></pre></td></tr></table></figure></li><li><p>将新主题关联到用户: 添加新主题时需要绑定用户(修改<code>learning_log/views.py</code>的<code>new_topic</code>视图)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加位置 if form.is_valid(): 删掉原有的form.save()</span><br>new_topic = form.save(commit=<span class="hljs-literal">False</span>)<br>new_topic.owner = request.user<br>new_topic.save()<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-7-设置程序样式"><a href="#3-7-设置程序样式" class="headerlink" title="3.7 设置程序样式"></a>3.7 设置程序样式</h3><ol><li><p>django-bootstrap5</p><ul><li><p>安装: <code> pip install django-bootstrap5</code></p></li><li><p>将 django-bootstrap5 添加到<code>setting.py</code>的 INSTALLED_APPS 列表中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;django_bootstrap5&#x27;</span>,<br></code></pre></td></tr></table></figure></li></ul></li><li><p>完全重写<code>base.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Learning Log<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>    &#123;% load django_bootstrap5 %&#125;<br>    &#123;% bootstrap_css %&#125;<br>    &#123;% bootstrap_javascript %&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar navbar-expand-md navbar-light bg-light mb-4 border&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container-fluid&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-brand&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:index&#x27; %&#125;&quot;</span>&gt;</span>Learning Log<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar-toggler&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">data-bs-toggle</span>=<span class="hljs-string">&quot;collapse&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">data-bs-target</span>=<span class="hljs-string">&quot;#navbarCollapse&quot;</span> <span class="hljs-attr">aria-controls</span>=<span class="hljs-string">&quot;navbarCollapse&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">aria-expanded</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">&quot;Toggle navigation&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar-toggler-icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;collapse navbar-collapse&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;navbarCollapse&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar-nav me-auto mb-2 mb-md-0&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-item&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-link&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:topics&#x27; %&#125;&quot;</span>&gt;</span>Topics<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span> <span class="hljs-comment">&lt;!-- 定义导航栏左侧链接的代码结束 --&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- 与账户相关的链接 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar-nav ms-auto mb-2 mb-md-0&quot;</span>&gt;</span><br>                &#123;% if user.is_authenticated %&#125;<br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-item&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar-text me-2&quot;</span>&gt;</span>Hello, &#123;&#123; user.username &#125;&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                &#123;% else %&#125;<br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-item&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-link&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot;</span>&gt;</span>Register<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-item&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-link&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot;</span>&gt;</span>Log in<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                &#123;% endif %&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span> <span class="hljs-comment">&lt;!-- 与账户相关的链接到此结束 --&gt;</span><br><br>            &#123;% if user.is_authenticated %&#125;<br>                <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&#123;% url &#x27;accounts:logout&#x27; %&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>                    &#123;% csrf_token %&#125;<br>                    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-outline-secondary btn-sm&quot;</span>&gt;</span>Log out<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>            &#123;% endif %&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- 定义导航栏可折叠部分的代码结束 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- 定义导航栏容器的代码结束 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span> <span class="hljs-comment">&lt;!-- 定义导航栏的代码结束 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pb-2 mb-2 border-bottom&quot;</span>&gt;</span><br>        &#123;% block page_header %&#125;&#123;% endblock page_header %&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        &#123;% block content %&#125;&#123;% endblock content %&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>设置主页的样式(重写<code>index.html</code>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &#x27;base.html&#x27; %&#125;<br>&#123;% block page_header %&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p-3 mb-4 bg-light border rounded-3&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container-fluid py-4&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;display-3&quot;</span>&gt;</span>Track your learning.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lead&quot;</span>&gt;</span>Make you own Learning Log, and keep a list of the topics you&#x27;re learning about.Whenever you learn something new about a topic, make an entry summarizing what you&#x27;ve learned.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary btn-lg mt-1&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;accounts:register&#x27; %&#125;&quot;</span>&gt;</span>Register <span class="hljs-symbol">&amp;raquo;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>&#123;% endblock page_header %&#125;<br></code></pre></td></tr></table></figure></li><li><p>设置登录页面的样式(重写<code>login.html</code>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &#x27;base.html&#x27; %&#125;<br>&#123;% load django_bootstrap5 %&#125;<br>&#123;% block page_header %&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Log in to your account.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>&#123;% endblock page_header %&#125;<br><br>&#123;% block content %&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&#123;% url &#x27;accounts:login&#x27; %&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        &#123;% csrf_token %&#125;<br>        &#123;% bootstrap_form form %&#125;<br>        &#123;% bootstrap_button button_type=&quot;submit&quot; content=&quot;Log in&quot;%&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>&#123;% endblock content %&#125;<br></code></pre></td></tr></table></figure></li><li><p>设置 topics 页面的样式(重写<code>topics.html</code>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &#x27;base.html&#x27; %&#125;<br>&#123;% block page_header %&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Topics<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>&#123;% endblock page_header %&#125;<br><br>&#123;% block content %&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Topics<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-group border-bottom pb-2 mb-4&quot;</span>&gt;</span><br>        &#123;% for topic in topics %&#125;<br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-group-item border-0&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:topic&#x27; topic.id %&#125;&quot;</span>&gt;</span>&#123;&#123; topic.text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        &#123;% empty %&#125;<br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-group-item border-0&quot;</span>&gt;</span>No topics have been added yet.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        &#123;% endfor %&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:new_topic&#x27; %&#125;&quot;</span>&gt;</span>Add a new topic<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure></li><li><p>设置 topic 页面中条目的样式(重写<code>topic.html</code>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &#x27;base.html&#x27; %&#125;<br>&#123;% block page_header %&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; topic.text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>&#123;% endblock page_header %&#125;<br><br>&#123;% block content %&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:new_entry&#x27; topic.id %&#125;&quot;</span>&gt;</span>Add new entry<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>    &#123;% for entry in entries %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card mb-3&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 包含时间戳和编辑链接的标题 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-header&quot;</span>&gt;</span>&#123;&#123; entry.date_added|date:&#x27;M d, Y H:i&#x27; &#125;&#125;<br>                <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;learning_log:edit_entry&#x27; entry.id %&#125;&quot;</span>&gt;</span>edit entry<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 包含文本条目的正文 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-body&quot;</span>&gt;</span>&#123;&#123; entry.text|linebreaks &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    &#123;% empty %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>There are no entries for this topic yet.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    &#123;% endfor %&#125;<br>&#123;% endblock content %&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python编程：从入门到实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 入门</title>
    <link href="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/1.%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/1.%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-入门"><a href="#Python-入门" class="headerlink" title="Python 入门"></a>Python 入门</h1><h2 id="0-Python-基础"><a href="#0-Python-基础" class="headerlink" title="0 Python 基础"></a>0 Python 基础</h2><h3 id="0-1-关键字"><a href="#0-1-关键字" class="headerlink" title="0.1 关键字"></a>0.1 关键字</h3><ol><li><p><strong>利用Python标准库提供的 <code>keyword</code>模块.输出当前版本的所有关键字</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> keyword<br><span class="hljs-built_in">print</span>(keyword.kwlist)<br></code></pre></td></tr></table></figure></li><li><p>Python 关键字</p><ul><li>基本类型: <code>False, True, None</code></li><li>控制流: <ul><li>分支结构: <code>if, elif, else[, match, case]</code></li><li>循环结构: <code>for, in, while, continue, break</code></li><li>逻辑判断: <code>and, or, not, is</code></li></ul></li><li>类,函数,对象: <code>class, def, return, pass ,lambda, del</code></li><li>异常处理: <code>assert, try, except, finally, raise</code></li><li>包: <code>import, from, as</code></li><li>线程: <code>async, yield, await</code></li><li>其他: <code>global, nonlocal, with</code></li></ul></li></ol><h3 id="0-2-特性"><a href="#0-2-特性" class="headerlink" title="0.2 特性"></a>0.2 特性</h3><ol><li><strong>易于学习</strong>: Python 关键字较少,结构简单</li><li><strong>易于阅读</strong>: Python 代码定义清晰</li><li><strong>易于维护</strong>: Python 的成功在于其源代码是相当容易维护</li><li><strong>广泛的标准库</strong>: Python 的最大的优势之一是丰富的库.可跨平台</li><li><strong>互动模式</strong>: 可从终端输入执行代码并获得结果的语言,互动的测试和调试代码片断</li><li><strong>可移植</strong>: 基于其开放源代码的特性.Python 已经被移植到许多平台</li><li><strong>可扩展</strong>: 如果需要关键代码有性能要求,或者不想公开算法.可以使用 C&#x2F;C++ 完成,然后由 Python 调用</li><li><strong>数据库</strong>: Python 提供所有主要的商业数据库的接口</li><li><strong>GUI编程</strong>: Python 支持 GUI 可以创建和移植到许多系统调用</li><li><strong>可嵌入</strong>: Python 可以嵌入到 C&#x2F;C++ 程序,让程序的用户获得”脚本化”的能力</li></ol><h3 id="0-3-注释"><a href="#0-3-注释" class="headerlink" title="0.3 注释"></a>0.3 注释</h3><ol><li><p>单行注释: <code># text</code></p></li><li><p>文件编码声明注释(位于文件首行): <code># coding:utf-8</code></p></li><li><p>多行注释: <code>&#39;&#39;&#39; text &#39;&#39;&#39; </code> or <code>&quot;&quot;&quot; text &quot;&quot;&quot;</code></p></li><li><p>文档注释:</p><ul><li>其本质是多行注释</li><li>位于方法体最前面</li><li>方法的 <strong><code>__doc__</code> 属性可以获取文档注释</strong></li></ul></li><li><p>行与缩进</p><ul><li><strong>python 使用缩进来表示代码块,不需要使用大括号</strong></li><li><strong>缩进的空格数是可变的,但同一代码块的语句必须包含相同的缩进空格数</strong></li><li><strong>与 C 相同: Python 同样以在行尾加上续行转义符 <code>\</code> 来实现多行语句</strong></li><li><strong>在 <code>[], &#123;&#125;, ()</code> 中的多行语句自动续行.不需要使用反斜杠 <code>\</code> 续行</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_hi</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param name: 被打印的字符串</span><br><span class="hljs-string">    :return: None</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Hi, <span class="hljs-subst">&#123;name&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>Python 之禅</strong>: <code>import this</code></p><blockquote><p>The Zen of Python, by Tim Peters</p><p>Beautiful is better than ugly.<br>Explicit is better than implicit.<br>Simple is better than complex.<br>Complex is better than complicated.<br>Flat is better than nested.<br>Sparse is better than dense.<br>Readability counts.<br>Special cases aren’t special enough to break the rules.<br>Although practicality beats purity.<br>Errors should never pass silently.<br>Unless explicitly silenced.<br>In the face of ambiguity, refuse the temptation to guess.<br>There should be one– and preferably only one –obvious way to do it.<br>Although that way may not be obvious at first unless you’re Dutch.<br>Now is better than never.<br>Although never is often better than <em>right</em> now.<br>If the implementation is hard to explain, it’s a bad idea.<br>If the implementation is easy to explain, it may be a good idea.<br>Namespaces are one honking great idea – let’s do more of those!</p></blockquote></li></ol><h3 id="0-4-运算符"><a href="#0-4-运算符" class="headerlink" title="0.4 运算符"></a>0.4 运算符</h3><ol><li><p>算术运算符</p><ul><li>基本算术运算符: <code>+,-,*,/,%</code>.  <strong>整除</strong>: <code>//</code>. <strong>乘方</strong>: <code>**</code></li><li><strong>注意与 C 不同的是: Python 中 <code>/</code> 是自然除法,而非整除法</strong></li></ul></li><li><p>赋值运算符</p><ul><li>基本赋值: <code>=, +=, -=, *=, /=, %=</code>. <code>**=</code>: 乘方后赋值. <code>//=</code>: 整除后赋值</li><li><code>:=</code> <strong>海象运算符(Python3.8 新增),可在表达式内部进行赋值</strong></li></ul></li><li><p><strong>逻辑运算符</strong>: <code>and, or, not</code></p></li><li><p><strong>成员运算符</strong>: <code>in, not in</code></p></li><li><p><strong>身份运算符</strong>: <code>is, is not</code></p></li><li><p>优先级</p><table><thead><tr><th>优先级</th><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td>1</td><td align="left"><code>(expressions), [exp], &#123;exp&#125;, &#123;key: value&#125;</code></td><td align="left">括号内的表达式</td></tr><tr><td>2</td><td align="left"><code>x[index], x[:], x(arguments), x.attribute</code></td><td align="left">读取,切片,调用,属性引用</td></tr><tr><td>3</td><td align="left"><code>await x</code></td><td align="left"><code>await</code> 表达式</td></tr><tr><td>4</td><td align="left"><code>**</code></td><td align="left">乘方(指数)</td></tr><tr><td>5</td><td align="left"><code>+x, -x, ~x</code></td><td align="left">正,负,按位非 NOT</td></tr><tr><td>6</td><td align="left"><code>*, @, /, //, %</code></td><td align="left">乘,矩阵乘,除,整除,取余</td></tr><tr><td>7</td><td align="left"><code>+, -</code></td><td align="left">加,减</td></tr><tr><td>8</td><td align="left"><code>&lt;&lt;, &gt;&gt;</code></td><td align="left">移位</td></tr><tr><td>9</td><td align="left"><code>&amp;</code></td><td align="left">按位与 AND</td></tr><tr><td>10</td><td align="left"><code>^</code></td><td align="left">按位异或 XOR</td></tr><tr><td>11</td><td align="left">|</td><td align="left">按位或 OR</td></tr><tr><td>12</td><td align="left"><code>in,not in, is,is not, &lt;,&lt;=,&gt;,&gt;=,!=,==</code></td><td align="left">成员检测, 比较运算</td></tr><tr><td>13</td><td align="left"><code>not x</code></td><td align="left">逻辑非 NOT</td></tr><tr><td>14</td><td align="left"><code>and</code></td><td align="left">逻辑与 AND</td></tr><tr><td>15</td><td align="left"><code>or</code></td><td align="left">逻辑或 OR</td></tr><tr><td>16</td><td align="left"><code>if - else</code></td><td align="left">条件表达式</td></tr><tr><td>17</td><td align="left"><code>lambda</code></td><td align="left">lambda 表达式</td></tr><tr><td>18</td><td align="left"><code>:=</code></td><td align="left">赋值表达式</td></tr></tbody></table></li></ol><h3 id="0-5-字符串"><a href="#0-5-字符串" class="headerlink" title="0.5 字符串"></a>0.5 字符串</h3><ol><li><p>表示形式: 用 <code>&#39;</code> 或 <code>&quot;</code> 或 <code>&#39;&#39;&#39;</code> 包围.特别地,<strong>三引号允许字符串跨行</strong></p></li><li><p><strong>Python 没有 <code>char</code> 类型.转而用长度为 1 的字符串代替</strong></p></li><li><p><strong>字符串的运算符重载</strong></p><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td><code>+</code></td><td>拼接字符串</td></tr><tr><td><code>*</code></td><td>重复字符串</td></tr><tr><td><code>[]</code></td><td>下标索引</td></tr><tr><td><code>in / not in</code></td><td>成员运算</td></tr><tr><td><code>r / R</code></td><td>raw string: 前缀 r 表示不进行字符转义</td></tr><tr><td><code>%</code></td><td>格式字符串,与 C 类似</td></tr></tbody></table></li><li><p><strong><code>f-string</code>(字面量格式化字符串,Python3.6添加)</strong></p><ul><li>以 f 作为字符串前缀,用 <code>&#123;&#125;</code> 包围表达式</li><li><code>&#123;&#125;</code> 的表达式将会被计算后的值替换</li></ul></li><li><p><code>print()</code>: 默认换行输出.如果要实现不换行输出,需要在变量末尾加上 <code>end=&quot;&quot;</code> </p></li><li><p><code>input([prompt])</code></p><ul><li>格式: <code>str = input(&quot;prompt&quot;)</code> </li><li>作用: 从标准输入(默认是键盘)读入一行文本</li><li>先将 “prompt” 字符串进行标准输出,然后等待用户输入,并以 <code>string</code> 类型返回</li></ul></li><li><p><code>string</code> 内建函数</p><ul><li><p>判断字符串内容形式</p><table><thead><tr><th>函数</th><th>作用(假定的条件,满足返回true)</th></tr></thead><tbody><tr><td>isdecimal() &#x2F; <strong>isdigit()</strong></td><td>非空 &amp; 只包含十进制字符 &#x2F; <strong>只包含数字</strong></td></tr><tr><td>isalnum()</td><td>非空 &amp; 所有字符都是字母或数字</td></tr><tr><td>isalpha()</td><td>非空 &amp; 所有字符都是字母或中文</td></tr><tr><td>islower() &#x2F; isupper()</td><td>非空 &amp; 全为小&#x2F;大写</td></tr><tr><td>isnumeric()</td><td>非空 &amp; 只包含数字字符</td></tr><tr><td>isspace()</td><td>非空 &amp; 只包含空白</td></tr><tr><td>istitle()</td><td>是标题化的</td></tr><tr><td>endswith(suffix, beg&#x3D;0, end&#x3D;len(string))</td><td>字符串以 suffix 结束</td></tr><tr><td><strong>startswith(substr, beg&#x3D;0,end&#x3D;len(string))</strong></td><td><strong>字符串以 substr 开头</strong></td></tr></tbody></table></li><li><p>格式化字符串</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>capitalize()</td><td>首字母大写化</td></tr><tr><td><strong>title()</strong></td><td><strong>标题化</strong></td></tr><tr><td>lower()</td><td>小写化</td></tr><tr><td>upper()</td><td>大写化</td></tr><tr><td>lstrip([chars])</td><td>删除字符串左边的指定字符(默认空格)</td></tr><tr><td>rstrip([chars])</td><td>删除字符串末尾的指定字符(默认空格)</td></tr><tr><td><strong>strip([chars])</strong></td><td><strong>执行 lstrip(), rstrip()</strong></td></tr><tr><td>swapcase()</td><td>大小写反向</td></tr><tr><td><strong>center(width[, fillchar])</strong></td><td><strong>居中对齐</strong></td></tr><tr><td>ljust(width[, fillchar])</td><td>左对齐</td></tr><tr><td>rjust(width[, fillchar])</td><td>右对齐</td></tr><tr><td>expandtabs(tabsize&#x3D;8)</td><td>将 tab 符号转为空格(默认为8个)</td></tr></tbody></table></li><li><p>字符串处理</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><strong>split(str&#x3D;””, num&#x3D;string.count(str))</strong></td><td><strong>分割字符串</strong></td></tr><tr><td>splitlines([keepends])</td><td>按行 (‘\r’, ‘\r\n’, \n’) 分隔字符串</td></tr><tr><td>count(str, beg&#x3D;0, end&#x3D;len(string))</td><td>计算 str 出现的次数</td></tr><tr><td><strong>find(str, beg&#x3D;0, end&#x3D;len(string))</strong></td><td><strong>查找</strong></td></tr><tr><td>rfind(str, beg&#x3D;0,end&#x3D;len(string))</td><td>反向查找</td></tr><tr><td>replace(old, new, max)</td><td>替换字符串. max 指定最大替换次数</td></tr><tr><td>encode(encoding&#x3D;’UTF-8’, errors&#x3D;’strict’)</td><td>指定编码的格式</td></tr></tbody></table></li></ul></li></ol><h3 id="0-6-内置函数"><a href="#0-6-内置函数" class="headerlink" title="0.6 内置函数"></a>0.6 内置函数</h3><ol><li><p>判断对象所属类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">type</span>(obj)<span class="hljs-comment"># 返回对象的类型</span><br><span class="hljs-built_in">isinstance</span>(obj, class_name)<span class="hljs-comment"># 判断对象是否是已知类型</span><br><span class="hljs-comment"># 区别在于 type 不认子类,而 isinstance 认为子类是父类类型</span><br></code></pre></td></tr></table></figure></li><li><p>数学函数(<code>import math</code>)</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>abs(x) &#x2F; fabs(x)</td><td>绝对值 &#x2F; 浮点绝对值</td></tr><tr><td>ceil(x) &#x2F; floor(x)</td><td>向上&#x2F;下取整</td></tr><tr><td>sqrt(x) &#x2F; exp(x) &#x2F; pow(x, y)</td><td>$\sqrt{x}$ &#x2F; $e^x$ &#x2F; $x^y$</td></tr><tr><td>log(x) &#x2F; log10(x)</td><td>$\mathrm{ln}x$ &#x2F; $\mathrm{log}_{10}x$</td></tr><tr><td><strong>max(x, y,…) &#x2F; min(x, y,…)</strong></td><td><strong>取最大&#x2F;小值,参数可以为序列</strong></td></tr><tr><td>modf(x)</td><td>返回x的整数部分与小数部分,符号与x相同</td></tr><tr><td><strong>round(x[, n])</strong></td><td><strong>4舍6进5看齐,奇进偶舍. n 指定位数</strong></td></tr></tbody></table></li><li><p>随机函数(<code>import random</code>)</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><strong>seed(x)</strong></td><td><strong>设定随机数种子</strong></td></tr><tr><td><strong>choice(seq)</strong></td><td><strong>从序列的元素中随机挑选一个元素</strong></td></tr><tr><td>randint(x, y)</td><td>随机生成一个整数.范围: [x, y]</td></tr><tr><td><strong>random()</strong></td><td><strong>随机生成一个实数.范围: [0, 1)</strong></td></tr><tr><td>uniform(x, y)</td><td>随机生成一个实数.范围: [x, y]</td></tr><tr><td>shuffle(lst)</td><td>将序列的所有元素随机排序</td></tr></tbody></table></li></ol><div STYLE="page-break-after: always;"></div><h2 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1 基本数据类型"></a>1 基本数据类型</h2><h3 id="1-1-list"><a href="#1-1-list" class="headerlink" title="1.1 list"></a>1.1 list</h3><ol><li><p><strong>元素类型: 可以有不同类型.允许嵌套列表.基本允许任何对象</strong></p></li><li><p>创建方式: 用 <code>[]</code> 包围元素.用 <code>,</code> 分隔元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">spam = [<span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;rat&quot;</span>]  <span class="hljs-comment"># spam 为列表,拥有3个元素</span><br></code></pre></td></tr></table></figure></li><li><p>获取列表元素</p><ul><li>使用 <code>l[index: int]</code> 获取列表 <code>l</code> 在索引为 <code>index</code> 处的元素</li><li>允许使用负数作为索引值,表示倒数.如 -1 表示最后一个元素</li><li>当索引(从0开始)越界时,将会抛出 <code>IndexError</code></li></ul></li><li><p><strong>切片: 获取列表的一部分,也是一个列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">list_name[start=<span class="hljs-number">0</span> : end=<span class="hljs-built_in">len</span>(list_name) : step=<span class="hljs-number">1</span>]<br><span class="hljs-comment"># start: 开始位置.默认为0</span><br><span class="hljs-comment"># end:   结束位置.默认为列表的长度</span><br><span class="hljs-comment"># step:  切片步长.默认为1,可省略.负数表示反向</span><br></code></pre></td></tr></table></figure></li><li><p><strong>运算符重载: 用 <code>+</code> 进行连接,用 <code>*</code> 运算符进行重复</strong>(与字符串类似)</p></li><li><p>删除部分元素: 使用 <code>del</code> 关键字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> list_name[:<span class="hljs-number">3</span>]  <span class="hljs-comment"># 删除前3个元素</span><br></code></pre></td></tr></table></figure></li><li><p>技巧: 在遍历列表的同时获取下标</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> index, obj <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(obj_list):<br>    <span class="hljs-built_in">print</span>(index, obj)<br></code></pre></td></tr></table></figure></li><li><p>list 常用方法</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><strong>append(obj)</strong></td><td><strong>在列表末尾添加新的对象</strong></td></tr><tr><td>count(obj)</td><td>统计某个元素在列表中出现的次数</td></tr><tr><td>extend(seq)</td><td>将可迭代序列的内容拓展到列表末尾</td></tr><tr><td><strong>remove(obj) &#x2F; index(obj)</strong></td><td><strong>移除对象 &#x2F; 获取索引(只针对第一次匹配成功的)</strong></td></tr><tr><td><strong>reverse()</strong> &#x2F; clear() &#x2F; copy()</td><td><strong>原地翻转列表</strong> &#x2F; 清空列表 &#x2F; 复制列表</td></tr><tr><td><strong>pop(index&#x3D;-1)</strong></td><td><strong>移除列表中的一个元素并返回(默认最后一个)</strong></td></tr><tr><td><strong>insert(index, obj)</strong></td><td><strong>将对象插入列表的指定下标</strong></td></tr><tr><td><strong>sort(key&#x3D;None, reverse&#x3D;False)</strong></td><td><strong>原地排序. <code>key</code> 是关键字函数,指定排序规则</strong></td></tr></tbody></table></li></ol><div STYLE="page-break-after: always;"></div><h3 id="1-2-tuple"><a href="#1-2-tuple" class="headerlink" title="1.2 tuple"></a>1.2 tuple</h3><ol><li><p><strong><code>tuple</code> 与 <code>list</code> 类似,区别在于 <code>tuple</code> 不可更改</strong></p></li><li><p>创建方式: 用 <code>()</code> 包围.用 <code>,</code> 分隔元素(区别于列表使用 <code>[]</code>)</p></li><li><p>切片: 与 <code>list</code> 相同</p></li><li><p>当函数返回多个值时,其本质返回的是元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">return</span> width, height  <span class="hljs-comment"># 相当于返回 (width, height)</span><br></code></pre></td></tr></table></figure></li><li><p>字符串可看作一种特殊的 <code>tuple</code></p></li></ol><h3 id="1-3-dictionary"><a href="#1-3-dictionary" class="headerlink" title="1.3 dictionary"></a>1.3 dictionary</h3><ol><li><p>特点</p><ul><li><strong>无序的对象集合</strong>(在 Python 3.6 后变得有序)</li><li><strong>通过 <code>key</code> 存取 <code>value</code></strong> (<code>list</code> 通过下标偏移)</li><li><strong><code>key</code> 必须是不可变类型的,且必须唯一</strong>(常用数字,字符串,元组充当)</li></ul></li><li><p>字典元素访问</p><ul><li><p>元素形如: <code>key : value</code> </p></li><li><p>整体形如: <code>dict = &#123;key1 : value1, key2 : value2, ..., keyn : valuen&#125;</code> </p></li><li><p>访问方式: <code>dict[key]</code>.需注意若 <code>key</code> 不存在将会抛出 <code>KeyError</code></p></li><li><p><strong>添加元素: <code>dict[key] = value</code></strong> </p></li><li><p><strong>遍历字典: 当对字典进行遍历时,默认遍历所有的 <code>key</code></strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dictionary:<br>    <span class="hljs-built_in">print</span>(key, dictionary[key])<br></code></pre></td></tr></table></figure></li></ul></li><li><p>dictionary 常用方法</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><strong>keys() &#x2F; values()</strong></td><td><strong>返回动态视图对象,具有所有的 key &#x2F; value 信息</strong></td></tr><tr><td><strong>items()</strong></td><td><strong>返回动态视图对象,具有所有的 key-value 信息</strong></td></tr><tr><td><strong>get(key, default&#x3D;None)</strong></td><td><strong>返回 value.若 key 不存在,返回 default</strong></td></tr><tr><td>setdefault(key, default&#x3D;None)</td><td>返回 value.若 key 不存在,添加 (key, value&#x3D;default)</td></tr><tr><td><strong>pop(key, default)</strong></td><td><strong>删除 key 所对应的值,返回 value</strong></td></tr><tr><td>popitem()</td><td>删除最后的 key-value,并返回</td></tr><tr><td>update(dict)</td><td>加入 dict 的 key-value</td></tr></tbody></table></li></ol><div STYLE="page-break-after: always;"></div><h3 id="1-4-set"><a href="#1-4-set" class="headerlink" title="1.4 set"></a>1.4 set</h3><ol><li><p><strong>特点: 无序,可变,元素唯一</strong></p></li><li><p>创建方式: </p><ul><li>用 <code>&#123;&#125;</code> 包围.用 <code>,</code> 分隔元素</li><li>创建空集合: <code>set()</code></li></ul></li><li><p>操作符重载: 并集(<code>|</code>), 交集(<code>&amp;</code>), 差集(<code>-</code>), 异或(<code>^</code>)</p></li><li><p>set 常用方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><strong>add(element)</strong></td><td><strong>添加元素</strong></td></tr><tr><td><strong>pop</strong>()</td><td><strong>随机移除元素,并将其返回</strong></td></tr><tr><td>update(set)</td><td>添加元素,可以有多个</td></tr><tr><td>discard(element)</td><td>删除集合中指定的元素.若不存在,不会引发错误</td></tr><tr><td><strong>remove(element)</strong></td><td><strong>移除指定元素.若不存在会发生错误</strong></td></tr><tr><td>isdisjoint(set)</td><td>认为两个集合不包含相同的元素</td></tr><tr><td>issubset(set)</td><td>认为指定集合是子集</td></tr><tr><td>issuperset(set)</td><td>认为指定集合是超集</td></tr></tbody></table></li><li><p>list, tuple, dictionary, set 通用 方法&#x2F;函数</p><table><thead><tr><th>函数&#x2F;方法</th><th>作用</th></tr></thead><tbody><tr><td><strong>len(object)</strong></td><td><strong>计算元素个数</strong></td></tr><tr><td>clear()</td><td>清空容器</td></tr><tr><td>copy()</td><td>(浅)复制容器</td></tr></tbody></table></li></ol><h3 id="1-5-bytes"><a href="#1-5-bytes" class="headerlink" title="1.5 bytes"></a>1.5 bytes</h3><ol><li>含义: 不可变的二进制序列</li><li>元素类型: 0 ~ 255 的整数</li><li>作用: 用于处理二进制数据(如图像, 音频, 视频)</li><li>创建方式: <ul><li>使用 <code>b</code> 前缀 (如 <code>x=b&quot;hello&quot;</code>)</li><li>使用 <code>bytes()</code> 函数将其他类型对象转换为 <code>bytes</code> 类型</li></ul></li></ol><div STYLE="page-break-after: always;"></div><h3 id="1-6-数据类型转换"><a href="#1-6-数据类型转换" class="headerlink" title="1.6 数据类型转换"></a>1.6 数据类型转换</h3><ol><li><p>Python 数据类型</p><ul><li><code>number(int, bool, float, complex), string, list, tuple, set, dictionary</code></li><li>其中 <code>number, string, tuple</code> 不可变; <code>list, dictionary, set</code> 可变</li></ul></li><li><p>复数形如 <code>a+bj</code> 或 <code>complex(a, b)</code></p></li><li><p>隐式类型转换</p><ul><li>运算时较低数据类型会自动转换为较高数据类型,以避免信息丢失</li><li><code>bool &lt; int &lt; float &lt; complex</code></li></ul></li><li><p>显式类型转换</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>int(x, base&#x3D;10)</strong></td><td align="left"><strong>返回整数</strong></td></tr><tr><td align="left">float(x)</td><td align="left">返回浮点数</td></tr><tr><td align="left">complex(real[, imag])</td><td align="left">返回复数</td></tr><tr><td align="left"><strong>str(object&#x3D;””)</strong></td><td align="left"><strong>将对象 object 转换为字符串</strong></td></tr><tr><td align="left"><strong>repr(object)</strong></td><td align="left"><strong>将对象 object 转换为表达式字符串</strong></td></tr><tr><td align="left"><strong>eval(str)</strong></td><td align="left"><strong>计算字符串中的有效 Python 表达式,并返回一个对象</strong></td></tr><tr><td align="left"><strong>list(iterable)</strong></td><td align="left"><strong>将可迭代序列转换为列表</strong></td></tr><tr><td align="left">tuple(iterable)</td><td align="left">将可迭代序列转换为元组</td></tr><tr><td align="left">set([iterable])</td><td align="left">将可迭代序列转换为可变集合</td></tr><tr><td align="left">dict(d)</td><td align="left">创建一个字典.其中 d是(key, value)元组序列</td></tr><tr><td align="left">frozenset([iterable])</td><td align="left">将可迭代序列转换为不可变集合</td></tr><tr><td align="left"><strong>chr(x)</strong></td><td align="left"><strong>将一个整数(0~255)转换为一个字符</strong></td></tr><tr><td align="left"><strong>ord(c)</strong></td><td align="left"><strong>将一个字符转换为整数值(与 chr 相对)</strong></td></tr><tr><td align="left"><strong>hex(x)</strong></td><td align="left"><strong>将一个整数转换为一个十六进制字符串</strong></td></tr><tr><td align="left">oct(x)</td><td align="left">将一个整数转换为一个八进制字符串</td></tr></tbody></table></li></ol><h2 id="2-程序控制"><a href="#2-程序控制" class="headerlink" title="2 程序控制"></a>2 程序控制</h2><h3 id="2-1-分支"><a href="#2-1-分支" class="headerlink" title="2.1 分支"></a>2.1 分支</h3><ol><li><p>与 C 的区别: 用 <code>elif</code> 代替了 <code>else if</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> &lt;condition_1&gt;:<span class="hljs-comment"># 条件表达式的值为 True 时,则执行,且下面的判断不在执行</span><br>    &lt;statement_block_1&gt;<br><span class="hljs-keyword">elif</span> condition_2:<span class="hljs-comment"># 当 condition_1 的值为 False,才会进行判断</span><br>    &lt;statement_block_2&gt;<br><span class="hljs-keyword">else</span>:<span class="hljs-comment"># 当所有的条件表达式都为 False,才会执行</span><br>    &lt;statement_block_3&gt;<br></code></pre></td></tr></table></figure></li><li><p><code>match - case</code>(Python3.10添加)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">match</span> subject:<span class="hljs-comment"># 类似于 C 中的 switch-case</span><br>    <span class="hljs-keyword">case</span> &lt;pattern_1&gt;:<span class="hljs-comment"># 当成功匹配时,执行相应的语句</span><br>        &lt;action_1&gt;<br>    <span class="hljs-keyword">case</span> &lt;pattern_2&gt;:<br>        &lt;action_2&gt;<br>    <span class="hljs-keyword">case</span> _:  <span class="hljs-comment"># 可以匹配一切.该语句与 C 中的 &#x27;default:&#x27; 作用类似</span><br>        &lt;action_wildcard&gt;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-循环"><a href="#2-2-循环" class="headerlink" title="2.2 循环"></a>2.2 循环</h3><ol><li><p><code>while</code> 语句与 C 的区别: 没有 <code>do while</code> 语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> &lt;expr&gt;:<span class="hljs-comment"># 当表达式的值为 True,则执行循环</span><br>    &lt;statement(s)&gt;<span class="hljs-comment"># 可以使用 continue 和 break 语句</span><br><span class="hljs-keyword">else</span>:<span class="hljs-comment"># 若循环语句未被 break 打断,则 else 语句将会被执行</span><br>    &lt;additional_statement(s)&gt;<br></code></pre></td></tr></table></figure></li><li><p><code>for</code> 经常用来遍历可迭代对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> &lt;variable&gt; <span class="hljs-keyword">in</span> &lt;sequence&gt;:<span class="hljs-comment"># 当可以取到序列对象的元素时,则执行循环</span><br>    &lt;statements&gt;  <span class="hljs-comment"># 可以使用 continue 和 break 语句</span><br><span class="hljs-keyword">else</span>:<span class="hljs-comment"># 若循环语句未被 break 打断,则 else 语句将会被执行</span><br>    &lt;statements&gt;<br></code></pre></td></tr></table></figure><ul><li><code>for</code> 可与 <code>else</code> 进行匹配.当循环完成时,执行<code>else</code>语句块(遇到 <code>break</code> 不会执行)</li><li>遍历数字序列时,可用内置的 <code>range</code> 函数生成数列</li><li><strong><code>range(start=0, stop, step=1)</code> 返回一个整数序列对象,仅在迭代时返回数字</strong></li></ul></li><li><p><strong>不要在<code>for</code>循环遍历列表时修改列表,否则将导致Python难以追踪其中的元素.此时应使用<code>while</code></strong></p></li><li><p><code>pass</code> 语句: 用于占位,表示什么也不做</p></li></ol><h3 id="2-3-推导式"><a href="#2-3-推导式" class="headerlink" title="2.3 推导式"></a>2.3 推导式</h3><ol><li><p><strong>列表推导式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># [表达式 for 变量 in 列表 if 条件].其中条件语句是可选的</span><br><span class="hljs-comment"># 目的: 过滤出长度大于3的字符串,并将其全大写</span><br>names = [<span class="hljs-string">&#x27;Bob&#x27;</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-string">&#x27;alice&#x27;</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>,<span class="hljs-string">&#x27;Wendy&#x27;</span>,<span class="hljs-string">&#x27;Smith&#x27;</span>]<br>new_names = [name.upper() <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(name)&gt;<span class="hljs-number">3</span>]<br><br>[ out_exp_res <span class="hljs-keyword">for</span> out_exp <span class="hljs-keyword">in</span> input_list <span class="hljs-keyword">if</span> condition ]<br><span class="hljs-comment"># out_exp_res: 列表生成元素表达式,可以是有返回值的函数</span><br><span class="hljs-comment"># 迭代时: input_list 将 out_exp 传入到 out_exp_res 表达式中</span><br><span class="hljs-comment"># condition: 条件表达式</span><br></code></pre></td></tr></table></figure></li><li><p>字典推导式</p><ul><li>格式: <code>&#123; key_expr: value_expr for key, value in collection if condition &#125;</code> </li><li><code>key_expr : value_expr</code>: 字典生成元素表达式</li></ul></li><li><p>集合推导式</p><ul><li>格式: <code>&#123; expression for item in Sequence if condition &#125;</code></li></ul></li><li><p>元组推导式</p><ul><li>格式: <code>(expression for item in Sequence if condition )</code> </li><li><strong>注意: 元组推导式返回的结果是一个生成器对象,需要使用 <code>tuple()</code> 函数才会成为元组</strong></li></ul></li></ol><h3 id="2-4-迭代器"><a href="#2-4-迭代器" class="headerlink" title="2.4 迭代器"></a>2.4 迭代器</h3><ol><li><p>迭代器</p><ul><li>迭代器可以记住遍历的位置,只能往前不会后退</li><li>从集合的第一个元素开始访问.直到所有的元素被访问完结束</li><li>迭代器基础函数: <code>iter(), next()</code></li></ul></li><li><p>创建方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># string, list, tuple 均可创建迭代器</span><br><span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>it = <span class="hljs-built_in">iter</span>(<span class="hljs-built_in">list</span>)<span class="hljs-comment"># 创建迭代器对象</span><br>it = <span class="hljs-built_in">next</span>(it)<span class="hljs-comment"># 将迭代器指向下一元素</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> it: <span class="hljs-comment"># 迭代器遍历</span><br></code></pre></td></tr></table></figure></li><li><p>类的迭代器</p><ul><li>需要在类中实现 <code>__iter__, __next__</code> 方法  </li><li><code>StopIteration</code> 异常用于标识迭代的完成,防止出现无限循环的情况</li></ul></li></ol><h3 id="2-5-生成器"><a href="#2-5-生成器" class="headerlink" title="2.5 生成器"></a>2.5 生成器</h3><ol><li>生成器<ul><li>Python 中,使用了 <strong><code>yield</code></strong> 的函数被称为<strong>生成器(generator)</strong></li><li><code>yield</code> 关键字用于定义生成器函数</li><li>生成器函数是一种特殊的函数,可以在迭代过程中逐步产生值,而不是一次性返回所有结果</li><li>生成器是一个返回迭代器的函数,只能用于迭代操作</li></ul></li><li>执行过程<ul><li>生成器函数中遇到 <strong>yield</strong> 语句时,函数的执行暂停</li><li>然后将 yield 后面的表达式作为当前迭代的值返回</li><li>每次调用生成器的 <strong>next</strong> 方法或使用 for 循环进行迭代时</li><li>函数会从上次暂停的地方继续执行,直到再次遇到 yield 语句</li></ul></li></ol><h3 id="2-6-函数"><a href="#2-6-函数" class="headerlink" title="2.6 函数"></a>2.6 函数</h3><ol><li><p>定义方式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">paraList</span>):  <span class="hljs-comment"># 不带表达式的 return 相当于返回 None</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure></li><li><p>参数传递</p><ul><li>不可变对象: 类似 C++ 的值传递.如整数,字符串,元组</li><li>可变对象:类似 C++ 的引用传递.如字典,列表(传递<code>listName[:]</code>则原列表不会被修改)</li><li>函数可以直接作为参数进行传递</li></ul></li><li><p>参数类型</p><ul><li><strong>位置参数</strong><ul><li>必须按顺序传入函数,调用时 给定的参数数量需与声明一致</li><li><strong>强制位置参数</strong>: 在函数定义中参数 <code>/</code> 左侧的必须是位置参数</li></ul></li><li><strong>关键字参数</strong><ul><li>在调用时指出参数名并显式赋值.可以不按顺序书写</li><li><strong>强制关键字参数</strong>: 在函数定义中参数 <code>*</code> 右侧的必须时关键字参数</li></ul></li><li>默认参数: 与 C++ 类似.在函数定义时直接指定参数的默认值</li><li><strong>收集参数</strong><ul><li>声明时不会对这些参数命名,因为长度未知</li><li>以 <code>*</code> 为前缀的参数将会以 <code>tuple</code> 的形式接受参数(常用 <code>*args</code>)</li><li>以 <code>**</code> 为前缀的参数将会以 <code>dictionary</code> 的形式接受参数(常用 <code>**kwargs</code>)</li></ul></li></ul></li><li><p>匿名函数(<code>lambda</code> 关键字创建匿名函数)</p><ul><li><code>lambda</code> 只是一个表达式,而非代码块,无法访问全局命名空间</li><li><code>lambda</code> 函数拥有自己的命名空间,仅能访问参数列表的参数</li><li>语法: <code>lambda arg1 ,arg2, ..., argn : expression</code></li></ul></li></ol><h3 id="2-7-模块"><a href="#2-7-模块" class="headerlink" title="2.7 模块"></a>2.7 模块</h3><ol><li><p><code>import</code>: 导包</p><ul><li>语法: <code>import moudle1[, moudle2, ..., moudleN]</code></li><li>模块只会被导入1次, 无论执行了多少次 <code>import</code> </li><li>此时对模块中的内容进行调用需要 <code>.</code> 运算符: <code>moudle1.func</code></li></ul></li><li><p><code>from</code>: 简化调用</p><ul><li>从模块中导入指定的部分到当前命名空间中.此时不需要使用<code>.</code>运算符调用</li><li>语法: <code>from moudle_name import name1[, name2, ..., nameN]</code></li><li><code>from moudle_name import *</code> 会将模块的全部内容导入到当前命名空间中(不推荐)</li></ul></li><li><p><code>as</code>: 为对象(模块,函数…)指定别名</p><ul><li><strong>导入模块完整语法</strong>: <code>[from moudle_name] import object_name [as alias]</code></li></ul></li><li><p><code>__name__</code> 属性</p><ul><li><p>每个模块都有 <code>__name__</code> 属性</p></li><li><p><strong>当 <code>__name__</code> 的值为 <code>&#39;__main__&#39;</code> 时.表明该模块自身在运行.否则是被导入</strong></p></li><li><p>如需要模块的某块代码仅在其自身运行时执行,可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>: <br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>dir()</code> 函数: 模块内定义的所有名称.以字符串列表的形式返回</p></li><li><p><strong>包: 将模块以文件夹的形式组织到一起(包下面可以有子包)</strong></p><ul><li>当目录包含一个名为 <code>__init__.py</code> 的文件才会被认为是一个包</li><li>导入包中的内容: <code>form packeage_name import moudle_name</code></li><li><code>moudle_name</code>可以是子包, 模块, 函数, 类, 变量</li></ul></li><li><p><code>__all__</code>属性: 这是一个列表,以字符串的形式存放</p><ul><li>该属性作用于 <code>from xx import *</code> 语句.对可以访问的内容进行了限制<ul><li>在模块中,该属性直接存在于该文件中</li><li>在包中,该属性存放在必需的文件<code>__init__.py</code>中</li></ul></li></ul></li></ol><h2 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3 面向对象"></a>3 面向对象</h2><h3 id="3-1-与-C-的区别"><a href="#3-1-与-C-的区别" class="headerlink" title="3.1 与 C++ 的区别"></a>3.1 与 C++ 的区别</h3><ol><li>类成员<ul><li><strong>类命名空间中所有的命名都是有效属性名,而不需要特别声明</strong></li><li><strong>类的方法必须提供一个额外参数 <code>self</code>.指向实例本身</strong></li><li>类属性位于类中,方法外.而实例属性位于 <code>__init__</code> 方法中</li><li>私有属性(双下划线开头): <code>__private_atrrs</code> </li><li>私有方法(双下划线开头): <code>__private_methods()</code></li></ul></li><li>构造方法<ul><li>名称固定为 <code>__init__()</code>.在实例化时自动调用</li><li>没有 <code>this</code> 指针.用 <code>self</code> 表示正在调用该方法的对象(<code>self</code> 名称只是惯例,不是规定)</li><li>调用父类的方法: 使用 <code>super()</code> 函数.获取父类</li></ul></li><li>继承<ul><li>继承的语法: <code>class Class_name(BaseClass_name):</code> </li><li>多继承语法: <code>class Class_name(Base1, Base2):</code></li></ul></li></ol><h3 id="3-2-异常处理"><a href="#3-2-异常处理" class="headerlink" title="3.2 异常处理"></a>3.2 异常处理</h3><ol><li><p><code>try - except - else - finally</code> </p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 可能出现异常的代码</span><br><span class="hljs-keyword">except</span> [异常 <span class="hljs-keyword">as</span> 别名]:  <span class="hljs-comment"># 可以使用 Exception as e</span><br>    <span class="hljs-comment"># 发生异常时,执行的代码</span><br>[<span class="hljs-keyword">else</span>:]<br><span class="hljs-comment"># 没有发生异常时,执行的代码</span><br>[<span class="hljs-keyword">finally</span>:]<br>    <span class="hljs-comment"># 无论是否发生异常,都要执行的代码</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>若执行时发生异常. <code>try</code> 子句的剩余部分将被忽略</strong></p></li><li><p><strong>异常类型将与 <code>except</code> 提供名称进行匹配.匹配成功则将执行相应的 <code>expect</code> 子句</strong></p></li><li><p><strong>若没有匹配的 <code>expect</code>.则异常传递给 <code>try</code></strong> </p></li><li><p><code>except</code> 子句可以同时处理多个异常.以 tuple 的方式进行存放</p></li><li><p>最后一个 <code>except</code> 子句可以忽略异常的名称,将被当作通配符使用</p></li></ul></li><li><p><strong><code>raise</code>: 抛出一个指定的异常</strong></p><ul><li>语法: <code>raise [Exception [, args [, traceback]]]</code> </li><li><code>raise</code> 指定了要被抛出的异常. 必须是一个异常的实例或者是异常的类(Exception 的子类)</li><li>例如: <code>raise Exception(&quot;x 不能为负&quot;)</code></li></ul></li><li><p><strong>异常传递: 如果一个异常发生,但没有捕获异常,则传递给调用者处理.若都没处理,最终由系统处理</strong></p></li><li><p><strong>取得原谅比许可更简单(EAFP: easier to ask for forgiveness than permission)</strong></p><ul><li><strong>即直奔主流程,而将意外情况放在异常处理中</strong></li><li>而不是 LBYL(look before you leap): 先进行数据检查,然后进行操作</li></ul></li><li><p><code>with</code>: 用于异常处理,封装了 <code>try - except - finally</code> 编码范式,提高易用性</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用 try</span><br>file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./hello.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br><span class="hljs-keyword">try</span>:<br>    file.write(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><span class="hljs-keyword">finally</span>:<br>    file.close()<br>    <br><span class="hljs-comment"># 使用 with</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./hello.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(<span class="hljs-string">&#x27;hello,world!&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><p><code>with</code> 语句的实现在于上下文管理器</p></li><li><p><strong>上下文管理器</strong>: 实现了<code>__enter__(), __exit__()</code>的类</p></li></ul></li></ol><h3 id="3-3-自定义异常"><a href="#3-3-自定义异常" class="headerlink" title="3.3 自定义异常"></a>3.3 自定义异常</h3><ol><li><p><strong>异常类继承自 <code>Exception</code> 类</strong></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyError</span>(<span class="hljs-title class_ inherited__">Exception</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):  <span class="hljs-comment"># Exception类默认的 __init__() 被重写</span><br>        <span class="hljs-variable language_">self</span>.value = value<br></code></pre></td></tr></table></figure></li><li><p>若创建一个模块有可能抛出多种不同的异常时</p><ul><li>通常为这个包建立一个基础异常类.然后基于这个基础类为不同的错误情况创建子类</li><li>大多数的异常的名字都以 <code>Error</code> 结尾,就像标准的异常命名</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Error</span>(<span class="hljs-title class_ inherited__">Exception</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InputError</span>(<span class="hljs-title class_ inherited__">Error</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Exception raised for errors in the input.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Attributes:</span><br><span class="hljs-string">        expression -- input expression in which the error occurred</span><br><span class="hljs-string">        message -- explanation of the error</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, expression, message</span>):<br>        <span class="hljs-variable language_">self</span>.expression = expression<br>        <span class="hljs-variable language_">self</span>.message = message<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransitionError</span>(<span class="hljs-title class_ inherited__">Error</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Raised when an operation attempts a state transition that&#x27;s not allowed.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Attributes:</span><br><span class="hljs-string">        previous -- state at beginning of transition</span><br><span class="hljs-string">        next -- attempted new state</span><br><span class="hljs-string">        message -- explanation of why the specific transition is not allowed</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, previous, <span class="hljs-built_in">next</span>, message</span>):<br>        <span class="hljs-variable language_">self</span>.previous = previous<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>        <span class="hljs-variable language_">self</span>.message = message<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-文件"><a href="#3-4-文件" class="headerlink" title="3.4 文件"></a>3.4 文件</h3><ol><li><p><strong><code>open()</code> 方法: 打开一个文件,并返回文件对象.若无法被打开,抛出 <code>OSError</code></strong></p></li><li><p><strong><code>close()</code> 方法: 关闭文件对象.使用 <code>open()</code> 方法打开的文件必须关闭</strong></p></li><li><p>常用<code>with - as</code>语句打开文件(此时无需手动关闭文件)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打开名为 &quot;pi_digits.txt&quot; 的文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;pi_digits.txt&#x27;</span>) <span class="hljs-keyword">as</span> fileObject:<br>    <span class="hljs-built_in">print</span>(fileObject.read().rstrip())<br></code></pre></td></tr></table></figure></li><li><p><code>open</code>的完整语法格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">open</span>(file, mode=<span class="hljs-string">&#x27;r&#x27;</span>, buffering=-<span class="hljs-number">1</span>, encoding=<span class="hljs-literal">None</span>, <br>     errors=<span class="hljs-literal">None</span>, newline=<span class="hljs-literal">None</span>, closefd=<span class="hljs-literal">True</span>, opener=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><ul><li><code>file</code>: 文件路径(必须指定)</li><li><code>mode</code>: 文件打开模式</li><li><code>buffering</code>: 设置缓冲</li><li><code>encoding</code>: 指定编码方式,一般为 ‘utf-8’</li><li><code>errors</code>: 报错级别</li><li><code>newline</code>: 区分换行符</li><li><code>closefd</code>: 传入的 <code>file</code> 参数类型</li><li><code>opener</code>: 设置自定义开启器.开启器的返回值必须是一个打开的文件描述符</li></ul></li><li><p><code>mode</code>参数可以为</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>t &#x2F; b</strong></td><td align="left"><strong>文本格式(默认) &#x2F; 二进制格式</strong></td></tr><tr><td align="left"><strong>r &#x2F; w</strong></td><td align="left"><strong>只读模式(默认) &#x2F; 只写模式(若文件已存在,则写入后会从头覆盖,若不存在则创建文件)</strong></td></tr><tr><td align="left"><strong>a</strong></td><td align="left"><strong>追加模式.若文件已存在,则写入内容追加到文件末尾,若不存在则创建文件</strong></td></tr><tr><td align="left">x</td><td align="left">写模式.需先新建文件,若该文件已存在则会报错</td></tr><tr><td align="left"><strong>+</strong></td><td align="left"><strong>打开一个文件进行更新(可读可写)</strong></td></tr></tbody></table><ul><li>打开格式(t, b) 可与 读写方式(r, w, a, x)进行组合,<code>+</code>也可以进行组合</li><li>如<code>wb+</code>: 用二进制格式打开文件进行读写.一般用于非文本文件,如图片</li></ul></li><li><p>file 对象的常用方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><strong>read(size&#x3D;-1)</strong></td><td><strong>读取指定字节数的数据.默认读取整个文件</strong></td></tr><tr><td>readline(size)</td><td>读取整行,包括 <code>&quot;\n&quot;</code>.返回值为读取到的字节数</td></tr><tr><td><strong>readlines()</strong></td><td><strong>读取所有行(直到EOF)并以列表形式返回.可与<code>for - in</code>连用</strong></td></tr><tr><td><strong>write(str)</strong></td><td><strong>将字符串写入文件,返回值为写入的字符长度</strong></td></tr><tr><td>writelines(sequence)</td><td>向文件写入字符串序列(不会自行添加换行符)</td></tr><tr><td>flush()</td><td>刷新缓冲区,将缓冲区中的数据立即写入文件</td></tr><tr><td>tell()</td><td>获取文件指针的当前位置</td></tr><tr><td><strong>seek(offset, whence&#x3D;0)</strong></td><td><strong>移动文件指针到指定位置.并将其作为返回值,失败返回-1<br />whence: 基准位置(0: 文件头,1: 当前位置,2: 文件末尾)<br />offset: 偏移量(可为负数).</strong></td></tr></tbody></table></li><li><p>JSON 数据</p><ul><li><p>json 模块可以对 JSON 数据进行编解码,包含两个函数</p><ul><li><code>json.dumps()</code>: 对数据编码  Python string  -&gt;   JSON Object</li><li><code>json.loads()</code>: 对数据解码   JSON string   -&gt; Python Object</li></ul></li><li><p>Python 编解码为 JSON 对照表</p><table><thead><tr><th>Python</th><th>JSON</th></tr></thead><tbody><tr><td>int, float, int- &amp; float-derived Enums</td><td>number</td></tr><tr><td>True &#x2F; False &#x2F; None</td><td>true &#x2F; false &#x2F; null</td></tr><tr><td>list, tuple</td><td>array</td></tr><tr><td>dict &#x2F; str</td><td>object &#x2F; string</td></tr></tbody></table></li><li><p>示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 写入 JSON 数据</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    json.dump(data, f)<br> <br><span class="hljs-comment"># 读取数据</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.json&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    data = json.load(f)<br></code></pre></td></tr></table></figure></li></ul></li></ol><div STYLE="page-break-after: always;"></div><h2 id="4-Python-库"><a href="#4-Python-库" class="headerlink" title="4 Python 库"></a>4 Python 库</h2><h3 id="4-1-标准库概括"><a href="#4-1-标准库概括" class="headerlink" title="4.1 标准库概括"></a>4.1 标准库概括</h3><ol><li>os 模块: 提供与操作系统交互的函数</li><li>sys 模块:提供与 Python 解释器和系统相关的功能</li><li>time 模块: 提供处理时间的函数</li><li>datetime 模块: 提供更高级的日期和时间处理函数</li><li>random 模块: 提供生成随机数的函数</li><li>math 模块: 提供数学函数</li><li>re 模块: 提供正则表达式处理函数</li><li>json 模块: 提供 JSON 编解码函数.可将 Python 对象转换为 JSON 格式,并从 JSON 格式解析出 Python 对象</li><li>urllib 模块: 提供访问网页和处理 URL 的功能.包括下载文件,发送 POST 请求,处理 cookies 等</li></ol><h3 id="4-2-第三方库"><a href="#4-2-第三方库" class="headerlink" title="4.2 第三方库"></a>4.2 第三方库</h3><ol><li><p>配置 <code>pip</code> 从清华源下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure></li><li><p>更新 <code>pip</code> </p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pip<br></code></pre></td></tr></table></figure></li><li><p><code>pytest</code>: Python 测试框架.用于代码测试</p></li><li><p><code>pygame</code>: 基于 Python 的游戏开发库</p></li><li><p><code>Matplotlib</code>: Python 2D-绘图领域使用最广泛的套件</p></li><li><p><code>Plotly</code>: 创建漂亮的基于 web 的交互式可视化</p></li></ol><h3 id="4-3-代码测试"><a href="#4-3-代码测试" class="headerlink" title="4.3 代码测试"></a>4.3 代码测试</h3><ol><li><p>安装 <code>pytest</code>: <code>python -m pip install --user pytest</code></p></li><li><p>测试函数</p><ul><li><p><strong>文件名必须用 <code>test_</code> 开头或 <code>_test</code> 结尾.而测试函数只能用 <code>test_</code> 开头</strong></p></li><li><p>测试中 <code>pytest</code> 将找出这些文件,并运行其中需要进行测试的函数</p></li><li><p>考虑到测试函数会被 pytest 自动调用.其名称可以起得很长.便于阅读</p></li><li><p>作出断言(<code>assert</code>): 在测试函数中应成立的条件语句,一个函数可以有多个 <code>assert</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_add</span>(): <span class="hljs-comment"># 测试函数</span><br>    <span class="hljs-keyword">assert</span> add(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure></li><li><p>常用的 <code>assert</code> 形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">assert</span> xx：    判断 xx 为真<br><span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> xx：判断 xx 不为真<br><span class="hljs-keyword">assert</span> a <span class="hljs-keyword">in</span> b：判断 b 包含 a<br><span class="hljs-keyword">assert</span> a == b：判断 a 等于 b<br><span class="hljs-keyword">assert</span> a != b：判断 a 不等于 b<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在终端窗口执行 <code>pytest</code>.将自动完成测试,并在终端输出测试信息</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/1.%E5%9F%BA%E7%A1%80/assets/Pytest.png" alt="pytest"></p></li><li><p>为管理测试函数,还可以将其封装在类中</p></li><li><p>测试类方法时需实例化对象.然后测试过程与测试函数相似</p></li><li><p>夹具(fixture)</p><ul><li><p>使用 <code>@pytest.fixture</code> 装饰函数,使得该函数可以成为其他测试函数的参数</p></li><li><p>其他测试函数可接收该参数(被装饰的函数名)继续测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-string">&quot;&quot;&quot; Dog类有2个属性: name, age.以及对应的 setter 方法 &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-variable language_">self</span>.age = age<br>        <span class="hljs-variable language_">self</span>.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setAge</span>(<span class="hljs-params">self, age</span>):<br>        <span class="hljs-variable language_">self</span>.age = age<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test_class_Dog</span>:<br>    <span class="hljs-string">&quot;&quot;&quot; 将测试函数封装在类中 &quot;&quot;&quot;</span><br><span class="hljs-meta">    @pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;class&quot;</span></span>)</span><br>    <span class="hljs-comment"># scope可为 session -&gt; module(默认) -&gt; class -&gt; function</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dog_object_test</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot; 实例化一个 Dog 对象,将其作为测试用例 &quot;&quot;&quot;</span><br>        dog = Dog(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">return</span> dog<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_set_name</span>(<span class="hljs-params">self, dog_object_test</span>):<br>        <span class="hljs-string">&quot;&quot;&quot; 测试 setName 方法&quot;&quot;&quot;</span><br>        dog_object_test.setName(<span class="hljs-string">&quot;Jerry&quot;</span>)<br>        <span class="hljs-keyword">assert</span> dog_object_test.name == <span class="hljs-string">&quot;Jerry&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_set_age</span>(<span class="hljs-params">self, dog_object_test</span>):<br>        <span class="hljs-string">&quot;&quot;&quot; 测试 setAge 方法 &quot;&quot;&quot;</span><br>        dog_object_test.setAge(<span class="hljs-number">5</span>)<br>        <span class="hljs-keyword">assert</span> dog_object_test.age == <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="附录A-Pycharm"><a href="#附录A-Pycharm" class="headerlink" title="附录A Pycharm"></a>附录A Pycharm</h2><ol><li><p>新建 Python 项目</p><ul><li><p><kbd>新建项目</kbd> -&gt; 在<kbd>位置</kbd>栏选择项目所存放的位置</p></li><li><p>Python 解释器选中 <kbd>先前配置的解释器</kbd>(注意不要选择上面的虚拟环境,导包可能出现问题)</p></li><li><p>若<kbd>解释器</kbd>栏中显示<code>无解释器</code>,点击<kbd>添加解释器</kbd> -&gt; <kbd>系统解释器</kbd>选择合适的解释器</p></li><li><p><kbd>创建 main.py 欢迎脚本</kbd>可以取消勾选</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/1.%E5%9F%BA%E7%A1%80/assets/PyCharm_Create_Project.png"></p></li></ul></li><li><p>Pycharm 基础操作</p><ul><li>新建 Python 文件: 右键左侧的<kbd>pythonProject</kbd> -&gt; <kbd>新建</kbd> -&gt; <kbd>Python 文件</kbd> -&gt; 输入文件名并确认</li><li>运行 Python 代码: 右键文本区域,执行<kbd>运行'main'</kbd>即可执行当前代码</li><li><strong>万能快捷键</strong>: <kbd>Alt</kbd><kbd>Enter</kbd>.可以在不同的场景下实现不同的操作</li><li><strong>随处搜索</strong>: <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>A</kbd>  or  双击<kbd>Shift</kbd>  or  右上角的<kbd>随处搜索</kbd></li><li><kbd>Python 控制台</kbd>: 可以直接输入代码运行,直接与 Python 交互</li></ul></li><li><p>开启&#x2F;关闭 Pycharm 速度太慢的解决方案</p><ul><li>关闭 Pycharm 时一直显示 <strong>正在关闭项目…</strong><br>在<kbd>随处搜索</kbd>中搜索注册表,找到 <code>ide.await.scope.completion</code>,取消勾选即可</li><li>打开 Pycharm 时一直显示 <strong>正在扫描要建立索引的文件</strong><br>设置中的<kbd>工具</kbd> -&gt; <kbd>共享索引</kbd>.将<code>Python 软件包</code>改为<code>不下载,使用本地索引</code></li></ul></li><li><p>调整编辑区字体</p><ul><li><p>右上角的齿轮 -&gt; <kbd>设置</kbd> -&gt; <kbd>编辑器</kbd> -&gt; <kbd>字体</kbd>.调整字体为 <kbd>Consolas</kbd></p></li><li><p>在<kbd>编辑器</kbd> -&gt; <kbd>常规</kbd>中,勾选 <kbd>使用 Ctrl + 鼠标滚轮改动字号</kbd>.方便调整字体大小</p></li></ul></li><li><p>Pycharm 主界面</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/1.%E5%9F%BA%E7%A1%80/assets/PyCharm_Main_Interface.png"></p></li><li><p><strong>安装第三方库</strong></p><ul><li><p>点击左下角的<kbd>终端</kbd>,即可使用 pip 安装第三方库([参考 4.2 第三方库](# 4.2 第三方库))</p></li><li><p>在<kbd>Python软件包</kbd>可以更方便的管理 Python 包,在设置图标(管理仓库)点击<kbd>+</kbd>新建即可</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/1.%E5%9F%BA%E7%A1%80/assets/PyCharm_Python_Package.png" alt="PyCharm Python Package"></p><ul><li>由于 pip 下载需要连接国外的网站,下载缓慢.可以找一个国内的镜像网站作为下载源</li><li>清华源: <code>https://pypi.tuna.tsinghua.edu.cn/simple</code></li><li>阿里源: <code>http://mirrors.aliyun.com/pypi/simple</code></li></ul></li><li><p>若出现 <code>Error: Python packaging tool &#39;setuptools&#39; not found</code></p><ul><li>在终端中执行 <code>pip install setuptools</code> 即可</li></ul></li></ul></li><li><p><strong>在左侧的<kbd>学习</kbd>中,可以学习 Python 的 IDE 功能</strong></p><table><thead><tr><th>代码段操作</th><th>操作方式</th></tr></thead><tbody><tr><td>扩展 &#x2F; 收缩代码选区</td><td><kbd>Ctrl</kbd><kbd>W</kbd> &#x2F; <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>W</kbd></td></tr><tr><td>注释 &#x2F; 复制 &#x2F; 删除行</td><td><kbd>Ctrl</kbd><kbd>/</kbd> &#x2F; <kbd>D</kbd> &#x2F; <kbd>Y</kbd></td></tr><tr><td>移动代码段</td><td><kbd>Alt/Ctrl</kbd><kbd>Shift</kbd><kbd>箭头</kbd></td></tr><tr><td>收起 &#x2F; 展开</td><td><kbd>Ctrl</kbd><kbd>-</kbd> &#x2F; <kbd>=</kbd>.<kbd>Shift</kbd>可以增强为选中所有</td></tr><tr><td>包围 &#x2F; 解包</td><td><kbd>Ctrl</kbd><kbd>Alt</kbd><kbd>T</kbd> &#x2F; <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>Delete</kbd></td></tr></tbody></table><table><thead><tr><th>代码补全</th><th>操作方式</th></tr></thead><tbody><tr><td>显式代码补全</td><td><kbd>Ctrl</kbd><kbd>Space</kbd>在选择时按<kbd>Tab</kbd>可以覆盖后面的内容<br /><kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>Space</kbd>调用智能补全</td></tr><tr><td>后缀补全</td><td>键入的内容将自动转换为某种表达式<br />如<code>.ifnn</code>将转换为<code>if XX is not None:</code></td></tr><tr><td><code>F-String</code>补全</td><td>键入<kbd>{</kbd>后再输入变量,可以按 F-String 的形式补全</td></tr></tbody></table><table><thead><tr><th>重构</th><th>操作方式</th></tr></thead><tbody><tr><td>显示所有可用的重构</td><td><kbd>Ctrl</kbd><kbd>Alt</kbd><kbd>Shift</kbd><kbd>T</kbd></td></tr><tr><td>重命名字段</td><td><kbd>Shift</kbd><kbd>F6</kbd></td></tr><tr><td>提取局部变量 &#x2F; 方法</td><td><kbd>Ctrl</kbd><kbd>Alt</kbd><kbd>V</kbd> &#x2F; <kbd>M</kbd></td></tr><tr><td>就地重构</td><td>要给局部变量重命名或给方法添加参数时<br /><kbd>Alt</kbd><kbd>Enter</kbd>展示出 Pycharm 的猜测</td></tr></tbody></table><table><thead><tr><th>代码辅助</th><th>操作方式</th></tr></thead><tbody><tr><td>还原移除的代码</td><td>在编辑器右键,选择<kbd>本地历史记录</kbd>.即可浏览历史修改</td></tr><tr><td>更正代码格式</td><td><kbd>Ctrl</kbd><kbd>Alt</kbd><kbd>L</kbd>.<kbd>Shift</kbd>增强为显示重新格式化设置</td></tr><tr><td>显示形参信息 &#x2F; 文档内容</td><td><kbd>Ctrl</kbd><kbd>P</kbd> &#x2F; <kbd>Q</kbd></td></tr><tr><td>转到下一个高亮显示的错误</td><td><kbd>F2</kbd></td></tr><tr><td>展开警告说明</td><td><kbd>Ctrl</kbd><kbd>F1</kbd></td></tr><tr><td>高亮显示符号的所有用法</td><td><kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>F7</kbd></td></tr></tbody></table><table><thead><tr><th>导航</th><th>操作方式</th></tr></thead><tbody><tr><td>打开<code>在文件中查找 / 替换</code>窗口</td><td><kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>F</kbd> &#x2F; <kbd>R</kbd></td></tr><tr><td>跳转到方法的声明 &#x2F; 查看器所有的用法</td><td><kbd>Ctrl</kbd><kbd>B</kbd></td></tr><tr><td>显示最近打开的文件</td><td><kbd>Ctrl</kbd><kbd>E</kbd>.<kbd>Delete</kbd>可以删除文件历史记录</td></tr></tbody></table></li><li><p>调试程序</p><ul><li><p>若程序并未按照预期执行,可以通过设置断点(点击行号即可)的方式调试程序</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/1.%E5%9F%BA%E7%A1%80/assets/PyCharm_Debug.png" alt="PyCharm Debug"></p></li><li><p>执行代码的方式</p><ul><li>步过 <kbd>F8</kbd>: 执行并越过该行的子函数</li><li>步入 <kbd>F7</kbd>: 进入该行的子函数的源码继续执行</li><li>步出 <kbd>Shift</kbd><kbd>F8</kbd>: 跳出函数体,回到调用该函数的地方</li><li>恢复程序 <kbd>F9</kbd>: 继续执行代码,直到下一断点</li><li>单步执行 <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>F7</kbd>: 步入,但忽略 libraries 的语句</li><li>执行到光标处 <kbd>Alt</kbd><kbd>F9</kbd></li></ul></li><li><p>对表达式求值: 在监视窗口可以对<kbd>表达式求值</kbd>,以及<kbd>添加监视</kbd><br><kbd>Ctrl</kbd><kbd>Alt</kbd><kbd>F8</kbd>可以对光标所在位置的表达式快速求值.还可以结合控制台的输出进行判断<br>找出错误的表达式并进行修改,然后重新运行代码,排除问题</p></li></ul></li><li><p>设置文件模板: <code>编辑器</code> -&gt; <code>文件和代码模板</code> -&gt; <code>Python Script</code></p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/1.%E5%9F%BA%E7%A1%80/assets/Python_Script.png" alt="Python Script"></p></li></ol><h2 id="附录B-Git-版本控制"><a href="#附录B-Git-版本控制" class="headerlink" title="附录B Git 版本控制"></a>附录B Git 版本控制</h2><ol><li><p><a href="https://git-scm.com/">官网下载</a> Git</p><ul><li><p>安装 Git: 一路<code>next</code>即可</p></li><li><p>检查安装: 命令行中运行<code>git version</code></p></li><li><p>配置 Git (命令行中执行)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;用户名&quot;<br>git config --global user.email &quot;用户邮箱&quot;<br></code></pre></td></tr></table></figure></li><li><p>检查配置是否成功: <code>git config --list</code></p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/1.%E5%9F%BA%E7%A1%80/assets/Git_Config.png" alt="Git Config"></p></li></ul></li><li><p>在 Pycharm 中配置 Git</p><ul><li><kbd>设置</kbd> -&gt; <kbd>版本控制</kbd> -&gt; <kbd>Git</kbd> -&gt; 选择 Git 可执行文件路径为 <code>Git\cmd\git.exe</code></li></ul></li><li><p>创建本地仓库</p><ul><li><p>点击左下角的 <kbd>Git</kbd> -&gt; <kbd>创建 Git 仓库...</kbd>.选择创建仓库的目录后确认即可</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/1.%E5%9F%BA%E7%A1%80/assets/PyCharm_Git.png" alt="PyCharm Git"></p></li></ul></li><li><p>对现有的 Git 仓库进行操作</p><ul><li><strong>获取网络上的 Git 仓库</strong>: 在编辑器右键 -&gt; <kbd>Git</kbd> -&gt; <kbd>克隆...</kbd>.填写 <code>URL</code> 和 <code>本地目录</code>即可</li><li><strong>新建分支</strong>: 点击左上角的 <kbd>VCS 微件</kbd> -&gt; <kbd>新建分支</kbd>.输入新分支的名称,进行创建</li><li><strong>提交修改</strong>: 在新分支修改文件后,IDE 将会检测到修改<br>点击左侧的 <kbd>提交</kbd>.选择需要进行版本管理的文件.在下方的<kbd>提交消息</kbd>中添加更改信息即可<br>点击<kbd>提交消息</kbd>的右下角的设置,勾选<kbd>格式化代码</kbd>将会根据代码样式自动编辑文件</li><li><strong>修正</strong>: 如果忘记添加某些需要提交的文件,可以勾选<kbd>修正</kbd>再次提交</li><li><strong>推送到远程仓库</strong>: <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>K</kbd> 打开推送对话框.即可推送提交</li></ul></li><li><p>查看项目历史记录</p><ul><li>点击左下的 <kbd>Git</kbd>.可以看到 git 分支.提交记录可以进行筛选,右键可以对其进行多种操作</li><li>工具栏右侧可以看到相关信息.双击提交文件树中的文件可以查看具体差异</li><li><kbd>与本地比较</kbd> 也可以对比文件的差异.其中绿色表示无差异,蓝色表示存在差异</li></ul></li><li><p>功能分支工作流</p><ul><li><p>完成分支工作后准备推送到远程.需要检查是否与 Main 分支中已提交的内容产生冲突</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/1.%E5%9F%BA%E7%A1%80/assets/Pycharm_Git_Branch01.png" alt="PyCharm Git Branch01"></p></li><li><p>签出 Main 分支: 点击左上角的 <kbd>VCS 微件</kbd> -&gt; 选中<kbd>Main</kbd> -&gt; <kbd>签出</kbd></p></li><li><p>更新 Main 分支: <kbd>Ctrl</kbd><kbd>T</kbd>打开<code>更新项目</code>对话框进行更新.此时 Main 分支可能已经作出更改:</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/1.%E5%9F%BA%E7%A1%80/assets/PyCharm_Git_Branch02.png" alt="PyCharm Git Branch02"></p></li><li><p><strong>变基</strong>: 将提交放在他人的修改之后可能更加合适,此时就需要进行变基<br>点击左上角的 <kbd>VCS 微件</kbd> -&gt; 选中<kbd>feature</kbd> -&gt; <kbd>签出并变基到 Main</kbd></p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/1.%E5%9F%BA%E7%A1%80/assets/PyCharm_Git_Branch03.png" alt="PyCharm Git Branch03"></p></li><li><p><strong>更新到远程仓库</strong>: 右键<code>HEAD</code>,选择<kbd>推送</kbd>.此时由于本地的<code>feature</code>分支 变基后与远程冲突<br>因此,需要使用<kbd>强制推送</kbd>(慎重使用)</p></li></ul></li></ol><h2 id="附录C-虚拟环境"><a href="#附录C-虚拟环境" class="headerlink" title="附录C 虚拟环境"></a>附录C 虚拟环境</h2><ol><li><p><strong><a href="https://pypi.org/project/pip/">pip</a>: Python 的包管理工具.提供对 Python 包的查找, 下载, 安装, 卸载功能</strong></p><ul><li><p>pip 会随着 Python 一起安装.查看 pip 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip --version<br></code></pre></td></tr></table></figure></li><li><p>Ubuntu 安装 pip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install python-pip<br></code></pre></td></tr></table></figure></li><li><p>安装 &#x2F; 升级 &#x2F; 卸载包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install SomePackage              # 最新版本<br>pip install SomePackage==1.0.4       # 指定版本<br>pip install &#x27;SomePackage&gt;=1.0.4&#x27;     # 最小版本<br>pip install --upgrade SomePackage    # 升级包<br>pip uninstall SomePackage  # 卸载包<br></code></pre></td></tr></table></figure></li><li><p>升级 pip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install -U pip# Linux 环境<br>sudo easy_install --upgrade pip# 若上一条命令出错可使用<br>python -m pip install -U pip# Windows 环境<br></code></pre></td></tr></table></figure></li><li><p>其他功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip list# 显示已安装的包<br>pip list -o# 查看可升级的包<br>pip show# 显示安装包信息<br>pip show -f SomePackage# 查找指定包的信息<br>pip search SomePackage# 搜索包<br></code></pre></td></tr></table></figure></li></ul></li><li><p>创建虚拟环境需要 <code>virtualenv</code> 包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install virtualenv# Windows<br>sudo apt install python3-virtualenv# Ubuntu 安装方式<br></code></pre></td></tr></table></figure></li><li><p><strong>创建虚拟环境</strong>.此时会创建与环境名同名的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">virtualenv 环境名<br>virtualenv -p /usr/bin/python3.8 环境名  # 指定使用特定版本的 Python 创建虚拟环境<br></code></pre></td></tr></table></figure></li><li><p><strong>切换到某个虚拟环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">source &lt;环境名称&gt;/bin/activate# Linux<br>.\&lt;环境名称&gt;\Scripts\activate# Windows<br></code></pre></td></tr></table></figure></li><li><p><strong>退出虚拟环境</strong>: 将会退出到默认全局 Python 环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">deactivate<br></code></pre></td></tr></table></figure></li><li><p>删除虚拟环境: 只需删除对应的目录文件即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf &lt;环境名称&gt;  # Linux<br>rd /s /q &lt;环境名称&gt;# Windows<br></code></pre></td></tr></table></figure></li><li><p>在 PyCharm 中使用虚拟环境: <code>设置</code> -&gt; <code>Python</code> 解释器中进行选择</p><p><img src="/2024/10/29/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/1.%E5%9F%BA%E7%A1%80/assets/virtualenv.png"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python编程：从入门到实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
