<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python</title>
    <link href="/2025/09/10/Computer/Python/"/>
    <url>/2025/09/10/Computer/Python/</url>
    
    <content type="html"><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="0-Python-基础"><a href="#0-Python-基础" class="headerlink" title="0 Python 基础"></a>0 Python 基础</h2><h3 id="0-1-关键字"><a href="#0-1-关键字" class="headerlink" title="0.1 关键字"></a>0.1 关键字</h3><ol><li><p><strong>利用 python 标准库提供的 <code>keyword</code>模块.输出当前版本的所有关键字</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> keyword<br><span class="hljs-built_in">print</span>(keyword.kwlist)<br></code></pre></td></tr></table></figure></li><li><p>python 关键字</p><ul><li>基本类型: <code>False, True, None</code></li><li>控制流<ul><li>分支结构: <code>if, elif, else[, match, case]</code></li><li>循环结构: <code>for, in, while, continue, break</code></li><li>逻辑判断: <code>and, or, not, is</code></li></ul></li><li>类, 函数, 对象: <code>class, def, return, pass ,lambda, del</code></li><li>异常处理: <code>assert, try, except, finally, raise</code></li><li>包: <code>import, from, as</code></li><li>线程: <code>async, yield, await</code></li><li>其他: <code>global, nonlocal, with</code></li></ul></li><li><p>注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8  # 文件编码声明注释(位于文件首行)</span><br><span class="hljs-string">&#x27;&#x27;&#x27; 多行注释 &#x27;&#x27;&#x27;</span><br><span class="hljs-string">&quot;&quot;&quot; 多行注释 &quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>行与缩进</p><ul><li><strong>python 使用缩进来表示代码块,不需要使用大括号</strong></li><li>缩进的空格数是可变的,但同一代码块的语句必须包含相同的缩进空格数</li><li>与 C 相同: python 同样以在行尾加上续行转义符 <code>\</code> 来实现多行语句</li><li>在 <code>[], &#123;&#125;, ()</code> 中的多行语句自动续行.不需要使用反斜杠 <code>\</code> 续行</li></ul></li><li><p><strong>python 之禅</strong>: <code>import this</code></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs applescript">The Zen <span class="hljs-keyword">of</span> python, <span class="hljs-keyword">by</span> Tim Peters<br><br>Beautiful <span class="hljs-keyword">is</span> better than ugly.<br>Explicit <span class="hljs-keyword">is</span> better than implicit.<br>Simple <span class="hljs-keyword">is</span> better than complex.<br>Complex <span class="hljs-keyword">is</span> better than complicated.<br>Flat <span class="hljs-keyword">is</span> better than nested.<br>Sparse <span class="hljs-keyword">is</span> better than dense.<br>Readability counts.<br>Special cases aren&#x27;t special enough <span class="hljs-keyword">to</span> break <span class="hljs-keyword">the</span> rules.<br>Although practicality beats purity.<br>Errors should never pass silently.<br>Unless explicitly silenced.<br>In <span class="hljs-keyword">the</span> face <span class="hljs-keyword">of</span> ambiguity, refuse <span class="hljs-keyword">the</span> temptation <span class="hljs-keyword">to</span> guess.<br>There should be one<span class="hljs-comment">-- and preferably only one --obvious way to do it.</span><br>Although <span class="hljs-keyword">that</span> way may <span class="hljs-keyword">not</span> be obvious <span class="hljs-keyword">at</span> <span class="hljs-keyword">first</span> unless you&#x27;re Dutch.<br>Now <span class="hljs-keyword">is</span> better than never.<br>Although never <span class="hljs-keyword">is</span> often better than *right* now.<br>If <span class="hljs-keyword">the</span> implementation <span class="hljs-keyword">is</span> hard <span class="hljs-keyword">to</span> explain, <span class="hljs-keyword">it</span>&#x27;s a bad idea.<br>If <span class="hljs-keyword">the</span> implementation <span class="hljs-keyword">is</span> easy <span class="hljs-keyword">to</span> explain, <span class="hljs-keyword">it</span> may be a good idea.<br>Namespaces are one honking great idea <span class="hljs-comment">-- let&#x27;s do more of those!</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="0-2-运算符"><a href="#0-2-运算符" class="headerlink" title="0.2 运算符"></a>0.2 运算符</h3><ol><li><p>算术运算符</p><ul><li>基本算术运算符: <code>+, -, *, /, %</code>.  整除: <code>//</code>. 乘方: <code>**</code></li><li><strong>注意与 C 不同的是: python 中 <code>/</code> 是实数除法,而非整数除法</strong></li></ul></li><li><p>赋值运算符</p><ul><li>基本赋值: <code>=, +=, -=, *=, /=, %=</code>. <code>**=</code>: 乘方后赋值. <code>//=</code>: 整除后赋值</li><li><code>:=</code> <strong>海象运算符(python3.8 新增),可在表达式内部进行赋值</strong></li></ul></li><li><p><strong>逻辑运算符</strong>: <code>and, or, not</code></p></li><li><p><strong>成员运算符</strong>: <code>in, not in</code></p></li><li><p><strong>身份运算符</strong>: <code>is, is not</code></p></li><li><p>运算符优先级</p><table><thead><tr><th>优先级</th><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td>1</td><td align="left"><code>(expressions), [exp], &#123;exp&#125;, &#123;key: value&#125;</code></td><td align="left">括号内的表达式</td></tr><tr><td>2</td><td align="left"><code>x[index], x[:], x(arguments), x.attribute</code></td><td align="left">读取,切片,调用,属性引用</td></tr><tr><td>3</td><td align="left"><code>await x</code></td><td align="left"><code>await</code> 表达式</td></tr><tr><td>4</td><td align="left"><code>**</code></td><td align="left">乘方(指数)</td></tr><tr><td>5</td><td align="left"><code>+x, -x, ~x</code></td><td align="left">正,负,按位非 NOT</td></tr><tr><td>6</td><td align="left"><code>*, @, /, //, %</code></td><td align="left">乘,矩阵乘,除,整除,取余</td></tr><tr><td>7</td><td align="left"><code>+, -</code></td><td align="left">加,减</td></tr><tr><td>8</td><td align="left"><code>&lt;&lt;, &gt;&gt;</code></td><td align="left">移位</td></tr><tr><td>9</td><td align="left"><code>&amp;</code></td><td align="left">按位与 AND</td></tr><tr><td>10</td><td align="left"><code>^</code></td><td align="left">按位异或 XOR</td></tr><tr><td>11</td><td align="left">|</td><td align="left">按位或 OR</td></tr><tr><td>12</td><td align="left"><code>in, not in, is, is not, &lt;, &lt;=, &gt;, &gt;=, !=, ==</code></td><td align="left">成员检测, 比较运算</td></tr><tr><td>13</td><td align="left"><code>not x</code></td><td align="left">逻辑非 NOT</td></tr><tr><td>14</td><td align="left"><code>and</code></td><td align="left">逻辑与 AND</td></tr><tr><td>15</td><td align="left"><code>or</code></td><td align="left">逻辑或 OR</td></tr><tr><td>16</td><td align="left"><code>if - else</code></td><td align="left">条件表达式</td></tr><tr><td>17</td><td align="left"><code>lambda</code></td><td align="left">lambda 表达式</td></tr><tr><td>18</td><td align="left"><code>:=</code></td><td align="left">赋值表达式</td></tr></tbody></table></li></ol><h3 id="0-3-字符串"><a href="#0-3-字符串" class="headerlink" title="0.3 字符串"></a>0.3 字符串</h3><ol><li><p>字符串表示形式: 用 <code>&#39;</code> 或 <code>&quot;</code> 或 <code>&#39;&#39;&#39;</code> 包围.特别地,<strong>三引号允许字符串跨行</strong></p></li><li><p><strong>python 没有 <code>char</code> 类型.使用长度为 1 的字符串代替</strong></p></li><li><p><strong>字符串的运算符重载</strong></p><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td>+</td><td>拼接字符串</td></tr><tr><td>*</td><td>重复字符串</td></tr><tr><td>[]</td><td>下标索引</td></tr><tr><td>in &#x2F; not in</td><td>成员运算</td></tr><tr><td>r &#x2F; R</td><td>raw string: 前缀 r 表示不进行字符转义</td></tr><tr><td>%</td><td>格式字符串.如 <code>print(&quot;%d&quot; % age)</code></td></tr></tbody></table></li><li><p>格式化输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># format 方法格式化.print 默认换行输出.如果要实现不换行输出,需要在变量末尾加上 end=&quot;&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;age: &#123;&#125;, name: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(age, name), end=<span class="hljs-string">&quot;&quot;</span>)<br><br><span class="hljs-comment"># f-string(python3.6).f 作为前缀,用 &#123;&#125; 包围表达式.其中的表达式将会被计算后的值替换</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;age: <span class="hljs-subst">&#123;age&#125;</span>, name: <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>标准输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将 &quot;prompt&quot; 字符串进行标准输出,然后等待用户输入,并以 string 类型返回(读取一行)</span><br><span class="hljs-built_in">str</span> = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;prompt&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><code>string</code> 相关内建函数</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>isalnum()</td><td>非空 &amp; 所有字符都是字母或数字</td></tr><tr><td>endswith(suffix, beg&#x3D;0, end&#x3D;len(string))</td><td>字符串以 suffix 结束</td></tr><tr><td><strong>startswith(substr, beg&#x3D;0,end&#x3D;len(string))</strong></td><td><strong>字符串以 substr 开头</strong></td></tr><tr><td>strip([chars])</td><td>删除字符串左右的指定字符(默认空格)</td></tr><tr><td>center(width[, fillchar])</td><td>居中对齐</td></tr><tr><td><strong>split(str&#x3D;””, num&#x3D;string.count(str))</strong></td><td><strong>分割字符串</strong></td></tr><tr><td>splitlines([keepends])</td><td>按行 (<code>&#39;\r&#39;, &#39;\r\n&#39;, \n&#39;</code>) 分割字符串</td></tr><tr><td>count(str, beg&#x3D;0, end&#x3D;len(string))</td><td>计算 str 出现的次数</td></tr><tr><td><strong>find(str, beg&#x3D;0, end&#x3D;len(string))</strong></td><td><strong>查找</strong></td></tr><tr><td>rfind(str, beg&#x3D;0, end&#x3D;len(string))</td><td>反向查找</td></tr><tr><td>replace(old, new, max)</td><td>替换字符串. max 指定最大替换次数</td></tr><tr><td>encode(encoding&#x3D;’UTF-8’, errors&#x3D;’strict’)</td><td>指定编码的格式</td></tr></tbody></table></li></ol><h3 id="0-4-内置函数"><a href="#0-4-内置函数" class="headerlink" title="0.4 内置函数"></a>0.4 内置函数</h3><ol><li><p>判断对象所属类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">type</span>(obj)                   <span class="hljs-comment"># 返回对象的类型</span><br><span class="hljs-built_in">isinstance</span>(obj, class_name)<span class="hljs-comment"># 判断对象是否是已知类型.会认为子类对象是父类类型</span><br></code></pre></td></tr></table></figure></li><li><p>转换函数</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>bin(), oct(), hex()</td><td>进制转换.分别为 二进制, 八进制, 十六进制</td></tr><tr><td>chr()</td><td>Unicode 码点 -&gt; 字符</td></tr><tr><td>ord()</td><td>字符 -&gt; Unicode 码点</td></tr></tbody></table></li><li><p>数学函数(<code>import math</code>)</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>abs(x) &#x2F; fabs(x)</td><td>绝对值 &#x2F; 浮点绝对值</td></tr><tr><td>ceil(x) &#x2F; floor(x)</td><td>向上&#x2F;下取整</td></tr><tr><td>sqrt(x) &#x2F; exp(x) &#x2F; pow(x, y)</td><td>$\sqrt{x}$ &#x2F; $e^x$ &#x2F; $x^y$</td></tr><tr><td>log(x) &#x2F; log10(x)</td><td>$\mathrm{ln}x$ &#x2F; $\mathrm{log}_{10}x$</td></tr><tr><td>max(x, y,…) &#x2F; min(x, y,…)</td><td>取最大 &#x2F; 小值,参数可以为序列</td></tr><tr><td>modf(x)</td><td>返回 x的 整数部分与小数部分(符号与 x 相同)</td></tr><tr><td>round(x[, n])</td><td>4舍6进5看齐,奇进偶舍. n 指定位数</td></tr></tbody></table></li><li><p>随机函数(<code>import random</code>)</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><strong>seed(x)</strong></td><td><strong>设定随机数种子</strong></td></tr><tr><td><strong>choice(seq)</strong></td><td><strong>从序列的元素中随机挑选一个元素</strong></td></tr><tr><td>randint(x, y)</td><td>随机生成一个整数.范围: <code>[x, y]</code></td></tr><tr><td><strong>random()</strong></td><td><strong>随机生成一个实数.范围: <code>[0, 1)</code></strong></td></tr><tr><td>uniform(x, y)</td><td>随机生成一个实数.范围: <code>[x, y]</code></td></tr><tr><td>shuffle(lst)</td><td>将序列的所有元素随机排序</td></tr></tbody></table></li></ol><h2 id="1-数据容器"><a href="#1-数据容器" class="headerlink" title="1 数据容器"></a>1 数据容器</h2><h3 id="1-1-容器"><a href="#1-1-容器" class="headerlink" title="1.1 容器"></a>1.1 容器</h3><p><img src="/2025/09/10/Computer/Python/1-Python-Container-API.png"></p><ol><li><em>斜体</em> 表示抽象方法,必须由其具体子类实现</li><li>顶部的3个抽象基类 <code>Iterable, Sized, Container</code> 均只有一个抽象方法</li><li>python 不强制要求具体类继承这些抽象基类(如只要实现了 <code>__len__</code> 方法,就满足 Sized 接口)</li><li>Collection 具有三个重要的专用接口<ul><li><strong>Sequence</strong>: 规范 <code>list, str</code> 等内置类型的接口.也只有它实现了 <code>__reversed__</code> 方法</li><li><strong>Mapping</strong>: 被 <code>dict, collection.defaultdict</code> 等实现</li><li><strong>Set</strong>: 内置类型 <code>set, frozenset</code> 的接口</li></ul></li></ol><h3 id="1-2-列表"><a href="#1-2-列表" class="headerlink" title="1.2 列表"></a>1.2 列表</h3><ol><li><p>列表: 有序, 可变, 可重复的元素集合(元素类型允许嵌套列表.基本允许任何对象作为元素)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]  <span class="hljs-comment"># 使用 [] 包围元素表示列表; 使用 `,` 分隔元素</span><br></code></pre></td></tr></table></figure></li><li><p>列表推导式: 筛选和转换可迭代类中的项,并以此构建列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># [表达式 for 变量 in 列表 if 条件].其中: 表达式可以是有返回值的函数,条件语句是可选的</span><br><span class="hljs-comment"># 示例: 过滤出长度大于3的字符串,并将其全大写</span><br>names = [<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;Jerry&#x27;</span>, <span class="hljs-string">&#x27;Wendy&#x27;</span>, <span class="hljs-string">&#x27;Smith&#x27;</span>]<br>new_names = [name.upper() <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(name) &gt; <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure></li><li><p>访问元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">first_color = colors[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 正向索引.从  0 开始</span><br>last_color  = colors[-<span class="hljs-number">1</span>] <span class="hljs-comment"># 反向索引.从 -1 开始</span><br>error_color = colors[<span class="hljs-number">3</span>]  <span class="hljs-comment"># 访问越界.抛出 IndexError: list index out of range</span><br></code></pre></td></tr></table></figure></li><li><p><strong>切片: 获取列表的一部分,也是一个列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">list_name[start=<span class="hljs-number">0</span> : end=<span class="hljs-built_in">len</span>(list_name) : step=<span class="hljs-number">1</span>]<br><span class="hljs-comment"># start: 开始位置.默认为0</span><br><span class="hljs-comment"># end:   结束位置.默认为列表的长度</span><br><span class="hljs-comment"># step:  切片步长.默认为1,可省略.负数表示反向</span><br><span class="hljs-comment"># python 调用 seq.__getitem__(slice(start, stop, step)) 求解切片 seq[start : stop : step]</span><br></code></pre></td></tr></table></figure></li><li><p>运算符重载: 用 <code>+</code> 进行连接,用 <code>*</code> 运算符进行重复(与字符串类似)</p></li><li><p>常用操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加元素</span><br>colors.append(<span class="hljs-string">&#x27;black&#x27;</span>)            <span class="hljs-comment"># 添加元素到列表末尾</span><br>colors.extend([<span class="hljs-string">&#x27;black&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>]) <span class="hljs-comment"># 将可迭代序列拓展到列表末尾</span><br>colors.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;white&#x27;</span>)         <span class="hljs-comment"># 添加元素到指定的索引处</span><br><br><span class="hljs-comment"># 删除元素</span><br>colors.remove(<span class="hljs-string">&#x27;black&#x27;</span>)            <span class="hljs-comment"># 按首个匹配值删除元素</span><br>second_color = colors.pop(<span class="hljs-number">1</span>)      <span class="hljs-comment"># 按索引删除元素并返回该元素(默认为最后一个)</span><br><span class="hljs-keyword">del</span> colors[<span class="hljs-number">0</span>]                     <span class="hljs-comment"># 按索引删除元素</span><br><span class="hljs-keyword">del</span> colors[:]                     <span class="hljs-comment"># 按切片删除元素</span><br>numbers.clear()                   <span class="hljs-comment"># 清空列表. 等价于 del colors[:]</span><br><br><span class="hljs-comment"># 修改元素</span><br>colors[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;yellow&#x27;</span>              <span class="hljs-comment"># 按索引修改元素</span><br>colors[<span class="hljs-number">0</span>: <span class="hljs-number">2</span>] = [<span class="hljs-string">&#x27;purple&#x27;</span>]         <span class="hljs-comment"># 按切片修改元素</span><br><br><span class="hljs-comment"># 查询元素</span><br>position   = colors.index(<span class="hljs-string">&#x27;red&#x27;</span>)  <span class="hljs-comment"># 获取首个匹配值的索引</span><br>red_count  = colors.count(<span class="hljs-string">&#x27;red&#x27;</span>)  <span class="hljs-comment"># 统计元素出现的次数</span><br>is_present = <span class="hljs-string">&#x27;red&#x27;</span> <span class="hljs-keyword">in</span> colors      <span class="hljs-comment"># 检查元素是否存在</span><br><br><span class="hljs-comment"># 翻转列表</span><br>colors.reverse()<br></code></pre></td></tr></table></figure></li><li><p>排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&#x27;grape&#x27;</span>, <span class="hljs-string">&#x27;raspberry&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>]<br><span class="hljs-built_in">sorted</span>(fruits)                 <span class="hljs-comment"># 默认排序 [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;grape&#x27;, &#x27;raspberry&#x27;]</span><br><span class="hljs-built_in">sorted</span>(fruits, reverse = <span class="hljs-literal">True</span>) <span class="hljs-comment"># 反向排序 [&#x27;raspberry&#x27;, &#x27;grape&#x27;, &#x27;banana&#x27;, &#x27;apple&#x27;]</span><br><span class="hljs-built_in">sorted</span>(fruits, key = <span class="hljs-built_in">len</span>)      <span class="hljs-comment"># 长度排序 [&#x27;grape&#x27;, &#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;raspberry&#x27;]</span><br>fruits.sort()                  <span class="hljs-comment"># 原地排序 [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;grape&#x27;, &#x27;raspberry&#x27;]</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="1-3-元组"><a href="#1-3-元组" class="headerlink" title="1.3 元组"></a>1.3 元组</h3><ol><li><p>元组: 有序, 不可变, 可重复的元素集合.创建方式: 用 <code>()</code> 包围,区别于列表使用 <code>[]</code></p><ul><li><p>元组支持的方法: 所有不进行 <em>增, 删, 改</em> 的列表方法</p></li><li><p>字符串可看作一种特殊的 <code>tuple</code></p></li><li><p>当函数返回多个值时,其本质返回的是元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">return</span> width, height  <span class="hljs-comment"># 相当于返回 (width, height)</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>tuple</code> 与 <code>list</code> 类似,区别在于 <code>tuple</code> 不可更改</strong>.通常用于</p><ul><li>不可变列表: 意图清晰,其长度不可变; 相对于列表占用内存更少</li><li>无需字段名称的记录: 使用位置信息决定数据的意义.使用解包获取数据</li></ul></li><li><p>生成器表达式: 返回的结果是一个生成器对象,需要使用 <code>tuple()</code> 函数转化为元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">(expression <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-type">Sequence</span> <span class="hljs-keyword">if</span> condition )<br><br>symbols = <span class="hljs-string">&#x27;$¢£¥€¤&#x27;</span><br>tup = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">ord</span>(symbol) <span class="hljs-keyword">for</span> symbol <span class="hljs-keyword">in</span> symbols)  <span class="hljs-comment"># (36, 162, 163, 165, 8364, 164)</span><br></code></pre></td></tr></table></figure><ul><li>生成器表达式使用迭代器协议逐个产出项,而不是构建整个列表提供给其他构造函数</li><li>当生成器表达式作为函数的唯一参数时,可以省略 <code>()</code></li></ul></li><li><p>解包: 将可迭代对象(如 列表, 元组, 字典…)的元素解开并分配到多个变量的过程(可以嵌套)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 元组解包</span><br>point = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>x, y = point  <span class="hljs-comment"># x = 10, y = 20</span><br><br><span class="hljs-comment"># 列表解包</span><br>colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]<br>r, g, b = colors  <span class="hljs-comment"># r = &#x27;red&#x27;, g = &#x27;green&#x27;, b = &#x27;blue&#x27;</span><br><br><span class="hljs-comment"># 交换变量的值</span><br>a, b = b, a<br><br><span class="hljs-comment"># 使用 * 收集多余的元素.只有一个变量可被 * 装饰.而该变量的位置并不强制要求在最后</span><br>first, *middle, last = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <span class="hljs-comment"># first = 1, middle = [2, 3, 4], last = 5</span><br></code></pre></td></tr></table></figure></li><li><p>具名元组(<code>namedtuple</code>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><br><span class="hljs-comment"># collections.namedtuple 是工厂函数.创建了一个元组的子类.为每个位置元素赋予了名称</span><br>Person = namedtuple(<span class="hljs-string">&#x27;Person&#x27;</span>, [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;job&#x27;</span>])<br><br><span class="hljs-comment"># 创建实例</span><br>bob = Person(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-string">&#x27;developer&#x27;</span>)<br>alice = Person(name=<span class="hljs-string">&#x27;Alice&#x27;</span>, age=<span class="hljs-number">25</span>, job=<span class="hljs-string">&#x27;designer&#x27;</span>) <span class="hljs-comment"># 关键字参数也可用</span><br><br><span class="hljs-comment"># 访问方式</span><br><span class="hljs-built_in">print</span>(bob.name)    <span class="hljs-comment"># &#x27;Bob&#x27; (通过字段名)</span><br><span class="hljs-built_in">print</span>(bob[<span class="hljs-number">0</span>])      <span class="hljs-comment"># &#x27;Bob&#x27; (通过索引)</span><br><span class="hljs-built_in">print</span>(bob.age)     <span class="hljs-comment"># 30</span><br><br><span class="hljs-comment"># 仍然具有元组的所有特性</span><br>name, age, job = bob <span class="hljs-comment"># 解包</span><br><span class="hljs-keyword">for</span> field <span class="hljs-keyword">in</span> bob:    <span class="hljs-comment"># 迭代</span><br>    <span class="hljs-built_in">print</span>(field)<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-4-字典"><a href="#1-4-字典" class="headerlink" title="1.4 字典"></a>1.4 字典</h3><ol><li><p>字典: 无序(python 3.6 后有序), 可变, 键值对(key-value pairs)的元素集合(key 必须不可变且唯一.常用数字, 字符串)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 字典的元素形如 key: value. 使用 &#123;&#125; 包裹表示字典,使用 `,` 分隔元素</span><br>config = &#123;<span class="hljs-string">&#x27;host&#x27;</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-string">&#x27;port&#x27;</span>: <span class="hljs-number">8080</span>, <span class="hljs-string">&#x27;debug&#x27;</span>: <span class="hljs-literal">True</span>&#125;<br><br><span class="hljs-comment"># 字典推导式</span><br>&#123; key_expr: value_expr <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> collection <span class="hljs-keyword">if</span> condition &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>可 hash</strong>: 对象的哈希码在整个生命周期不变(<code>__hash__</code>方法),且可与其他对象比较(<code>__eq__</code>方法)</p><ul><li>可 hash 对象的相等  &lt;-等价于-&gt;  hash 值相等</li><li>数值类型及不可变的扁平类型(<code>str, bytes</code>). 可 hash</li><li>若容器本身不可变,且其元素也全为不可变的.可 hash</li></ul></li><li><p>python 使用哈希表实现 <code>dict</code></p><ul><li><code>key</code> 必须可 hash.必须正确实现 <code>__hash__, __eq__</code> </li><li>通过 <code>key</code> 访问项的速度非常快.通过计算 <code>key</code> 的哈希码直接定位</li><li>为节省内存,不要在 <code>__init__</code> 之外创建实例属性</li></ul></li><li><p>常用操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 访问元素.使用 dict[key] 形式访问 key 所对应的 value</span><br>host = config[<span class="hljs-string">&#x27;host&#x27;</span>]             <span class="hljs-comment"># 通过 key 访问 value.若 key 不存在将会抛出 KeyError</span><br>config[<span class="hljs-string">&#x27;name&#x27;</span>] = <span class="hljs-string">&#x27;bob&#x27;</span>            <span class="hljs-comment"># 通过 key 修改 value.若 key 不存在将会新增 key-value</span><br>port = config.get[<span class="hljs-string">&#x27;port&#x27;</span>, <span class="hljs-number">0</span>]      <span class="hljs-comment"># 避免 KeyError 异常. 若 key 不存在返回指定的数据</span><br>port = config.setdefault(<span class="hljs-string">&#x27;port&#x27;</span>, <span class="hljs-number">8000</span>) <span class="hljs-comment"># 添加 key-value.若 key 不存在不会修改原本的值</span><br><br><span class="hljs-comment"># 删除元素</span><br><span class="hljs-keyword">del</span> config[<span class="hljs-string">&#x27;debug&#x27;</span>]        <span class="hljs-comment"># 通过 key 删除</span><br>port = config.pop(<span class="hljs-string">&#x27;port&#x27;</span>)  <span class="hljs-comment"># 通过 key 删除并返回对应的 value</span><br>item = config.popitem()    <span class="hljs-comment"># 删除并返回最后插入的 key-value</span><br>config.clear()             <span class="hljs-comment"># 清空字典. config = &#123;&#125;</span><br><br><span class="hljs-comment"># 遍历字典.当对字典进行遍历时,默认遍历所有的 key</span><br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> config:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;key&#125;</span>: <span class="hljs-subst">&#123;config[key]&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 显式遍历字典 key-value</span><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> config.items():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;key&#125;</span>: <span class="hljs-subst">&#123;value&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 合并字典</span><br>dict1.update(dict2)     <span class="hljs-comment"># 用另一个字典更新当前字典</span><br>merged = dict1 | dict2  <span class="hljs-comment"># python 3.9+ 合并运算符 |</span><br></code></pre></td></tr></table></figure></li><li><p>默认字典(<code>collections.defaultdict</code> 提供更便捷的默认值处理)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-comment"># 为不存在的键提供默认值</span><br>word_count = defaultdict(<span class="hljs-built_in">int</span>)  <span class="hljs-comment"># 默认值为 int() = 0</span><br><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;cherry&#x27;</span>]:<br>    word_count[word] += <span class="hljs-number">1</span>      <span class="hljs-comment"># 不需要检查键是否存在</span><br><span class="hljs-comment"># defaultdict(&lt;class &#x27;int&#x27;&gt;, &#123;&#x27;apple&#x27;: 2, &#x27;banana&#x27;: 1, &#x27;cherry&#x27;: 1&#125;)</span><br><br><span class="hljs-comment"># 列表作为默认值</span><br>class_grades = defaultdict(<span class="hljs-built_in">list</span>)<br>class_grades[<span class="hljs-string">&#x27;math&#x27;</span>].append(<span class="hljs-number">90</span>)<br>class_grades[<span class="hljs-string">&#x27;math&#x27;</span>].append(<span class="hljs-number">85</span>)<br><span class="hljs-comment"># defaultdict(&lt;class &#x27;list&#x27;&gt;, &#123;&#x27;math&#x27;: [90, 85]&#125;)</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="1-5-集合"><a href="#1-5-集合" class="headerlink" title="1.5 集合"></a>1.5 集合</h3><ol><li><p><code>set</code>: 无序, 可变, 元素唯一的集合.其元素必须 可 hash.但 <code>set</code> 本身不可 hash,因此不可嵌套(<code>frozenset</code> 可 hash)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 集合使用 &#123;&#125; 包裹表示字典,使用 `,` 分隔元素.字典同样使用 &#123;&#125;, 但元素形式不同,以区分</span><br>colors = &#123;<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>&#125;<br><br><span class="hljs-comment"># 集合推导式</span><br>&#123; expression <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-type">Sequence</span> <span class="hljs-keyword">if</span> condition &#125;<br></code></pre></td></tr></table></figure></li><li><p><code>set</code> 实现</p><ul><li>底层用哈希表实现.成员测试效率非常高</li><li>向集合添加元素后,现有元素的顺序可能发生变化</li></ul></li><li><p>常用操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加元素</span><br>colors.add(<span class="hljs-string">&#x27;yellow&#x27;</span>)                <span class="hljs-comment"># 添加元素.若元素已经存在,则无变化</span><br>colors.update([<span class="hljs-string">&#x27;purple&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>]) <span class="hljs-comment"># 添加多个元素</span><br><br><span class="hljs-comment"># 删除元素</span><br>colors.remove(<span class="hljs-string">&#x27;green&#x27;</span>)      <span class="hljs-comment"># 删除元素.如果不存在则抛出 KeyError</span><br>colors.discard(<span class="hljs-string">&#x27;pink&#x27;</span>)      <span class="hljs-comment"># 删除元素.如果不存在也不报错</span><br>random_color = colors.pop() <span class="hljs-comment"># 随机删除元素并将其返回</span><br><br><span class="hljs-comment"># 集合运算</span><br>A = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>B = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;<br>union        = A | B  <span class="hljs-comment"># 并集     &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</span><br>intersection = A &amp; B  <span class="hljs-comment"># 交集     &#123;4, 5&#125;</span><br>difference   = A - B  <span class="hljs-comment"># 差集     &#123;1, 2, 3&#125;</span><br>sym_diff     = A ^ B  <span class="hljs-comment"># 对称差集 &#123;1, 2, 3, 6, 7, 8&#125;</span><br><br><span class="hljs-comment"># 集合比较</span><br>A == B  <span class="hljs-comment"># 相等性. 反之有 A != B</span><br>A &lt; B   <span class="hljs-comment"># 真子集. 反之有 A  &gt; B</span><br>A &lt;= B  <span class="hljs-comment">#   子集. 反之有 A &gt;= B</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="2-程序控制"><a href="#2-程序控制" class="headerlink" title="2 程序控制"></a>2 程序控制</h2><h3 id="2-1-控制流"><a href="#2-1-控制流" class="headerlink" title="2.1 控制流"></a>2.1 控制流</h3><ol><li><p><code>if - elif - else</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> &lt;condition_1&gt;:  <span class="hljs-comment"># 条件表达式的值为 True 时,则执行,且下面的判断不在执行</span><br>    &lt;statement_block_1&gt;<br><span class="hljs-keyword">elif</span> condition_2:  <span class="hljs-comment"># 当 condition_1 的值为 False,才会进行判断</span><br>    &lt;statement_block_2&gt;<br><span class="hljs-keyword">else</span>:              <span class="hljs-comment"># 当所有的条件表达式都为 False,才会执行</span><br>    &lt;statement_block_3&gt;<br></code></pre></td></tr></table></figure></li><li><p><code>match - case</code>(python3.10)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">match</span> subject:         <span class="hljs-comment"># 类似于 C 中的 switch-case</span><br>    <span class="hljs-keyword">case</span> &lt;pattern_1&gt;:  <span class="hljs-comment"># 当成功匹配时,执行相应的语句</span><br>        &lt;action_1&gt;<br>    <span class="hljs-keyword">case</span> &lt;pattern_2&gt;:<br>        &lt;action_2&gt;<br>    <span class="hljs-keyword">case</span> _:            <span class="hljs-comment"># 可以匹配一切.该语句与 C 中的 &#x27;default:&#x27; 作用类似</span><br>        &lt;action_wildcard&gt;<br></code></pre></td></tr></table></figure></li><li><p><code>while</code>(python 没有 <code>do while</code>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> &lt;expr&gt;:       <span class="hljs-comment"># 当表达式的值为 True,则执行循环</span><br>    &lt;statement(s)&gt;  <span class="hljs-comment"># 可以使用 continue 和 break 语句</span><br><span class="hljs-keyword">else</span>:               <span class="hljs-comment"># 若循环语句未被 break 打断,则 else 语句将会被执行</span><br>    &lt;additional_statement(s)&gt;<br></code></pre></td></tr></table></figure></li><li><p><code>for</code> 经常用来遍历可迭代对象(不要在 <code>for</code> 循环遍历列表时修改列表,此时应该使用 <code>while</code>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> &lt;variable&gt; <span class="hljs-keyword">in</span> &lt;sequence&gt;:  <span class="hljs-comment"># 当可以取到序列对象的元素时,则执行循环</span><br>    &lt;statements&gt;               <span class="hljs-comment"># 可以使用 continue 和 break 语句</span><br><span class="hljs-keyword">else</span>:                          <span class="hljs-comment"># 若循环语句未被 break 打断,则 else 语句将会被执行</span><br>    &lt;statements&gt;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-迭代器"><a href="#2-2-迭代器" class="headerlink" title="2.2 迭代器"></a>2.2 迭代器</h3><ol><li><p>迭代器(Iterator)</p><ul><li>迭代器可以记住遍历的位置,只能往前不会后退</li><li>从第一个元素开始访问.直到所有的元素被访问完结束.当没有元素可以访问时抛出 <code>StopIteration</code> 异常</li></ul></li><li><p>迭代器协议</p><ul><li>任何实现 <code>__iter__(), __next__()</code> 方法的对象都是迭代器(或实现 <code>__getitem__</code> 方法且接收从 0 开始索引)</li><li><code>__iter__()</code>: 返回迭代器对象本身</li><li><code>__next__()</code>: 返回容器的下一个元素.如果没有更多元素则抛出 <code>StopIteration</code> 异常</li></ul></li><li><p>迭代器与可迭代对象: <code>iter(Iterable) -&gt; Iterator</code></p><table><thead><tr><th align="left">特性</th><th align="left">可迭代对象 (Iterable)</th><th align="left">迭代器 (Iterator)</th></tr></thead><tbody><tr><td align="left">定义</td><td align="left">实现了 <code>__iter__()</code> 方法</td><td align="left">实现了 <code>__iter__()</code> 和 <code>__next__()</code> 方法</td></tr><tr><td align="left">功能</td><td align="left">可以被迭代</td><td align="left">实际执行迭代操作</td></tr><tr><td align="left">状态</td><td align="left">无状态(通常)</td><td align="left">有状态(记住当前位置)</td></tr><tr><td align="left">示例</td><td align="left">列表, 元组, 字符串, 字典</td><td align="left"><code>iter()</code> 函数的返回值</td></tr></tbody></table></li><li><p>迭代器使用示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fibonacci</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, max_count</span>):<br>        <span class="hljs-variable language_">self</span>.max_count = max_count<br>        <span class="hljs-variable language_">self</span>.count = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.before, <span class="hljs-variable language_">self</span>.after = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.count &gt;= <span class="hljs-variable language_">self</span>.max_count:<br>            <span class="hljs-keyword">raise</span> StopIteration<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.count == <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.before<br>        <span class="hljs-variable language_">self</span>.before, <span class="hljs-variable language_">self</span>.after = <span class="hljs-variable language_">self</span>.after, <span class="hljs-variable language_">self</span>.before + <span class="hljs-variable language_">self</span>.after<br>        <span class="hljs-variable language_">self</span>.count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.before<br><br><span class="hljs-comment"># 使用迭代器</span><br><span class="hljs-keyword">for</span> fib <span class="hljs-keyword">in</span> Fibonacci(<span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">print</span>(fib)<br></code></pre></td></tr></table></figure></li><li><p>内置迭代器工具</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># enumerate: 带索引的迭代</span><br>fruits = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;cherry&#x27;</span>]<br><span class="hljs-keyword">for</span> index, fruit <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(fruits):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;index&#125;</span>: <span class="hljs-subst">&#123;fruit&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># zip: 并行迭代</span><br>names = [<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Charlie&#x27;</span>]<br>ages = [<span class="hljs-number">25</span>, <span class="hljs-number">30</span>, <span class="hljs-number">35</span>]<br><span class="hljs-keyword">for</span> name, age <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(names, ages):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span> is <span class="hljs-subst">&#123;age&#125;</span> years old&quot;</span>)<br><br><span class="hljs-comment"># map: 对每个元素应用函数</span><br>numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>squared = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x**<span class="hljs-number">2</span>, numbers)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(squared))  <span class="hljs-comment"># [1, 4, 9, 16]</span><br><br><span class="hljs-comment"># filter: 过滤元素</span><br>numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>even = <span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, numbers)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(even))  <span class="hljs-comment"># [2, 4, 6]</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>iter</code> 处理可调用对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">d6</span>():<br>    <span class="hljs-keyword">return</span> randint(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)<br><br><span class="hljs-comment"># 第一个参数必须为可迭代对象.其将被重复调用(不传入参数)并产生值</span><br><span class="hljs-comment"># 第二个参数为哨符.当可调用对象返回哨符时,迭代器抛出 StopIteration.且不会产出哨符</span><br><span class="hljs-keyword">for</span> roll <span class="hljs-keyword">in</span> <span class="hljs-built_in">iter</span>(d6, <span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(roll)<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-生成器"><a href="#2-3-生成器" class="headerlink" title="2.3 生成器"></a>2.3 生成器</h3><ol><li><p><strong>生成器: 使用了 <code>yield</code> 的函数</strong></p><ul><li>生成器函数是一种特殊的函数,可以在迭代过程中逐步产生值,而不是一次性返回所有结果</li><li>生成器是一个返回迭代器的函数,只能用于迭代操作</li></ul></li><li><p>生成器执行过程</p><ul><li>生成器函数中遇到 <code>yield</code> 语句时,函数的执行暂停,然后将 <code>yield</code> 后面的表达式作为当前迭代的值返回</li><li>调用生成器的 <code>next</code> 函数或使用 <code>for</code> 循环迭代时,函数会从上次暂停的地方继续执行,直到再次遇到 <code>yield</code> 语句</li></ul></li><li><p>生成器使用示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">limit</span>):<br>    before, after = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> count &lt; limit:<br>        <span class="hljs-keyword">yield</span> before<br>        before, after = after, before + after<br>        count += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 利用生成器获取迭代器</span><br>fib = fibonacci()  <span class="hljs-comment"># 获取迭代器</span><br><span class="hljs-built_in">next</span>(f)            <span class="hljs-comment"># 使用迭代器</span><br><br><span class="hljs-comment"># 生成器使用 for 循环</span><br><span class="hljs-keyword">for</span> fib <span class="hljs-keyword">in</span> fibonacci(<span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">print</span>(fib, end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-函数"><a href="#2-4-函数" class="headerlink" title="2.4 函数"></a>2.4 函数</h3><ol><li><p>参数类型</p><ul><li><p>位置参数: 实参的顺序必须与形参的定义顺序完全一致</p></li><li><p>关键字参数: 通过 <code>参数名=值</code> 的形式传递.顺序无关紧要,代码可读性更强</p></li><li><p>默认参数: 在定义时为参数指定默认值(必须是不可变对象),调用时可不传递该参数</p></li><li><p>可变参数: <code>*args</code> 接收任意数量的位置参数,打包成元组</p></li><li><p>可变参数: <code>**kwargs</code> 接收任意数量的关键字参数,打包成字典</p></li><li><p>参数组合使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">function</span>(<span class="hljs-params"></span><br><span class="hljs-params">    positional_only_parameters,  <span class="hljs-comment"># 仅位置参数 (Python 3.8+)</span></span><br><span class="hljs-params">    /,                           <span class="hljs-comment"># 分隔符: 前面的参数只能是位置参数</span></span><br><span class="hljs-params">    standard_parameters,         <span class="hljs-comment"># 普通位置 / 关键字参数</span></span><br><span class="hljs-params">    *args,                       <span class="hljs-comment"># 可变位置参数</span></span><br><span class="hljs-params">    *,                           <span class="hljs-comment"># 分隔符: 后面的参数只能是关键字参数</span></span><br><span class="hljs-params">    keyword_only_parameters,     <span class="hljs-comment"># 仅关键字参数</span></span><br><span class="hljs-params">    **kwargs                     <span class="hljs-comment"># 可变关键字参数</span></span><br><span class="hljs-params"></span>):<br>    <span class="hljs-keyword">pass</span>                         <span class="hljs-comment"># 函数体.没有 return 语句的默认返回 None</span><br><br><span class="hljs-comment"># 通常不会使用所有特性.而是进行组合</span><br><span class="hljs-comment"># 标准参数 + 仅关键字参数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_user</span>(<span class="hljs-params">name, email, *, is_active=<span class="hljs-literal">True</span>, role=<span class="hljs-string">&#x27;user&#x27;</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;创建用户，配置选项必须明确指定&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;创建用户: <span class="hljs-subst">&#123;name&#125;</span>, <span class="hljs-subst">&#123;email&#125;</span>, 活跃: <span class="hljs-subst">&#123;is_active&#125;</span>, 角色: <span class="hljs-subst">&#123;role&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 仅位置参数 + 关键字参数  </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_distance</span>(<span class="hljs-params">x1, y1, x2, y2, /, *, unit=<span class="hljs-string">&#x27;meters&#x27;</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;计算距离，坐标必须位置传递，单位必须关键字指定&quot;&quot;&quot;</span><br>    distance = ((x2-x1)**<span class="hljs-number">2</span> + (y2-y1)**<span class="hljs-number">2</span>)**<span class="hljs-number">0.5</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;距离: <span class="hljs-subst">&#123;distance&#125;</span> <span class="hljs-subst">&#123;unit&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">return</span> distance<br></code></pre></td></tr></table></figure></li></ul></li><li><p>python 查找变量名的顺序: 函数内部(local) -&gt; 闭包(enclosing) -&gt; 模块(global) -&gt; 内置(build-in)</p></li><li><p>函数是一等对象(First-Class Object)</p><ul><li>一等对象的要求: 可赋值给变量; 可作为参数传递(高阶函数); 可作为函数返回值(闭包); 可存储于数据结构</li><li>装饰器是这一概念的最佳体现</li></ul></li><li><p>匿名函数: 通常用于作为高阶函数的参数</p><ul><li><p><code>lambda</code> 只是一个表达式,而非代码块,无法访问全局命名空间</p></li><li><p><code>lambda</code> 函数拥有自己的命名空间,仅能访问参数列表的参数.函数体只能有一行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> arguments : expression<br></code></pre></td></tr></table></figure></li></ul></li><li><p>闭包: 函数 + 创建该函数的环境.只有在函数嵌套才有闭包概念</p><ul><li>嵌套函数中.内部函数引用外部函数的变量.外部函数将内部函数返回</li><li>闭包好似一个拥有多个属性,但只有一个方法的对象(简化的对象)</li></ul></li><li><p>闭包示例: 求平均值的函数.要求每次调用它时计算 <code>以往输入的数据 + 本次输入数据</code> 的平均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 由于求平均值仅需 总和,项数 信息,可以改进如下: </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">averager</span>():<br>    count = <span class="hljs-number">0</span>                  <span class="hljs-comment"># 外部函数的局部变量</span><br>    total = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">average</span>(<span class="hljs-params">new_value</span>):<br>        <span class="hljs-keyword">nonlocal</span> count, total  <span class="hljs-comment"># count, total 标记为非局部变量</span><br>        total += new_value     <span class="hljs-comment"># 由于 nonlocal 的存在.total 不是内部函数的局部变量</span><br>        count += <span class="hljs-number">1</span>             <span class="hljs-comment"># 内部函数引用外部函数的变量</span><br>        <span class="hljs-keyword">return</span> total / count   <span class="hljs-comment"># 内部函数正常执行功能并返回</span><br>    <span class="hljs-keyword">return</span> average             <span class="hljs-comment"># 外部函数将内部函数返回</span><br><br><span class="hljs-comment"># 闭包的使用</span><br>avg = averager()  <span class="hljs-comment"># avg 是函数.也可以看成一个简易的对象,可以直接调用到内部的 average 函数</span><br>avg(<span class="hljs-number">10</span>)           <span class="hljs-comment"># 10 被传递给内部函数的 new_value. 10 / 1 = 10</span><br>avg(<span class="hljs-number">50</span>)           <span class="hljs-comment"># 50 被传递给内部函数的 new_value. (10 + 50) / 2 = 30</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-5-装饰器"><a href="#2-5-装饰器" class="headerlink" title="2.5 装饰器"></a>2.5 装饰器</h3><ol><li><p>装饰器是特殊的函数</p><ul><li>装饰器的参数是一个函数,然后返回一个新函数</li><li>装饰器遵循了开放封闭原则.可以在不修改原函数的代码的情况下原函数的行为</li><li>装饰器在加载(导入)模块时立即执行.而被装饰的函数只在显式调用时运行</li></ul></li><li><p>装饰器的本质上只是语法糖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@decorate                 </span><span class="hljs-comment"># 装饰器的使用(假设存在 decorate 装饰器)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>():             <span class="hljs-comment"># target 会被 decorate 处理后再返回</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;target()&#x27;</span>)<br>    <br><span class="hljs-comment"># 与下面的代码效果一致</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;target()&#x27;</span>)<br><br>target = decorate(target) <span class="hljs-comment"># 手动装饰 target 函数  </span><br></code></pre></td></tr></table></figure></li><li><p>装饰器模板(处理任意参数的装饰器)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">universal_decorator</span>(<span class="hljs-params">func</span>):         <span class="hljs-comment"># 装饰器接收一个函数作为参数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):      <span class="hljs-comment"># 定义内部函数</span><br>        result = func(*args, **kwargs) <span class="hljs-comment"># 传递所有参数.并调用入参函数进行处理</span><br>        <span class="hljs-keyword">return</span> result                  <span class="hljs-comment"># 将内部函数的处理结果返回</span><br>    <span class="hljs-keyword">return</span> wrapper                     <span class="hljs-comment"># 将内部函数返回</span><br><br><span class="hljs-meta">@universal_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-comment"># 装饰器使用</span><br>add(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure></li><li><p>装饰器示例: 显示函数运行时间的简单装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-comment"># 创建装饰器</span><br>DEFAULT_FMT = <span class="hljs-string">&#x27;[&#123;elapsed: 0.8f&#125;]s &#123;name&#125;(&#123;arg_str&#125;) -&gt; &#123;result!r&#125;&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">clock</span>(<span class="hljs-params">fmt=DEFAULT_FMT</span>): <span class="hljs-comment"># 参数fmt: 格式化输出字符串</span><br>    <span class="hljs-string">&quot;&quot;&quot;参数化装饰器的工厂函数 clock: 每当被装饰的函数被调用时: 打印其运行时间,传入参数,调用结果</span><br><span class="hljs-string">       这是一个含参装饰器.装饰的函数是含参的,且有返回值的函数&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorate</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;decorate 才是真正的装饰器,其参数为一个函数.clock 用于接收装饰器的参数&quot;&quot;&quot;</span><br><span class="hljs-meta">        @functools.wraps(<span class="hljs-params">func</span>)        </span><span class="hljs-comment"># 将相关的属性从 func 复制到 clocked 中.建议装饰器均使用</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">clocked</span>(<span class="hljs-params">*args, **kwargs</span>): <span class="hljs-comment"># 接收位置参数及关键字参数</span><br>            <span class="hljs-string">&quot;&quot;&quot;clocked 是真正被持有的函数对象.真正承担工作&quot;&quot;&quot;</span><br>            t0 = time.perf_counter()           <span class="hljs-comment"># 获取初始时间</span><br>            result = func(*args, **kwargs)     <span class="hljs-comment"># 调用原函数,计算结果</span><br>            elapsed = time.perf_counter() - t0 <span class="hljs-comment"># 获取运行时间</span><br>            name = func.__name__               <span class="hljs-comment"># 获取函数名</span><br>            arg_lst = [<span class="hljs-built_in">repr</span>(arg) <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> args]<br>            arg_lst.extend(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;k&#125;</span>=<span class="hljs-subst">&#123;v!r&#125;</span>&#x27;</span> <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> kwargs.items())<br>            arg_str = <span class="hljs-string">&#x27;,&#x27;</span>.join(arg_lst)   <span class="hljs-comment"># 获取参数列表,使用逗号将其分隔</span><br>            <span class="hljs-built_in">print</span>(fmt.<span class="hljs-built_in">format</span>(**<span class="hljs-built_in">locals</span>())) <span class="hljs-comment"># locals() 函数以字典形式返回所有局部变量</span><br>            <span class="hljs-comment"># 格式化输出形如: [0.00015620]s factorial(10) -&gt; 3628800</span><br>            <span class="hljs-keyword">return</span> result <span class="hljs-comment"># 由于 clocked 将取代被装饰的函数,因此需要返回真正的计算结果</span><br>        <span class="hljs-keyword">return</span> clocked    <span class="hljs-comment"># 返回内部函数,取代被装饰的函数</span><br>    <span class="hljs-keyword">return</span> decorate<br><br><span class="hljs-comment"># 使用装饰器</span><br><span class="hljs-meta">@clock(<span class="hljs-params">fmt=<span class="hljs-string">&#x27;&#123;name&#125;(&#123;arg_str&#125;):\t &#123;elapsed: 0.7f&#125;s&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> n * factorial(n-<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 每次调用 factorial() 时装饰器都会发挥作用</span><br>factorial(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure></li><li><p>类装饰器示例(相对于装饰器函数而言,明显减少了嵌套的层数)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br>DEFAULT_FMT = <span class="hljs-string">&#x27;[&#123;elapsed:0.8f&#125;s] &#123;name&#125;(&#123;args&#125;) -&gt; &#123;result&#125;&#x27;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, fmt=DEFAULT_FMT</span>):<br>        <span class="hljs-variable language_">self</span>.fmt = fmt<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, func</span>):  <span class="hljs-comment"># __call__ 魔法方法专注于添加功能即可</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">clocked</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            t0 = time.perf_counter()<br>            result = func(*args, **kwargs)<br>            elapsed = time.perf_counter() - t0<br>            name = func.__name__<br>            arg_lst = [<span class="hljs-built_in">repr</span>(arg) <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> args]<br>            arg_lst.extend(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;k&#125;</span>=<span class="hljs-subst">&#123;v!r&#125;</span>&#x27;</span> <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> kwargs.items())<br>            arg_str = <span class="hljs-string">&#x27;,&#x27;</span>.join(arg_lst)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-variable language_">self</span>.fmt.<span class="hljs-built_in">format</span>(**<span class="hljs-built_in">locals</span>()))<br>            <span class="hljs-keyword">return</span> result<br>        <span class="hljs-keyword">return</span> clocked<br><br><span class="hljs-meta">@Clock(<span class="hljs-params">fmt=<span class="hljs-string">&#x27;&#123;name&#125;(&#123;arg_str&#125;):\t &#123;elapsed: 0.7f&#125;s&#x27;</span></span>)  </span><span class="hljs-comment"># 使用类装饰器时用类名</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> n * factorial(n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-6-类型提示"><a href="#2-6-类型提示" class="headerlink" title="2.6 类型提示"></a>2.6 类型提示</h3><ol><li><p>类型提示: 为变量,函数参数和返回值添加预期类型的注解系统.不会在运行时强制类型检查,而是为开发工具提供信息</p><ul><li><strong>可选</strong>: 类型检查工具不对没有类型提示的代码发出警告.无法确认时假定为Any类型(与其他所有类型兼容)</li><li><strong>不在运行时捕获类型错误</strong>: 类型提示相关问题由静态类型检查工具, lint 程序, IDE 捕获</li><li><strong>不能改善性能</strong>: 理论上类型注解提供的数据可以优化生成的字节码,但 python 并未优化</li></ul></li><li><p>变量类型提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 基本类型</span><br>name: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;Alice&quot;</span><br>age: <span class="hljs-built_in">int</span> = <span class="hljs-number">25</span><br>price: <span class="hljs-built_in">float</span> = <span class="hljs-number">19.99</span><br>is_active: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">True</span><br><br><span class="hljs-comment"># Python 3.9+ 泛化类型提示</span><br>numbers: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>person: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>] = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Bob&quot;</span>&#125;<br><br><span class="hljs-comment"># python 3.10+ 联合类型</span><br>user_id: <span class="hljs-built_in">int</span> | <span class="hljs-built_in">str</span> = <span class="hljs-number">123</span><br>maybe_number: <span class="hljs-built_in">float</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure></li><li><p>函数类型提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_data</span>(<span class="hljs-params">data: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>], threshold: <span class="hljs-built_in">int</span> = <span class="hljs-number">10</span></span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]:<br>    <span class="hljs-keyword">return</span> [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data <span class="hljs-keyword">if</span> x &gt; threshold]<br><br>filtered_data: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>] = process_data([<span class="hljs-number">5</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">20</span>])<br><br><span class="hljs-comment"># python 3.10+ 联合类型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_input</span>(<span class="hljs-params">value: <span class="hljs-built_in">int</span> | <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-built_in">int</span> | <span class="hljs-built_in">str</span>:<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure></li><li><p>类型别名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypeAlias<br><br><span class="hljs-comment"># 明确的类型别名声明</span><br>UserId: TypeAlias = <span class="hljs-built_in">int</span> | <span class="hljs-built_in">str</span><br>UserProfile: TypeAlias = <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span> | <span class="hljs-built_in">int</span> | <span class="hljs-built_in">bool</span>]<br>Coordinates: TypeAlias = <span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>]<br><br><span class="hljs-comment"># 使用类型别名</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user_profile</span>(<span class="hljs-params">user_id: UserId</span>) -&gt; UserProfile:<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&quot;active&quot;</span>: <span class="hljs-literal">True</span>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_distance</span>(<span class="hljs-params">point1: Coordinates, point2: Coordinates</span>) -&gt; <span class="hljs-built_in">float</span>:<br>    x1, y1 = point1<br>    x2, y2 = point2<br>    <span class="hljs-keyword">return</span> ((x2 - x1) ** <span class="hljs-number">2</span> + (y2 - y1) ** <span class="hljs-number">2</span>) ** <span class="hljs-number">0.5</span><br></code></pre></td></tr></table></figure></li><li><p>类型检查工具 Mypy</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install mypy # 安装 mypy<br>mypy example.py  # 检查指定文件<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">渐进式采用</span><br>mypy --ignore-missing-imports .  # 开始阶段: 宽松检查<br>mypy --disallow-untyped-defs .   # 中期阶段: 启用更多检查<br>mypy --strict .                  # 成熟阶段: 严格模式<br></code></pre></td></tr></table></figure></li><li><p>在代码中编写注释信息: <code># type: ignore[code]</code>句法,告诉类型检查工具忽略特定行,函数,文件的类型错误</p></li></ol><h3 id="2-7-模块"><a href="#2-7-模块" class="headerlink" title="2.7 模块"></a>2.7 模块</h3><ol><li><p>模块: 一个 <code>.py</code> 文件就是一个模块.模块可以包含函数, 类, 变量和可执行代码</p></li><li><p>导入模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> moudle1[, moudle2, ..., moudleN] <span class="hljs-comment"># 需使用 moudle1.func() 方式调用函数</span><br><span class="hljs-keyword">from</span> moudle_name <span class="hljs-keyword">import</span> name1[, name2, ..., nameN] <span class="hljs-comment"># 可以直接使用 name1.简化使用</span><br>[<span class="hljs-keyword">from</span> moudle_name] <span class="hljs-keyword">import</span> object_name [<span class="hljs-keyword">as</span> alias]  <span class="hljs-comment"># 导入模块完整语法.导入并指定别名</span><br></code></pre></td></tr></table></figure></li><li><p>保护执行代码</p><ul><li><p>每个模块都有 <code>__name__</code> 属性.<strong>当 <code>__name__ == __main__&#39;</code> 时.表明该模块自身在运行.否则是被导入</strong></p></li><li><p>如需要模块的某块代码仅在其自身运行时执行,可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>包: 将模块以文件夹的形式组织到一起(包下面可以有子包)</strong></p><ul><li>注意当目录包含一个名为 <code>__init__.py</code> 的文件才会被认为是一个包</li></ul></li><li><p><code>__all__</code>属性: 这是一个列表,以字符串的形式存放</p><ul><li>该属性作用于 <code>from xx import *</code> 语句.对可以访问的内容进行了限制.只会包含列表内的功能</li><li>在模块中,该属性直接存在于该文件中; 在包中,该属性存放在必需的文件 <code>__init__.py</code> 中</li></ul></li></ol><h2 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3 面向对象"></a>3 面向对象</h2><h3 id="3-1-面向对象"><a href="#3-1-面向对象" class="headerlink" title="3.1 面向对象"></a>3.1 面向对象</h3><ol><li><p>封装</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-comment"># 属性 (通过特殊的 __init__ 方法初始化.这是构造函数)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):  <span class="hljs-comment"># self 代表类的实例本身.类似 c++ 的 this 指针</span><br>        <span class="hljs-variable language_">self</span>.name = name       <span class="hljs-comment"># public 属性(设计思想: 约定优先于配置)</span><br>        <span class="hljs-variable language_">self</span>._mood = <span class="hljs-string">&quot;happy&quot;</span>   <span class="hljs-comment"># protected 属性(只是约定,并不强制)</span><br>        <span class="hljs-variable language_">self</span>.__secret = <span class="hljs-number">18</span>     <span class="hljs-comment"># private 属性(并非真正的私有,而是被混淆为 _Dog__secret)</span><br><br>    <span class="hljs-comment"># 方法 (Method).类的声明与实现位于同一文件.无需分离</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> says: unknown sound&quot;</span><br><br>animal = Animal(<span class="hljs-string">&quot;Buddy&quot;</span>) <span class="hljs-comment"># 创建对象.无需使用 new</span><br><span class="hljs-built_in">print</span>(animal.name)       <span class="hljs-comment"># 访问公有属性</span><br><span class="hljs-built_in">print</span>(animal.speak())    <span class="hljs-comment"># 调用方法</span><br></code></pre></td></tr></table></figure></li><li><p>继承(python 允许多继承)</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-comment"># 定义抽象基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>(<span class="hljs-title class_ inherited__">ABC</span>):   <span class="hljs-comment"># 继承自 ABC.相当于 C++ 的 public 继承</span><br><span class="hljs-meta">    @abstractmethod </span><span class="hljs-comment"># 装饰器.声明为抽象方法,强制子类必须实现此方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-meta">    @staticmethod   </span><span class="hljs-comment"># 标记为静态方法.只是写在类中的普通方法.不需要 self 或 cls</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">validate_positive</span>(<span class="hljs-params">value, name=<span class="hljs-string">&quot;value&quot;</span></span>):<br>        <span class="hljs-keyword">if</span> value &lt;= <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span> must be positive&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-comment"># 具体子类必须实现所有抽象方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-title class_ inherited__">Shape</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, radius</span>):<br>        Shape.validate_positive(radius, <span class="hljs-string">&quot;radius&quot;</span>)<br>        <span class="hljs-variable language_">self</span>._radius = radius<br><br><span class="hljs-meta">    @classmethod    </span><span class="hljs-comment"># 标记为类方法.此时第一个参数 cls 是类本身(Circle).而非类实例 self</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">from_diameter</span>(<span class="hljs-params">cls, diameter</span>):<br>        cls.validate_positive(diameter, <span class="hljs-string">&quot;diameter&quot;</span>)<br>        <span class="hljs-keyword">return</span> cls(diameter / <span class="hljs-number">2</span>)       <span class="hljs-comment"># 实现通过 diameter 创建实例,如 c = Circle.from_diameter(100)</span><br><br><span class="hljs-meta">    @property       </span><span class="hljs-comment"># 标记为 setter 方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">radius</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._radius<br><br><span class="hljs-meta">    @radius.setter  </span><span class="hljs-comment"># 标记为 getter 方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">radius</span>(<span class="hljs-params">self, value</span>):<br>        Shape.validate_positive(value, <span class="hljs-string">&#x27;radius&#x27;</span>)<br>        <span class="hljs-variable language_">self</span>._radius = value<br><br>    <span class="hljs-comment"># 方法重写(Override).python 所有的函数都是虚函数.直接重新定义即可</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3.14159</span> * <span class="hljs-variable language_">self</span>._radius ** <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p>多态: python 不关心对象的实际类型,只关心是否需要的方法或属性</p></li></ol><h3 id="3-2-魔法方法"><a href="#3-2-魔法方法" class="headerlink" title="3.2 魔法方法"></a>3.2 魔法方法</h3><ol><li><p>魔法方法(magic method)</p><ul><li>魔法方法命名形式为 <code>__*__</code>(使用前后双下划线, dunder)</li><li>魔法方法供 python 解释器调用,而非自行调用</li></ul></li><li><p>魔法方法名称(应该有前后双下划线,这里省略了)</p><table><thead><tr><th>分类</th><th>方法名称</th></tr></thead><tbody><tr><td>字符串(字节)表示形式</td><td><strong>repr</strong>, <strong>str</strong>, format, bytes, fspath</td></tr><tr><td>转换为数值</td><td>bool, complex, int, float, hash, index</td></tr><tr><td>模拟容器</td><td><strong>len</strong>, <strong>getitem</strong>, setitem, delitem, contains</td></tr><tr><td>迭代</td><td><strong>iter</strong>, aiter, <strong>next</strong>, anext, reversed</td></tr><tr><td>可调用对象或执行协程</td><td>call, await</td></tr><tr><td>上下文管理</td><td>enter, exit, aexit, aenter</td></tr><tr><td>构造和析构</td><td>new, init, del</td></tr><tr><td>属性管理</td><td>getattr, getattribute, setattr, delattr, dir</td></tr><tr><td>属性描述符</td><td>get, set, delete, set_name</td></tr><tr><td>抽象基类</td><td>instancecheck, subclasscheck</td></tr><tr><td>类元编程</td><td>prepare, init_subclass, class_getitem, mro_entries</td></tr></tbody></table></li><li><p>运算符及其背后的特殊方法</p><table><thead><tr><th>一元运算符</th><th>正向方法</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td><code>__pos__</code></td><td>取正算术运算</td></tr><tr><td>-</td><td><code>__neg__</code></td><td>取反算术运算.x &#x3D;&#x3D; +x</td></tr><tr><td>~</td><td><code>__invert__</code></td><td>按位取反整数.~x &#x3D;&#x3D; -(x+1)</td></tr><tr><td>abs()</td><td><code>__abs__</code></td><td>取绝对值</td></tr></tbody></table><table><thead><tr><th>中缀运算符</th><th>正向方法</th><th>反向方法</th><th>就地方法</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td><code>__add__</code></td><td><code>__radd__</code></td><td><code>__iadd__</code></td><td>加法或拼接</td></tr><tr><td>-</td><td><code>__sub__</code></td><td><code>__rsub__</code></td><td><code>__isub__</code></td><td>减法</td></tr><tr><td>*</td><td><code>__mul__</code></td><td><code>__rmul__</code></td><td><code>__imul__</code></td><td>乘法或重复</td></tr><tr><td>&#x2F;</td><td><code>__truediv__</code></td><td><code>__rtruediv__</code></td><td><code>__itruediv__</code></td><td>除法</td></tr><tr><td>&#x2F;&#x2F;</td><td><code>__floordiv__</code></td><td><code>__rfloordiv__</code></td><td><code>__ifloordiv__</code></td><td>整除</td></tr><tr><td>%</td><td><code>__mod__</code></td><td><code>__rmod__</code></td><td><code>__imod__</code></td><td>求模</td></tr><tr><td>divmod()</td><td><code>__divmod__</code></td><td><code>__rdivmod__</code></td><td><code>__idivmod__</code></td><td>带余除法</td></tr><tr><td>**, pow()</td><td><code>__pow__</code></td><td><code>__rpow__</code></td><td><code>__ipow__</code></td><td>幂</td></tr><tr><td>@</td><td><code>__matmul__</code></td><td><code>__rmatmul__</code></td><td><code>__imatmul__</code></td><td>矩阵乘法</td></tr><tr><td>&amp;</td><td><code>__and__</code></td><td><code>__rand__</code></td><td><code>__iand__</code></td><td>位与</td></tr><tr><td>|</td><td><code>__or__</code></td><td><code>__ror__</code></td><td><code>__ior__</code></td><td>位或</td></tr><tr><td>^</td><td><code>__xor__</code></td><td><code>__rxor__</code></td><td><code>__ixor__</code></td><td>位异或</td></tr><tr><td>&lt;&lt;</td><td><code>__lshift__</code></td><td><code>__rlshift__</code></td><td><code>__ilshift__</code></td><td>按位左移</td></tr><tr><td>&gt;&gt;</td><td><code>__rshift__</code></td><td><code>__rrshift__</code></td><td><code>__irshift__</code></td><td>按位右移</td></tr></tbody></table><table><thead><tr><th>分组</th><th>比较运算符</th><th>正向方法调用</th><th>反向方法调用</th><th>后备机制</th></tr></thead><tbody><tr><td>相等性</td><td>a &#x3D;&#x3D; b</td><td><code>a.__eq__(b)</code></td><td><code>b.__eq__(a)</code></td><td>返回 id(a) &#x3D;&#x3D; id(b)</td></tr><tr><td></td><td>a !&#x3D; b</td><td><code>a.__ne__(b)</code></td><td><code>b.__ne__(a)</code></td><td>返回 not(a &#x3D;&#x3D; b)</td></tr><tr><td>排序</td><td>a &gt; b</td><td><code>a.__gt__(b)</code></td><td><code>b.__lt__(a)</code></td><td>抛出 TypeError</td></tr><tr><td></td><td>a &lt; b</td><td><code>a.__lt__(b)</code></td><td><code>b.__gt__(a)</code></td><td>抛出 TypeError</td></tr><tr><td></td><td>a &gt;&#x3D; b</td><td><code>a.__ge__(b)</code></td><td><code>b.__le__(a)</code></td><td>抛出 TypeError</td></tr><tr><td></td><td>a &lt;&#x3D; b</td><td><code>a.__le__(b)</code></td><td><code>b.__ge__(a)</code></td><td>抛出 TypeError</td></tr></tbody></table></li></ol><h3 id="3-3-Pythonic"><a href="#3-3-Pythonic" class="headerlink" title="3.3 Pythonic"></a>3.3 Pythonic</h3><ol><li><p>python 风格的纸牌</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br><br><span class="hljs-comment"># Card 是一个具名元组(元组的子类).拥有2个属性: rank, suit</span><br>Card = collections.namedtuple(<span class="hljs-string">&#x27;Card&#x27;</span>, [<span class="hljs-string">&#x27;rank&#x27;</span>, <span class="hljs-string">&#x27;suit&#x27;</span>])<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FrenchDeck</span>:<br>    ranks = [<span class="hljs-built_in">str</span>(n) <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">11</span>)] + <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;JQKA&#x27;</span>)  <span class="hljs-comment"># 属性 ranks: [2 ~ 10, J, Q, K, A]</span><br>    suits = <span class="hljs-string">&#x27;spades diamonds clubs hearts&#x27;</span>.split()         <span class="hljs-comment"># 属性 suits: [spades, diamonds, clubs, hearts]</span><br><br>    <span class="hljs-comment"># 构造函数.获得私有属性 _cards: 13 * 4 的 Card 对象组成的列表</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>._cards = [Card(rank, suit) <span class="hljs-keyword">for</span> suit <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.suits<br>                                        <span class="hljs-keyword">for</span> rank <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.ranks]<br><br>    <span class="hljs-comment"># 获取纸牌的数量(52).委托给内置函数 _cards 的 len() 函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._cards)<br><br>    <span class="hljs-comment"># 获取某张纸牌.委托给 _cards 的 [] 操作符.使类支持索引, 切片, 迭代功能</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, position</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._cards[position]<br></code></pre></td></tr></table></figure></li><li><p>使用方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choice<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    deck = FrenchDeck()  <span class="hljs-comment"># 构建 FrenchDeck 的实例. 解释器会调用 __init__ 方法</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;deck 的总数量为: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(deck)&#125;</span>&quot;</span>)  <span class="hljs-comment"># len()    自动调用 __len__ 方法</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;随机抽的牌为: <span class="hljs-subst">&#123;choice(deck)&#125;</span>&quot;</span>)  <span class="hljs-comment"># choice() 需要实现 __getitem__ 方法</span><br></code></pre></td></tr></table></figure></li><li><p>python 风格</p><ul><li>获取容器大小是内置函数 <code>len(collection)</code>, 而非 <code>collection.len()</code><ul><li><code>len</code> 作为内置函数可以在任何地方调用,而无需依赖特定的对象类型</li><li>性能: 内置函数的调用开销较低.如 CPython 内置长度会直接读取结构体中的字段</li></ul></li><li>python 解释器会调用特殊方法来执行基本对象操作.使操作方式获得统一</li></ul></li></ol><h3 id="3-4-异常处理"><a href="#3-4-异常处理" class="headerlink" title="3.4 异常处理"></a>3.4 异常处理</h3><ol><li><p><code>try - except - else - finally</code></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">file = <span class="hljs-literal">None</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Opening file...&quot;</span>)<br>    file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;somefile.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-comment"># 可能抛出 FileNotFoundError</span><br>    data = file.read()               <span class="hljs-comment"># 可能抛出 IOError</span><br>    <span class="hljs-comment"># ... 其他可能抛出异常的操作</span><br><br><span class="hljs-keyword">except</span> FileNotFoundError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;File not found: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># else 子句: 当且仅当 try 块中没有发生任何异常时执行</span><br>    <span class="hljs-comment"># 这是放置 &quot;成功逻辑&quot; 的理想位置.与异常处理逻辑分离</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;File read successfully!&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Read <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(data)&#125;</span> characters.&quot;</span>)<br><br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-comment"># finally 子句: 无论是否发生异常都会执行</span><br>    <span class="hljs-comment"># 这是进行资源清理(如关闭文件,网络连接)的绝对保障</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Finally: Cleaning up resources.&quot;</span>)<br>    <span class="hljs-keyword">if</span> file <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> file.closed:<br>        file.close()<br>    <span class="hljs-comment"># 这里的代码永远都会执行</span><br></code></pre></td></tr></table></figure></li><li><p><code>raise</code>: 抛出一个指定的异常.必须是一个异常的实例或者是异常的类(Exception 的子类)</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">raise</span> [Exception [, args [, traceback]]]<br><span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;x 不能为负&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>异常传递: 如果一个异常发生,但没有捕获异常,则传递给调用者处理.若都没处理,最终由系统处理</p></li><li><p><strong>取得原谅比许可更简单(EAFP: easier to ask for forgiveness than permission)</strong></p><ul><li>即直奔主流程,而将意外情况放在异常处理中</li><li>而不是 LBYL(look before you leap): 先进行数据检查,然后进行操作</li></ul></li><li><p><code>with</code>: 用于异常处理,封装了 <code>try - except - finally</code> 编码范式,提高易用性</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用 try</span><br>file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./hello.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br><span class="hljs-keyword">try</span>:<br>    file.write(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><span class="hljs-keyword">finally</span>:<br>    file.close()<br><br><span class="hljs-comment"># 使用 with</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./hello.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(<span class="hljs-string">&#x27;hello,world!&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>自定义异常</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCustomError</span>(<span class="hljs-title class_ inherited__">Exception</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;A custom exception for my application.&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 通常非常简单, pass 即可.因为继承本身就提供了类型区分</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure></li><li><p>断言: 健全性检查,用于确保代码没有做明显错误的事情</p><ul><li><p>若 <code>assert</code> 语句检查失败,则抛出 <code>AssertionError</code> 异常</p></li><li><p>断言成功时,无作用.当断言失败时,说明程序出现 bug,应立即停止程序(快速失败)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">assert</span> condition, <span class="hljs-string">&#x27;错误信息&#x27;</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="3-5-文件"><a href="#3-5-文件" class="headerlink" title="3.5 文件"></a>3.5 文件</h3><ol><li><p>python 风格采用上下文管理器(context manager)和 <code>with</code> 语句进行资源管理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 写入文件 - 最 Pythonic 的方式</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file: <span class="hljs-comment"># &#x27;w&#x27; 表示写入模式</span><br>    file.write(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>)      <span class="hljs-comment"># 写入内容</span><br><span class="hljs-comment"># 文件在这里会自动关闭.无需显式调用 file.close()</span><br><br><span class="hljs-comment"># 读取文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file: <span class="hljs-comment"># &#x27;r&#x27; 表示读取模式</span><br>    content = file.read()              <span class="hljs-comment"># 一次性读取所有内容</span><br>    <span class="hljs-built_in">print</span>(content)<br><br><span class="hljs-comment"># 逐行读取</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file: <span class="hljs-comment"># 文件对象是可迭代的</span><br>        <span class="hljs-built_in">print</span>(line, end=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>二进制文件读写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取二进制文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;image.jpg&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> file: <span class="hljs-comment"># 注意 &#x27;b&#x27; 模式</span><br>    chunk = file.read(<span class="hljs-number">1024</span>)           <span class="hljs-comment"># 每次读取 1024 byte</span><br>    <span class="hljs-keyword">while</span> chunk:<br>        <span class="hljs-comment"># 处理二进制数据</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Read <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(chunk)&#125;</span> bytes&quot;</span>)<br>        chunk = file.read(<span class="hljs-number">1024</span>)<br><br><span class="hljs-comment"># 写入二进制文件</span><br>data = <span class="hljs-string">b&#x27;\x00\x01\x02\x03&#x27;</span> <span class="hljs-comment"># bytes 对象</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;binary.bin&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(data)<br></code></pre></td></tr></table></figure></li><li><p><code>mode</code> 参数可以进行组合.如 <code>wb+</code>: 用二进制格式打开文件进行读写.一般用于非文本文件</p><table><thead><tr><th align="left">模式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">t &#x2F; b</td><td align="left">文本格式(默认) &#x2F; 二进制格式</td></tr><tr><td align="left">r &#x2F; w</td><td align="left">只读模式(默认) &#x2F; 只写模式(若文件已存在,则写入后会从头覆盖,若不存在则创建文件)</td></tr><tr><td align="left">a</td><td align="left">追加模式.若文件已存在,则写入内容追加到文件末尾,若不存在则创建文件</td></tr><tr><td align="left">x</td><td align="left">独占创建.若该文件已存在则会报错</td></tr><tr><td align="left">+</td><td align="left">打开一个文件进行更新(可读可写)</td></tr></tbody></table></li></ol><h2 id="4-标准库"><a href="#4-标准库" class="headerlink" title="4 标准库"></a>4 标准库</h2><h3 id="4-1-sys"><a href="#4-1-sys" class="headerlink" title="4.1 sys"></a>4.1 sys</h3><ol><li><p>sys 模块: 提供 python 解释器本身以及其环境交互的变量和函数</p></li><li><p>获取命令行参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># script.py</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;脚本名:&quot;</span>, sys.argv[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;参数个数:&quot;</span>, <span class="hljs-built_in">len</span>(sys.argv) - <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &gt; <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;参数列表:&quot;</span>, sys.argv[<span class="hljs-number">1</span>:])<br>    <span class="hljs-keyword">for</span> i, arg <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(sys.argv[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;参数 <span class="hljs-subst">&#123;i&#125;</span>: <span class="hljs-subst">&#123;arg&#125;</span>&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请提供命令行参数。&quot;</span>)<br><br><span class="hljs-comment"># 运行方式: python script.py arg1 arg2 arg3</span><br><span class="hljs-comment"># 输出:</span><br><span class="hljs-comment"># 脚本名: script.py</span><br><span class="hljs-comment"># 参数个数: 3</span><br><span class="hljs-comment"># 参数列表: [&#x27;arg1&#x27;, &#x27;arg2&#x27;, &#x27;arg3&#x27;]</span><br><span class="hljs-comment"># 参数 1: arg1</span><br><span class="hljs-comment"># 参数 2: arg2</span><br><span class="hljs-comment"># 参数 3: arg3</span><br></code></pre></td></tr></table></figure></li><li><p>退出程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">sys.exit(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 非零状态码表示错误退出</span><br>sys.exit(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 零状态码表示成功退出</span><br></code></pre></td></tr></table></figure></li><li><p>解释器版本信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;版本字符串:&quot;</span>, sys.version)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;版本元组:&quot;</span>, sys.version_info)<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-2-pathlib"><a href="#4-2-pathlib" class="headerlink" title="4.2 pathlib"></a>4.2 pathlib</h3><ol><li><p>os 模块: 现代 python 中处理文件路径的推荐方式</p></li><li><p>path 对象创建(将文件系统路径视为具有方法和属性的对象.而非普通的字符串)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br>data_file = Path(<span class="hljs-string">&#x27;data&#x27;</span>) / <span class="hljs-string">&#x27;file.csv&#x27;</span>     <span class="hljs-comment"># 重载 \ 运算符</span><br>config_file = Path(<span class="hljs-string">&#x27;config/settings.ini&#x27;</span>) <span class="hljs-comment"># 字符串构造</span><br></code></pre></td></tr></table></figure></li><li><p>路径信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">p = Path(<span class="hljs-string">&#x27;/home/user/projects/python_script.py&#x27;</span>)<br><br>p.name       <span class="hljs-comment"># 文件名(包含后缀): &#x27;python_script.py&#x27;</span><br>p.stem       <span class="hljs-comment"># 文件名(不包含后缀): &#x27;python_script&#x27;</span><br>p.suffix     <span class="hljs-comment"># 文件后缀: &#x27;.py&#x27;</span><br>p.suffixes   <span class="hljs-comment"># 所有后缀列表: [&#x27;.py&#x27;] (对于 &#x27;.tar.gz&#x27; 则返回 [&#x27;.tar&#x27;, &#x27;.gz&#x27;])</span><br>p.parent     <span class="hljs-comment"># 父目录: Path(&#x27;/home/user/projects&#x27;)</span><br>p.anchor     <span class="hljs-comment"># 根目录(盘符或 &#x27;/&#x27;): &#x27;/&#x27; 或 &#x27;C:\\&#x27;</span><br><br>str_path = <span class="hljs-built_in">str</span>(p)      <span class="hljs-comment"># 将路径转化为字符串(有时需要传给只接受字符串的函数)</span><br>abs_path = p.resolve() <span class="hljs-comment"># 获取绝对路径(如果路径是相对的,会基于当前工作目录进行解析)</span><br></code></pre></td></tr></table></figure></li><li><p>路径状态(真正访问磁盘数据)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">p = Path(<span class="hljs-string">&#x27;my_file.txt&#x27;</span>)<br><br>p.exists()      <span class="hljs-comment"># 路径是否存在(文件或目录)</span><br>p.is_file()     <span class="hljs-comment"># 是否是文件</span><br>p.is_dir()      <span class="hljs-comment"># 是否是目录</span><br>p.is_absolute() <span class="hljs-comment"># 是否是绝对路径</span><br></code></pre></td></tr></table></figure></li><li><p>遍历目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">p = Path(<span class="hljs-string">&#x27;/home/user/projects&#x27;</span>)<br><br><span class="hljs-comment"># 遍历当前目录下的所有子项(文件和目录)</span><br><span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> p.iterdir():<br>    <span class="hljs-built_in">print</span>(child)<br><br><span class="hljs-comment"># 递归遍历当前目录及其所有子目录下的文件(通配符搜索)</span><br><span class="hljs-comment"># 查找所有 .py 文件</span><br><span class="hljs-keyword">for</span> py_file <span class="hljs-keyword">in</span> p.rglob(<span class="hljs-string">&#x27;*.py&#x27;</span>):<br>    <span class="hljs-built_in">print</span>(py_file)<br><br><span class="hljs-comment"># 非递归的通配符搜索(类似 iterdir() 但可以过滤)</span><br><span class="hljs-keyword">for</span> py_file <span class="hljs-keyword">in</span> p.glob(<span class="hljs-string">&#x27;*.py&#x27;</span>):<br>    <span class="hljs-built_in">print</span>(py_file)<br></code></pre></td></tr></table></figure></li><li><p>文件系统操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">p.mkdir()  <span class="hljs-comment"># 创建一级目录</span><br>p.unlink() <span class="hljs-comment"># 删除文件</span><br>p.rmdir()  <span class="hljs-comment"># 删除空目录</span><br><br><span class="hljs-comment"># 重命名或移动文件</span><br>source = Path(<span class="hljs-string">&#x27;old_name.txt&#x27;</span>)<br>destination = Path(<span class="hljs-string">&#x27;new_name.txt&#x27;</span>)<br>source.rename(destination)<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-3-json"><a href="#4-3-json" class="headerlink" title="4.3 json"></a>4.3 json</h3><ol><li><p><code>json</code> 模块: 处理 json 数据</p></li><li><p>json 字符串与 python 对象的转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><br>data = &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">30</span>,<br>    <span class="hljs-string">&quot;is_student&quot;</span>: <span class="hljs-literal">False</span>,<br>    <span class="hljs-string">&quot;hobbies&quot;</span>: [<span class="hljs-string">&quot;读书&quot;</span>, <span class="hljs-string">&quot;编程&quot;</span>, <span class="hljs-string">&quot;音乐&quot;</span>],<br>    <span class="hljs-string">&quot;address&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;city&quot;</span>: <span class="hljs-string">&quot;北京&quot;</span>,<br>        <span class="hljs-string">&quot;country&quot;</span>: <span class="hljs-string">&quot;中国&quot;</span><br>    &#125;,<br>    <span class="hljs-string">&quot;score&quot;</span>: <span class="hljs-literal">None</span><br>&#125;<br><br><span class="hljs-comment"># dict --&gt; json str</span><br>json_string = json.dumps(data, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># json str --&gt; dict</span><br>python_obj  = json.loads(json_string)<br><br><span class="hljs-comment"># dict --&gt; user.json file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;users.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    json.dump(data, f, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># user.json file --&gt; dict</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;users.json&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    data = json.load(f)<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-4-re"><a href="#4-4-re" class="headerlink" title="4.4 re"></a>4.4 re</h3><ol><li><p><code>re</code> 模块: 提供正则表达式处理函数</p></li><li><p>正则表达式匹配规则</p><ul><li>字面字符: 普通字符.如数字, 字母, 空格</li><li>字符类: 使用 <code>[]</code> 包围的字符集合.匹配其中的任意一个</li><li>转义字符: 具有特殊含义的字符,匹配它们需要加上 <code>\</code>. 如 <code>. ^ $ * + ? &#123; &#125; [ ] \ | ( )</code></li><li>预定义字符<ul><li><code>.</code>: 任意单个字符</li><li><code>\d</code>: 数字; <code>\D</code>: 非数字</li><li><code>\w</code>: 单词字符(字母, 数字, 下划线); <code>\W</code>: 非单词字符</li></ul></li><li>量词: 重复匹配<ul><li><code>*</code>: 0次或多次; <code>+</code> 1次或多次; <code>?</code>: 0次或1次</li><li><code>&#123;n&#125;</code>: 恰好 n 次; <code>&#123;n,&#125;</code>: 至少 n 次; <code>&#123;n,m&#125;</code>: n 到 m 次</li></ul></li><li>位置锚点<ul><li><code>^</code>: 字符串开头; <code>$</code>: 字符串结尾</li><li><code>\b</code>: 单词边界; <code>\B</code>: 非单词边界</li></ul></li></ul></li><li><p>匹配字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>text = <span class="hljs-string">&quot;hello world hello python&quot;</span><br>result = re.<span class="hljs-keyword">match</span>(<span class="hljs-string">r&quot;hello&quot;</span>, text)    <span class="hljs-comment"># 从开头匹配</span><br>result = re.search(<span class="hljs-string">r&quot;hello&quot;</span>, text)   <span class="hljs-comment"># 搜索整个字符串的第一个匹配项</span><br>result = re.findall(<span class="hljs-string">r&quot;hello&quot;</span>, text)  <span class="hljs-comment"># 查找所有匹配项</span><br>result = re.finditer(<span class="hljs-string">r&quot;hello&quot;</span>, text) <span class="hljs-comment"># 查找所有匹配项.并返回迭代器</span><br><br>result = re.sub(<span class="hljs-string">r&quot;hello&quot;</span>, <span class="hljs-string">r&quot;hi&quot;</span>, text)         <span class="hljs-comment"># 替换匹配项</span><br>result, count = re.sub(<span class="hljs-string">r&quot;hello&quot;</span>, <span class="hljs-string">r&quot;hi&quot;</span>, text)  <span class="hljs-comment"># 替换匹配项.并返回次数</span><br>result = re.split(<span class="hljs-string">r&quot;hello&quot;</span>, text)              <span class="hljs-comment"># 分割字符串</span><br></code></pre></td></tr></table></figure></li><li><p>match 对象: 匹配成功后返回的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">result.group()  <span class="hljs-comment"># 获取匹配的组.可以指定索引(字符串或元组类型)</span><br>result.groups() <span class="hljs-comment"># 获取所有分组(元组类型)</span><br>result.span()   <span class="hljs-comment"># 获取匹配范围.左闭右开区间(元组类型)</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="4-5-logging"><a href="#4-5-logging" class="headerlink" title="4.5 logging"></a>4.5 logging</h3><ol><li><p><code>logging</code> 模块: 日志记录</p></li><li><p>日志级别</p><table><thead><tr><th align="left">级别</th><th align="left">函数</th><th align="left">使用场景</th></tr></thead><tbody><tr><td align="left">DEBUG</td><td align="left">10</td><td align="left">详细的调试信息.开发时使用</td></tr><tr><td align="left">INFO</td><td align="left">20</td><td align="left">确认程序按预期运行</td></tr><tr><td align="left">WARNING</td><td align="left">30</td><td align="left">表明一些意外情况.但程序还能运行</td></tr><tr><td align="left">ERROR</td><td align="left">40</td><td align="left">由于严重问题.某些功能无法正常运行</td></tr><tr><td align="left">CRITICAL</td><td align="left">50</td><td align="left">严重错误.程序本身可能无法继续运行</td></tr></tbody></table></li><li><p>实例: 调试 <code>factorial</code> 阶乘函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-comment"># 该语句需要位于程序上方,而无需关注其原理</span><br>logging.basicConfig(level=logging.DEBUG,<br>                    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span><br>)<br><span class="hljs-comment"># logging.disable(logging.CRITICAL)  # 该语句可禁用日志</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>):<br>    logging.debug(<span class="hljs-string">f&#x27;进入 factorial(<span class="hljs-subst">&#123;n&#125;</span>)&#x27;</span>)<br>    total = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        total *= i<br>        logging.debug(<span class="hljs-string">f&#x27;i = <span class="hljs-subst">&#123;i&#125;</span>, total = <span class="hljs-subst">&#123;total&#125;</span>&#x27;</span>)<br>    logging.debug(<span class="hljs-string">f&#x27;结束 factorial(<span class="hljs-subst">&#123;n&#125;</span>)&#x27;</span>)<br>    <span class="hljs-keyword">return</span> total<br><br><span class="hljs-built_in">print</span>(factorial(<span class="hljs-number">5</span>))<br><span class="hljs-comment"># 终端输出:</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">2024-06-20 00:12:32,424 - DEBUG - 进入 factorial(5)</span><br><span class="hljs-string">2024-06-20 00:12:32,439 - DEBUG - i = 1, total = 1</span><br><span class="hljs-string">2024-06-20 00:12:32,449 - DEBUG - i = 2, total = 2</span><br><span class="hljs-string">2024-06-20 00:12:32,457 - DEBUG - i = 3, total = 6</span><br><span class="hljs-string">2024-06-20 00:12:32,469 - DEBUG - i = 4, total = 24</span><br><span class="hljs-string">2024-06-20 00:12:32,479 - DEBUG - i = 5, total = 120</span><br><span class="hljs-string">2024-06-20 00:12:32,488 - DEBUG - 结束 factorial(5)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>记录到文件: 修改 <code>basicConfig</code> 的关键字参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">logging.basicConfig(level=logging.DEBUG,<br>                    filename=<span class="hljs-string">r&#x27;D:\test.log&#x27;</span>,<br>                    filemode=<span class="hljs-string">&#x27;a&#x27;</span>,<br>                    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>,<br>                    encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span><br>)<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-三方库"><a href="#5-三方库" class="headerlink" title="5 三方库"></a>5 三方库</h2><h3 id="5-1-pip"><a href="#5-1-pip" class="headerlink" title="5.1 pip"></a>5.1 pip</h3><ol><li><p><strong><a href="https://pypi.org/project/pip/">pip</a>: python 的包管理工具.提供对 python 包的查找, 下载, 安装, 卸载功能</strong></p></li><li><p>配置 <code>pip</code> 从清华源下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure></li><li><p>更新 <code>pip</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pip<br></code></pre></td></tr></table></figure></li><li><p>安装 &#x2F; 升级 &#x2F; 卸载包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install SomePackage            # 最新版本<br>pip install SomePackage==1.0.4     # 指定版本<br>pip install &#x27;SomePackage&gt;=1.0.4&#x27;   # 最小版本<br>pip install --upgrade SomePackage  # 升级包<br>pip uninstall SomePackage          # 卸载包<br></code></pre></td></tr></table></figure></li><li><p>升级 pip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install -U pip               # Linux 环境<br>sudo easy_install --upgrade pip  # 若上一条命令出错可使用<br>python -m pip install -U pip     # Windows 环境<br></code></pre></td></tr></table></figure></li><li><p>其他功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip list                 # 显示已安装的包<br>pip list -o              # 查看可升级的包<br>pip show                 # 显示安装包信息<br>pip show -f SomePackage  # 查找指定包的信息<br>pip search SomePackage   # 搜索包<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-2-virtualenv"><a href="#5-2-virtualenv" class="headerlink" title="5.2 virtualenv"></a>5.2 virtualenv</h3><ol><li><p>Windows 环境(<code>pip</code> 会随着 python 一起安装)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip --version                        # 查看 pip 版本<br>python -m pip install --upgrade pip  # 更新 pip<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一个 .venv 的虚拟环境文件夹.并使用 --upgrade-deps 自动升级 pip 和 setuptools</span><br>python -m venv .venv --upgrade-deps<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">激活指定的虚拟环境, 此时终端(cmd)提示符前会显示 (.venv)</span><br>.\.venv\Scripts\activate<br><span class="hljs-meta prompt_"># </span><span class="language-bash">若出现 Execution Policy 报错,使用 管理员身份打开 PowerShell,运行下面命令</span><br>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force<br></code></pre></td></tr></table></figure></li><li><p>linux 环境: 在 Ubuntu 20.04.6 LTS 中,默认安装 python2 (<code>python</code>) 和 python3 (<code>python3</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">python --version   # python 2.7.18<br>python3 --version  # python 3.8.10<br><br>sudo apt update<br>sudo apt install python3-pip  # 安装官方仓库的 pip<br>pip3 --version                # 验证安装<br><br>pip3 install virtualenv       # 安装 virtualenv<br>python3 -m virtualenv .venv   # 创建虚拟环境<br>source .venv/bin/activate     # 激活虚拟环境<br></code></pre></td></tr></table></figure></li><li><p>虚拟环境的使用与删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入虚拟环境后安装的第三方库不会影响到其他环境</span><br>pip install numpy<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">退出虚拟环境. 将会退出到默认全局 python 环境</span><br>deactivate<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除虚拟环境. 只需删除对应的目录文件即可</span><br>rm -rf .venv<br></code></pre></td></tr></table></figure></li><li><p>在 VS Code 中使用虚拟环境</p><ul><li>安装 <code>python</code> 拓展.在状态栏中直接选择 python 虚拟环境</li><li>或 <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>P</kbd> 搜索 <code>Python: Select Interpreter</code>. 选择虚拟环境</li><li>后续 <kbd>Ctrl</kbd><kbd>`</kbd> 打开的终端直接会进入虚拟环境</li></ul></li></ol><h3 id="5-3-pytest"><a href="#5-3-pytest" class="headerlink" title="5.3 pytest"></a>5.3 pytest</h3><ol><li><p><code>pytest</code>: python 测试框架.用于代码测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install pytest<br></code></pre></td></tr></table></figure></li><li><p>测试函数</p><ul><li><p><strong>文件名必须用 <code>test_</code> 开头或 <code>_test</code> 结尾.而测试函数只能用 <code>test_</code> 开头</strong></p></li><li><p>测试中 <code>pytest</code> 将找出这些文件,并运行其中需要进行测试的函数</p></li><li><p>考虑到测试函数会被 <code>pytest</code> 自动调用.其名称可以起得很长.便于阅读</p></li><li><p>作出断言(<code>assert</code>): 在测试函数中应成立的条件语句,一个函数可以有多个 <code>assert</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_add</span>(): <span class="hljs-comment"># 测试函数</span><br>    <span class="hljs-keyword">assert</span> add(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure></li><li><p>常用的 <code>assert</code> 形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">assert</span> xx：     <span class="hljs-comment"># 判断 xx 为真</span><br><span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> xx： <span class="hljs-comment"># 判断 xx 不为真</span><br><span class="hljs-keyword">assert</span> a <span class="hljs-keyword">in</span> b： <span class="hljs-comment"># 判断 b 包含 a</span><br><span class="hljs-keyword">assert</span> a == b： <span class="hljs-comment"># 判断 a 等于 b</span><br><span class="hljs-keyword">assert</span> a != b： <span class="hljs-comment"># 判断 a 不等于 b</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>在终端窗口执行 <code>pytest</code>.将自动完成测试,并在终端输出测试信息</p></li><li><p>为管理测试函数,还可以将其封装在类中.测试类方法时需实例化对象.过程与测试函数相似</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>Code</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LVGL</title>
    <link href="/2025/06/07/Embedded/LVGL/"/>
    <url>/2025/06/07/Embedded/LVGL/</url>
    
    <content type="html"><![CDATA[<h1 id="LVGL"><a href="#LVGL" class="headerlink" title="LVGL"></a>LVGL</h1><h2 id="0-开发环境"><a href="#0-开发环境" class="headerlink" title="0 开发环境"></a>0 开发环境</h2><h3 id="0-1-简介"><a href="#0-1-简介" class="headerlink" title="0.1 简介"></a>0.1 简介</h3><ol><li><strong><a href="https://lvgl.io/">LVGL(Light and Versatile Graphics Librar)</a>: 开源的嵌入式图形库.用于创建图形用户界面的嵌入式系统</strong><ul><li>轻量级: 设计用于资源受限的嵌入式系统,内存占用小</li><li>跨平台: 支持多种微控制器和显示器</li><li>丰富的组件: 按钮, 标签, 滑块, 图表, 列表等</li><li>硬件加速: 支持利用 GPU 加速图形渲染</li><li>开源免费: 遵循 MIT 许可证</li></ul></li><li>技术规格<ul><li>架构: 面向对象的 C 语言实现</li><li>内存需求<ul><li>最低配置: ~16KB RAM, ~64KB Flash</li><li>推荐配置: ~48KB RAM, ~180KB Flash</li></ul></li><li>支持的操作系统: 可裸机运行或与 FreeRTOS, Zephyr 等 RTOS 集成</li><li>显示支持: 单缓冲, 双缓冲, 直接模式.支持多显示器</li><li>输入设备: 触摸屏, 鼠标, 键盘, 编码器等</li></ul></li></ol><h3 id="0-2-模拟器"><a href="#0-2-模拟器" class="headerlink" title="0.2 模拟器"></a>0.2 模拟器</h3><ol><li><p><a href="https://www.yuque.com/icheima/vzsofu/fm096ylkxkt6dikd">使用模拟器依赖的源码</a>(统一使用 v8.3)</p><ul><li><a href="https://github.com/lvgl/lv_port_pc_eclipse/tree/release/v8.3">模拟器源码</a>(Eclipse with SDLdriver)</li><li><a href="https://github.com/lvgl/lvgl/tree/release/v8.3">LVGL 源码</a></li><li><a href="https://github.com/lvgl/lv_drivers/tree/release/v8.3">LVGL drivers 源码</a></li></ul></li><li><p>将模拟器源码的文件解压得到 <code>lv_port_pc_eclipse-release-v8.3</code> 目录</p><ul><li>将 LVGL 源码解压并复制到到 <code>lvgl</code> 目录(原目录为空)</li><li>将 LVGL drivers 源码解压并复制到到 <code>lv_drivers</code> 目录(原目录为空)</li></ul></li><li><p><a href="https://github.com/libsdl-org/SDL/releases">下载 SDL2 库</a></p><ul><li><p>将 <code>SDL2-devel-2.32.8-mingw.zip</code> 解压得到 <code>SDL2-2.32.8</code></p></li><li><p>添加环境变量(指向 SDL 安装目录的 <code>bin</code> 目录)</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">D</span>:\code\SDL2-<span class="hljs-number">2</span>.<span class="hljs-number">32</span>.<span class="hljs-number">8</span>\x86_64-w64-mingw32\bin<br></code></pre></td></tr></table></figure></li></ul></li><li><p><a href="https://cmake.org/download/">下载安装 CMake</a>(如 <code>cmake-4.0.2-windows-x86_64.msi</code>)</p></li><li><p>将 <code>main</code> 函数改名为 <code>SDL_main</code>(SDL2 要求 Windows 平台的主函数必须是 <code>SDL_main</code>)</p></li><li><p>将 <code>D:\code\SDL2-2.32.8\x86_64-w64-mingw32\bin\SDL2.dll</code> 动态链接文件复制到工程的 <code>bin</code> 目录下</p></li><li><p>修改 <code>CMakeLists.txt</code> 文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.20</span>)<br><br><span class="hljs-comment"># 项目基本配置</span><br><span class="hljs-keyword">project</span>(lvgl VERSION <span class="hljs-number">1.0</span> LANGUAGES C CXX)<br><br><span class="hljs-comment"># 设置C/C++标准</span><br><span class="hljs-keyword">set</span>(CMAKE_C_STANDARD <span class="hljs-number">11</span>)<br><span class="hljs-keyword">set</span>(CMAKE_C_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-comment"># 包含头文件路径</span><br><span class="hljs-keyword">include_directories</span>(<br>    <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span><br>    <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lvgl<br>    <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lv_drivers<br>    <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/source<br>)<br><br><span class="hljs-comment"># 收集源文件</span><br><span class="hljs-keyword">file</span>(GLOB_RECURSE LVGL_SOURCES <br>    <span class="hljs-string">&quot;lvgl/src/*.c&quot;</span><br>    <span class="hljs-string">&quot;lvgl/demos/*.c&quot;</span><br>)<br><span class="hljs-keyword">file</span>(GLOB_RECURSE DRIVER_SOURCES <br>    <span class="hljs-string">&quot;lv_drivers/*.c&quot;</span><br>)<br><span class="hljs-keyword">file</span>(GLOB_RECURSE APP_SOURCES <br>    <span class="hljs-string">&quot;main.c&quot;</span><br>    <span class="hljs-string">&quot;mouse_cursor_icon.c&quot;</span><br>)<br><br><span class="hljs-comment"># 合并所有源文件</span><br><span class="hljs-keyword">set</span>(SOURCES <br>    <span class="hljs-variable">$&#123;LVGL_SOURCES&#125;</span><br>    <span class="hljs-variable">$&#123;DRIVER_SOURCES&#125;</span><br>    <span class="hljs-variable">$&#123;APP_SOURCES&#125;</span><br>)<br><br><span class="hljs-comment"># 输出目录配置 - 区分 Debug, Release</span><br><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin/Debug)<br><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin/Release)<br><br><span class="hljs-comment"># 编译选项配置 - 区分构建类型</span><br><span class="hljs-keyword">if</span>(CMAKE_BUILD_TYPE <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;Debug&quot;</span>)<br>    <span class="hljs-keyword">add_compile_options</span>(-g -O0)<br><span class="hljs-keyword">else</span>()<br>    <span class="hljs-keyword">add_compile_options</span>(-O3)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># 查找 SDL2 并链接</span><br><span class="hljs-keyword">find_package</span>(SDL2 REQUIRED)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;SDL2_INCLUDE_DIRS&#125;</span>)<br><br><span class="hljs-comment"># 生成可执行文件</span><br><span class="hljs-keyword">add_executable</span>(main <span class="hljs-variable">$&#123;SOURCES&#125;</span>)<br><span class="hljs-keyword">add_compile_definitions</span>(LV_CONF_INCLUDE_SIMPLE)<br><br><span class="hljs-comment"># 显式链接 SDL2 库(MinGW 需要 -mconsole)</span><br><span class="hljs-keyword">if</span>(MINGW)<br>    <span class="hljs-keyword">target_link_options</span>(main PRIVATE -mconsole)  <span class="hljs-comment"># MinGW 强制启用控制台</span><br><span class="hljs-keyword">elseif</span>(MSVC)<br>    <span class="hljs-keyword">set_target_properties</span>(main PROPERTIES LINK_FLAGS <span class="hljs-string">&quot;/SUBSYSTEM:CONSOLE&quot;</span>)  <span class="hljs-comment"># MSVC 强制控制台</span><br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># 链接 SDL2 库</span><br><span class="hljs-keyword">target_link_libraries</span>(main PRIVATE <span class="hljs-variable">$&#123;SDL2_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="0-3-启动流程"><a href="#0-3-启动流程" class="headerlink" title="0.3 启动流程"></a>0.3 启动流程</h3><ol><li><p>运行 demo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">SDL_main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    (<span class="hljs-type">void</span>)argc; <span class="hljs-comment">/*Unused*/</span><br>    (<span class="hljs-type">void</span>)argv; <span class="hljs-comment">/*Unused*/</span><br><br>    <span class="hljs-comment">/*Initialize LVGL*/</span><br>    lv_init();<br><br>    <span class="hljs-comment">/*Initialize the HAL (display, input devices, tick) for LVGL*/</span><br>    hal_init();<br><br>    LV_LOG_USER(<span class="hljs-string">&quot;hello, lvgl&quot;</span>);<br>    lv_demo_widgets();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">/* Periodically call the lv_task handler.</span><br><span class="hljs-comment">         * It could be done in a timer interrupt or an OS task too.*/</span><br>        lv_timer_handler();<br>        usleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>SDL_main</code>: SDL2 的推荐入口函数,用于跨平台兼容性(Windows 需要此定义)</p></li><li><p><strong><code>lv_init()</code>: 初始化 LVGL 的核心系统(内存管理, 内部数据结构等)</strong></p><ul><li>必须第一个调用,之后才能设置硬件抽象层(HAL)或创建 UI</li></ul></li><li><p><code>hal_init()</code>: 配置 LVGL 与硬件的交互接口</p><ul><li>显示(Display): SDL2 创建的虚拟屏幕</li><li>输入设备(Input Device): 如鼠标, 键盘</li><li>心跳(Tick): 提供时间基准(如 <code>SDL_Delay</code>)</li></ul></li><li><p><code>LV_LOG_USER</code>: LVGL 的日志宏,输出到控制台(需在 <code>lv_conf.h</code> 中启用 <code>LV_USE_LOG</code>)</p></li><li><p><strong><code>lv_timer_handler()</code></strong></p><ul><li>处理定时器: 执行所有注册的 LVGL 定时器</li><li>屏幕刷新: 更新脏区域(dirty areas)并触发屏幕刷新</li><li>输入设备处理: 读取输入设备(如触摸屏, 键盘)事件</li></ul></li></ol><h3 id="0-4-配置选项"><a href="#0-4-配置选项" class="headerlink" title="0.4 配置选项"></a>0.4 配置选项</h3><ol><li><p><strong><code>lv_conf.h</code>: LVGL 的核心配置文件</strong></p><ul><li>用于自定义库的功能, 性能, 内存占用</li><li>允许开发者根据项目需求裁剪 LVGL 的功能, 从而优化资源使用</li></ul></li><li><p><code>lvgl/lv_conf_template.h</code>: LVGL 源码中提供了一个模板文件</p><ul><li><p>使用时需复制并重命名为 <code>lv_conf.h</code>,通常存放于与 <code>lvgl</code> 库同级的目录</p></li><li><p>启用方式: 在 <code>lv_conf.h</code> 开头取消注释以下宏(将 0 改为 1 即可)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0 <span class="hljs-comment">/*Set it to &quot;1&quot; to enable content*/</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>关键参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Color depth: 1 (1 byte per pixel), 8 (RGB332), 16 (RGB565), 32 (ARGB8888) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_COLOR_DEPTH 32</span><br><br><span class="hljs-comment">/* Default display refresh period. LVG will redraw changed areas with this period time */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_DISP_DEF_REFR_PERIOD 16  <span class="hljs-comment">/*[ms] 1000 / 16 = 62.5fps */</span></span><br><br><span class="hljs-comment">/*Input device read period in milliseconds*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_INDEV_DEF_READ_PERIOD 16  <span class="hljs-comment">/*[ms] 1000 / 16 = 62.5fps */</span></span><br><br><span class="hljs-comment">/* Size of the memory available for `lv_mem_alloc()` in bytes (&gt;= 2kB) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_MEM_SIZE (128 * 1024U)  <span class="hljs-comment">/* [bytes] */</span></span><br></code></pre></td></tr></table></figure><ul><li><strong><code>LV_COLOR_DEPTH</code> 需要与显示屏控制器支持的格式一致</strong></li><li><code>LV_INDEV_DEF_READ_PERIOD</code> 应 ≤ <code>LV_DISP_DEF_REFR_PERIOD</code>.确保输入事件能被及时处理</li><li><code>LV_MEM_SIZE</code> 不支持动态拓展内存池大小,必须在初始化时固定(因为是静态数组)</li></ul></li></ol><h3 id="0-5-日志模块"><a href="#0-5-日志模块" class="headerlink" title="0.5 日志模块"></a>0.5 日志模块</h3><ol><li><p>日志级别</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Enable the log module */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_USE_LOG 1                   <span class="hljs-comment">// 1: 启用, 0: 禁用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_LOG_LEVEL LV_LOG_LEVEL_WARN <span class="hljs-comment">// 包含 warn, error, user</span></span><br></code></pre></td></tr></table></figure></li><li><p>输出方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_LOG_PRINTF 1  <span class="hljs-comment">// 使用标准 printf 输出</span></span><br></code></pre></td></tr></table></figure></li><li><p>使用方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">LV_LOG_TRACE(<span class="hljs-string">&quot;Button %p clicked&quot;</span>, btn);    <span class="hljs-comment">// 跟踪详细流程</span><br>LV_LOG_INFO(<span class="hljs-string">&quot;Loading screen %d&quot;</span>, id);      <span class="hljs-comment">// 关键信息</span><br>LV_LOG_WARN(<span class="hljs-string">&quot;Low memory: %d bytes&quot;</span>, <span class="hljs-built_in">free</span>); <span class="hljs-comment">// 警告</span><br>LV_LOG_ERROR(<span class="hljs-string">&quot;Failed to alloc buffer!&quot;</span>);   <span class="hljs-comment">// 错误</span><br>LV_LOG_USER(<span class="hljs-string">&quot;Custom message&quot;</span>);             <span class="hljs-comment">// 用户自定义</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="0-6-文件系统"><a href="#0-6-文件系统" class="headerlink" title="0.6 文件系统"></a>0.6 文件系统</h3><ol><li><p><strong>文件系统: 在 LVGL 中启用 标准 C 文件系统 API(如 fopen &#x2F; fread) 的支持</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_USE_FS_STDIO 1  <span class="hljs-comment">// 1: 启用, 0: 禁用</span></span><br></code></pre></td></tr></table></figure><ul><li>作用: 开启基于 <code>stdio.h</code>(如 <code>fopen, fread</code>)的文件系统驱动</li><li>依赖: 需确保目标平台支持标准 C 文件操作(嵌入式系统可能需要实现这些函数)</li></ul></li><li><p><strong>驱动器字母映射</strong>(将逻辑驱动器号(如 <code>&#39;A&#39;</code>)映射到物理文件系统路径)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_FS_STDIO_LETTER <span class="hljs-string">&#x27;A&#x27;</span></span><br>lv_img_set_src(img, <span class="hljs-string">&quot;A:/images/logo.png&quot;</span>);  <span class="hljs-comment">// 示例: 对应实际路径 &quot;/images/logo.png&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>工作路径</strong>: 指定文件系统的根目录路径.LVGL 会将所有文件路径附加到该路径后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_FS_STDIO_PATH <span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_FS_STDIO_PATH <span class="hljs-string">&quot;/data&quot;</span>  <span class="hljs-comment">// 示例: 实际路径为 &quot;/data/images/logo.png&quot;</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>缓存大小</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_FS_STDIO_CACHE_SIZE 0  <span class="hljs-comment">// 0: 禁用缓存. &gt; 0: 启用缓存</span></span><br></code></pre></td></tr></table></figure></li><li><p>完整示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_USE_FS_STDIO 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LV_USE_FS_STDIO</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_FS_STDIO_LETTER <span class="hljs-string">&#x27;A&#x27;</span>       <span class="hljs-comment">// 通过 &quot;A:&quot; 访问文件</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_FS_STDIO_PATH <span class="hljs-string">&quot;/sd&quot;</span>       <span class="hljs-comment">// 根目录为 SD 卡挂载点</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_FS_STDIO_CACHE_SIZE 1024  <span class="hljs-comment">// 1KB 缓存</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">lv_obj_t</span> * img = lv_img_create(lv_scr_act());<br>lv_img_set_src(img, <span class="hljs-string">&quot;A:/assets/bg.jpg&quot;</span>);  <span class="hljs-comment">// 实际路径: /sd/assets/bg.jpg</span><br>  <br><span class="hljs-type">lv_font_t</span> * font = lv_font_load(<span class="hljs-string">&quot;A:/fonts/montserrat_16.bin&quot;</span>);<br>  <br><span class="hljs-type">lv_fs_file_t</span> file;<br><span class="hljs-type">lv_fs_res_t</span> res = lv_fs_open(&amp;file, <span class="hljs-string">&quot;A:/config.json&quot;</span>, LV_FS_MODE_RD);<br></code></pre></td></tr></table></figure></li></ol><ul><li>若标准 <code>stdio</code> 不满足需求(如 ROM 文件系统),可参考 <code>lv_fs_stdio.c</code> 实现自定义驱动</li></ul><h2 id="1-对象"><a href="#1-对象" class="headerlink" title="1 对象"></a>1 对象</h2><h3 id="1-1-基类"><a href="#1-1-基类" class="headerlink" title="1.1 基类"></a>1.1 基类</h3><ol><li><p><strong>LVGL 中,<code>lv_obj_t</code> 是所有控件的基类(类似于面向对象编程中的父类)</strong></p><ul><li>是构建用户界面的最基本元素</li><li>所有控件(如按钮, 标签, 滑块等)都继承自 <code>lv_obj_t</code></li></ul></li><li><p><strong>创建对象</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">lv_obj_t</span> *screen = lv_scr_act();       <span class="hljs-comment">// 获取当前屏幕.是没有父对象的特殊 lv_obj_t</span><br><span class="hljs-type">lv_obj_t</span> *obj = lv_obj_create(screen); <span class="hljs-comment">// 在获取的屏幕上创建一个对象</span><br></code></pre></td></tr></table></figure></li><li><p>删除对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">lv_obj_del(obj);<br></code></pre></td></tr></table></figure><ul><li>删除对象本身及其所有子对象(递归删除整个子树)</li><li>自动解除与父对象, 组, 动画等的关联</li><li>释放对象占用的内存资源(如果使用 LVGL 的动态内存分配)</li><li>触发相关事件(如 <code>LV_EVENT_DELETE</code>)</li></ul></li><li><p>父子关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 设置父对象 */</span><br>lv_obj_set_parent(obj, new_parent);<br><br><span class="hljs-comment">/* 获取子对象 */</span><br><span class="hljs-type">lv_obj_t</span> *child = lv_obj_get_child(parent, index);<br><br><span class="hljs-comment">/* 遍历所有子对象 */</span><br><span class="hljs-type">lv_obj_t</span> *child;<br>LV_ITERATE_CHILDREN(child, parent) &#123;<br>    <span class="hljs-comment">// 处理每个子对象</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>父对象通常是容器.如 <code>lv_obj_t, lv_cont_t</code> 或屏幕 <code>lv_scr_act()</code></li><li><strong>视觉层级: 子对象永远显示在父对象之上</strong></li><li>坐标系统: 子对象的坐标是相对于父对象的,移动父对象时所有子对象会同步移动,无需逐个调整</li><li>继承属性: 子对象默认继承父对象的部分属性(如坐标相对父对象偏移, 是否可见, 是否启用等)</li><li>事件传递机制: 事件会从子对象向父对象冒泡(除非被拦截),方便实现复杂交互</li><li>管理生命周期: 删除父对象时会自动递归删除所有子对象</li></ul></li></ol><h3 id="1-2-位置"><a href="#1-2-位置" class="headerlink" title="1.2 位置"></a>1.2 位置</h3><ol><li><p>坐标系: 以左上角为原点 (0,0); 向右为正方向; 向下为正方向</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">lv_coord_t</span> x = lv_obj_get_x(obj);<br><span class="hljs-type">lv_coord_t</span> y = lv_obj_get_y(obj);<br></code></pre></td></tr></table></figure></li><li><p>位置设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">lv_obj_set_pos(obj, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>); <span class="hljs-comment">// 设置绝对坐标.从父对象的偏移 (100, 50) 像素</span><br>lv_obj_set_x(obj, x);         <span class="hljs-comment">// 仅设置X</span><br>lv_obj_set_y(obj, y);         <span class="hljs-comment">// 仅设置Y</span><br></code></pre></td></tr></table></figure></li><li><p>盒子模型: LVGL遵循CSS的 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing">border-box</a> 模型</p><p><img src="/2025/06/07/Embedded/LVGL/1-lvgl-boxmodel.png"></p></li><li><p>对齐设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 基本对齐.对齐后仍然可以设置位置</span><br>lv_obj_set_align(obj, align);<br><br><span class="hljs-comment">// 对齐到特定对象</span><br>lv_obj_align_to(obj, base, align, x_ofs, y_ofs);<br></code></pre></td></tr></table></figure><p><img src="/2025/06/07/Embedded/LVGL/1-lvgl-align.png"></p></li></ol><h3 id="1-3-尺寸"><a href="#1-3-尺寸" class="headerlink" title="1.3 尺寸"></a>1.3 尺寸</h3><ol><li><p>尺寸获取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">lv_coord_t</span> width = lv_obj_get_width(obj);<br><span class="hljs-type">lv_coord_t</span> height = lv_obj_get_height(obj);<br></code></pre></td></tr></table></figure></li><li><p>尺寸设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">lv_obj_set_size(obj, width, height);  <span class="hljs-comment">// 同时设置宽高</span><br>lv_obj_set_size(obj, LV_PCT(<span class="hljs-number">100</span>), LV_PCT(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 设置为父对象的相对大小</span><br></code></pre></td></tr></table></figure></li><li><p>特殊尺寸设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 根据内容自动调整大小</span><br>lv_obj_update_layout(obj);  <span class="hljs-comment">// 强制重新计算布局</span><br>lv_obj_refr_size(obj);      <span class="hljs-comment">// 刷新对象尺寸</span><br><br><span class="hljs-comment">// 设置尺寸模式</span><br>lv_obj_set_width_fit(obj, LV_SIZE_CONTENT);  <span class="hljs-comment">// 宽度适应内容</span><br>lv_obj_set_height_fit(obj, LV_SIZE_CONTENT); <span class="hljs-comment">// 高度适应内容</span><br><br><span class="hljs-comment">// 扩大对象的可点击区域</span><br>lv_obj_set_ext_click_area(obj, left, right, top, bottom);<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-4-布局"><a href="#1-4-布局" class="headerlink" title="1.4 布局"></a>1.4 布局</h3><ol><li><p><strong><code>Flex</code>: 以单行或单列方式动态排列子控件,自动处理空间分配和对齐.适合列表,工具栏</strong></p><ul><li><code>main axis</code>: 主轴.默认为水平方向</li><li><code>cross axis</code>: 交叉轴.与主轴垂直</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 创建 Flex 容器 */</span><br><span class="hljs-type">lv_obj_t</span> *cont = lv_obj_create(lv_scr_act());<br>lv_obj_set_size(cont, <span class="hljs-number">300</span>, <span class="hljs-number">200</span>);<br>lv_obj_set_flex_flow(cont, LV_FLEX_FLOW_ROW_WRAP);  <span class="hljs-comment">// 行排列.自动换行</span><br><br><span class="hljs-comment">/* 添加子控件 */</span><br><span class="hljs-type">lv_obj_t</span> *btn1 = lv_btn_create(cont);<br><span class="hljs-type">lv_obj_t</span> *btn2 = lv_btn_create(cont);<br><span class="hljs-type">lv_obj_t</span> *btn3 = lv_btn_create(cont);<br><br><span class="hljs-comment">/* 设置子控件弹性属性 */</span><br>lv_obj_set_flex_grow(btn1, <span class="hljs-number">1</span>);  <span class="hljs-comment">// btn1 占据剩余空间的1/4</span><br>lv_obj_set_flex_grow(btn2, <span class="hljs-number">2</span>);  <span class="hljs-comment">// btn2 占据剩余空间的2/4</span><br>lv_obj_set_flex_grow(btn3, <span class="hljs-number">1</span>);  <span class="hljs-comment">// btn2 占据剩余空间的1/4</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Grid</code>: 通过行和列的二维网格系统精确控制子控件位置,适合复杂布局</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 创建 Grid 容器 */</span><br><span class="hljs-type">lv_obj_t</span> *cont = lv_obj_create(lv_scr_act());<br>lv_obj_set_size(cont, LV_PCT(<span class="hljs-number">100</span>), LV_PCT(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 全屏</span><br>lv_obj_set_layout(cont, LV_LAYOUT_GRID);         <span class="hljs-comment">// 启用 Grid 布局</span><br><br><span class="hljs-comment">/* 定义网格列: 左侧卡片(占2份弹性空间) + 右侧卡片(占1份弹性空间) */</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_coord_t</span> col_dsc[] = &#123;LV_GRID_FR(<span class="hljs-number">2</span>), LV_GRID_FR(<span class="hljs-number">1</span>), LV_GRID_TEMPLATE_LAST&#125;;<br><span class="hljs-comment">/* 定义网格行: 标题行高 40px + 内容区弹性填充 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_coord_t</span> row_dsc[] = &#123;<span class="hljs-number">40</span>, LV_GRID_FR(<span class="hljs-number">1</span>), LV_GRID_TEMPLATE_LAST&#125;;<br>lv_obj_set_grid_dsc_array(cont, col_dsc, row_dsc); <span class="hljs-comment">// 应用网格定义</span><br><br><span class="hljs-comment">/* 创建标题栏.居中显示.定位到第0行,跨2列 */</span><br><span class="hljs-type">lv_obj_t</span> *title = lv_label_create(cont);<br>lv_label_set_text(title, <span class="hljs-string">&quot;title&quot;</span>);<br>lv_obj_set_grid_cell(title, LV_GRID_ALIGN_CENTER, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, LV_GRID_ALIGN_CENTER, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">/* 创建温度显示栏.定位到第1行第0列 */</span><br><span class="hljs-type">lv_obj_t</span> *temp_card = lv_obj_create(cont);<br><span class="hljs-type">lv_obj_t</span> *temp_label = lv_label_create(temp_card);<br>lv_label_set_text_fmt(temp_label, <span class="hljs-string">&quot;temperature\n%d&quot;</span>, <span class="hljs-number">25</span>);<br>lv_obj_set_grid_cell(temp_card, LV_GRID_ALIGN_STRETCH, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, LV_GRID_ALIGN_STRETCH, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">/* 创建湿度显示栏.定位到第1行第1列 */</span><br><span class="hljs-type">lv_obj_t</span> *humi_card = lv_obj_create(cont);<br><span class="hljs-type">lv_obj_t</span> *humi_label = lv_label_create(humi_card);<br>lv_label_set_text_fmt(humi_label, <span class="hljs-string">&quot;humidity\n%d%%&quot;</span>, <span class="hljs-number">60</span>);<br>lv_obj_set_grid_cell(humi_card, LV_GRID_ALIGN_STRETCH, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, LV_GRID_ALIGN_STRETCH, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-5-图层"><a href="#1-5-图层" class="headerlink" title="1.5 图层"></a>1.5 图层</h3><ol><li><p>LVGL 的图层系统是管理对象显示层级和特殊覆盖界面的核心机制,它构成了屏幕内容的立体堆叠结构</p><p><img src="/2025/06/07/Embedded/LVGL/1-lvgl-layer.png"></p><ul><li><strong>固定层级关系: 系统维护严格的 z 轴顺序</strong></li><li>全局共享: 所有屏幕共用同一组图层</li><li>事件穿透: 高层可拦截低层的事件</li><li>独立渲染: 每层单独合成最终图像</li></ul></li><li><p>图层类型</p><table><thead><tr><th align="left">图层类型</th><th align="left">描述</th><th align="left">典型用途</th><th align="left">访问函数</th></tr></thead><tbody><tr><td align="left">基础层(Base)</td><td align="left">默认对象层</td><td align="left">常规 UI 内容</td><td align="left"><code>lv_scr_act()</code></td></tr><tr><td align="left">顶部层(Top)</td><td align="left">覆盖层</td><td align="left">系统状态栏</td><td align="left"><code>lv_layer_top()</code></td></tr><tr><td align="left">系统层(Sys)</td><td align="left">最高优先级</td><td align="left">弹窗, 菜单</td><td align="left"><code>lv_layer_sys()</code></td></tr></tbody></table></li><li><p>获取图层对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">lv_obj_t</span> *scr = lv_scr_act();<br><span class="hljs-type">lv_obj_t</span> *layer_top = lv_layer_top();<br><span class="hljs-type">lv_obj_t</span> *layer_sys = lv_layer_sys();<br></code></pre></td></tr></table></figure></li><li><p>图层控制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 设置图层可见性</span><br>lv_obj_add_flag(lv_layer_top(), LV_OBJ_FLAG_HIDDEN);   <span class="hljs-comment">// 隐藏顶部层</span><br>lv_obj_clear_flag(lv_layer_sys(), LV_OBJ_FLAG_HIDDEN); <span class="hljs-comment">// 显示系统层</span><br><br><span class="hljs-comment">// 移动对象到其他图层</span><br>lv_obj_move_to_layer(obj, lv_layer_sys());  <span class="hljs-comment">// 提升到系统层</span><br><br><span class="hljs-comment">// 获取对象所在图层</span><br><span class="hljs-type">lv_layer_t</span> * layer = lv_obj_get_layer(obj);<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-6-事件"><a href="#1-6-事件" class="headerlink" title="1.6 事件"></a>1.6 事件</h3><ol><li><p>事件类型</p><table><thead><tr><th align="left"><strong>事件类型</strong></th><th align="left"><strong>触发场景</strong></th><th align="left"><strong>常见事件码</strong></th></tr></thead><tbody><tr><td align="left">输入事件</td><td align="left">用户触摸, 按键, 编码器操作</td><td align="left"><code>LV_EVENT_PRESSED, LV_EVENT_CLICKED</code></td></tr><tr><td align="left">绘图事件</td><td align="left">对象需要刷新显示时</td><td align="left"><code>LV_EVENT_REFRESH, LV_EVENT_DRAW_MAIN</code></td></tr><tr><td align="left">控件特定事件</td><td align="left">特定控件独有的行为(如滑块值改变)</td><td align="left"><code>LV_EVENT_VALUE_CHANGED</code> (滑块)</td></tr><tr><td align="left">系统事件</td><td align="left">对象生命周期变化(创建, 删除, 动画完成)</td><td align="left"><code>LV_EVENT_DELETE, LV_EVENT_READY</code></td></tr></tbody></table></li><li><p><strong>事件回调: 通过 <code>lv_obj_add_event_cb()</code> 为对象绑定事件处理函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">event_handler</span><span class="hljs-params">(<span class="hljs-type">lv_event_t</span> * e)</span> &#123;<br>    <span class="hljs-type">lv_obj_t</span> *obj = lv_event_get_target(e);       <span class="hljs-comment">// 获取触发事件的对象</span><br>    <span class="hljs-type">lv_event_code_t</span> code = lv_event_get_code(e);  <span class="hljs-comment">// 获取事件类型</span><br>    <span class="hljs-type">int</span> *data = (<span class="hljs-type">int</span> *)lv_event_get_user_data(e); <span class="hljs-comment">// 获取用户数据</span><br><br>    <span class="hljs-comment">/* 根据事件类型,进行相应处理 */</span><br>    <span class="hljs-keyword">switch</span>(code) &#123;<br>    <span class="hljs-keyword">case</span> LV_EVENT_CLICKED:<br>        LV_LOG_USER(<span class="hljs-string">&quot;Button clicked!&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> LV_EVENT_VALUE_CHANGED:<br>        LV_LOG_USER(<span class="hljs-string">&quot;Value changed!&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>监听事件: 以按钮的点击事件为例(可以监听多个事件)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> my_data = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 用户数据,可以有多种类型</span><br><span class="hljs-type">lv_obj_t</span> * btn = lv_btn_create(lv_scr_act());<br>lv_obj_add_event_cb(btn, event_handler, LV_EVENT_CLICKED | LV_EVENT_PRESSED, &amp;my_data);<br></code></pre></td></tr></table></figure></li><li><p>手动触发: 以<code>值改变</code>事件为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">lv_event_send(obj, LV_EVENT_VALUE_CHANGED, <span class="hljs-string">&quot;Custom data&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>事件传递</p><ul><li><strong>冒泡传递(Bubbling): 若子对象未处理事件(返回 <code>lv_RES_INV</code>),则事件向父对象传递</strong></li><li><strong>事件穿透: 对于透明或不可点击区域,可通过返回 <code>lv_RES_INV</code> 允许事件传递到底层对象</strong></li></ul></li></ol><h2 id="2-样式"><a href="#2-样式" class="headerlink" title="2 样式"></a>2 样式</h2><h3 id="2-1-样式概念"><a href="#2-1-样式概念" class="headerlink" title="2.1 样式概念"></a>2.1 样式概念</h3><ol><li><p><strong>样式: 是构建美观界面的核心.LVGL 采用类似 CSS 的样式机制,可以灵活控制对象的外观表现</strong></p><ul><li>层级化: 支持多个样式叠加</li><li>状态敏感: 不同状态(如按下, 禁用)可应用不同样式</li><li><strong>继承机制: 子对象可继承父对象的部分样式属性</strong></li><li>低内存占用: 样式可被多个对象共享</li></ul></li><li><p>样式属性分类</p><ul><li>大小与布局: 宽度, 高度, 对齐等</li><li>背景: 颜色, 透明度, 渐变等</li><li>边框: 宽度, 颜色, 圆角等</li><li>文本: 字体, 颜色, 对齐等</li><li>特效: 阴影, 模糊, 透明度动画等</li></ul></li><li><p>基础使用方式(创建一个 <code>textarea</code> 并添加 <code>style</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 样式初始化 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style;<br>lv_style_init(&amp;style);<br><br><span class="hljs-comment">/* 设置背景样式 */</span><br>lv_style_set_radius(&amp;style, <span class="hljs-number">8</span>);                        <span class="hljs-comment">// 圆角半径</span><br>lv_style_set_bg_opa(&amp;style, LV_OPA_COVER);             <span class="hljs-comment">// 不透明度</span><br>lv_style_set_bg_color(&amp;style, lv_color_hex(<span class="hljs-number">0xF5F5F5</span>)); <span class="hljs-comment">// 浅灰色背景</span><br><br><span class="hljs-comment">/* 设置边框样式 */</span><br>lv_style_set_border_width(&amp;style, <span class="hljs-number">2</span>);                      <span class="hljs-comment">// 边框宽度</span><br>lv_style_set_border_color(&amp;style, lv_color_hex(<span class="hljs-number">0xCCCCCC</span>)); <span class="hljs-comment">// 边框颜色</span><br><br><span class="hljs-comment">/* 设置文本样式 */</span><br>lv_style_set_text_color(&amp;style, lv_color_black());      <span class="hljs-comment">// 黑色文本</span><br>lv_style_set_text_font(&amp;style, &amp;lv_font_montserrat_16); <span class="hljs-comment">// 字体</span><br><br><span class="hljs-comment">/* 设置内边距 */</span><br>lv_style_set_pad_all(&amp;style, <span class="hljs-number">10</span>); <span class="hljs-comment">// 四周内边距</span><br><br><span class="hljs-comment">/* 创建文本框对象 */</span><br><span class="hljs-type">lv_obj_t</span> *textarea = lv_textarea_create(lv_scr_act());<br>lv_obj_set_size(textarea, <span class="hljs-number">200</span>, <span class="hljs-number">80</span>); <span class="hljs-comment">// 大小</span><br>lv_obj_center(textarea);            <span class="hljs-comment">// 居中对齐</span><br>lv_textarea_set_placeholder_text(textarea, <span class="hljs-string">&quot;please input...&quot;</span>);  <span class="hljs-comment">// 提示文本</span><br>lv_textarea_set_one_line(textarea, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// 允许单行模式(按需使用)</span><br><br><span class="hljs-comment">/* 应用样式 */</span><br>lv_obj_add_style(textarea, &amp;style, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-样式状态"><a href="#2-2-样式状态" class="headerlink" title="2.2 样式状态"></a>2.2 样式状态</h3><ol><li><p><strong>添加样式时其状态参数决定了样式何时生效</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">lv_obj_add_style</span><span class="hljs-params">(<span class="hljs-type">lv_obj_t</span> * obj, <span class="hljs-type">lv_style_t</span> * style, <span class="hljs-type">lv_state_t</span> state)</span>;<br></code></pre></td></tr></table></figure></li><li><p>状态参数(<code>lv_state_t</code>)是位掩码,因此可以组合使用</p><table><thead><tr><th align="left">状态</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>LV_STATE_DEFAULT</code> (0x0000)</td><td align="left">默认状态</td></tr><tr><td align="left"><code>LV_STATE_CHECKED</code> (0x0001)</td><td align="left">切换 &#x2F; 选中状态</td></tr><tr><td align="left"><code>LV_STATE_FOCUSED</code> (0x0002)</td><td align="left">通过键盘或编码器聚焦</td></tr><tr><td align="left"><code>LV_STATE_FOCUS_KEY</code> (0x0004)</td><td align="left">通过键盘聚焦</td></tr><tr><td align="left"><code>LV_STATE_EDITED</code> (0x0008)</td><td align="left">由编码器编辑</td></tr><tr><td align="left"><code>LV_STATE_HOVERED</code> (0x0010)</td><td align="left">鼠标悬停(未按下)</td></tr><tr><td align="left"><code>LV_STATE_PRESSED</code> (0x0020)</td><td align="left">被按下</td></tr><tr><td align="left"><code>LV_STATE_SCROLLED</code> (0x0040)</td><td align="left">正在滚动</td></tr><tr><td align="left"><code>LV_STATE_DISABLED</code> (0x0080)</td><td align="left">禁用状态</td></tr></tbody></table></li><li><p>多样式示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 应用到按钮的默认状态 */</span><br>lv_obj_add_style(btn, &amp;style_btn, LV_STATE_DEFAULT);<br><br><span class="hljs-comment">/* 应用到悬停状态 */</span><br>lv_obj_add_style(btn, &amp;style_hover, LV_STATE_HOVERED);<br><br><span class="hljs-comment">/* 应用到按下 + 聚焦状态 */</span><br>lv_obj_add_style(btn, &amp;style_pressed_focused, LV_STATE_PRESSED | LV_STATE_FOCUSED);<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-样式部件"><a href="#2-3-样式部件" class="headerlink" title="2.3 样式部件"></a>2.3 样式部件</h3><ol><li><p><strong>样式部件(style parts): 可以单独设置样式的对象组成部分</strong>.如</p><ul><li>按钮由主体(MAIN)和指示器(INDICATOR)组成</li><li>滑块由主体(MAIN), 指示器(INDICATOR)和旋钮(KNOB)组成</li></ul></li><li><p>常见样式部件</p><table><thead><tr><th align="left">部件</th><th align="left">描述</th><th align="left">适用对象</th></tr></thead><tbody><tr><td align="left"><code>LV_PART_MAIN</code></td><td align="left">主体部分</td><td align="left">所有对象</td></tr><tr><td align="left"><code>LV_PART_SCROLLBAR</code></td><td align="left">滚动条</td><td align="left">可滚动容器</td></tr><tr><td align="left"><code>LV_PART_INDICATOR</code></td><td align="left">指示器</td><td align="left">滑块, 开关等</td></tr><tr><td align="left"><code>LV_PART_KNOB</code></td><td align="left">旋钮</td><td align="left">滑块, 旋钮等</td></tr><tr><td align="left"><code>LV_PART_SELECTED</code></td><td align="left">选中项</td><td align="left">列表, 表格等</td></tr><tr><td align="left"><code>LV_PART_ITEMS</code></td><td align="left">子项</td><td align="left">列表, 菜单等</td></tr></tbody></table></li><li><p>多部件样式示例(精确控制 <code>slide</code> 的指示器部分)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建样式</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_main;<br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_indicator;<br><br><span class="hljs-comment">// 初始化主体样式</span><br>lv_style_init(&amp;style_main);<br>lv_style_set_bg_color(&amp;style_main, lv_palette_main(LV_PALETTE_BLUE));<br>lv_style_set_radius(&amp;style_main, <span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 初始化指示器样式</span><br>lv_style_init(&amp;style_indicator);<br>lv_style_set_bg_color(&amp;style_indicator, lv_palette_main(LV_PALETTE_RED));<br><br><span class="hljs-comment">// 应用到滑块对象</span><br><span class="hljs-type">lv_obj_t</span> *slider = lv_slider_create(lv_scr_act());<br>lv_obj_set_align(slider, LV_ALIGN_CENTER);<br>lv_obj_add_style(slider, &amp;style_main, LV_PART_MAIN);           <span class="hljs-comment">// 主体部分</span><br>lv_obj_add_style(slider, &amp;style_indicator, LV_PART_INDICATOR); <span class="hljs-comment">// 指示器部分</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-样式管理"><a href="#2-4-样式管理" class="headerlink" title="2.4 样式管理"></a>2.4 样式管理</h3><ol><li><p><strong>本地样式(Local Styles)</strong>: 直接为对象设置样式属性,而无需创建独立的样式结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">lv_obj_set_style_bg_color(obj, lv_palette_main(LV_PALETTE_GREEN), <span class="hljs-number">0</span>);  <span class="hljs-comment">// 颜色</span><br>lv_obj_set_style_text_font(obj, &amp;lv_font_montserrat_20, <span class="hljs-number">0</span>);            <span class="hljs-comment">// 字体</span><br></code></pre></td></tr></table></figure></li><li><p>样式继承</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 创建基础样式 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_base;<br>lv_style_init(&amp;style_base);<br>lv_style_set_bg_opa(&amp;style_base, LV_OPA_COVER);<br><br><span class="hljs-comment">/* 创建继承样式 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_child;<br>lv_style_init(&amp;style_child);<br>lv_style_set_bg_color(&amp;style_child, lv_palette_main(LV_PALETTE_RED));<br>lv_style_set_parent(&amp;style_child, &amp;style_base);  <span class="hljs-comment">// 继承基础样式</span><br></code></pre></td></tr></table></figure></li><li><p>样式组织</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 按功能组织样式 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_card;          <span class="hljs-comment">// 卡片样式</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_btn_primary;   <span class="hljs-comment">// 主要按钮</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_btn_secondary; <span class="hljs-comment">// 次要按钮</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_text_title;    <span class="hljs-comment">// 标题文本</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_text_body;     <span class="hljs-comment">// 正文文本</span><br><br><span class="hljs-comment">/* 按状态组织样式 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_btn_default;<br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_btn_pressed;<br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_btn_disabled;<br></code></pre></td></tr></table></figure></li><li><p>性能优化</p><ul><li>共享样式: 多个相似对象使用同一个样式实例</li><li>避免频繁修改: 在界面初始化时集中设置样式</li><li>使用样式缓存: 对频繁切换的样式预先创建好</li><li>合理使用过渡动画: 避免同时激活过多动画效果</li></ul></li></ol><h2 id="3-控件"><a href="#3-控件" class="headerlink" title="3 控件"></a>3 控件</h2><h3 id="3-1-标签"><a href="#3-1-标签" class="headerlink" title="3.1 标签"></a>3.1 标签</h3><ol><li><p>文本显示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">lv_obj_t</span> *label = lv_label_create(lv_scr_act());                <span class="hljs-comment">// 在屏幕上创建 label 对象</span><br>lv_label_set_text(label, <span class="hljs-string">&quot;hello, lvgl&quot;</span>);                        <span class="hljs-comment">// 文本内容</span><br>lv_obj_align(label, LV_ALIGN_CENTER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);                     <span class="hljs-comment">// 居中对齐</span><br>lv_obj_set_style_text_color(label, lv_color_hex(<span class="hljs-number">0xFF0000</span>), <span class="hljs-number">0</span>);  <span class="hljs-comment">// 字体颜色</span><br>lv_obj_set_style_text_font(label, &amp;lv_font_montserrat_20, <span class="hljs-number">0</span>);   <span class="hljs-comment">// 字体及大小</span><br></code></pre></td></tr></table></figure></li><li><p>中文支持: lvgl 自带的字库并不支持中文显示.需要创建自己的字体库</p></li><li><p>进入<a href="https://lvgl.io/tools/fontconverter">字体在线转换网站</a>进行字体转换(转换完成后将得到一个 <code>.c</code> 文件,将其加入工程)</p><img src="./4-lvgl-font-convert.png" style="zoom:67%;" /><ul><li>英文字母, 数字, 基本标点符号(与 ASCII 编码兼容): 0x20-0x7F</li><li><code>中日韩统一表意文字</code>区块包含了汉字(20992个汉字): 0x4E00-0x9FFF</li><li>全角和半角区块: 0xFF00-0xFFEF</li><li>通用标点区块(引号等): 0x2000-0x206F</li><li>CJK 符号和标点区块(句号等): 0x3000-0x303F</li></ul></li><li><p>中文显示只需要知名使用的字体即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">LV_FONT_DECLARE(sy_ky_bold);  <span class="hljs-comment">// 声明外部字体.这里使用的是 思源黑体等宽版</span><br><span class="hljs-type">lv_obj_t</span> * label = lv_label_create(lv_scr_act());    <span class="hljs-comment">// 创建 label 对象</span><br>lv_obj_set_style_text_font(label, &amp;sy_ky_bold, <span class="hljs-number">0</span>);   <span class="hljs-comment">// 使用 sy_ky_bold 字体</span><br>lv_label_set_text(label, <span class="hljs-string">&quot;好好学习，\n天天向上。&quot;</span>);  <span class="hljs-comment">// 设置中文文本</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-2-图片"><a href="#3-2-图片" class="headerlink" title="3.2 图片"></a>3.2 图片</h3><ol><li><p>进入<a href="https://lvgl.io/tools/imageconverter">图片转换在线网站</a>进行图片转换(<code>Color format</code> 选择 <code>CF_TRUE_COLOR</code>.转换完成后将得到一个 <code>.c</code> 文件,将其加入工程)</p><p><img src="/2025/06/07/Embedded/LVGL/4-lvgl-image-converter.png"></p></li><li><p>图片显示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">LV_IMG_DECLARE(abao);                         <span class="hljs-comment">// 声明图片数据</span><br><span class="hljs-type">lv_obj_t</span>* img = lv_img_create(lv_scr_act());  <span class="hljs-comment">// 创建 img 对象</span><br>lv_img_set_src(img, &amp;abao);                   <span class="hljs-comment">// 设置图片源数据</span><br></code></pre></td></tr></table></figure></li><li><p>gif 显示: 转换 gif 格式数据时 <code>Color format</code> 选择 <code>CF_RAW</code>(转换完成后将得到一个 <code>.c</code> 文件,将其加入工程)</p><ul><li><p>使用 gif 图像生成文件步骤与上面的 image 生成步骤完全相同(需要在 <code>lv_conf.h</code> 文件中开启 GIF 功能)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*GIF decoder library*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_USE_GIF 1</span><br></code></pre></td></tr></table></figure></li><li><p>显示 gif</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">LV_IMG_DECLARE(astronauts);                  <span class="hljs-comment">// 声明图片数据</span><br><span class="hljs-type">lv_obj_t</span>* gif = lv_gif_create(lv_scr_act()); <span class="hljs-comment">// 创建 gif 对象</span><br>lv_gif_set_src(gif, &amp;astronauts);            <span class="hljs-comment">// 设置 gif 图片源数据</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="3-3-按钮"><a href="#3-3-按钮" class="headerlink" title="3.3 按钮"></a>3.3 按钮</h3><ol><li><p>按钮基础功能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">lv_obj_t</span> *button = lv_btn_create(lv_scr_act());  <span class="hljs-comment">// 创建 button 对象</span><br>lv_obj_align(button, LV_ALIGN_CENTER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);     <span class="hljs-comment">// 设置 button 对齐</span><br><br><span class="hljs-type">lv_obj_t</span> *label = lv_label_create(button);       <span class="hljs-comment">// 创建 label 对象</span><br>lv_label_set_text(label, <span class="hljs-string">&quot;Toggle&quot;</span>);              <span class="hljs-comment">// 设置 label 文本内容</span><br></code></pre></td></tr></table></figure></li><li><p>按钮状态系统</p><table><thead><tr><th align="left"><strong>状态标志</strong></th><th align="left"><strong>描述</strong></th><th align="left"><strong>触发条件</strong></th></tr></thead><tbody><tr><td align="left"><code>LV_STATE_DEFAULT</code></td><td align="left">默认状态</td><td align="left">初始状态</td></tr><tr><td align="left"><code>LV_STATE_PRESSED</code></td><td align="left">按下状态</td><td align="left">用户按下按钮</td></tr><tr><td align="left"><code>LV_STATE_CHECKED</code></td><td align="left">选中状态</td><td align="left">按钮被选中(需设置 CHECKABLE)</td></tr><tr><td align="left"><code>LV_STATE_DISABLED</code></td><td align="left">禁用状态</td><td align="left">按钮被禁用</td></tr><tr><td align="left"><code>LV_STATE_FOCUSED</code></td><td align="left">焦点状态</td><td align="left">按钮获得焦点</td></tr><tr><td align="left"><code>LV_STATE_EDITED</code></td><td align="left">编辑状态</td><td align="left">对象正在被编辑</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 添加状态(可以有多个状态) */</span><br>lv_obj_add_state(btn, LV_STATE_CHECKED | LV_STATE_FOCUSED);<br><br><span class="hljs-comment">/* 移除状态 */</span><br>lv_obj_clear_state(btn, LV_STATE_CHECKED);<br><br><span class="hljs-comment">/* 检查状态 */</span><br><span class="hljs-type">bool</span> is_checked = lv_obj_has_state(btn, LV_STATE_CHECKED);<br></code></pre></td></tr></table></figure></li><li><p>事件处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* clicked 事件回调函数.改变 label 的 text */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">button_handler</span><span class="hljs-params">(<span class="hljs-type">lv_event_t</span> * e)</span> &#123;<br>    <span class="hljs-type">lv_obj_t</span> *obj = lv_event_get_target(e);<br><br>    <span class="hljs-keyword">if</span>(lv_event_get_code(e) == LV_EVENT_CLICKED) &#123;<br>        <span class="hljs-type">lv_obj_t</span> *label = lv_obj_get_child(obj, <span class="hljs-number">0</span>); <span class="hljs-comment">// 获取按钮的第一个子对象(即 label)</span><br>        <span class="hljs-keyword">if</span>(label &amp;&amp; lv_obj_check_type(label, &amp;lv_label_class))<br>            lv_label_set_text(label, <span class="hljs-string">&quot;clicked&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test_button</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">lv_obj_t</span> *button = lv_btn_create(lv_scr_act());  <span class="hljs-comment">// 创建 button 对象</span><br>    lv_obj_align(button, LV_ALIGN_CENTER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);     <span class="hljs-comment">// 设置 button 对齐</span><br>    lv_obj_add_flag(button, LV_OBJ_FLAG_CHECKABLE);  <span class="hljs-comment">// 设置 button 可被选中</span><br>    lv_obj_add_event_cb(button, button_handler,<br>                        LV_EVENT_CLICKED, <span class="hljs-literal">NULL</span>);     <span class="hljs-comment">// 绑定 clicked 事件</span><br><br>    <span class="hljs-type">lv_obj_t</span> *label = lv_label_create(button);       <span class="hljs-comment">// 创建 label 对象</span><br>    lv_label_set_text(label, <span class="hljs-string">&quot;Toggle&quot;</span>);              <span class="hljs-comment">// 设置 label 文本内容</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>LVGL</tag>
      
      <tag>GUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESP32</title>
    <link href="/2024/07/01/Embedded/ESP32/"/>
    <url>/2024/07/01/Embedded/ESP32/</url>
    
    <content type="html"><![CDATA[<h1 id="ESP32"><a href="#ESP32" class="headerlink" title="ESP32"></a>ESP32</h1><h2 id="0-开发环境"><a href="#0-开发环境" class="headerlink" title="0 开发环境"></a>0 开发环境</h2><h3 id="0-1-开发板"><a href="#0-1-开发板" class="headerlink" title="0.1 开发板"></a>0.1 开发板</h3><ol><li><p>开发板型号: <a href="https://docs.espressif.com/projects/esp-dev-kits/zh_CN/latest/esp32s3/esp32-s3-devkitc-1/index.html">ESP32-S3-DevKitC-1-wroom-1</a></p><p><img src="/2024/07/01/Embedded/ESP32/0-ESP32-S3-DevKitC-1-wroom-1.png"></p><ul><li>拥有两个 USB 接口.一个是 USB 转串口, 另一个是 USB OTG 接口(JTAG 调试)</li><li>拥有两个按键: RST 是复位键. 若按住 Boot 键的同时按一下 RST 进入 <code>固件下载</code> 模式</li><li>RGB LED: 可寻址 RGB 发光二极管(WS2812). 注意 v1.0 由 GPIO48 驱动, v1.1 由 GPIO38 驱动</li></ul></li><li><p>芯片型号: <code>ESP32-S3 N16R8</code>.模组 <code>ESP32-S3-DevKitC-1-N16R8V</code> 引脚</p><p><img src="/2024/07/01/Embedded/ESP32/0-ESP32-S3-DevKitC-Pin.jpg"></p></li><li><p><strong>ESP32-S3-WROOM-1-N16R8: 乐鑫(Espressif)推出的一款高性能 Wi-Fi&#x2F;蓝牙双模模组</strong></p><ul><li>esp32-s3: 主控芯片型号(Xtensa LX7 双核, 240MHz)</li><li>WROOM-1: 模组系列(集成 PCB 天线)</li><li>N16: 内置 16MB spi flash.(qspi, 支持 120MHz, 理论传输速率 60MB&#x2F;s)</li><li>R8: 内置 8MB Octal psram(八线 Octal psram, 最高 120MHz, 理论带宽 120MB&#x2F;s)</li><li>无线: 2.4GHz Wi-Fi 4 (802.11 b&#x2F;g&#x2F;n) + Bluetooth 5 LE</li><li>天线: 板载 PCB 天线</li></ul></li></ol><h3 id="0-2-Linux-环境"><a href="#0-2-Linux-环境" class="headerlink" title="0.2 Linux 环境"></a>0.2 <a href="https://www.bilibili.com/video/BV1eRg7exEcT?spm_id_from=333.788.videopod.episodes&vd_source=ca18f72085fcabc81ea5ba4e594aefe7&p=2">Linux 环境</a></h3><ol><li><p>搭建 Linux 开发环境参考 Linux 文档环境搭建部分(这里默认搭建完成,并使用 Ubuntu)</p></li><li><p>环境搭建</p><ul><li><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install git wget flex bison gperf python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 net-tools<br></code></pre></td></tr></table></figure></li><li><p>拉取 esp-idf 源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建工作目录</span><br>mkdir -p ~/esp<br>cd ~/esp<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用脚本,将 github 地址映射为 gitee,减少因网络而导致的配置失败</span><br>git clone https://gitee.com/EspressifSystems/esp-gitee-tools.git<br>cd esp-gitee-tools   # 执行 gitee 工具切换镜像脚本<br>./jihu-mirror.sh set # 执行脚本,将 github 地址映射为 gitee<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拉取 esp-idf 源码(文件较多,耐心等待)</span><br>cd ~/esp<br>git clone --recursive https://github.com/espressif/esp-idf.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到 5.2 版本(包括子模块).保持环境一致(非必需)</span><br>cd esp-idf<br>git checkout v5.2<br>git submodule update --init --recursive<br></code></pre></td></tr></table></figure></li><li><p>配置编译环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">更换 pip 源(非必需).可以使用 pip config list 命令查看当前的 pip 镜像源</span><br>pip config set global.index-url http://mirrors.aliyun.com/pypi/simple<br>pip config set global.trusted-host mirrors.aliyun.com<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装编译工具</span><br>../esp-gitee-tools/install.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置环境变量.该操作每次打开一个终端都要运行,后面介绍解决办法</span><br>source export.sh<br></code></pre></td></tr></table></figure></li></ul></li><li><p>编译示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">copy 官方 example</span><br>cd ~/esp<br>mkdir esp-proj<br>cp -r esp-idf/examples/get-started/hello_world/ esp-proj/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译工程</span><br>cd esp-proj/hello_world/   # 进入工程目录.idf.py 的指令需要在项目的所处的目录中执行<br>idf.py set-target esp32s3  # 配置芯片型号.需查阅开发板原理图<br>idf.py build               # 构建项目<br></code></pre></td></tr></table></figure></li><li><p>烧录示例: 需要将开发板连接到 Linux(如果使用是 WSL, 可参考 Linux 文档的连接 USB 设备部分)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">烧录指令.出现 Done 表示烧录完成.需要进入烧录模式(按住 boot 键,按一次 reset)</span><br>idf.py flash<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时会出现 /dev/ttyUSB0 failed to connect... 因此先修改权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">该操作会随着设备拔插失效,因此每次都要执行.后面描述解决办法</span><br>sudo chmod 777 /dev/ttyUSB0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">烧录并监视串口. Ctrl + ] 退出</span><br>idf.py flash monitor<br></code></pre></td></tr></table></figure></li><li><p>优化配置</p><ul><li><p>永久环境变量: 将添加环境变量的语句添加到 <code>.profile</code> 文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;export IDF_PATH=~/esp/esp-idf&quot; &gt;&gt; ~/.profile<br>echo &quot;source \$IDF_PATH/export.sh&quot; &gt;&gt; ~/.profile<br></code></pre></td></tr></table></figure></li><li><p>解决每次插拔设备后权限不足的问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将当前用户添加到 dialout 组.使其获得串口设备的访问权限</span><br>sudo usermod -aG dialout $USER<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后重新连接客户会话终端.后续不再需要修改权限</span><br>exit              # 完全退出当前 SSH 会话或终端.然后需要手动重新连接<br>id | grep dialout # 验证修改.需要确认当前用户已经加入了 dialout 组<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-3-IDF-工具"><a href="#0-3-IDF-工具" class="headerlink" title="0.3 IDF 工具"></a>0.3 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/api-guides/tools/idf-py.html">IDF 工具</a></h3><ol><li><p><code>idf.py</code> 命令行工具提供了一个前端界面, 管理工程构建, 工程部署, 工程调试等操作</p><ul><li><code>CMake</code>: 配置要构建的工程</li><li><code>Ninja</code>: 构建工程</li><li><code>esptool</code>: 烧录目标芯片</li><li>注意 <code>idf.py</code> 应在 <code>esp-idf</code> 工程目录下运行.即包含 <code>CMakeLists.txt</code> 文件的目录</li></ul></li><li><p>前置工作相关</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py set-target esp32s3  # 指定芯片类型为 esp32s3<br>idf.py menuconfig          # 打开配置界面.一般第一次需要修改 flash size<br>idf.py save-defconfig      # 生成 sdkconfig.defaults 默认配置文件<br>idf.py create-project test # 创建一个名为 test 的工程<br></code></pre></td></tr></table></figure></li><li><p>构建项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py build       # 编译项目代码, 生成可执行固件.默认输出到 build 目录<br>idf.py clean       # 清除构建生成的临时文件(保留配置)<br>idf.py fullclean   # 彻底清除构建目录和配置(包括 sdkconfig)<br>idf.py reconfigure # 重新运行 CMake 并更新配置<br></code></pre></td></tr></table></figure></li><li><p>烧录固件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py flash          # 构建并烧录. -p &lt;port&gt; 指定串口, -b &lt;baud&gt; 指定烧录波特率<br>idf.py flash-settings # 仅烧录分区表和配置(非完整固件)<br>idf.py erase-flash    # 擦除整个 flash<br>idf.py erase-otadata  # 擦除 OTA 数据<br></code></pre></td></tr></table></figure></li><li><p>调试监控</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py monitor # 启动串口监视器,查看设备日志(默认波特率 115200). Ctrl + ] 退出监视器<br>idf.py gdb     # 启动 GDB 调试器(需提前配置 OpenOCD 或 JTAG)<br>idf.py openocd # 启动 OpenOCD 调试服务<br></code></pre></td></tr></table></figure></li><li><p>其他</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py size             # 显示应用程序大小.包括 ram 和 flash 及各部分大小<br>idf.py merge bin        # 合并二进制文件<br>idf.py create-component # 创建新组件<br></code></pre></td></tr></table></figure></li><li><p>切换 idf 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前 idf 版本</span><br>idf.py --version<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换 idf 版本</span><br>cd ~/esp/esp-idf    # 需要进入到 esp-idf 目录进行操作<br>git checkout v5.4.1 # 切换到 V5.4.1<br>git submodule update --init --recursive  # 更新子模块<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重新安装工具链</span><br>./install.sh     # 安装匹配的工具链<br>source export.sh # 设置环境变量<br></code></pre></td></tr></table></figure></li><li><p>烧录完成后 esp32 的启动流程</p><ul><li>一级引导程序: 固化于 ROM 中,不可修改.加载二级引导程序到 ram 执行<ul><li>通过检查 IO0 引脚的电平,选择程序模式</li><li>当芯片上电检测到 IO0 引脚为低电平时,进入下载模式,否则执行二级引导程序</li></ul></li><li>二级引导程序: <code>boot loader</code> 程序.从 0x8000 处读取分区表,处理各种段,加载应用程序</li><li>应用程序: 硬件外设和基本 C 语言运行环境的初始化, <code>freeRTOS</code> 初始化, 最后执行 <code>app_main()</code> 函数</li></ul></li></ol><h3 id="0-4-工程配置"><a href="#0-4-工程配置" class="headerlink" title="0.4 工程配置"></a>0.4 工程配置</h3><ol><li><p>在工程目录下执行下面命令打开交互式配置菜单(基于 Kconfig)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py menuconfig<br></code></pre></td></tr></table></figure><p><img src="/2024/07/01/Embedded/ESP32/0-Ubuntu-idf-menuconfig.png"></p><ul><li><code>menuconfig</code> 用于配置芯片型号, 串口, Wi-Fi 等参数</li><li>配置保存在 <code>sdkconfig</code> 文件中</li></ul></li><li><p>目前阶段可修改的配置</p><ul><li>系统主频: <code>Component config -&gt; ESP system setting -&gt; cpu frequency</code> 选为 240MHz</li><li>Flash 大小: <code>Serial flasher config -&gt; Flash size</code> 选为 16MB(需要根据具体芯片型号选择)</li><li>按 <kbd>S</kbd> 保存, <kbd>Q</kbd> 退出</li></ul></li><li><p>注意: 修改了 <code>menuconfig</code> 后,需要重新编译工程</p></li></ol><h3 id="0-5-工程结构"><a href="#0-5-工程结构" class="headerlink" title="0.5 工程结构"></a>0.5 工程结构</h3><ol><li><p>最基础的 esp-idf 项目结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">my_esp32_project/   # 项目根目录<br>├── CMakeLists.txt  # 项目顶层 CMake 文件(必需): 设置项目名称和包含 esp-idf 构建系统<br>├── sdkconfig       # 项目配置文件(自动生成): 保存 idf.py menuconfig 的所有配置选项<br>├── build/          # 构建输出目录(自动生成): 包含最终的二进制文件(bootloader, 分区表, 应用程序)<br>├── main/           # main 组件(必需且名称固定): 特殊的必需组件.包含应用程序的入口点<br>│   ├── CMakeLists.txt          # main 组件的 CMake 文件<br>│   └── main.c                  # 应用程序入口文件<br>└── components/                 # 自定义组件目录(名称固定)<br>    └── my_component/           # 示例自定义组件<br>        ├── CMakeLists.txt      # 组件的 CMake 文件(必需)<br>        ├── Kconfig.projbuild   # 组件的配置选项(可选)<br>        ├── include/            # 公共头文件目录(可选)<br>        │   └── my_component.h  # 公共头文件<br>        └── src/<br>            └── my_component.c  # 实现文件<br></code></pre></td></tr></table></figure></li><li><p>顶层 <code>CMakeLists.txt</code> </p><ul><li><p>最小项目的 <code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.20</span>) <span class="hljs-comment"># 指定构建本项目所需的 CMake 最低版本</span><br><span class="hljs-keyword">include</span>($ENV&#123;IDF_PATH&#125;/tools/cmake/<span class="hljs-keyword">project</span>.cmake) <span class="hljs-comment"># 包含并导入 esp-idf 构建系统</span><br><span class="hljs-keyword">project</span>(hello_world)                 <span class="hljs-comment"># 定义项目名称并完成项目的最终配置</span><br></code></pre></td></tr></table></figure></li><li><p>可选的配置项</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(IDF_TARGET esp32s3)              <span class="hljs-comment"># 可选: 设置目标芯片型号(默认为 esp32)</span><br><span class="hljs-keyword">set</span>(PARTITIONS_TABLE partitions.csv) <span class="hljs-comment"># 可选: 指定自定义分区表文件</span><br></code></pre></td></tr></table></figure></li><li><p>导入组件到工程(idf 路径下的默认组件无需声明就可以使用.这里介绍的其他组件导入方式)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(EXTRA_COMPONENT_DIRS ../../components) <span class="hljs-comment"># 可选: 指定额外的组件目录</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>main</code> 组件</p><ul><li>包含 <code>app_main()</code> 函数.这是程序的起点</li><li>构建系统会自动将其包含在项目中.无需在顶层 cmake 中显式声明</li><li>可以依赖其他组件,但其他组件不能依赖 <code>main</code> 组件</li></ul></li></ol><h3 id="0-6-组件"><a href="#0-6-组件" class="headerlink" title="0.6 组件"></a>0.6 组件</h3><ol><li><p>**组件(Component): 一个独立的代码库.**包含以下内容</p><ul><li>源代码(<code>.c</code> 文件)</li><li>头文件(<code>.h</code> 文件)</li><li>组件配置文件(<code>Kconfig.projbuild</code>): 配置选项添加到 <code>idf.py menuconfig</code> 的图形化配置菜单中</li><li>编译脚本(<code>CMakeLists.txt</code>): 定义组件的源文件, 头文件, 依赖</li></ul></li><li><p>esp-idf 本身就是由许多这样的组件构成的(如 <code>driver, spi_flash, nvs_flash, freertos</code> 等)</p></li><li><p>组件的 <code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># components/my_component/CMakeLists.txt</span><br>idf_component_register(<br>    SRCS <span class="hljs-string">&quot;src/my_component.c&quot;</span>,  <span class="hljs-comment"># 列出所有源文件</span><br>    INCLUDE_DIRS <span class="hljs-string">&quot;include&quot;</span>,     <span class="hljs-comment"># 列出公共头文件目录.供其他组件包含</span><br>    REQUIRES driver esp_timer   <span class="hljs-comment"># 列出此组件依赖的公共组件</span><br>)<br></code></pre></td></tr></table></figure><ul><li><code>REQUIRES</code>: 声明公共依赖.你的组件的头文件需要这些依赖的头文件.并继续传递下去</li><li><code>PRIV_REQUIRES</code>: 声明私有依赖.这些依赖仅用于你的组件的源文件编译和链接.不会传递给其他组件</li></ul></li><li><p>在 <code>main</code> 组件中使用其他组件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># main/CMakeLists.txt</span><br><br>idf_component_register(<br>    SRCS <span class="hljs-string">&quot;main.c&quot;</span>,<br>    REQUIRES my_component  <span class="hljs-comment"># 声明 main 组件依赖于 my_component</span><br>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="0-7-API-约定"><a href="#0-7-API-约定" class="headerlink" title="0.7 API 约定"></a>0.7 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/api-reference/api-conventions.html">API 约定</a></h3><ol><li><p>编程接口</p><ul><li>在 esp-idf 组件的公共头文件中声明的 C 函数, 结构体, 枚举, 类型定义, 预处理器宏</li><li>编译系统函数, 预定义变量, 选项</li><li><code>Kconfig</code> 选项, 可用于代码及编译系统文件</li><li>主机工具及其命令行参数</li></ul></li><li><p>错误处理</p><ul><li>多数 esp-idf api 会返回由 <code>esp_err_t</code> 类型定义的错误代码.实质上是带符号的整型<ul><li><code>ESP_OK</code> 代表成功,其值定义为0</li><li>错误代码通常均以 <code>ESP_ERR_</code> 前缀开头</li><li>常见错误(比如内存不足, 超时, 无效参数等)的错误代码则已经在 <code>esp_err.h</code> 文件中定义</li></ul></li><li>向 <code>esp_err_to_name</code> 函数传递错误码作为参数即可转换为具体的错误消息</li><li>宏 <code>ESP_ERROR_CHECK</code> 的功能和 <code>assert</code> 类似.若参数不等于 <code>ESP_OK</code>,则打印错误消息,并调用 <code>abort()</code></li></ul></li><li><p>配置结构体</p><ul><li><p>为确保应用程序与未来 esp-idf 版本的兼容性,请正确初始化配置结构体</p></li><li><p>多数 esp-idf 中的初始化, 配置, 安装函数: 形如 <code>..._init(), ..._config(), ..._install()</code>,<br>都需要一个指向配置结构体的指针作为参数</p></li><li><p><strong>应用程序必须初始化结构体的所有字段</strong></p></li><li><p>使用 C99 的指定初始化器完成结构体的初始化.以简洁的方式设置字段,并将剩余字段初始化为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">esp_timer_create_args_t</span> my_timer_args = &#123;<br>    .callback = &amp;my_timer_callback,<br>    <span class="hljs-comment">/* 正确.字段 .arg 和 .name 已初始化为零 */</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>私有 api</p><ul><li><strong>某些头文件包含的 api 仅限于在 esp-idf 源代码中使用,不支持在应用程序中使用</strong></li><li>此类头文件的名称或路径通常带有 <code>private</code> 或 <code>esp_private</code></li><li>私有 api 可能在次要或补丁版本之间以不兼容的方式被删除或更改</li></ul></li><li><p><code>esp-idf</code> 的 <code>freeRTOS</code></p><ul><li>优先级问题: esp32 有双核,因此任务是可以并行的</li><li>esp-idf 自动创建5个任务: 空闲, 定时器, app_main, IPC, ESP 定时器</li><li>esp-idf 不使用原生的 FreeRTOS 内存堆管理,实现了自己的堆</li><li>删除任务应避免删除另一个核心的任务</li><li>临界区使用自旋锁确保同步(因为还有一个核心)</li><li>若任务中用到浮点运算,则创建任务时必须指定具体运行的核心,而不能由系统安排</li><li>通常负责处理无线网络的任务固定到 cpu0, 处理应用程序其余部分的任务被固定到 cpu1</li></ul></li><li><p>在 <code>esp-idf</code> 中,为了支持双核,重新实现了创建任务的 api</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskCreatePinnedToCore</span> <span class="hljs-params">(</span><br><span class="hljs-params">    TaskFunction_t pxTaskCode,  <span class="hljs-comment">// 指向任务函数的指针</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> pcName,   <span class="hljs-comment">// 任务名,最大长度为 configMax_TASK_NAME_LEN</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> configSTACK_DEPTH_TYPE usStackDepth,  <span class="hljs-comment">// 任务堆栈大小,默认单位为4字节</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span> *<span class="hljs-type">const</span> pvParameters,   <span class="hljs-comment">// 传递给任务函数的参数</span></span><br><span class="hljs-params">    UBaseType_t uxPriority,     <span class="hljs-comment">// 任务优先级, 0 ~ configMAX_PRIORITIES - 1</span></span><br><span class="hljs-params">    TaskHandle_t *<span class="hljs-type">const</span> pxCreatedTask,  <span class="hljs-comment">// 任务句柄,即任务的控制块</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> BaseType_t xCoreID    <span class="hljs-comment">// 分配到哪个内核运行</span></span><br><span class="hljs-params">)</span>;<br><span class="hljs-comment">// 返回值 pdPASS 表示创建成功. errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY 表示失败</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="0-8-开发演示"><a href="#0-8-开发演示" class="headerlink" title="0.8 开发演示"></a>0.8 开发演示</h3><ol><li><p>新建项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">source ~/esp/esp-idf/export.sh  # 环境引入<br>idf.py create-project main      # 新建项目<br>mv main &lt;jlc-esp32s3&gt;           # 重命名目录<br>cd &lt;jlc-esp32s3&gt;                # 进入工作目录<br></code></pre></td></tr></table></figure></li><li><p>初始化 git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim .gitignore                  # 忽略 build/ .vscode/<br>git init &amp;&amp; git add .           # 暂存所有文件<br>git commit -m &quot;git init&quot;        # 首次提交<br></code></pre></td></tr></table></figure></li><li><p>编译烧录(需先编写代码)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py set-target esp32s3       # 选择开发板上的芯片型号<br>idf.py build flash monitor      # 构建, 烧录, 监视<br></code></pre></td></tr></table></figure></li><li><p>引入 C&#x2F;C++ 插件进行文件跳转工具: 新建文件 <code>.vscode/c_cpp_properties.json</code><br> 需要注意 构建时是否生成了 <code>build/compile_commands.json</code> 文件.这是跳转功能的关键</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ESP-IDF&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;compileCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/build/compile_commands.json&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gcc-x64&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>[编辑默认配置](# 0.4 工程配置)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py menuconfig     # 根据 esp 的型号配置 config<br>idf.py save-defconfig # 将其保存为 sdkconfig.defaults<br>                      # 若发现该更改未生效,可以将 sdkconfig 文件删除后重新编译<br></code></pre></td></tr></table></figure></li></ol><h3 id="0-9-组件建立"><a href="#0-9-组件建立" class="headerlink" title="0.9 组件建立"></a>0.9 组件建立</h3><ol><li><p>新建 <code>components/jlc_esp32s3</code> 目录作为 esp32-s3 实战派的板级支持包.具体如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">your_project/<br>├── components/<br>│   └── jlc_esp32s3/          # 板级支持包组件<br>│       ├── CMakeLists.txt    # 组件构建配置<br>│       ├── Kconfig.projbuild # 组件配置选项<br>│       ├── include/<br>│       │   └── jlc_esp32s3.h # 公共头文件<br>│       └── src/<br>│           ├── jlc_esp32s3.c # 主要实现文件<br>├── main/<br>│   ├── CMakeLists.txt<br>│   └── main.c<br>└── CMakeLists.txt<br></code></pre></td></tr></table></figure></li><li><p>组件 <code>cmake</code> 配置(<code>components/jlc_esp32s3/CMakeLists.txt</code>)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cmake">idf_component_register(<br>    SRCS<br>        <span class="hljs-string">&quot;src/jlc_esp32s3.c&quot;</span><br>    INCLUDE_DIRS<br>        <span class="hljs-string">&quot;include&quot;</span><br>    REQUIRES<br>        driver      <span class="hljs-comment"># 基础外设驱动(gpio, i2c, adc...)</span><br>        log         <span class="hljs-comment"># 日志系统</span><br>    PRIV_REQUIRES<br>        nvs_flash   <span class="hljs-comment"># 非易失存储</span><br>        esp_timer   <span class="hljs-comment"># 定时器</span><br>        freertos    <span class="hljs-comment"># RTOS 功能</span><br>)<br></code></pre></td></tr></table></figure></li><li><p>组件 <code>Kconfig</code> 配置文件(<code>components/jlc_esp32s3/Kconfig.projbuild</code>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kconfig">menu &quot;jlc szp esp32-s3 config&quot;<br><br>    config JLC_SZP_BOARD_VERSION<br>        string &quot;board version&quot;<br>        default &quot;V1.0&quot;<br>        help<br>            jlc szp esp32-s3 board version<br><br>endmenu<br></code></pre></td></tr></table></figure></li><li><p>公共头文件(<code>components/jlc_esp32s3/include/jlc_esp32s3.h</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">jlc_szp_get_board_info</span><span class="hljs-params">(<span class="hljs-type">char</span> *info, <span class="hljs-type">int</span> len)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>主要实现文件(<code>components/jlc_esp32s3/src/jlc_esp32s3.c</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sdkconfig.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;jlc_esp32s3.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">jlc_szp_get_board_info</span><span class="hljs-params">(<span class="hljs-type">char</span> *info, <span class="hljs-type">int</span> len)</span><br>&#123;<br>    <span class="hljs-built_in">snprintf</span>(info, len, <span class="hljs-string">&quot;jlc szp verison: %s&quot;</span>, CONFIG_JLC_SZP_BOARD_VERSION);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在主程序中使用建立的组件</p><ul><li><p>在 <code>main/CMakeLists.txt</code> 引入组件依赖</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">idf_component_register(<br>    REQUIRES jlc_esp32s3<br>)<br></code></pre></td></tr></table></figure></li><li><p>在 <code>main/main.c</code> 中调用函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;jlc_esp32s3.h&quot;</span></span><br>jlc_szp_get_board_info(board_info, <span class="hljs-keyword">sizeof</span>(board_info) - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-基础外设"><a href="#1-基础外设" class="headerlink" title="1 基础外设"></a>1 基础外设</h2><h3 id="1-1-GPIO"><a href="#1-1-GPIO" class="headerlink" title="1.1 GPIO"></a>1.1 GPIO</h3><ol><li><p>esp32-s3 芯片具有 48 个物理 gpio pin</p><ul><li>每个 pin 都可用作一个通用的 io, 或连接一个内部的外设信号</li><li>通过 io mux, rtc io mux, gpio 交换矩阵,可配置外设模块的输入 &#x2F; 输出信号来源于任何 pin</li></ul></li><li><p>使用示例(GPIO0 下降沿触发后获取 GPIO 端口和电平值)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;freertos/FreeRTOS.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;freertos/task.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;freertos/queue.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/gpio.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USER_KEY_GPIO GPIO_NUM_0            <span class="hljs-comment">// 按键 gpio</span></span><br><span class="hljs-type">static</span> QueueHandle_t user_key_queue = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 队列句柄</span><br><br><span class="hljs-comment">/* GPIO 中断服务函数.该函数只是将消息传递给任务函数,并不进行处理 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> IRAM_ATTR <span class="hljs-title function_">gpio_isr_handler</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> gpio_num = (<span class="hljs-type">uint32_t</span>) arg;<br>    xQueueSendFromISR(user_key_queue, &amp;gpio_num, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-comment">/* GPIO 中断处理任务.该任务接收消息队列的数据.然后将其打印 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">key_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> gpio_num;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span>(xQueueReceive(user_key_queue, &amp;gpio_num, portMAX_DELAY))<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;GPIO[%ld] intr. val: %d\n&quot;</span>, gpio_num, gpio_get_level(gpio_num));<br>&#125;<br><br><span class="hljs-comment">/* user key gpio init */</span><br><span class="hljs-type">gpio_config_t</span> io0_conf = &#123;<br>    .intr_type = GPIO_INTR_NEGEDGE,        <span class="hljs-comment">// 下降沿中断</span><br>    .mode = GPIO_MODE_INPUT,               <span class="hljs-comment">// 输入模式</span><br>    .pin_bit_mask = <span class="hljs-number">1ULL</span> &lt;&lt; USER_KEY_GPIO, <span class="hljs-comment">// 选择 GPIO0</span><br>    .pull_down_en = <span class="hljs-number">0</span>,                     <span class="hljs-comment">// 禁能内部下拉</span><br>    .pull_up_en = <span class="hljs-number">1</span>                        <span class="hljs-comment">// 使能内部上拉</span><br>&#125;;<br>gpio_config(&amp;io0_conf);<br>gpio_install_isr_service(<span class="hljs-number">0</span>);<br>gpio_isr_handler_add(USER_KEY_GPIO, gpio_isr_handler, (<span class="hljs-type">void</span> *)USER_KEY_GPIO);<br><br>user_key_queue = xQueueCreate(<span class="hljs-number">10</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint32_t</span>));     <span class="hljs-comment">// 创建消息队列</span><br>xTaskCreate(key_task, <span class="hljs-string">&quot;key_task&quot;</span>, <span class="hljs-number">2048</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 创建中断任务</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="1-2-LEDC"><a href="#1-2-LEDC" class="headerlink" title="1.2 LEDC"></a>1.2 LEDC</h3><ol><li><p>ledc 主要用于控制 LED,也可产生 pwm 信号用于其他设备的控制</p><ul><li>led pwm 控制器可在无需 cpu 干预的情况下自动改变占空比,实现亮度和颜色渐变</li><li>该控制器有 8 路通道,可以产生独立的波形,驱动 rgb led 等设备</li><li>ledc 通道共有两组,分别为 8 路高速通道和 8 路低速通道<ul><li>高速通道模式在硬件中实现,可以自动且无干扰地改变 pwm 占空比</li><li>低速通道模式下,pwm 占空比需要由软件中的驱动器改变,每组通道都可以使用不同的时钟源</li></ul></li></ul></li><li><p>使用示例(使用 ledc_channel_0 和 timer0 调节引脚 pwm 占空比)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/ledc.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDC_GPIO         GPIO_NUM_42         <span class="hljs-comment">// 使用 GPIO42 连接 led</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDC_CHANNEL      LEDC_CHANNEL_0      <span class="hljs-comment">// 使用 channel0(共8个)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDC_TIMER        LEDC_TIMER_0        <span class="hljs-comment">// 使用 timer0(共4个)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDC_MODE         LEDC_LOW_SPEED_MODE <span class="hljs-comment">// 使用 低速模式</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDC_DUTY_RES     LEDC_TIMER_13_BIT   <span class="hljs-comment">// 设置 13bit 分辨率.2^13 = 8192级亮度</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDC_FREQUENCY    5000                <span class="hljs-comment">// PWM 频率 5kHz</span></span><br><br><span class="hljs-comment">/* 1. 配置定时器 */</span><br><span class="hljs-type">ledc_timer_config_t</span> ledc_timer = &#123;<br>    .speed_mode       = LEDC_MODE,      <span class="hljs-comment">// 速度模式</span><br>    .timer_num        = LEDC_TIMER,     <span class="hljs-comment">// 选择定时器0</span><br>    .duty_resolution  = LEDC_DUTY_RES,  <span class="hljs-comment">// 设置分辨率</span><br>    .freq_hz          = LEDC_FREQUENCY, <span class="hljs-comment">// PWM 频率 5kHz</span><br>    .clk_cfg          = LEDC_AUTO_CLK,  <span class="hljs-comment">// 自动选择时钟源</span><br>&#125;;<br>ledc_timer_config(&amp;ledc_timer);<br><br><span class="hljs-comment">/* 2. 配置通道 */</span><br><span class="hljs-type">ledc_channel_config_t</span> ledc_channel = &#123;<br>    .speed_mode     = LEDC_MODE,         <span class="hljs-comment">// 速度模式与定时器一致</span><br>    .channel        = LEDC_CHANNEL,      <span class="hljs-comment">// 选择通道0</span><br>    .timer_sel      = LEDC_TIMER,        <span class="hljs-comment">// 绑定到定时器0</span><br>    .intr_type      = LEDC_INTR_DISABLE, <span class="hljs-comment">// 禁用中断</span><br>    .gpio_num       = LEDC_GPIO,         <span class="hljs-comment">// 绑定引脚</span><br>    .duty           = <span class="hljs-number">0</span>,                 <span class="hljs-comment">// 初始占空比为0</span><br>    .hpoint         = <span class="hljs-number">0</span>                  <span class="hljs-comment">// 相位点.通常设为0</span><br>&#125;;<br>ledc_channel_config(&amp;ledc_channel);<br><br><span class="hljs-comment">/* ledc set duty */</span><br>ledc_set_duty(LEDC_MODE, LEDC_CHANNEL, duty);  <span class="hljs-comment">// duty: 0 ~ 2^13-1</span><br>ledc_update_duty(LEDC_MODE, LEDC_CHANNEL);<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-3-UART"><a href="#1-3-UART" class="headerlink" title="1.3 UART"></a>1.3 UART</h3><ol><li><p>esp32-s3 包含2个 uart 控制器(几乎所有 gpio 都可以用作 uart 引脚)</p><table><thead><tr><th>uart 控制器</th><th>rx pin (默认)</th><th>tx pin (默认)</th><th>说明</th></tr></thead><tbody><tr><td>uart0</td><td>io44</td><td>io43</td><td>通常用于程序下载和日志输出(Serial Monitor)</td></tr><tr><td>uart1</td><td>io18</td><td>io17</td><td>引脚可任意映射.可安全用于通用用途的 uart</td></tr></tbody></table><ul><li>可配置的波特率(最高 5Mbps)</li><li>可配置的数据位(5-8); 停止位(1, 1.5, 2); 奇偶校验位(偶, 奇, 无)</li><li>支持多种中断(发送完成, 接收数据, 接收超时, 错误等)</li><li>独立的 tx 和 rx 环形缓冲区</li><li>支持 RS485 模式和自动流控制(CTS&#x2F;RTS)</li></ul></li><li><p>使用示例(使用 uart2 发送 &#x2F; 接收数据)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/uart.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART_NUM UART_NUM_2     <span class="hljs-comment">// 使用 uart2</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TXD_PIN GPIO_NUM_11     <span class="hljs-comment">// tx pin 映射</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RXD_PIN GPIO_NUM_10     <span class="hljs-comment">// rx pin 映射</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE (1024)         <span class="hljs-comment">// 缓冲区大小</span></span><br><br><span class="hljs-comment">/* uart init */</span><br><span class="hljs-type">uart_config_t</span> uart_config = &#123;<br>    .baud_rate = <span class="hljs-number">9600</span>,                     <span class="hljs-comment">// 波特率</span><br>    .data_bits = UART_DATA_8_BITS,         <span class="hljs-comment">// 数据位</span><br>    .parity = UART_PARITY_DISABLE,         <span class="hljs-comment">// 校验位</span><br>    .stop_bits = UART_STOP_BITS_1,         <span class="hljs-comment">// 停止位</span><br>    .flow_ctrl = UART_HW_FLOWCTRL_DISABLE, <span class="hljs-comment">// 流控制</span><br>    .source_clk = UART_SCLK_DEFAULT,       <span class="hljs-comment">// 时钟源</span><br>&#125;;<br>uart_param_config(UART_NUM, &amp;uart_config);<br>uart_set_pin(UART_NUM, TXD_PIN, RXD_PIN, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);<br>uart_driver_install(UART_NUM, BUF_SIZE, BUF_SIZE, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">/* uart send data(const char* data) */</span><br>uart_write_bytes(UART_NUM, data, <span class="hljs-built_in">strlen</span>(data));         <span class="hljs-comment">// 发送数据</span><br>uart_wait_tx_done(UART_NUM, <span class="hljs-number">100</span> / portTICK_PERIOD_MS);  <span class="hljs-comment">// 等待发送完成</span><br><br><span class="hljs-comment">/* uart receive data */</span><br><span class="hljs-type">uint8_t</span> data[<span class="hljs-number">128</span>];<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-type">int</span> len = uart_read_bytes(UART_NUM_1, data, <span class="hljs-keyword">sizeof</span>(data) - <span class="hljs-number">1</span>, <span class="hljs-number">20</span> / portTICK_PERIOD_MS);<br>    <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>        data[len] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">// 添加字符串结束符</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received %d bytes: %s&quot;</span>, len, data);<br>    &#125;<br>    vTaskDelay(<span class="hljs-number">10</span> / portTICK_PERIOD_MS);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-4-I2C"><a href="#1-4-I2C" class="headerlink" title="1.4 I2C"></a>1.4 I2C</h3><ol><li><p>esp32-s3 包含2个 i2c 控制器(几乎所有 gpio 都可以用作 i2c 引脚)</p><ul><li>支持 7bit(常用)和 10bit 设备地址</li><li>标准模式(100 Kbps) 和快速模式(400 Kbps)</li></ul></li><li><p>目标: 与 qmi8658(sda –&gt; io1, scl –&gt; io2) 通信.获取加速度和倾角值(读取 0x0 的 id 寄存器,预期为 0x5)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/i2c_master.h&quot;</span></span><br><br><span class="hljs-comment">/* i2c bus init */</span><br><span class="hljs-type">static</span> <span class="hljs-type">i2c_master_bus_handle_t</span> bus_handle;<br><span class="hljs-type">i2c_master_bus_config_t</span> i2c_mst_config = &#123;<br>    .i2c_port = I2C_NUM_0,                <span class="hljs-comment">// i2c0 控制器</span><br>    .scl_io_num = GPIO_NUM_2,             <span class="hljs-comment">// scl - io2</span><br>    .sda_io_num = GPIO_NUM_1,             <span class="hljs-comment">// sda - io1</span><br>    .glitch_ignore_cnt = <span class="hljs-number">7</span>,               <span class="hljs-comment">// 毛刺忽略计数.抗干扰</span><br>    .clk_source = I2C_CLK_SRC_DEFAULT,    <span class="hljs-comment">// 默认时钟源</span><br>    .flags.enable_internal_pullup = <span class="hljs-literal">true</span>, <span class="hljs-comment">// 启用内部上拉</span><br>&#125;;<br>i2c_new_master_bus(&amp;i2c_mst_config, &amp;bus_handle);<br><br><span class="hljs-comment">/* i2c bus add device */</span><br><span class="hljs-type">static</span> <span class="hljs-type">i2c_master_dev_handle_t</span> qmi8658_handle;<br><span class="hljs-type">i2c_device_config_t</span> dev_cfg = &#123;<br>    .dev_addr_length = I2C_ADDR_BIT_LEN_7, <span class="hljs-comment">// 7bit 设备地址模式</span><br>    .device_address = <span class="hljs-number">0x6A</span>,                <span class="hljs-comment">// qmi8658 的 I2C 地址为 0x6A(7bit)</span><br>    .scl_speed_hz = <span class="hljs-number">100000</span>,                <span class="hljs-comment">// SCL 时钟频率为 100kHz(标准模式)</span><br>&#125;;<br><span class="hljs-type">i2c_master_bus_handle_t</span> bus_handle;<br>i2c_master_get_bus_handle(I2C_NUM_0, &amp;bus_handle); <span class="hljs-comment">// 在其他文件获取 i2c bus handle</span><br>i2c_master_bus_add_device(bus_handle, &amp;dev_cfg, &amp;qmi8658_handle);<br><br><span class="hljs-comment">/* read qmi8658 register */</span><br><span class="hljs-type">static</span> <span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">qmi8658_read_reg</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> reg, <span class="hljs-type">uint8_t</span> *data, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> i2c_master_transmit_receive(qmi8658_handle, &amp;reg, <span class="hljs-number">1</span>, data, len, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-comment">/* write qmi8658 register */</span><br><span class="hljs-type">static</span> <span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">qmi8658_write_reg</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> reg, <span class="hljs-type">uint8_t</span> data)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> write_buf[<span class="hljs-number">2</span>] = &#123;reg, data&#125;;<br>    <span class="hljs-keyword">return</span> i2c_master_transmit(qmi8658_handle, write_buf, <span class="hljs-keyword">sizeof</span>(write_buf), <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-5-SPI"><a href="#1-5-SPI" class="headerlink" title="1.5 SPI"></a>1.5 SPI</h3><ol><li><p>ESP32-S3 包含4个 spi 控制器</p><ul><li>spi0, spi1: 专用 spi 控制器.以 qspi 模式与 flash, psram 进行通信</li><li>spi2, spi3: 通用 spi 控制器.支持通用的主机 &#x2F; 从机通信</li><li>支持标准 spi, dual spi, quad spi 模式</li><li>最高 80MHz 时钟频率</li></ul></li><li><p>使用示例(使用 spi2_host 发送 command &#x2F; data)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/spi_master.h&quot;</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">spi_device_handle_t</span> spi_handle;<br><span class="hljs-comment">/* spi bus init */</span><br><span class="hljs-type">spi_bus_config_t</span> bus_config = &#123;<br>    .mosi_io_num = GPIO_NUM_11,         <span class="hljs-comment">// MOSI 引脚 (主出从入)</span><br>    .miso_io_num = GPIO_NUM_13,         <span class="hljs-comment">// MISO 引脚 (主入从出)</span><br>    .sclk_io_num = GPIO_NUM_12,         <span class="hljs-comment">// SCLK 时钟引脚</span><br>    .quadwp_io_num = GPIO_NUM_NC,       <span class="hljs-comment">// 未使用 Quad spi 的 WP 引脚</span><br>    .quadhd_io_num = GPIO_NUM_NC,       <span class="hljs-comment">// 未使用 Quad spi 的 HD 引脚</span><br>    .max_transfer_sz = <span class="hljs-number">4096</span>,            <span class="hljs-comment">// 最大传输大小</span><br>    .flags = SPICOMMON_BUSFLAG_MASTER,  <span class="hljs-comment">// 主模式标志</span><br>&#125;;<br>spi_bus_initialize(SPI2_HOST, &amp;bus_config, SPI_DMA_CH_AUTO);<br><br><span class="hljs-comment">/* spi bus add device */</span><br><span class="hljs-type">spi_device_interface_config_t</span> dev_config = &#123;<br>    .command_bits = <span class="hljs-number">0</span>,                  <span class="hljs-comment">// 命令位数为0(不使用命令相位)</span><br>    .address_bits = <span class="hljs-number">0</span>,                  <span class="hljs-comment">// 地址位数为0(不使用地址相位)</span><br>    .dummy_bits = <span class="hljs-number">0</span>,                    <span class="hljs-comment">// 虚拟位数为0</span><br>    .mode = <span class="hljs-number">0</span>,                          <span class="hljs-comment">// spi mode0(CPOL=0, CPHA=0)</span><br>    .duty_cycle_pos = <span class="hljs-number">128</span>,              <span class="hljs-comment">// 时钟占空比(默认50%)</span><br>    .cs_ena_pretrans = <span class="hljs-number">0</span>,               <span class="hljs-comment">// 传输前 CS 建立时间</span><br>    .cs_ena_posttrans = <span class="hljs-number">0</span>,              <span class="hljs-comment">// 传输后 CS 保持时间</span><br>    .clock_speed_hz = <span class="hljs-number">1</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>,  <span class="hljs-comment">// 时钟频率 1MHz</span><br>    .input_delay_ns = <span class="hljs-number">0</span>,                <span class="hljs-comment">// 输入延迟</span><br>    .spics_io_num = GPIO_NUM_10,        <span class="hljs-comment">// CS 片选引脚.自动管理</span><br>    .flags = <span class="hljs-number">0</span>,                         <span class="hljs-comment">// 附加标志</span><br>    .queue_size = <span class="hljs-number">7</span>,                    <span class="hljs-comment">// 传输队列大小</span><br>    .pre_cb = <span class="hljs-literal">NULL</span>,                     <span class="hljs-comment">// 传输前回调函数</span><br>    .post_cb = <span class="hljs-literal">NULL</span>,                    <span class="hljs-comment">// 传输后回调函数</span><br>&#125;;<br>spi_bus_add_device(SPI2_HOST, &amp;dev_config, &amp;spi_handle);<br><br><span class="hljs-comment">/* spi send command / data */</span><br>ssd1681_gpio_set_dc(<span class="hljs-number">0</span>); <span class="hljs-comment">// dc = 0 表示发送命令.发送数据使用 ssd1681_gpio_set_dc(1);</span><br><span class="hljs-type">spi_transaction_t</span> transaction = &#123;<br>    .length = <span class="hljs-number">8</span>,<br>    .tx_buffer = &amp;cmd,  <span class="hljs-comment">// cmd / data: const unsigned char</span><br>&#125;;<br>spi_device_transmit(spi_handle, &amp;transaction);<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-6-I2S"><a href="#1-6-I2S" class="headerlink" title="1.6 I2S"></a>1.6 I2S</h3><ol><li><p>i2s(Inter-IC Sound): 数字音频数据传输的同步串行通信协议</p><ul><li>bit clock: 每个脉冲对应一个数字音频 bit 的传输(bit clock &#x3D; 采样率 * 位宽 * 通道数)</li><li>word select: 左(低电平)右(高电平)声道选择.其频率与采样率相同</li></ul></li><li><p>esp32-s3 包含2个独立的 i2s 控制器,功能完全相同(几乎所有 gpio 都可以用作 i2s 引脚))</p><ul><li>支持全双工 &#x2F; 半双工</li><li>可作为 i2s master &#x2F; slave</li><li>数据位宽支持 8, 16, 24, 32bit</li></ul></li><li><p>使用示例(使用 i2s0 读写数据)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/i2s_std.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SAMPLE_RATE 16000  <span class="hljs-comment">// 采样率.需要与 codec 保持一致</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">i2s_chan_handle_t</span> tx_handle; <span class="hljs-comment">// 发送通道句柄(播放)</span><br><span class="hljs-type">static</span> <span class="hljs-type">i2s_chan_handle_t</span> rx_handle; <span class="hljs-comment">// 接收通道句柄(录音)</span><br><br><span class="hljs-comment">/* 配置 esp32-s3 作为 i2s master,为 es8311, es7210 提供共享时钟 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">codec_i2s_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 1. 配置通道参数,创建发送和接收通道</span><br>    <span class="hljs-type">i2s_chan_config_t</span> chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_MASTER);<br>    chan_cfg.auto_clear = <span class="hljs-literal">true</span>; <span class="hljs-comment">// dma 缓冲区自动清除</span><br>    i2s_new_channel(&amp;chan_cfg, &amp;tx_handle, &amp;rx_handle);<br><br>    <span class="hljs-comment">// 2. 配置 i2s 发送数据通道为 std 模式</span><br>    <span class="hljs-type">i2s_std_config_t</span> std_cfg = &#123;<br>        .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(SAMPLE_RATE), <span class="hljs-comment">// 时钟配置</span><br>        .slot_cfg = I2S_STD_PHILIPS_SLOT_DEFAULT_CONFIG(    <span class="hljs-comment">// 时隙配置</span><br>            I2S_DATA_BIT_WIDTH_16BIT, <span class="hljs-comment">// bit width: 16bit</span><br>            I2S_SLOT_MODE_STEREO      <span class="hljs-comment">// stereo: 立体声</span><br>        ),<br>        .gpio_cfg = &#123;<br>            .mclk = GPIO_I2S_MCK,  <span class="hljs-comment">// 主时钟 mclk = 采样率 * mclk 倍数 = 16k * 256 = 4.096MHz</span><br>            .bclk = GPIO_I2S_BCK,  <span class="hljs-comment">// 位时钟 bclk = 采样率 * 位深 * 声道数 = 16k * 16 * 2 = 512KHz</span><br>            .ws   = GPIO_I2S_WS,   <span class="hljs-comment">// 字切换 ws(lrclk) = 采样率 = 16KHz</span><br>            .dout = GPIO_I2S_D0,   <span class="hljs-comment">// 数据输出.输出到 es8311 然后播放</span><br>            .din  = GPIO_I2S_DI,   <span class="hljs-comment">// 数据输入.从 es7210 读取输入数据</span><br>        &#125;,<br>    &#125;;<br><br>    <span class="hljs-comment">// 3. 分别初始化发送和接收通道(使用相同配置)</span><br>    i2s_channel_init_std_mode(tx_handle, &amp;std_cfg);<br>    i2s_channel_init_std_mode(rx_handle, &amp;std_cfg);<br><br>    <span class="hljs-comment">// 4. 启用通道</span><br>    i2s_channel_enable(tx_handle);<br>    i2s_channel_enable(rx_handle);<br>&#125;<br><br><span class="hljs-comment">/* 发送音频数据. data: 数据地址; size: 数据量(byte); bytes_written: 实际写入量 */</span><br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">i2s_play_audio</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> *bytes_written)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> i2s_channel_write(tx_handle, data, size, bytes_written, portMAX_DELAY);<br>&#125;<br><br><span class="hljs-comment">/* 读取音频数据. data: 数据地址; size: 数据量(byte); bytes_read: 实际读取量 */</span><br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">i2s_record_audio</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> *bytes_read)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> i2s_channel_read(rx_handle, data, size, bytes_read, portMAX_DELAY);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-7-PSRAM"><a href="#1-7-PSRAM" class="headerlink" title="1.7 PSRAM"></a>1.7 PSRAM</h3><ol><li><p>esp-idf 默认不启用 psram(因为会影响功耗和稳定性).即使硬件支持也需在配置中显式开启</p></li><li><p>启用 psram: 在 <code>menuconfig</code> 中开启 <code>external SPI-connected RAM</code> 并选择为 <code>Octal Mode PSRAM</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Component config -&gt; ESP PSRAM -&gt; Support for external, SPI-connected RAM -&gt; SPI RAM config<br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启 psram: Mode (QUAD/OCT) of SPI RAM chip <span class="hljs-keyword">in</span> use (Octal Mode PSRAM) -&gt; Octal Mode PSRAM</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置频率: Set RAM clock speed -&gt; 80MHz</span><br></code></pre></td></tr></table></figure></li><li><p>日志分析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">boot.esp32s3: Boot SPI Speed : 80MHz  # spi flash 运行频率为 80MHz<br>boot.esp32s3: SPI Mode       : DIO    # DIO 模式(Dual I/O, 双线数据输入输出)<br>boot.esp32s3: SPI Flash Size : 16MB   # 检测到外部 spi Flash 容量为 16MB<br><br>boot: ## Label     Usage       Type  ST   Offset    Length<br>boot:  0 nvs       WiFi data    01   02  00009000  00006000 # 存储 Wi-Fi 配置等非易失性数据<br>boot:  1 phy_init  RF data      01   01  0000f000  00001000 # 存储 RF 射频校准数据<br>boot:  2 factory   factory app  00   00  00010000  00100000 # 主应用程序固件分区<br><br>I (233) esp_psram: Found 8MB PSRAM device  # 检测到 8MB Octal psram,初始化成功<br>I (238) esp_psram: Speed: 40MHz            # psram 频率: 40MHz<br>I (973) esp_psram: SPI SRAM memory test OK # psram 自检通过.耗时较长,约 700ms<br><br>cpu_start: Pro cpu start user code         # 主核(CPU0)开始执行用户代码<br>cpu_start: cpu freq: 160000000 Hz          # CPU 主频设置为 160MHz<br><br>heap_init: Initializing. RAM available for dynamic allocation:    # 初始化堆内存<br>heap_init: At 3FC95C20 len 00053AF0 (334 KiB): RAM                # 内部 ram<br>heap_init: At 3FCE9710 len 00005724 (21 KiB): RAM                 # 内部 ram<br>heap_init: At 3FCF0000 len 00008000 (32 KiB): DRAM                # 用于 DMA<br>heap_init: At 600FE010 len 00001FD8 (7 KiB): RTCRAM               # 深度睡眠可保留内存<br>esp_psram: Adding pool of 8192K of PSRAM memory to heap allocator # psram 加入堆分配器<br><br>I (1104) main_task: Calling app_main() # 调用用户编写的 app_main(),应用程序正式运行<br></code></pre></td></tr></table></figure></li><li><p>psram 内存申请(系统初始化后,psram 将自动加入堆分配器)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* malloc 可能分配到内部 ram 或 psram(优先使用内部 ram,大内存会自动分配到 psram) */</span><br><span class="hljs-type">uint8_t</span> *buffer = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>); <span class="hljs-comment">// 分配 2MB</span><br><br><span class="hljs-comment">/* 强制分配到 psram */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_heap_caps.h&quot;</span></span><br><span class="hljs-type">uint8_t</span> *psram_buffer = heap_caps_malloc(<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>, MALLOC_CAP_SPIRAM); <br><br><span class="hljs-comment">/* 将 c++ 对象分配到 psram */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SensorData</span> &#123;</span><br>public:<br>    <span class="hljs-type">float</span> readings[<span class="hljs-number">2048</span>];<br>&#125;;<br><span class="hljs-type">void</span>* operator <span class="hljs-title function_">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> &#123;<br>    <span class="hljs-keyword">return</span> heap_caps_malloc(size, MALLOC_CAP_SPIRAM);<br>&#125;<br><br>SensorData *data = new SensorData();<br></code></pre></td></tr></table></figure></li><li><p>最佳实践</p><ul><li>psram: 大型缓冲(图像 &#x2F; 音频), 不频繁访问的配置数据</li><li>ram(内部): 被高频访问的数据, dma 缓冲区, rtos 任务栈</li></ul></li></ol><h2 id="2-设备驱动"><a href="#2-设备驱动" class="headerlink" title="2 设备驱动"></a>2 设备驱动</h2><h3 id="2-1-TF"><a href="#2-1-TF" class="headerlink" title="2.1 TF"></a>2.1 TF</h3><ol><li><p>通信方式: spi &#x2F; sdio(这里采用 sdio 的 1bit 模式.即只使用 DAT0 数据线)</p></li><li><p>esp32-s3(ESP32-S3-WROOM-1) 的 <code>sdmmc</code> 控制器(引脚固定.无法更改)</p><table><thead><tr><th align="left">信号线</th><th align="left">GPIO 引脚</th><th align="left">功能描述</th></tr></thead><tbody><tr><td align="left">CMD</td><td align="left">GPIO48</td><td align="left">命令 &#x2F; 响应线</td></tr><tr><td align="left">CLK</td><td align="left">GPIO47</td><td align="left">时钟信号</td></tr><tr><td align="left">DAT0</td><td align="left">GPIO21</td><td align="left">数据线0</td></tr><tr><td align="left">DAT1</td><td align="left">GPIO20</td><td align="left">数据线1 (1位模式不需要)</td></tr><tr><td align="left">DAT2</td><td align="left">GPIO19</td><td align="left">数据线2 (1位模式不需要)</td></tr><tr><td align="left">DAT3</td><td align="left">GPIO18</td><td align="left">数据线3 (1位模式不需要)</td></tr></tbody></table></li><li><p>在 <code>main/CMakeLists.txt</code> 中添加</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">REQUIRES fatfs sdmmc<br></code></pre></td></tr></table></figure></li><li><p><code>sdmmc</code> 相关接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/sdmmc_host.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_vfs_fat.h&quot;</span> <span class="hljs-comment">// 虚拟文件系统层.负责文件系统挂载</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sdmmc_cmd.h&quot;</span>   <span class="hljs-comment">// 提供 SD 卡通信协议</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SD_MOUNT_POINT <span class="hljs-string">&quot;/sdcard&quot;</span>  <span class="hljs-comment">// SD 卡在文件系统中的根目录</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *TAG = <span class="hljs-string">&quot;sdmmc&quot;</span>;<br><br><span class="hljs-comment">/* sd card mount */</span><br><span class="hljs-comment">// 1. 配置 SDMMC 主机 - 使用 1bit 模式</span><br><span class="hljs-type">sdmmc_host_t</span> host = SDMMC_HOST_DEFAULT();<br>host.max_freq_khz = SDMMC_FREQ_DEFAULT;  <span class="hljs-comment">// 初始频率 20MHz</span><br>host.flags = SDMMC_HOST_FLAG_1BIT;       <span class="hljs-comment">// 1bit mode</span><br><span class="hljs-comment">// 2. 配置 SDMMC 槽位 - 只需要3个引脚</span><br><span class="hljs-type">sdmmc_slot_config_t</span> slot_config = SDMMC_SLOT_CONFIG_DEFAULT();<br>slot_config.width = <span class="hljs-number">1</span>;                   <span class="hljs-comment">// 1bit 总线宽度</span><br><span class="hljs-comment">// ESP32-S3-WROOM-1 专用引脚配置(DAT1, DAT2, DAT3 不需要配置,会自动忽略)</span><br>slot_config.clk = GPIO_NUM_47;           <span class="hljs-comment">// 时钟 - GPIO47</span><br>slot_config.cmd = GPIO_NUM_48;           <span class="hljs-comment">// 命令线 - GPIO48</span><br>slot_config.d0 = GPIO_NUM_21;            <span class="hljs-comment">// 数据线0 - GPIO21</span><br>slot_config.flags |= SDMMC_SLOT_FLAG_INTERNAL_PULLUP;  <span class="hljs-comment">// 启用内部上拉</span><br><span class="hljs-comment">// 3. 配置挂载参数</span><br><span class="hljs-type">esp_vfs_fat_sdmmc_mount_config_t</span> mount_config = &#123;<br>    .format_if_mount_failed = <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 如果挂载不成功是否需要格式化 sd card</span><br>    .max_files = <span class="hljs-number">5</span>,                   <span class="hljs-comment">// 允许打开的最大文件数</span><br>    .allocation_unit_size = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span>  <span class="hljs-comment">// 分配单元大小为 8k</span><br>&#125;;<br><span class="hljs-comment">// 4. 挂载文件系统</span><br><span class="hljs-type">sdmmc_card_t</span> *card;<br>esp_vfs_fat_sdmmc_mount(SD_MOUNT_POINT, &amp;host, &amp;slot_config, &amp;mount_config, &amp;card);<br><span class="hljs-comment">// 5. 打印 SD 卡信息</span><br>sdmmc_card_print_info(<span class="hljs-built_in">stdout</span>, card);<br><br><span class="hljs-comment">/* sd card unmount */</span><br><span class="hljs-type">sdmmc_card_t</span> *card = sdcard_mount();<br>esp_vfs_fat_sdcard_unmount(SD_MOUNT_POINT, card);<br><br><span class="hljs-comment">/* write / read data */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *path = SD_MOUNT_POINT <span class="hljs-string">&quot;/a.txt&quot;</span>;<br>FILE *f = fopen(path, <span class="hljs-string">&quot;rw&quot;</span>);<br><span class="hljs-keyword">if</span> (f) &#123;<br>    <span class="hljs-comment">// 使用标准库读写文件的接口</span><br>    fclose(f);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>menuconfig</code> 配置项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Component config → FAT Filesystem support<br><span class="hljs-meta prompt_"># </span><span class="language-bash">长文件名支持(默认仅支持8字符): Long filename support → Long file name buffer <span class="hljs-keyword">in</span> heap</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">中文支持: OEM Code Page → Simplified Chinese (DBCS) (CP936)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编码格式: API character encoding → API <span class="hljs-built_in">users</span> UTF-8 encoding</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-MIC"><a href="#2-2-MIC" class="headerlink" title="2.2 MIC"></a>2.2 MIC</h3><ol><li><p>使用 es7210 录音</p><ul><li>通过 [i2c](# 1.4 I2C) 配置 es7210 codec</li><li>通过 [i2s](# 1.6 I2S) 接收数据(I2S_DI)</li></ul></li><li><p>移植 <a href="https://components.espressif.com/components/espressif/es7210/versions/1.0.1~1">es7210</a> 组件(该组件虽已被弃用,但可以修改其 i2c 读写寄存器部分后使用)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py add-dependency &quot;espressif/es7210^1.0.1~1&quot;<br></code></pre></td></tr></table></figure></li><li><p>使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;es7210.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ES7210_SAMPLE_RATE    (16000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ES7210_MCLK_MULTIPLE  (I2S_MCLK_MULTIPLE_256)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ES7210_BIT_WIDTH      (I2S_DATA_BIT_WIDTH_16BIT)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">es7210_codec_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 创建 es7210 句柄(通过指定 i2c port 与 es7210 i2c addr).注意必须保证 i2c bus 已初始化</span><br>    <span class="hljs-type">es7210_dev_handle_t</span> es7210_handle = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">es7210_i2c_config_t</span> es7210_i2c_conf = &#123;<br>        .i2c_port = I2C_NUM_0, <span class="hljs-comment">// i2c bus port</span><br>        .i2c_addr = <span class="hljs-number">0x41</span>,      <span class="hljs-comment">// es7210 i2c addr</span><br>    &#125;;<br>    es7210_new_codec(&amp;es7210_i2c_conf, &amp;es7210_handle);<br><br>    <span class="hljs-comment">// 配置 es7210 时钟</span><br>    <span class="hljs-type">es7210_codec_config_t</span> codec_conf = &#123;<br>        .i2s_format = ES7210_I2S_FMT_I2S,                 <span class="hljs-comment">// 标准 i2s 格式</span><br>        .mclk_ratio = ES7210_MCLK_MULTIPLE,               <span class="hljs-comment">// mclk 倍数</span><br>        .sample_rate_hz = ES7210_SAMPLE_RATE,             <span class="hljs-comment">// 采样率.16KHz</span><br>        .bit_width = (<span class="hljs-type">es7210_i2s_bits_t</span>)ES7210_BIT_WIDTH, <span class="hljs-comment">// 位深. 16bit</span><br>        .mic_bias = ES7210_MIC_BIAS_2V87,                 <span class="hljs-comment">// mic 偏置电压</span><br>        .mic_gain = ES7210_MIC_GAIN_30DB,                 <span class="hljs-comment">// mic 模拟增益</span><br>        .flags.tdm_enable = <span class="hljs-literal">false</span>                         <span class="hljs-comment">// 不启动 TDM(时分复用) 模式</span><br>    &#125;;<br>    es7210_config_codec(es7210_handle, &amp;codec_conf);<br>    es7210_config_volume(es7210_handle, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-AMP"><a href="#2-3-AMP" class="headerlink" title="2.3 AMP"></a>2.3 AMP</h3><ol><li><p>使用 es8311 播放</p><ul><li>通过 [i2c](# 1.4 I2C) 配置 es8311 codec</li><li>通过 [i2s](# 1.6 I2S) 输出数据(I2S_DO)</li><li>通过 pac9557 IO 扩展控制 ns4150b 功放的开关 <code>PA_EN</code>(高电平有效)</li></ul></li><li><p>移植 [es8311](<a href="https://components.espressif.com/components/espressif/es8311/versions/1.0.0~1/readme">espressif&#x2F;es8311 • v1.0.0~1 • ESP Component Registry</a>) 组件(该组件虽已被弃用,但可以修改其 i2c 读写寄存器部分后使用)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py add-dependency &quot;espressif/es8311^1.0.0~1&quot;<br></code></pre></td></tr></table></figure></li><li><p>添加音乐文件(<code>canon.pcm</code>).需要在 <code>main/CMakeLists.txt</code> 文件中声明</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">EMBED_FILES <span class="hljs-string">&quot;canon.pcm&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>播放音频示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;es8311.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ES8311_SAMPLE_RATE     (16000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ES8311_MCLK_MULTIPLE   (256)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ES8311_MCLK_FREQ_HZ    (ES8311_SAMPLE_RATE * ES8311_MCLK_MULTIPLE)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">es8311_codec_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 创建 es8311 句柄(通过指定 i2c port 与 es8311 i2c addr).注意必须保证 i2c bus 已初始化</span><br>    <span class="hljs-type">es8311_handle_t</span> es8311_handle = es8311_create(I2C_NUM_0, ES8311_ADDRRES_0);<br>    <span class="hljs-keyword">if</span> (!es8311_handle) <span class="hljs-built_in">abort</span>();<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">es8311_clock_config_t</span> es8311_clk = &#123;<br>        .mclk_inverted      = <span class="hljs-literal">false</span>,  <span class="hljs-comment">// mclk 不反相</span><br>        .sclk_inverted      = <span class="hljs-literal">false</span>,  <span class="hljs-comment">// sclk 不反相</span><br>        .mclk_from_mclk_pin = <span class="hljs-literal">true</span>,   <span class="hljs-comment">// mclk pin 提供 es8311 的主时钟</span><br>        .mclk_frequency     = ES8311_MCLK_FREQ_HZ, <span class="hljs-comment">// 与 i2s 通道保持一致</span><br>        .sample_frequency   = ES8311_SAMPLE_RATE   <span class="hljs-comment">// 与 i2s 通道保持一致</span><br>    &#125;;<br><br>    <span class="hljs-comment">// 配置 es8311 时钟.并指定输入输出分辨率均为 16bit</span><br>    es8311_init(es8311_handle, &amp;es8311_clk, ES8311_RESOLUTION_16, ES8311_RESOLUTION_16);<br>    es8311_sample_frequency_config(es8311_handle, ES8311_MCLK_FREQ_HZ, ES8311_SAMPLE_RATE);<br>    es8311_voice_volume_set(es8311_handle, <span class="hljs-number">70</span>, <span class="hljs-literal">NULL</span>);<br>    es8311_microphone_config(es8311_handle, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">/* Import music file as buffer */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> _binary_canon_pcm_start[];  <span class="hljs-comment">// _binary_&lt;文件名&gt;_start</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> _binary_canon_pcm_end[];    <span class="hljs-comment">// _binary_&lt;文件名&gt;_end</span><br><br><span class="hljs-comment">/* es8311 play */</span><br><span class="hljs-type">int</span> bytes_write = <span class="hljs-number">0</span>;<br><span class="hljs-type">uint8_t</span> *data_ptr = (<span class="hljs-type">uint8_t</span> *)_binary_canon_pcm_start;<br><br><span class="hljs-comment">// (Optional) Disable TX channel and preload the data before enabling the TX channel</span><br><span class="hljs-comment">// so that the valid data can be transmitted immediately</span><br>i2s_channel_disable(tx_handle);  <br>i2s_channel_preload_data(tx_handle, data_ptr, _binary_canon_pcm_end - data_ptr, &amp;bytes_write);<br>data_ptr += bytes_write;<br><br><span class="hljs-comment">// start play</span><br>i2s_channel_enable(tx_handle);<br>i2s_channel_write(tx_handle, data_ptr, _binary_canon_pcm_end - data_ptr, &amp;bytes_write, portMAX_DELAY)<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-LCD"><a href="#2-4-LCD" class="headerlink" title="2.4 LCD"></a>2.4 LCD</h3><ol><li><p>通过 spi 给 lcd 传输数据(st7789)</p><ul><li>其中 lcd_cs 受控于 pca9557</li><li>需要开启 psram 参考 [psram 部分](# 1.7 PSRAM)</li><li><code>backlight</code> 参考 [ledc 部分](# 1.2 LEDC)</li><li>基于 <code>esp_lcd</code> 内置组件使用</li></ul></li><li><p><code>lcd</code> 相关 api</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_lcd_types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_lcd_panel_io.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_lcd_panel_vendor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_lcd_panel_ops.h&quot;</span></span><br><br><span class="hljs-comment">/* lcd panel init:  */</span><br><span class="hljs-type">static</span> <span class="hljs-type">esp_lcd_panel_io_handle_t</span> io_handle = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">esp_lcd_panel_handle_t</span> panel_handle = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">// a. lcd gpio init. must init spi host first</span><br><span class="hljs-type">const</span> <span class="hljs-type">esp_lcd_panel_io_spi_config_t</span> io_config = &#123;<br>    .dc_gpio_num = GPIO_LCD_DC,   <span class="hljs-comment">// dc pin</span><br>    .cs_gpio_num = GPIO_LCD_CS,   <span class="hljs-comment">// cs pin</span><br>    .pclk_hz = <span class="hljs-number">80</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>,  <span class="hljs-comment">// spi clk.最大 80MHz</span><br>    .lcd_cmd_bits = <span class="hljs-number">8</span>,            <span class="hljs-comment">// command 位宽.8bit</span><br>    .lcd_param_bits = <span class="hljs-number">8</span>,          <span class="hljs-comment">// parameter 位宽.8bit</span><br>    .spi_mode = <span class="hljs-number">0</span>,                <span class="hljs-comment">// spi mode0(CPOL=0, CPHA=0)</span><br>    .trans_queue_depth = <span class="hljs-number">10</span>,      <span class="hljs-comment">// 传输队列深度</span><br>&#125;;<br>esp_lcd_new_panel_io_spi((<span class="hljs-type">esp_lcd_spi_bus_handle_t</span>)SPI2_HOST, &amp;io_config, &amp;io_handle);<br><br><span class="hljs-comment">// b. st7789 panel init</span><br><span class="hljs-type">const</span> <span class="hljs-type">esp_lcd_panel_dev_config_t</span> panel_config = &#123;<br>    .reset_gpio_num = GPIO_LCD_RST,             <span class="hljs-comment">// rst pin</span><br>    .rgb_ele_order = LCD_RGB_ELEMENT_ORDER_RGB, <span class="hljs-comment">// RGB 标准顺序</span><br>    .bits_per_pixel = <span class="hljs-number">16</span>,                       <span class="hljs-comment">// RGB565</span><br>&#125;;<br>esp_lcd_new_panel_st7789(io_handle, &amp;panel_config, &amp;panel_handle);<br><br><span class="hljs-comment">// c. lcd reset -&gt; lcd cs</span><br>esp_lcd_panel_reset(panel_handle);<br>pca9557_init();<br>pca9557_set_lcd_cs(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// d. st7789 config</span><br>ESP_ERROR_CHECK(esp_lcd_panel_init(panel_handle));<br>ESP_ERROR_CHECK(esp_lcd_panel_invert_color(panel_handle, <span class="hljs-literal">true</span>));  <span class="hljs-comment">// 颜色反转</span><br>ESP_ERROR_CHECK(esp_lcd_panel_swap_xy(panel_handle, <span class="hljs-literal">true</span>));       <span class="hljs-comment">// 显示翻转 </span><br>ESP_ERROR_CHECK(esp_lcd_panel_mirror(panel_handle, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>)); <span class="hljs-comment">// 镜像</span><br><br><span class="hljs-comment">/* panel write data */</span><br>esp_lcd_panel_draw_bitmap(panel_handle, x_start, y_start, x_end, y_end, color_data);<br><br><span class="hljs-comment">/* lcd init: </span><br><span class="hljs-comment"> * 1. spi host init</span><br><span class="hljs-comment"> * 2. backlight init</span><br><span class="hljs-comment"> * 3. lcd panel init</span><br><span class="hljs-comment"> * 4. write full black data</span><br><span class="hljs-comment"> * 5. panel display on</span><br><span class="hljs-comment"> * 6. backlight on */</span><br>esp_lcd_panel_disp_on_off(panel_handle, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-5-Touch"><a href="#2-5-Touch" class="headerlink" title="2.5 Touch"></a>2.5 Touch</h3><ol><li><p>通过 i2c 与触控 ic 通信.需要安装 <a href="https://components.espressif.com/components/espressif/esp_lcd_touch_ft5x06/versions/1.0.7/readme">ft5x06</a> 组件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py add-dependency &quot;espressif/esp_lcd_touch_ft5x06^1.0.7&quot;<br></code></pre></td></tr></table></figure></li><li><p><code>touch</code> 相关 api</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_lcd_touch_ft5x06.h&quot;</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">esp_lcd_touch_handle_t</span> touch_handle = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">/* init ft5x06 touch ic */</span><br><span class="hljs-type">esp_lcd_touch_config_t</span> tp_cfg = &#123;<br>    .x_max = LCD_HEIGHT - <span class="hljs-number">1</span>,     <span class="hljs-comment">// [0, height)</span><br>    .y_max = LCD_WIDTH  - <span class="hljs-number">1</span>,     <span class="hljs-comment">// [0, width]</span><br>    .rst_gpio_num = GPIO_NUM_NC, <span class="hljs-comment">// 与 lcd panel 共享 rst</span><br>    .int_gpio_num = GPIO_NUM_NC, <span class="hljs-comment">// 轮询.不使用中断</span><br>    .levels = &#123;<br>        .reset = <span class="hljs-number">0</span>,              <span class="hljs-comment">// 复位有效电平</span><br>        .interrupt = <span class="hljs-number">0</span>,          <span class="hljs-comment">// 中断触发电平</span><br>    &#125;,<br>    .flags = &#123;<br>        .swap_xy = <span class="hljs-number">1</span>,            <span class="hljs-comment">// x, y 轴方向交换</span><br>        .mirror_x = <span class="hljs-number">1</span>,           <span class="hljs-comment">// x 轴镜像</span><br>        .mirror_y = <span class="hljs-number">0</span>,           <span class="hljs-comment">// y 轴镜像</span><br>    &#125;,<br>&#125;;<br><span class="hljs-type">esp_lcd_panel_io_handle_t</span> tp_io_handle = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">esp_lcd_panel_io_i2c_config_t</span> tp_io_config = ESP_LCD_TOUCH_IO_I2C_FT5x06_CONFIG();<br>tp_io_config.scl_speed_hz = <span class="hljs-number">100</span> * <span class="hljs-number">1000</span>;  <span class="hljs-comment">// 手动指定 i2c 频率</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">i2c_master_bus_handle_t</span> bus_handle;  <span class="hljs-comment">// must init i2s bus first</span><br>ESP_ERROR_CHECK(i2c_master_get_bus_handle(I2C_PORT_NUM, &amp;bus_handle));<br><br><span class="hljs-comment">// 创建 ft5x06 实例</span><br>ESP_ERROR_CHECK(esp_lcd_new_panel_io_i2c(bus_handle, &amp;tp_io_config, &amp;tp_io_handle));<br>ESP_ERROR_CHECK(esp_lcd_touch_new_i2c_ft5x06(tp_io_handle, &amp;tp_cfg, &amp;touch_handle));<br>assert(touch_handle);<br><br><span class="hljs-comment">/* 读取触摸数据 */</span><br>esp_lcd_touch_read_data(touch_handle);<br><br><span class="hljs-comment">/* 获取触摸点坐标(支持最多5点触摸) */</span><br>esp_lcd_touch_get_coordinates(touch_handle, touch_x, touch_y, touch_strength, &amp;touch_cnt, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-6-LVGL"><a href="#2-6-LVGL" class="headerlink" title="2.6 LVGL"></a>2.6 LVGL</h3><ol><li><p>安装 <a href="https://components.espressif.com/components/lvgl/lvgl/versions/8.3.11/readme?language=en">lvgl</a>, <a href="https://components.espressif.com/components/espressif/esp_lvgl_port/versions/2.6.2/readme">lvgl_port</a> 组件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py add-dependency &quot;lvgl/lvgl^8.3.11&quot;<br>idf.py add-dependency &quot;espressif/esp_lvgl_port^2.6.0&quot;<br></code></pre></td></tr></table></figure></li><li><p>lvgl 相关配置(<code>menuconfig</code> 中 &#96;&#96;)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Component config -&gt; LVGL configuration<br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启颜色反转: Color settings -&gt; [x] Swap the 2 bytes of RGB565 color...</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">自定义内存分配函数: Memory settings -&gt; [*] If <span class="hljs-literal">true</span> use custom malloc/free...</span><br></code></pre></td></tr></table></figure></li><li><p>接口适配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_lcd_touch_ft5x06.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_lvgl_port.h&quot;</span></span><br><br><span class="hljs-type">lv_disp_t</span> *disp_fb;<br><span class="hljs-type">lv_indev_t</span> *disp_indev;<br><span class="hljs-type">void</span> <span class="hljs-title function_">lvgl_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 初始化 lcd, touch 硬件</span><br>    lcd_init();<br>    lcd_touch_indev_init();<br><br>    <span class="hljs-comment">// 初始化 lvgl</span><br>    <span class="hljs-type">lvgl_port_cfg_t</span> lvgl_cfg = ESP_LVGL_PORT_INIT_CONFIG();<br>    lvgl_port_init(&amp;lvgl_cfg);<br><br>    <span class="hljs-comment">// 将 lcd 添加到 lvgl</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">lvgl_port_display_cfg_t</span> disp_cfg = &#123;<br>        .io_handle = io_handle,<br>        .panel_handle = panel_handle,<br>        .buffer_size = LCD_WIDTH * LCD_HEIGHT, <span class="hljs-comment">// LVGL缓存大小 </span><br>        .double_buffer = <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 是否开启双缓存</span><br>        .hres = LCD_WIDTH,      <span class="hljs-comment">// 液晶屏的宽</span><br>        .vres = LCD_HEIGHT,     <span class="hljs-comment">// 液晶屏的高</span><br>        .monochrome = <span class="hljs-literal">false</span>,    <span class="hljs-comment">// 是否单色显示器</span><br>        .rotation = &#123;           <span class="hljs-comment">// rotation 必须与 lcd init 设置的 翻转 和 镜像 一致</span><br>            .swap_xy = <span class="hljs-literal">true</span>,    <span class="hljs-comment">// 是否翻转</span><br>            .mirror_x = <span class="hljs-literal">true</span>,   <span class="hljs-comment">// x 方向是否镜像</span><br>            .mirror_y = <span class="hljs-literal">false</span>,  <span class="hljs-comment">// y 方向是否镜像</span><br>        &#125;,<br>        .flags = &#123;<br>            .buff_dma = <span class="hljs-literal">false</span>,   <span class="hljs-comment">// 是否使用 DMA 注意.dma 与 spiram 不能同时为 true</span><br>            .buff_spiram = <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否使用 PSRAM</span><br>        &#125;<br>    &#125;;<br>    disp_fb = lvgl_port_add_disp(&amp;disp_cfg);<br><br>    <span class="hljs-comment">// 将 lcd touch 组合添加到 lvgl</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">lvgl_port_touch_cfg_t</span> touch_cfg = &#123;<br>        .disp = disp_fb,<br>        .handle = touch_handle,<br>    &#125;;<br>    disp_indev = lvgl_port_add_touch(&amp;touch_cfg);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="A-Arduino"><a href="#A-Arduino" class="headerlink" title="A Arduino"></a>A <a href="https://www.bilibili.com/video/BV1RM4y1a7J5?spm_id_from=333.788.videopod.episodes&vd_source=ca18f72085fcabc81ea5ba4e594aefe7">Arduino</a></h3><ol><li><p><a href="https://www.arduino.cc/">下载安装 IDE</a></p></li><li><p>Arduino IDE 的基础设置</p><ul><li>中文: <code>file</code> -&gt; <code>preference</code> -&gt; <code>language</code> -&gt; 选择中文</li><li>安装开发板资源: 工具 -&gt; 开发板 -&gt; 开发板管理器 -&gt; 搜索 ESP32 并安装(需要能连接 <code>Github</code>)</li></ul></li><li><p>Arduino 基础</p><ul><li>在 <code>void setup() &#123;&#125;</code> 函数中的代码在上电时运行一次,用于初始化</li><li>在 <code>void loop() &#123;&#125;</code> 函数中的代码将会死循环运行</li></ul></li><li><p>hello,world(在 工具 -&gt; 串口监视器中查看输出)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 初始化串口</span><br>  Serial.<span class="hljs-built_in">begin</span>(<span class="hljs-number">9600</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;<br>  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello,world!\n&quot;</span>);<br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="B-MicroPython"><a href="#B-MicroPython" class="headerlink" title="B MicroPython"></a>B <a href="https://www.bilibili.com/video/BV1G34y1E7tE/?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click&vd_source=ca18f72085fcabc81ea5ba4e594aefe7">MicroPython</a></h3><ol><li><p>开发环境搭建</p><ul><li><p>安装 IDE: <a href="https://thonny.org/">Thonny</a></p></li><li><p>下载解释器: <a href="https://micropython.org/">MicroPython</a> 官网中 download 找到对应开发板,下载后缀为 <code>.bin</code> 的 Firmware</p></li></ul></li><li><p>烧录固件</p><ul><li><p>连接 ESP32 开发板,并安装 USB 转串口驱动(在设备管理器中查看)</p></li><li><p>在 Thonny 中配置解释器: <code>运行</code> -&gt; <code>配置解释器</code></p><ul><li><p><code>解释器</code> 选为 <code>MicroPython(ESP32)</code></p></li><li><p>端口会自动识别</p></li><li><p>最后点击 <code>安装或更新 MicroPython(esptool)</code> 即可</p></li></ul></li><li><p>烧录解释器: 在下拉菜单中 <code>Select local MicroPython image...</code> 选择下载的 <code>Firmware</code></p><ul><li><code>Target port</code> 自动识别.并勾选 <code>Erase all flash...</code></li><li><code>MicroPython family</code> 选为 <code>esp32-s3</code></li><li><code>version</code> 选为下载的 .bin 文件</li><li>最后点击 <code>Select local MicroPython image</code></li></ul></li><li><p>下载时可能需要按住 boot 键才能开始下载.耐心等待,直到出现 <code>Done!</code></p></li><li><p>成功烧录的标志: 左侧文件栏中出现 <code>MicroPython 设备</code> 或 Shell 窗口显示 <code>MicroPython</code></p></li></ul></li><li><p>Hello,world</p><ul><li><p>新建文件,并写入 <code>print(&quot;Hello,world!&quot;)</code>.将其保存到 <code>MicroPython设备</code></p></li><li><p>点击 <code>运行当前脚本</code>,即可运行.此时 Python 程序已运行于 ESP32</p></li></ul></li><li><p>对于 MicroPython 的 api,需参考其<a href="http://www.micropython.com.cn/en/latet/esp32/quickref.html">官网文档</a></p></li><li><p>MicroPython REPL(交互解释器) 位于 UART0.波特率115200</p></li></ol><h3 id="C-Letter-Shell"><a href="#C-Letter-Shell" class="headerlink" title="C Letter-Shell"></a>C <a href="https://github.com/NevermindZZT/letter-shell">Letter-Shell</a></h3><ol><li><p>letter-shell: 纯 c 编写的嵌入式 shell</p><ul><li>命令自动补全</li><li>权限管理系统</li><li>导出程序中变量</li><li>快捷键定义</li><li>文件系统支持</li></ul></li><li><p>移植代码</p><ul><li><p>源码准备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone git@github.com:NevermindZZT/letter-shell.git # 拉取源码<br><br>cd &lt;project_path&gt;/components                       # 在工程的 components 下操作<br>cp -r &lt;download_path&gt;/letter-shell/  letter-shell/ # 将源码复制到工程的 components 目录<br>cp letter-shell/demo/esp-idf/*  letter-shell/      # 将特定 demo 复制出来<br></code></pre></td></tr></table></figure></li><li><p>在 <code>main/CMakeLists.txt</code> 中引入依赖</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">REQUIRES <span class="hljs-string">&quot;letter-shell&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>解决编译报错: 将 <code>shell_port.c</code> 中的 <code>userShellWrite, userShellRead</code> 返回值类型改为 <code>signed short</code></p></li><li><p>初始化 shell: 在 app_main 中调用 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shell_port.h&quot;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">app_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    userShellInit();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果需要在 cpp 环境中使用.参考 <code>extensions/cpp_support/readme.md</code></p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ESP32</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS</title>
    <link href="/2024/06/01/Embedded/FreeRTOS/"/>
    <url>/2024/06/01/Embedded/FreeRTOS/</url>
    
    <content type="html"><![CDATA[<h1 id="FreeRTOS"><a href="#FreeRTOS" class="headerlink" title="FreeRTOS"></a>FreeRTOS</h1><h2 id="0-基本概念"><a href="#0-基本概念" class="headerlink" title="0 基本概念"></a>0 基本概念</h2><h3 id="0-1-简介"><a href="#0-1-简介" class="headerlink" title="0.1 简介"></a>0.1 简介</h3><ol><li>FreeRTOS 优势<ul><li><strong>开源免费</strong>: 通过 MIT 许可证发布,可免费使用, 修改, 分发.活跃的社区支持</li><li><strong>轻量级设计</strong>: 内核代码精简,适用资源受限的嵌入式系统(通常 6-12KB ROM, 1-2KB RAM)</li><li><strong>模块化设计</strong>: 支持动态加载组件(如 TCP&#x2F;IP 栈, 文件系统 FatFS).可根据需求裁剪功能</li><li><strong>可移植性</strong>: 代码主要用 C 编写,支持多种处理器架构.提供统一的 API,移植只需修改相关硬件层</li><li><strong>功能丰富</strong>: 提供了多任务调度, 任务通信, 同步等功能.适用复杂的嵌入式应用场景</li></ul></li><li>FreeRTOS 特点<ul><li><strong>任务管理</strong>: 可创建多个任务,每个任务独立栈空间,支持优先级继承和动态优先级调整</li><li><strong>内存管理</strong>: 提供多种内存管理机制(heap_1 ~ heap_5),如静态分配,动态分块,适应不同硬件资源</li><li><strong>任务调度</strong>: 通过任务调度器管理多个任务,支持不同优先级的任务,实现任务有序执行</li><li><strong>低功耗支持</strong>: 提供 Tickless 模式,在空闲时暂停系统节拍,显著降低功耗</li><li><strong>任务通信和同步</strong>: 提供了队列, 信号量等机制,支持任务间的通信和同步,确保数据安全传递</li><li><strong>定时器和中断处理</strong>: 支持定时器功能,能够处理中断</li></ul></li></ol><h3 id="0-2-多任务系统"><a href="#0-2-多任务系统" class="headerlink" title="0.2 多任务系统"></a>0.2 多任务系统</h3><ol><li><strong>多任务(Multitasking)</strong><ul><li>多任务操作系统能够同时管理多个任务,通过任务间快速切换制造并发执行的假象</li><li>在单核 CPU 上,任务依然是分时运行的,但调度器的高效切换,感知上像是同时执行多个任务</li></ul></li><li>多任务操作系统的优势<ul><li>提高 CPU 利用率: 对比在单任务系统中阻塞时,CPU 只能空转.多任务可以让其他任务在等待期间运行</li><li>并行处理: 如一个任务处理用户输入,一个进行数据计算,一个控制电机</li><li>增强实时性: 高优先级任务可以立即抢占低优先级任务,确保关键操作以及执行</li><li>模块化设计: 将不同功能拆分为独立任务,代码结构更清晰,易于维护</li><li>简化延时: 单任务的延时会阻塞整个程序.而多任务系统中可以通过 <code>vTaskDelay()</code> 让出 CPU</li><li>资源管理: 通过信号量,互斥量等机制对共享资源进行保护</li><li>内存隔离: 每个任务拥有独立栈空间,避免变量冲突</li><li>空闲任务优化: 当所有任务处于阻塞状态时,FreeRTOS 可进入低功耗模式,显著降低功耗</li></ul></li></ol><h3 id="0-3-任务状态"><a href="#0-3-任务状态" class="headerlink" title="0.3 任务状态"></a>0.3 任务状态</h3><ol><li><p><strong>FreeRTOS 任务有四种状态(FreeRTOS 优先级数值越大,表示优先级越高)</strong></p><p><img src="/2024/06/01/Embedded/FreeRTOS/0-FreeRTOS-status.png"></p></li><li><p><strong>运行态(Running)</strong></p><ul><li>当前正在执行的任务,占用 CPU 资源</li><li>单核 CPU 上,同一时刻只有一个任务处于运行态</li></ul></li><li><p><strong>就绪态(Ready)</strong></p><ul><li>任务已准备好运行,但尚未被调度器选中.可能因更高优先级任务正在运行</li><li>任务存放在就绪列表(Ready List)中,按优先级排序</li></ul></li><li><p><strong>阻塞态(Blocked)</strong></p><ul><li>任务在等待某个事件或超时,不占用 CPU</li><li>任务被移至阻塞列表(Blocked List),直到事件发生或超时</li><li>延时阻塞: <code>vTaskDelay(1000)</code> 等待 1 秒</li><li>同步阻塞: <code>xQueueReceive()</code> 等待队列数据</li><li>资源阻塞: <code>xSemaphoreTake()</code> 等待信号量</li></ul></li><li><p><strong>挂起态(Suspended)</strong></p><ul><li>任务被手动暂停,不参与调度,即使事件就绪也不会运行</li><li>常用于调试或临时禁用某个任务</li><li>挂起任务: <code>vTaskSuspend(TaskHandle_t xTask)</code></li><li>恢复任务: <code>vTaskResume(TaskHandle_t xTask)</code></li></ul></li><li><p>状态总结</p><table><thead><tr><th align="left">状态</th><th align="left">说明</th><th align="left">触发条件</th></tr></thead><tbody><tr><td align="left">运行态</td><td align="left">当前正在 CPU 上执行的任务</td><td align="left">被调度器选中执行</td></tr><tr><td align="left">就绪态</td><td align="left">已准备好运行,但尚未被调度</td><td align="left">任务创建 &#x2F; 从阻塞或挂起恢复 &#x2F; 高优先级任务释放 CPU</td></tr><tr><td align="left">阻塞态</td><td align="left">任务在等待延时或某个事件</td><td align="left">调用 <code>vTaskDelay()</code> &#x2F; 等待队列 &#x2F; 等待信号量</td></tr><tr><td align="left">挂起态</td><td align="left">任务被显式暂停,不会被调度</td><td align="left">调用 <code>vTaskSuspend()</code> &#x2F; 被其他任务挂起</td></tr></tbody></table></li></ol><h3 id="0-4-任务调度"><a href="#0-4-任务调度" class="headerlink" title="0.4 任务调度"></a>0.4 任务调度</h3><ol><li><strong>任务调度器(Scheduler)</strong>: 决定某一时刻要执行哪个任务,并管理任务之间的切换<ul><li><strong>抢占式调度(Preemptive Scheduling)</strong>: 高优先级任务可以立即抢占低优先级任务的 CPU 使用权</li><li><strong>时间片轮询(Time Slicing)</strong>: 相同优先级的任务按固定时间片(Tick)轮流执行</li></ul></li><li>调度器工作流程<ul><li><strong>任务创建</strong>: 调用 <code>xTaskCreate()</code> 创建任务,任务进入就绪态</li><li><strong>任务调度</strong><ul><li>调度器选择最高优先级的就绪任务运行</li><li>如果使用时间片轮转,相同优先级的任务会轮流执行</li></ul></li><li><strong>任务切换</strong>: 发生以下情况时,调度器会触发任务切换<ul><li>任务主动让出 CPU(如 <code>vTaskDelay(), taskYIELD()</code>)</li><li>高优先级任务就绪(抢占当前任务)</li><li>中断发生(某些中断会触发调度)</li></ul></li><li><strong>任务状态变化</strong><ul><li>运行 → 阻塞: 任务等待事件(如信号量, 队列)</li><li>阻塞 → 就绪: 事件发生(如数据到达)</li><li>挂起: 任务被手动暂停(<code>vTaskSuspend()</code>)</li></ul></li></ul></li><li>FreeRTOS 调度器的核心依赖<ul><li><strong>SysTick 定时器</strong>: 提供时间基准(Tick).用于时间片轮转和任务超时管理</li><li><strong>PendSV 中断(ARM Cortex-M)</strong>: 用于低优先级上下文切换,确保关键中断(如硬件 SPI)不被延迟</li><li><strong>任务控制块(TCB)</strong>: 存储任务状态, 栈指针, 优先级等信息,供调度器决策</li></ul></li></ol><h3 id="0-5-滴答时钟"><a href="#0-5-滴答时钟" class="headerlink" title="0.5 滴答时钟"></a>0.5 滴答时钟</h3><ol><li><strong>FreeRTOS 的滴答(Tick)是操作系统的时间基准,是任务调度和时间管理的基础</strong><ul><li>滴答时钟是 FreeRTOS 内部的时间基准,由硬件定时器周期性中断产生</li><li><strong>频率</strong>: 由 <code>configTICK_RATE_HZ</code> 宏定义,通常设置为 1000Hz(1ms) 或 100Hz(10ms)</li></ul></li><li>FreeRTOS 实时内核通过滴答计数变量测量时间(一般将 Systick 作为时钟来源)<ul><li>休眠时,RTOS 任务需指定唤醒的时间</li><li>阻塞时,需指定等待的最长时间</li></ul></li><li>定时器中断(RTOS 滴答中断)按严格的时间精度增加滴答数<ul><li>每次滴答数增加时,实时内核必须检查是否为解除阻塞或唤醒任务的时间</li><li>在滴答 ISR 期间唤醒或解除阻塞的任务优先级可能高于被中断任务的优先级</li></ul></li></ol><h3 id="0-6-上下文切换"><a href="#0-6-上下文切换" class="headerlink" title="0.6 上下文切换"></a>0.6 上下文切换</h3><ol><li><strong>上下文(Context)</strong>: 任务运行时 CPU 的状态<ul><li>程序计数器(PC)</li><li>处理器状态寄存器(如 xPSR)</li><li>通用寄存器(R0-R12)</li><li>栈指针(SP)</li></ul></li><li><strong>上下文切换(Context Switching)</strong>: 保存当前任务的上下文,恢复下一个任务的上下文的过程</li><li><strong>上下文切换时机</strong>: 任务切换时<ul><li>任务调用阻塞 API: 如 <code>vTaskDelay(), xQueueReceive()</code> 等</li><li>任务主动放弃 CPU: 调用 <code>taskYIELD()</code></li><li>滴答中断(Systick): 时间片轮转调度时</li><li>其他中断: 高优先级任务就绪时(如信号量, 队列等操作)</li><li>任务执行完毕</li></ul></li><li>FreeRTOS 中的实现方式<ul><li>真正切换上下文的执行在 PendSV(可挂起的系统调用)中断</li><li>PendSV 可以手动触发,且可以在其他更高中断优先级的 ISR 中设置</li><li>FreeRTOS 会将 PendSV 设置为最低中断优先级,以免任务切换导致影响到其他 ISR</li></ul></li></ol><h3 id="0-7-空闲任务"><a href="#0-7-空闲任务" class="headerlink" title="0.7 空闲任务"></a>0.7 空闲任务</h3><ol><li><strong>RTOS 调度器启动时,自动创建空闲任务,确保始终存在一个能够运行的任务</strong><ul><li>每个任务调度器都有一个空闲任务</li><li>创建时机: 在调用 <code>vTaskStartScheduler()</code> 时自动创建</li><li>以最低优先级创建,确保有更高优先级任务处于准备就绪状态时,空闲任务不使用 CPU 时间</li></ul></li><li><strong>空闲任务功能</strong><ul><li>负责删除已被终止的任务(调用 <code>vTaskDelete()</code> 的任务)</li><li>回收被删除任务的内存资源</li><li>实现 Tickless 空闲模式(当启用 <code>configUSE_TICKLESS_IDLE</code> 时)</li><li>执行用户定义的空闲任F务钩子函数(Idle Hook)</li></ul></li></ol><h2 id="1-移植"><a href="#1-移植" class="headerlink" title="1 移植"></a>1 移植</h2><h3 id="1-1-源码结构"><a href="#1-1-源码结构" class="headerlink" title="1.1 源码结构"></a>1.1 源码结构</h3><ol><li><p>获取源码: <a href="https://www.freertos.org/">官网下载</a></p></li><li><p>FreeRTOS 目录结构</p><blockquote><p>├── <strong>FreeRTOS</strong> (内核)<br>│   ├── Demo (例程)<br>│   ├── License (证书)<br>│   ├── Source (内核源码)<br>│   │   ├── include (头文件)<br>│   │   └── portable (移植文件,编译器环境相关)<br>│   └── Test (测试)<br>├── FreeRTOS-Plus (扩展组件,一般使用第三方组件)<br>└── tools (工具集)</p></blockquote></li></ol><h3 id="1-2-HAL-库移植"><a href="#1-2-HAL-库移植" class="headerlink" title="1.2 HAL 库移植"></a>1.2 HAL 库移植</h3><ol><li><p>在工程根目录创建 FreeRTOS 目录,在其中创建 <code>source, include, portable</code> 目录.然后将下面文件复制过来</p><ul><li><code>source</code> 目录: FreeRTOS&#x2F;Source 下的所有 .c 文件</li><li><code>include</code> 目录: FreeRTOS&#x2F;Source&#x2F;include 整个目录</li><li><code>portable</code> 目录:<ul><li>FreeRTOS&#x2F;Source&#x2F;portable&#x2F;RVDS 的相关文件(根据内核选择)</li><li>FreeRTOS&#x2F;Source&#x2F;portable&#x2F;MemMang 的 <code>heap_4.c</code></li></ul></li><li><code>FreeRTOSConfig.h</code>: 工程配置文件.可以在 DEMO 中寻找</li></ul></li><li><p>在 Keil 中添加路径…….</p></li><li><p>在系统配置文件 <code>FreeRTOSConfig.h</code> 中添加必须下面的3个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortPendSVHandler  PendSV_Handler <span class="hljs-comment">// 适配 stm32 的 PendSV_Handler 中断</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vPortSVCHandler     SVC_Handler    <span class="hljs-comment">// 适配 stm32 的 SVC_Handler 中断</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetSchedulerState 1   <span class="hljs-comment">// 查询调度器的当前状态</span></span><br></code></pre></td></tr></table></figure></li><li><p>在 <code>stm32f1xx_it.c</code> 文件中注释掉 <code>PendSV_Handler, SVC_Handler</code> 函数.否则会重复定义</p></li><li><p>配置时钟源: 在 <code>stm32f1xx_it.c</code> 文件中包含 <code>FreeRTOS.h, task.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FreeRTOS.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task.h&quot;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">xPortSysTickHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) &#123;  <span class="hljs-comment">// 如果开启了任务调度器</span><br>        xPortSysTickHandler();  <span class="hljs-comment">// 启动 freeRTOS 的滴答 ISR</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>hal</code> 库的延时函数默认使用 <code>SysTick</code>.将 FreeRTOS 的时钟配置为 <code>SysTick</code> 后可能引发问题</p><ul><li><strong>在中断调用 hal 库中提供的 <code>hal_delay()</code> 时,因为其优先级被设置为最低,</strong><br><strong>会等待外设中断结束.而外设中断又在等待 delay 结束,因此计数器无法累加,时间卡死</strong></li><li>因此不要在中断函数调用 <code>hal_delay()</code></li></ul></li><li><p>修改 <code>Hal timebase</code> 时钟源以解决 <code>hal_delay()</code> 的问题</p><ul><li>在 CubeMX 中选择 <code>Timebase Source</code> 默认为 <code>SysTick</code>, 改为其他未使用的定时器.如 TIM7</li><li>在 NVIC 中找到 <code>Time base interrupt</code>,将其优先级改为1.此时可以正常使用 <code>hal_delay()</code></li></ul></li></ol><h3 id="1-3-寄存器移植"><a href="#1-3-寄存器移植" class="headerlink" title="1.3 寄存器移植"></a>1.3 寄存器移植</h3><ol><li><p>前置步骤与 hal 库一致,直到第 4 步,因为寄存器开发没有 <code>stm32f1xx_it.c</code> 文件</p></li><li><p>在某一个文件中实现滴答定时器的中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">xPortSysTickHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) &#123;  <span class="hljs-comment">// 如果开启了任务调度器</span><br>        xPortSysTickHandler();  <span class="hljs-comment">// 启动 freeRTOS 的滴答 ISR</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自己实现的延时函数不应再依赖 <code>SysTick</code>, 防止卡死</p></li></ol><h3 id="1-4-系统配置文件"><a href="#1-4-系统配置文件" class="headerlink" title="1.4 系统配置文件"></a>1.4 系统配置文件</h3><ol><li>在系统配置文件 <code>FreeRTOSConfig.h</code> 中有很多配置项.可在 <a href="https://www.freertos.org/zh-cn-cmn-s/Documentation/02-Kernel/03-Supported-devices/02-Customization">官方文档</a> 查看详细信息</li><li>主要分为 <code>config</code> 参数 和 <code>INCLUDE</code> 宏<ul><li><code>config</code>: 功能配置.如基本配置, 内存配置, 钩子配置, 中断配置…</li><li><code>INCLUDE</code>: 裁剪功能(使用条件编译实现.1 表示可用,0 表示禁用)</li></ul></li></ol><h3 id="1-5-命名规范"><a href="#1-5-命名规范" class="headerlink" title="1.5 命名规范"></a>1.5 命名规范</h3><ol><li>数据类型<ul><li><code>TickType_t</code>: 用于表示系统节拍计数器的值<ul><li><code>configUSE_16_BIT_TICKS</code> 为 <code>true</code> 时, <code>TickType_t</code> 是16bit.否则为 32bit</li><li>记录 FreeRTOS 中系统过去的节拍次数</li></ul></li><li><code>BaseType_t</code>: 架构中最有效, 自然的类型. 32位架构下被定义为 32位类型</li><li><code>UBaseType_t</code>: <code>BaseType_t</code> 的 <code>unsigned</code> 版</li><li><code>StackType_t</code>: 用于存储堆栈的类型</li></ul></li><li>变量名采用驼峰式大小写,一般不用缩写<ul><li><code>uint32_t</code> 类型变量用 <code>ul</code> 前缀,即 <code>unsigned long</code></li><li><code>uint16_t</code> 类型变量用 <code>us</code> 前缀,即 <code>unsigned short</code></li><li><code>uint8_t</code> 类型变量用 <code>uc</code> 前缀,即 <code>unsigned char</code></li><li>非 <code>stdint</code> 类型的变量用 <code>x</code> 前缀,无符号变量用 <code>u</code> 前缀</li><li>枚举变量用 <code>e</code> 前缀, 指针变量用 <code>p</code> 前缀</li></ul></li><li>函数使用驼峰式大小写,一般不用缩写<ul><li>文件作用域静态(私有)函数用 <code>prv</code> 前缀</li><li>API 函数以其返回类型为前缀.对于 <code>void</code> 用 <code>v</code> 前缀</li><li>API 函数名称用定义 API 函数文件为前缀</li><li>如 <code>vTaskDelay</code>: 返回类型 <code>void</code>,定义于 <code>task.c</code>, 作用为 <code>delay</code></li></ul></li><li>宏使用完整的单词拼写<ul><li>宏用定义宏的文件为前缀.如 <code>FreeRTOSConfig.h</code> 定义 <code>configUSE_PREEMPTION</code></li><li>除前缀外,宏全大写,并使用下划线分隔</li></ul></li></ol><h2 id="2-任务控制"><a href="#2-任务控制" class="headerlink" title="2 任务控制"></a>2 任务控制</h2><h3 id="2-1-任务控制-API"><a href="#2-1-任务控制-API" class="headerlink" title="2.1 任务控制 API"></a>2.1 任务控制 API</h3><ol><li><p>任务创建可以动态(<code>xTaskCreate</code>)或静态的(<code>xTaskCreateStatic</code>).区别在于</p><ul><li>动态创建: 任务的控制块和栈空间由 FreeRTOS 管理</li><li>静态创建: 任务的控制块和栈空间由用户分配提供(在 <code>malloc</code> 受限时使用)</li></ul></li><li><p>动态创建任务步骤</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskCreate</span> <span class="hljs-params">(</span><br><span class="hljs-params">    TaskFunction_t pxTaskCode,  <span class="hljs-comment">// 指向任务函数的指针</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> pcName,   <span class="hljs-comment">// 任务名,最大长度为 configMax_TASK_NAME_LEN</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> configSTACK_DEPTH_TYPE usStackDepth,  <span class="hljs-comment">// 任务堆栈大小,默认单位为4字节.最小为128</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span> *<span class="hljs-type">const</span> pvParameters,  <span class="hljs-comment">// 传递给任务函数的参数</span></span><br><span class="hljs-params">    UBaseType_t uxPriority,    <span class="hljs-comment">// 任务优先级, 0 ~ configMAX_PRIORITIES - 1</span></span><br><span class="hljs-params">    TaskHandle_t *<span class="hljs-type">const</span> pxCreatedTask  <span class="hljs-comment">// 任务句柄,即任务的控制块</span></span><br><span class="hljs-params">)</span>;<br><span class="hljs-comment">// 返回值 pdPASS 表示创建成功. errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY 表示失败</span><br></code></pre></td></tr></table></figure></li><li><p>删除任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelete</span><span class="hljs-params">(TaskHandle_t xTaskToDelete)</span>;<br><span class="hljs-comment">// xTaskToDelete: 待删除任务的任务句柄</span><br><span class="hljs-comment">// 若传入 NULL: 删除任务自身(当前正在运行的任务)</span><br></code></pre></td></tr></table></figure><ul><li>被删除的任务将从就绪态任务列表, 阻塞态任务列表, 挂起态任务列表, 事件列表中移除</li><li>由空闲任务负责释放被删除任务中系统分配的内存</li></ul></li></ol><h3 id="2-2-任务控制示例"><a href="#2-2-任务控制示例" class="headerlink" title="2.2 任务控制示例"></a>2.2 任务控制示例</h3><ol><li><p>目标: 使用 <code>xTaskCreate</code> 和 <code>vTaskDelete</code></p><ul><li><code>start_task</code>: 启动任务,用于创建其他任务</li><li><code>task1</code>: 让 LED1 每 500ms 闪烁一次</li><li><code>task2</code>: 让 LED2 每 500ms 闪烁一次</li><li><code>task3</code>: 判断 KEY1 是否按下,按下时删除 <code>task1</code></li></ul></li><li><p>创建 <code>task_test.h</code> 文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __TASK_TEST_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __TASK_TEST_H__</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">freertos_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>创建 <code>task_test.c</code> 文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task_test.h&quot;</span></span><br><span class="hljs-comment">/* freeRTOS 必须的相关头文件 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FreeRTOS.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task.h&quot;</span></span><br><br><span class="hljs-comment">/* 所有任务的声明 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">start_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">task1</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">task2</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">task3</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>;<br><br><span class="hljs-comment">/* 任务句柄的声明 */</span><br><span class="hljs-type">static</span> TaskHandle_t task1_handler;<br><span class="hljs-type">static</span> TaskHandle_t task2_handler;<br><span class="hljs-type">static</span> TaskHandle_t task3_handler;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">freertos_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">/* 1. 创建启动任务 */</span><br>    TaskHandle_t start_task_handler;<br>    xTaskCreate((TaskFunction_t)start_task, <span class="hljs-string">&quot;start_task&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, &amp;start_task_handler);<br>    <span class="hljs-comment">/* 2. 启动调度器 */</span><br>    vTaskStartScheduler();<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">start_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    taskENTER_CRITICAL();  <span class="hljs-comment">// 进入临界区.临界区的代码不会被打断</span><br>    <span class="hljs-comment">/* 1. 创建需要运行的任务 */</span><br>    xTaskCreate( (TaskFunction_t)task1, <span class="hljs-string">&quot;task1&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, &amp;task1_handler);<br>    xTaskCreate( (TaskFunction_t)task2, <span class="hljs-string">&quot;task2&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, &amp;task2_handler);<br>    xTaskCreate( (TaskFunction_t)task3, <span class="hljs-string">&quot;task3&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, &amp;task3_handler);<br>    taskEXIT_CRITICAL();  <span class="hljs-comment">// 退出临界区.与进入临界区成对出现</span><br><br>    <span class="hljs-comment">/* 2. 删除自身(启动任务),退出任务.因为启动任务只需执行一次 */</span><br>    vTaskDelete(<span class="hljs-literal">NULL</span>);  <span class="hljs-comment">// 删除当前任务会立即停止运行,因此最后运行</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">task1</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;task1 working...\n&quot;</span>);<br>        LED_Toggle(LED1_Pin);<br>        vTaskDelay(<span class="hljs-number">500</span>);  <span class="hljs-comment">// 该延时函数会让任务进入阻塞态</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">task2</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;task2 working...\n&quot;</span>);<br>        LED_Toggle(LED2_Pin);<br>        vTaskDelay(<span class="hljs-number">500</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">task3</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-type">uint8_t</span> key = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;task3 working...\n&quot;</span>);<br>        key = key_detect();<br>        <span class="hljs-keyword">if</span>(key == KEY1 &amp;&amp; task1_handler != <span class="hljs-literal">NULL</span>) &#123;<br>            vTaskDelete(task1_handler);<br>            task1_handler = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        vTaskDelay(<span class="hljs-number">500</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 <code>main.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task_test.h&quot;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    freertos_start();  <span class="hljs-comment">// 程序开启任务调度器后不会执行之后的代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-挂起和恢复"><a href="#2-3-挂起和恢复" class="headerlink" title="2.3 挂起和恢复"></a>2.3 挂起和恢复</h3><ol><li><p>挂起任务.类似暂停</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 需要将宏 INCLUDE_vTaskSuspend 配置为1</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSuspend</span><span class="hljs-params">( TaskHandle_t xTaskToSuspend )</span>;<br><span class="hljs-comment">// xTaskToSuspend: 待挂起任务的任务句柄.为 NULL 表示挂起任务自身</span><br></code></pre></td></tr></table></figure></li><li><p>恢复任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 需要将宏 INCLUDE_vTaskResume 配置为1</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskResume</span><span class="hljs-params">( TaskHandle_t xTaskToResume )</span>;<br><span class="hljs-comment">// 无论 suspend 多少次,只需 resume 一次.被恢复的任务重新进入就绪态</span><br></code></pre></td></tr></table></figure></li><li><p>在中断恢复被挂起的任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 需要将宏 INCLUDE_vTaskResume 和 INCLUDE_vTaskResumeFromISR 配置为1</span><br>BaseType_t <span class="hljs-title function_">xTaskResumeFromISR</span><span class="hljs-params">( TaskHandle_t xTaskToResume )</span>;<br><span class="hljs-comment">// 返回值: pdTRUE(pdFALSE) 表示任务恢复后需要(不需要)进行任务切换</span><br><span class="hljs-comment">// 在中断服务程序调用 Freertos 的 API 函数,要求中断优先级不高于 FreeRTOS 管理的最高中断优先级</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-中断管理"><a href="#2-4-中断管理" class="headerlink" title="2.4 中断管理"></a>2.4 中断管理</h3><ol><li><p>优先级配置</p><ul><li>STM32 通过优先级配置寄存器支持16级不同优先级中断.数字越小表示优先级越高(FreeRTOS 任务相反)</li><li>FreeRTOS 将 PendSV, SysTick 设为最低中断优先级(15),保证任务切换不会阻塞系统对其他中断的响应</li><li>FreeRTOS 通过 BASEPPRI 寄存器实现中断管理,屏蔽优先级低于某一阈值的中断</li><li><strong>建议将所有的优先级指定为抢占优先级,方便 FreeRTOS 管理</strong></li><li><strong>在中断服务函数中调用 FreeRTOS 的 API 函数,必须使用 <code>From_ISR</code> 后缀的函数</strong></li></ul></li><li><p><strong>临界区</strong>: 必须在不被打断的情况下完整运行的代码段.如对外设初始化有严格时序要求的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">taskENTER_CRITICAL();  <span class="hljs-comment">// 进入临界区</span><br>taskEXIT_CRITICAL();   <span class="hljs-comment">// 退出临界区</span><br><br>taskENTER_CRITICAL_FROM_ISR(); <span class="hljs-comment">// 中断函数安全 API</span><br>taskEXIT_CRITICAL_FROM_ISR();  <span class="hljs-comment">// 中断函数安全 API</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-5-时间片调度"><a href="#2-5-时间片调度" class="headerlink" title="2.5 时间片调度"></a>2.5 时间片调度</h3><ol><li><p>在 FreeRTOS 中,同等优先级的任务轮流分享相同的 CPU 时间.一个时间片的长度等同于 SysTick 中断的周期</p></li><li><p>相对延时: 从函数调用时刻开始计算.适合任务无需严格周期.或每次循环时间不确定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 使当前任务阻塞指定的 时钟节拍数(Ticks) */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelay</span><span class="hljs-params">(<span class="hljs-type">const</span> TickType_t xTicksToDelay)</span>;<br><br><span class="hljs-comment">/* pdMS_TO_TICKS 宏将毫秒时间转换为节拍数 */</span><br>vTaskDelay(pdMS_TO_TICKS(<span class="hljs-number">1000</span>));  <span class="hljs-comment">// 延时 1000ms</span><br></code></pre></td></tr></table></figure></li><li><p>相对延时示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskExample</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 任务逻辑代码</span><br>        vTaskDelay(<span class="hljs-number">1000</span> / portTICK_PERIOD_MS); <span class="hljs-comment">// 延时 1000ms(从调用时刻开始)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>绝对延时: 使当前任务阻塞到绝对时间点(基于上一次唤醒时间 + 固定周期)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskDelayUntil</span><span class="hljs-params">(TickType_t *pxPreviousWakeTime,  <span class="hljs-comment">// 指向任务上一次唤醒时间的变量</span></span><br><span class="hljs-params">                          <span class="hljs-type">const</span> TickType_t xTimeIncrement)</span>; <span class="hljs-comment">// 期望的任务周期(Ticks)</span><br><span class="hljs-comment">// 返回 pdTRUE 表示正常延时,pdFALSE 表示因调度器挂起等原因导致计算的时间已过期</span><br></code></pre></td></tr></table></figure></li><li><p>绝对延时示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vStrictPeriodicTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    TickType_t xLastWakeTime = xTaskGetTickCount(); <span class="hljs-comment">// 初始化基准时间</span><br>    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 任务逻辑代码(执行时间可能变化)</span><br>        xTaskDelayUntil(&amp;xLastWakeTime, <span class="hljs-number">100</span> / portTICK_PERIOD_MS); <span class="hljs-comment">// 严格 100ms 周期</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-6-任务状态查询"><a href="#2-6-任务状态查询" class="headerlink" title="2.6 任务状态查询"></a>2.6 <a href="https://www.freertos.org/zh-cn-cmn-s/Documentation/02-Kernel/04-API-references/03-Task-utilities/00-Task-utilities">任务状态查询</a></h3><ol><li><p>获取任务优先级</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">UBaseType_t <span class="hljs-title function_">uxTaskPriorityGet</span><span class="hljs-params">(TaskHandle_t xTask)</span>;<br></code></pre></td></tr></table></figure></li><li><p>设置任务优先级</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskPrioritySet</span><span class="hljs-params">(TaskHandle_t xTask, UBaseType_t uxNewPriority)</span>;<br></code></pre></td></tr></table></figure><ul><li>传入 <code>NULL</code> 表示当前任务</li><li>修改优先级后.若新优先级高于当前运行任务的优先级,会立即触发任务切换(抢占)</li></ul></li><li><p>获取任务运行历史上剩余堆栈的最小值(预留至少 10%~20% 的堆栈余量)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">UBaseType_t <span class="hljs-title function_">uxTaskGetStackHighWaterMark</span><span class="hljs-params">(TaskHandle_t xTask)</span>;<br></code></pre></td></tr></table></figure><ul><li><p><strong>数值越大: 堆栈剩余越多,安全性越高; 数值接近 0: 堆栈即将溢出,需增大堆栈空间</strong></p></li><li><p>FreeRTOS 默认 <strong>不提供堆栈溢出检测</strong>(需手动启用 <code>configCHECK_FOR_STACK_OVERFLOW</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configCHECK_FOR_STACK_OVERFLOW 1  <span class="hljs-comment">// 方法1(检测调用链)或 2(检测栈尾)</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>获取所有任务信息(以表格形式).用于快速监控任务运行状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 开启追踪 task 信息 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TRACE_FACILITY 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_STATS_FROMATTING_FUNCTIONS 1</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskList</span><span class="hljs-params">(<span class="hljs-type">char</span> *pcWriteBuffer)</span>;<br><span class="hljs-comment">// 输出格式形如:</span><br>名称   状态  优先级  堆栈剩余  任务编号<br>task1   x      <span class="hljs-number">1</span>       <span class="hljs-number">79</span>       <span class="hljs-number">3</span><br><span class="hljs-comment">// 状态标志: X(运行), B(阻塞), R(就绪), S(挂起), D(删除)</span><br></code></pre></td></tr></table></figure></li><li><p>获取系统中所有任务的 CPU 占用率 和 运行时间信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 开启追踪 运行时间信息 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configGENERATE_RUN_TIME_STATS        1 <span class="hljs-comment">// 启用运行时统计</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_STATS_FORMATTING_FUNCTIONS 1 <span class="hljs-comment">// 启用统计格式化函数</span></span><br><br><span class="hljs-comment">/* 需要实现的宏(提供计时基准) */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">get_run_time_counter</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>; <span class="hljs-comment">// 示例: 获取系统运行时间(需用户实现)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() \  </span><br>    (<span class="hljs-type">void</span>)get_run_time_counter() <span class="hljs-comment">// 初始化统计计时器</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portGET_RUN_TIME_COUNTER_VALUE() \  </span><br>    get_run_time_counter() <span class="hljs-comment">// 获取当前计时值</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskGetRunTimeStats</span><span class="hljs-params">(<span class="hljs-type">char</span> *pcWriteBuffer)</span>;<br><span class="hljs-comment">// 输出格式形如:</span><br>Task       Runtime  Stats:<br>main        <span class="hljs-number">125000</span>    <span class="hljs-number">32</span>%  <br>IDLE        <span class="hljs-number">250000</span>    <span class="hljs-number">64</span>%  <br>Tmr Svc      <span class="hljs-number">18750</span>     <span class="hljs-number">4</span>%  <br>Monitor       <span class="hljs-number">6250</span>     <span class="hljs-number">1</span>%<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3 消息队列"></a>3 消息队列</h2><h3 id="3-1-队列概念"><a href="#3-1-队列概念" class="headerlink" title="3.1 队列概念"></a>3.1 队列概念</h3><ol><li><strong>队列是任务间通信的主要形式,实现 任务间异步通信 或 任务与中断间通信,传递结构化数据或信号</strong><ul><li><strong>线程安全</strong>: 自带互斥访问,无需额外同步</li><li><strong>阻塞机制</strong>: 任务在队列空 &#x2F; 满时可选择阻塞等待</li></ul></li><li>列队的运作原理<ul><li>本质是一个环形缓冲区,存储固定大小的数据项</li><li>包含头尾指针,支持 FIFO(默认) 或 LIFO 存取方式</li></ul></li><li>队列中的项可以是不同长度的数据块,而非固定大小</li></ol><h3 id="3-2-队列-API"><a href="#3-2-队列-API" class="headerlink" title="3.2 队列 API"></a>3.2 队列 API</h3><ol><li><p>创建队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">QueueHandle_t <span class="hljs-title function_">xQueueCreate</span><span class="hljs-params">(     <span class="hljs-comment">// 创建队列.成功则返回队列句柄</span></span><br><span class="hljs-params">    UBaseType_t uxQueueLength,  <span class="hljs-comment">// 队列容量</span></span><br><span class="hljs-params">    UBaseType_t uxItemSize)</span>;    <span class="hljs-comment">// 每个队列项所占内存的大小.单位为字节</span><br></code></pre></td></tr></table></figure></li><li><p>发送 &#x2F; 接收消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueSend</span><span class="hljs-params">(QueueHandle_t xQueue,        <span class="hljs-comment">// 队列句柄</span></span><br><span class="hljs-params">                      <span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvItemToQueue,   <span class="hljs-comment">// 待发送消息的指针</span></span><br><span class="hljs-params">                      TickType_t xTickToWait)</span>;     <span class="hljs-comment">// 等待时间</span><br>BaseType_t <span class="hljs-title function_">xQueueReceive</span><span class="hljs-params">(QueueHandle_t xQueue,     <span class="hljs-comment">// 队列句柄</span></span><br><span class="hljs-params">                         <span class="hljs-type">void</span> *pvBuffer,           <span class="hljs-comment">// 接收消息缓冲区的指针</span></span><br><span class="hljs-params">                         TickType_t xTickToWait)</span>   <span class="hljs-comment">// 等待时间</span><br></code></pre></td></tr></table></figure></li><li><p>中断版本(<code>FromISR</code> 后缀)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueSendFromISR</span><span class="hljs-params">(QueueHandle_t xQueue,       <span class="hljs-comment">// 队列句柄</span></span><br><span class="hljs-params">                             <span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvItemToQueue,  <span class="hljs-comment">// 待发送消的指针</span></span><br><span class="hljs-params">                             BaseType_t *pxHigherPriorityTaskWoken)</span>;<br><span class="hljs-comment">// pxHigherPriorityTaskWoken: 如果被系统设为 pdTRUE,则中断退出前要执行上下文切换函数</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-3-队列使用"><a href="#3-3-队列使用" class="headerlink" title="3.3 队列使用"></a>3.3 队列使用</h3><ol><li><p><strong>示例: 任务间传递整数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">QueueHandle_t xQueue;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vSenderTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        xQueueSend(xQueue, &amp;value, portMAX_DELAY); <span class="hljs-comment">// 发送数据</span><br>        vTaskDelay(pdMS_TO_TICKS(<span class="hljs-number">1000</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vReceiverTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-type">int</span> receivedValue;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (xQueueReceive(xQueue, &amp;receivedValue, portMAX_DELAY) == pdPASS) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received: %d\n&quot;</span>, receivedValue);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    xQueue = xQueueCreate(<span class="hljs-number">5</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    xTaskCreate(vSenderTask, <span class="hljs-string">&quot;Sender&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>);<br>    xTaskCreate(vReceiverTask, <span class="hljs-string">&quot;Receiver&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>);<br>    vTaskStartScheduler();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>示例: 中断与任务通信</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">QueueHandle_t xInterruptQueue;<br><br><span class="hljs-comment">// 中断服务程序(ISR)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">USART1_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">char</span> data = USART1-&gt;DR;<br>    BaseType_t xHigherPriorityTaskWoken = pdFALSE;<br>    <br>    xQueueSendFromISR(xInterruptQueue, &amp;data, &amp;xHigherPriorityTaskWoken);<br>    portYIELD_FROM_ISR(xHigherPriorityTaskWoken); <span class="hljs-comment">// 必要时触发任务切换</span><br>&#125;<br><br><span class="hljs-comment">// 任务处理中断数据</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vISRHandlerTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-type">char</span> receivedData;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (xQueueReceive(xInterruptQueue, &amp;receivedData, portMAX_DELAY)) &#123;<br>            process_data(receivedData); <span class="hljs-comment">// 处理数据</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4 信号量"></a>4 信号量</h2><h3 id="4-1-信号量概念"><a href="#4-1-信号量概念" class="headerlink" title="4.1 信号量概念"></a>4.1 信号量概念</h3><ol><li><p><strong>信号量(Semaphore): 轻量级的任务间同步与互斥机制.主要用于 资源管理 或 事件通知</strong></p><ul><li>核心特点: 不传递具体数据,仅通过计数值协调任务</li><li>信号量可以是二值的(0 &#x2F; 1)或计数型(正整数)</li></ul></li><li><p><strong>信号量的类型</strong></p><table><thead><tr><th align="left">类型</th><th align="left">特点</th><th align="left">典型应用场景</th></tr></thead><tbody><tr><td align="left">二进制信号量</td><td align="left">计数值仅 0 或 1,相当于互斥锁</td><td align="left">共享资源保护(如外设访问)</td></tr><tr><td align="left">计数信号</td><td align="left">计数值可 &gt;1,表示可用资源数量</td><td align="left">资源池管理(如内存块, 连接池)</td></tr><tr><td align="left">互斥量(Mutex)</td><td align="left">具有优先级继承机制,解决优先级反转问题</td><td align="left">临界区保护(高优先级任务需访问)</td></tr></tbody></table></li><li><p>共享资源管理</p><ul><li>管理对共享资源的访问,确保同一时刻只有一个任务可以访问共享资源</li><li>适用于对资源的互斥访问,控制任务的执行顺序.或限制同时访问某一资源的任务数量</li></ul></li></ol><h3 id="4-2-信号量-API"><a href="#4-2-信号量-API" class="headerlink" title="4.2 信号量 API"></a>4.2 信号量 API</h3><ol><li><p>创建信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建二进制信号量(初始值=0)</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateBinary</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-comment">// 创建计数型信号量</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateCounting</span><span class="hljs-params">(</span><br><span class="hljs-params">                      UBaseType_t uxMaxCount,       <span class="hljs-comment">// 最大信号量数</span></span><br><span class="hljs-params">                      UBaseType_t uxInitialCount)</span>;  <span class="hljs-comment">// 初始信号数</span><br><br><span class="hljs-comment">// 创建互斥量</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateMutex</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure></li><li><p>获取信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取信号量,成功返回 pdTRUE</span><br>BaseType_t <span class="hljs-title function_">xSemaPhoreTake</span><span class="hljs-params">(</span><br><span class="hljs-params">    SemaphoreHandle_t xSemaphore,  <span class="hljs-comment">// 信号量句柄</span></span><br><span class="hljs-params">    TickType_t xTicksToWait)</span>;      <span class="hljs-comment">// 阻塞超时时间(portMAX_DELAY 表示永久等待)</span><br></code></pre></td></tr></table></figure></li><li><p>释放信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 释放信号量.  中断安全版本为: xSemaphoreGiveFromISR()</span><br>BaseType_t <span class="hljs-title function_">xSemaPhoreGive</span><span class="hljs-params">(SemaphoreHandle_t xSemaphore)</span>;<br></code></pre></td></tr></table></figure></li><li><p>删除信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vSemaphoreDelete</span><span class="hljs-params">(SemaphoreHandle_t xSemaphore)</span>;<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-3-信号量使用"><a href="#4-3-信号量使用" class="headerlink" title="4.3 信号量使用"></a>4.3 信号量使用</h3><ol><li><p><strong>示例: 二进制信号量实现任务同步</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">SemaphoreHandle_t xBinarySem;<br><br><span class="hljs-comment">// 任务A: 释放信号量(触发任务B)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskA</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        xSemaphoreGive(xBinarySem); <span class="hljs-comment">// 发送信号</span><br>        vTaskDelay(pdMS_TO_TICKS(<span class="hljs-number">1000</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 任务B: 等待信号量</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskB</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (xSemaphoreTake(xBinarySem, portMAX_DELAY) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Signal received!\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> main() &#123;<br>    xBinarySem = xSemaphoreCreateBinary();<br>    xTaskCreate(vTaskA, <span class="hljs-string">&quot;TaskA&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>);<br>    xTaskCreate(vTaskB, <span class="hljs-string">&quot;TaskB&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">NULL</span>);<br>    vTaskStartScheduler();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>示例: 互斥量保护共享资源</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">SemaphoreHandle_t xMutex;<br><span class="hljs-type">int</span> sharedData = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vWriteTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (xSemaphoreTake(xMutex, portMAX_DELAY)) &#123;<br>            sharedData++; <span class="hljs-comment">// 安全修改数据</span><br>            xSemaphoreGive(xMutex);<br>        &#125;<br>        vTaskDelay(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vReadTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (xSemaphoreTake(xMutex, portMAX_DELAY)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Data: %d\n&quot;</span>, sharedData);<br>            xSemaphoreGive(xMutex);<br>        &#125;<br>        vTaskDelay(<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-事件标志组"><a href="#5-事件标志组" class="headerlink" title="5 事件标志组"></a>5 事件标志组</h2><h3 id="5-2-事件标志组概念"><a href="#5-2-事件标志组概念" class="headerlink" title="5.2 事件标志组概念"></a>5.2 事件标志组概念</h3><ol><li><p>**事件标志组(Event Group): **任务间事件通知机制</p><ul><li>允许任务 等待多个事件位的组合,并支持 同步多个任务的执行</li><li>适用于需要 复杂事件触发逻辑 的场景</li></ul></li><li><p><strong>事件位(Event Bits)</strong>: 每个事件标志组包含一个 32 位变量(<code>EventBits_t</code>),每位(bit)代表一个独立的事件</p><ul><li><strong>逻辑或(OR)</strong>: 任意一个事件位被置位即可唤醒任务</li><li><strong>逻辑与(AND)</strong>: 所有指定事件位被置位才唤醒任务</li></ul><ul><li><strong>跨任务同步</strong>: 多个任务可以等待同一组事件,实现协同操作</li><li><strong>高效性</strong>: 比信号量, 队列更节省内存,适用于高频事件通知</li></ul></li></ol><h3 id="5-2-事件标志组-API"><a href="#5-2-事件标志组-API" class="headerlink" title="5.2 事件标志组 API"></a>5.2 事件标志组 API</h3><ol><li><p>创建事件标志组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">EventGroupHandle_t <span class="hljs-title function_">xEventGroupCreate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure></li><li><p>设置事件位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">EventBits_t <span class="hljs-title function_">xEventGroupSetBits</span><span class="hljs-params">(</span><br><span class="hljs-params">    EventGroupHandle_t xEventGroup, <span class="hljs-comment">// 事件组句柄</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> EventBits_t uxBitsToSet   <span class="hljs-comment">// 要置位的事件位(按位或组合)</span></span><br><span class="hljs-params">)</span>;<br><br><span class="hljs-comment">// 置位 bit0 和 bit2</span><br>xEventGroupSetBits(xEventGroup, (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>));<br><span class="hljs-comment">// 中断安全版本: xEventGroupSetBitsFromISR</span><br></code></pre></td></tr></table></figure></li><li><p>清除事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">EventBits_t <span class="hljs-title function_">xEventGroupClearBits</span><span class="hljs-params">(</span><br><span class="hljs-params">    EventGroupHandle_t xEventGroup,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> EventBits_t uxBitsToClear</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure></li><li><p>等待事件位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">EventBits_t <span class="hljs-title function_">xEventGroupWaitBits</span><span class="hljs-params">(<span class="hljs-comment">// 等待事件组中的某些标志位</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> EventGroupHandle_t xEventGroup,    <span class="hljs-comment">// 事件组句柄</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> EventBits_t uxBitsToWaitFor,       <span class="hljs-comment">// 需要等待哪些位</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> BaseType_t xClearOnExit,           <span class="hljs-comment">// pdTRUE: 退出时清除这些位</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> BaseType_t xWaitForAllBits,        <span class="hljs-comment">// pdTRUE: 需所有位满足.pdFALSE: 任意位满足</span></span><br><span class="hljs-params">    TickType_t xTicksToWait)</span>;                <span class="hljs-comment">// 超时时间</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="5-3-事件标志组使用"><a href="#5-3-事件标志组使用" class="headerlink" title="5.3 事件标志组使用"></a>5.3 事件标志组使用</h3><ol><li><p><strong>示例: 等待单一事件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">EventGroupHandle_t xEventGroup;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSensor</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 模拟传感器数据就绪(置位 bit0)</span><br>        xEventGroupSetBits(xEventGroup, (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>));<br>        vTaskDelay(pdMS_TO_TICKS(<span class="hljs-number">1000</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskProcessor</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待 bit0 置位(不自动清除)</span><br>        xEventGroupWaitBits(xEventGroup, (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>), pdFALSE, pdFALSE, portMAX_DELAY);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sensor data ready!\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>示例: <strong>多事件组合触发</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vControlTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待 bit0 AND bit1 同时置位,或 bit2 单独置位</span><br>        EventBits_t uxBits = xEventGroupWaitBits(<br>            xEventGroup,<br>            (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>), <span class="hljs-comment">// 监听 bit0/1/2</span><br>            pdTRUE,  <span class="hljs-comment">// 退出时清除所有监听位</span><br>            pdFALSE, <span class="hljs-comment">// 任意条件满足即可(改为 pdTRUE 则需全部满足)</span><br>            portMAX_DELAY<br>        );<br><br>        <span class="hljs-keyword">if</span> (uxBits &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Event 0 triggered!\n&quot;</span>);<br>        <span class="hljs-keyword">if</span> (uxBits &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Event 1 triggered!\n&quot;</span>);<br>        <span class="hljs-keyword">if</span> (uxBits &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Event 2 triggered!\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-任务通知"><a href="#6-任务通知" class="headerlink" title="6 任务通知"></a>6 任务通知</h2><h3 id="6-1-任务通知概念"><a href="#6-1-任务通知概念" class="headerlink" title="6.1 任务通知概念"></a>6.1 任务通知概念</h3><ol><li><p><strong>任务通知(Task Notification)</strong> 是一种 <strong>轻量级, 高性能的任务间通信机制</strong></p><ul><li>允许一个任务或中断直接向另一个任务发送事件或数据,而无需使用队列, 信号量等传统通信对象</li><li>任务通知是 FreeRTOS 中最快的通信方式,适用于对实时性要求极高的场景</li></ul></li><li><p>任务通知的优点</p><ul><li><strong>极速通信</strong>: 比队列, 信号量快 <strong>45% ~ 500%</strong>(无需全局对象管理)</li><li><strong>低内存占用</strong>: 每个任务自带通知字段,无需额外内存</li><li><strong>多功能集成</strong>: 可模拟<ul><li><strong>二进制信号量</strong>(通知值作为标志)</li><li><strong>计数信号量</strong>(通知值作为计数器)</li><li><strong>事件标志组</strong>(通知值的每一位作为事件)</li><li><strong>轻量队列</strong>(传递 32 位数据或指针)</li></ul></li></ul></li><li><p>任务通知的限制</p><ul><li><strong>单接收者</strong>: 每个通知只能发送给一个特定任务</li><li><strong>无缓冲</strong>: 仅保存最新通知(覆盖旧值,除非使用计数模式)</li></ul></li><li><p>通信机制</p><table><thead><tr><th align="left"><strong>机制</strong></th><th align="left"><strong>特点</strong></th><th align="left"><strong>适用场景</strong></th></tr></thead><tbody><tr><td align="left"><strong>事件标志组</strong></td><td align="left">支持多事件组合触发,轻量高效</td><td align="left">复杂事件条件, 多任务同步</td></tr><tr><td align="left"><strong>信号量</strong></td><td align="left">仅单事件通知,无位操作</td><td align="left">简单资源管理或同步</td></tr><tr><td align="left"><strong>队列</strong></td><td align="left">可传递数据,但无法组合事件</td><td align="left">需要数据传输的场景</td></tr><tr><td align="left"><strong>任务通知</strong></td><td align="left">极快,但只能传递单值</td><td align="left">高性能一对一通信</td></tr></tbody></table></li></ol><h3 id="6-2-任务通知-API"><a href="#6-2-任务通知-API" class="headerlink" title="6.2 任务通知 API"></a>6.2 任务通知 API</h3><ol><li><p>发送任务通知</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskNotify</span><span class="hljs-params">(</span><br><span class="hljs-params">    TaskHandle_t xTaskToNotify, <span class="hljs-comment">// 目标任务句柄</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span> ulValue,           <span class="hljs-comment">// 传递的数据(32位)</span></span><br><span class="hljs-params">    eNotifyAction eAction       <span class="hljs-comment">// 通知方式(见下表)</span></span><br><span class="hljs-params">)</span>;<br><br><span class="hljs-comment">// 中断安全版本</span><br>BaseType_t <span class="hljs-title function_">xTaskNotifyFromISR</span><span class="hljs-params">(</span><br><span class="hljs-params">    TaskHandle_t xTaskToNotify,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span> ulValue,</span><br><span class="hljs-params">    eNotifyAction eAction,</span><br><span class="hljs-params">    BaseType_t *pxHigherPriorityTaskWoken</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left"><strong>动作</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left"><code>eNoAction</code></td><td align="left">仅触发任务,不更新通知值(类似二进制信号量)</td></tr><tr><td align="left"><code>eSetBits</code></td><td align="left">按位或(OR)操作通知值(类似事件标志组)</td></tr><tr><td align="left"><code>eIncrement</code></td><td align="left">通知值 +1(类似计数信号量)</td></tr><tr><td align="left"><code>eSetValueWithOverwrite</code></td><td align="left">直接覆盖通知值(默认行为)</td></tr><tr><td align="left"><code>eSetValueWithoutOverwrite</code></td><td align="left">仅当通知值未被读取时更新(避免覆盖)</td></tr></tbody></table></li><li><p>接受任务通知</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskNotifyWait</span><span class="hljs-params">(<span class="hljs-comment">// 等待接收任务通知</span></span><br><span class="hljs-params"><span class="hljs-type">uint32_t</span> ulBitsToClearOnEntry,  <span class="hljs-comment">// 进入函数清除的通知值位</span></span><br><span class="hljs-params"><span class="hljs-type">uint32_t</span> ulBitsToClearOnExit,   <span class="hljs-comment">// 退出函数清除的通知值位</span></span><br><span class="hljs-params"><span class="hljs-type">uint32_t</span> *pulNotificationValue, <span class="hljs-comment">// 存储接收到的值</span></span><br><span class="hljs-params">TickType_t xTicksToWait)</span>;       <span class="hljs-comment">// 等待时长</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="6-3-任务通知使用"><a href="#6-3-任务通知使用" class="headerlink" title="6.3 任务通知使用"></a>6.3 任务通知使用</h3><ol><li><p><strong>示例: 模拟二进制信号量(任务同步)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vSenderTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 发送通知(不传递数据,仅触发任务)</span><br>        xTaskNotify(xReceiverTask, <span class="hljs-number">0</span>, eNoAction);<br>        vTaskDelay(pdMS_TO_TICKS(<span class="hljs-number">1000</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vReceiverTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待通知(类似 xSemaphoreTake)</span><br>        xTaskNotifyWait(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, portMAX_DELAY);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Notification received!\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>示例: 传递 32 位数据</strong>**</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vDataProducerTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-type">uint32_t</span> data = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 发送数据并覆盖旧值</span><br>        xTaskNotify(xConsumerTask, data, eSetValueWithOverwrite);<br>        vTaskDelay(pdMS_TO_TICKS(<span class="hljs-number">500</span>));<br>        data++;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vDataConsumerTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-type">uint32_t</span> receivedData;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待并读取数据</span><br>        xTaskNotifyWait(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;receivedData, portMAX_DELAY);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Data: %lu\n&quot;</span>, receivedData);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>示例: <strong>模拟事件标志组(多事件触发)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_EVENT_DATA_READY  (1 &lt;&lt; 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_EVENT_ERROR       (1 &lt;&lt; 1)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vInterruptHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// 在中断中设置事件位(bit0)</span><br>    xTaskNotifyFromISR(xHandlerTask, TASK_EVENT_DATA_READY, eSetBits, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vEventHandlerTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-type">uint32_t</span> ulNotifiedValue;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待任意事件位触发</span><br>        xTaskNotifyWait(<span class="hljs-number">0</span>, <span class="hljs-number">0xFF</span>, &amp;ulNotifiedValue, portMAX_DELAY);<br>        <br>        <span class="hljs-keyword">if</span> (ulNotifiedValue &amp; TASK_EVENT_DATA_READY) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Data ready event!\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ulNotifiedValue &amp; TASK_EVENT_ERROR) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error event!\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="7-源码分析"><a href="#7-源码分析" class="headerlink" title="7 源码分析"></a>7 源码分析</h2><h3 id="7-1-双向链表"><a href="#7-1-双向链表" class="headerlink" title="7.1 双向链表"></a>7.1 双向链表</h3><h3 id="7-2-队列"><a href="#7-2-队列" class="headerlink" title="7.2 队列"></a>7.2 队列</h3><h3 id="7-3-内存管理"><a href="#7-3-内存管理" class="headerlink" title="7.3 内存管理"></a>7.3 内存管理</h3>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>FreeRTOS</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32</title>
    <link href="/2024/04/01/Embedded/STM32/"/>
    <url>/2024/04/01/Embedded/STM32/</url>
    
    <content type="html"><![CDATA[<h1 id="STM32"><a href="#STM32" class="headerlink" title="STM32"></a>STM32</h1><h2 id="0-开发板介绍"><a href="#0-开发板介绍" class="headerlink" title="0 开发板介绍"></a>0 开发板介绍</h2><h3 id="0-1-STM32-开发板"><a href="#0-1-STM32-开发板" class="headerlink" title="0.1 STM32 开发板"></a>0.1 STM32 开发板</h3><p><img src="/2024/04/01/Embedded/STM32/0-STM32F103C8T6-Board-Features.jpg"></p><ol><li>使用右侧 SWD 接口下载程序及供电</li><li>32.768KHz 晶振: 连接到 LSE(low-speed external clock signal),给 RTC 提供时钟.<br>如果无需使用掉电不丢失时间的功能,可去掉.由内部 40KHz 的 RC 时钟源给 RTC 提供时钟</li><li>8MHz 晶振: 连接到 HSE(high-speed external clock signal),给 SYSCLK 提供时钟.<br>由于芯片内部的 HSI RC 时钟源不够精准,<strong>通常采用外部独立时钟源来为芯片提供系统时钟</strong></li></ol><h3 id="0-2-开发板引脚图"><a href="#0-2-开发板引脚图" class="headerlink" title="0.2 开发板引脚图"></a>0.2 开发板引脚图</h3><p><img src="/2024/04/01/Embedded/STM32/0-STM32F103C8T6-Blue-Pill-Pin-Layout.gif"></p><h3 id="0-3-最小系统电路"><a href="#0-3-最小系统电路" class="headerlink" title="0.3 最小系统电路"></a>0.3 最小系统电路</h3><p><img src="/2024/04/01/Embedded/STM32/0-minimal-system-circuit.png"></p><ol><li>3V3 与 GND 间的 100nF 滤波电容: 保证供电电压的稳定</li><li><strong>晶振</strong>: 8MHz 晶振的典型电路.20pF 作为起振电容.接到芯片的5,6号脚.3,4号引脚预留接 32.768KHz 晶振</li><li><strong>复位</strong>: NRST 接到7号引脚,低电平复位<ul><li>刚上电时,电容充电,相当于短路,NRST 下拉至 GND(上电复位).充满电后短路,上拉至 3V3</li><li>之后,K1 断开时,NRST 拉至 3V3.K1 闭合时,电容放电,NRST 接地(手动复位)</li></ul></li><li><strong>启动配置</strong>: H1 起到开关的作用.实际中采用跳线帽的方式选择模式</li><li><strong>下载端口</strong>: SWDIO, SWCLK 分别接到芯片的34,37号引脚(PA13,14).正负极间同样可以加滤波电容</li></ol><h2 id="1-STM32"><a href="#1-STM32" class="headerlink" title="1 STM32"></a>1 STM32</h2><h3 id="1-1-STM32-命名规则"><a href="#1-1-STM32-命名规则" class="headerlink" title="1.1 STM32 命名规则"></a>1.1 STM32 命名规则</h3><p><img src="/2024/04/01/Embedded/STM32/1-STM32-naming.png"></p><h3 id="1-2-存储器和总线构架"><a href="#1-2-存储器和总线构架" class="headerlink" title="1.2 存储器和总线构架"></a>1.2 存储器和总线构架</h3><p><img src="/2024/04/01/Embedded/STM32/1-system-architecture.png"></p><h3 id="1-3-F103C8T6-引脚定义"><a href="#1-3-F103C8T6-引脚定义" class="headerlink" title="1.3 F103C8T6 引脚定义"></a>1.3 F103C8T6 引脚定义</h3><p><img src="/2024/04/01/Embedded/STM32/1-STM32F103C8T6-pin-define.png"></p><h3 id="1-4-片上资源-外设"><a href="#1-4-片上资源-外设" class="headerlink" title="1.4 片上资源(外设)"></a>1.4 片上资源(外设)</h3><table><thead><tr><th>英文缩写</th><th>名称</th><th>英文缩写</th><th>名称</th></tr></thead><tbody><tr><td>NVIC</td><td>嵌套向量中断控制器</td><td>CAN</td><td>CAN 通信</td></tr><tr><td>SysTick</td><td>系统滴答定时器</td><td>USB</td><td>USB 通信</td></tr><tr><td>RCC</td><td>复位和时钟控制</td><td>RTC</td><td>实时时钟</td></tr><tr><td>GPIO</td><td>通用 IO 口</td><td>CRC</td><td>CRC 校验</td></tr><tr><td>AFIO</td><td>复用 IO 口</td><td>PWR</td><td>电源控制</td></tr><tr><td>EXTI</td><td>外部中断</td><td>BKP</td><td>备份寄存器</td></tr><tr><td>TIM</td><td>定时器</td><td>IWDG</td><td>独立看门狗</td></tr><tr><td>ADC</td><td>模数转换器</td><td>WWDG</td><td>窗口看门狗</td></tr><tr><td>DMA</td><td>直接内存访问</td><td>DAC</td><td>数模转换器</td></tr><tr><td>USART</td><td>同步 &#x2F; 异步串口通信</td><td>SDIO</td><td>SD 卡接口</td></tr><tr><td>I2C</td><td>I2C 通信</td><td>FSMC</td><td>可变静态存储控制器</td></tr><tr><td>SPI</td><td>SPI 通信</td><td>USB OTG</td><td>USB 主机接口</td></tr></tbody></table><h2 id="2-工程建立"><a href="#2-工程建立" class="headerlink" title="2 工程建立"></a>2 工程建立</h2><h3 id="2-1-开发环境"><a href="#2-1-开发环境" class="headerlink" title="2.1 开发环境"></a>2.1 开发环境</h3><ol><li><p><strong>Keil5 MDK: IDE, 集成开发环境</strong></p><ul><li><p>运行 <code>MDK542a.exe</code> 文件,更改安装路径后,一路点击 <code>next</code> 即可</p></li><li><p>软件注册: 以管理员身份运行 Keil5 -&gt; <code>File</code> -&gt; <code>License Management</code> -&gt; 复制 CID</p><p><img src="/2024/04/01/Embedded/STM32/2-register-Keil.png"></p></li><li><p>运行 <code>keygen_new2032.exe</code> 文件 -&gt; 粘贴 <code>CID</code> -&gt; <code>Target</code> 选 <code>ARM</code> -&gt; 点击 <code>Generate</code> 生成序列码</p></li><li><p>将序列码粘贴到 keil5 中的 <code>New License ID Code</code> 栏 -&gt; <code>ADD LIC</code></p></li></ul></li><li><p><strong>器件支持包: 对相应的 MCU 型号提供支持</strong></p><ul><li><p>离线安装: 下载后,运行相应的器件支持包文件即可(<code>Keil.STM32F1xx_DFP.2.2.0.pack</code>)</p></li><li><p>在线安装: 打开 Keil -&gt; <code>Pack Installer</code> -&gt; <code>Device</code> -&gt; <code>STMicroelectronics</code> -&gt; install 后缀 <code>DFP</code> 的文件</p></li></ul></li><li><p><strong>STLink 驱动</strong>: Keil5 安装目录中自带(<code>Keil5\ARM\STLink\USBDriver\dpinst_amd64.exe</code>)</p></li><li><p><strong>JLink 驱动</strong>: 同样位于 Keil5 安装目录中(<code>Keil5\ARM\Segger\JLink.exe</code>)</p></li><li><p><strong>USB 转串口驱动</strong>: 运行 <code>CH341SER.EXE</code></p></li><li><p>STM32 开发方式</p><ul><li>基于寄存器: STM32 结构复杂,寄存器数量太多,不推荐</li><li>基于库函数: 使用 ST 官方提供的函数,间接配置寄存器(官方停止维护)</li><li>基于 HAL 库: 图形化界面配置 STM32(官方主推)</li></ul></li><li><p>基于库函数需要 STM32 库函数的文件(固件库)</p></li></ol><h3 id="2-2-寄存器开发"><a href="#2-2-寄存器开发" class="headerlink" title="2.2 寄存器开发"></a>2.2 寄存器开发</h3><ol><li><p>在 Keil5 中 -&gt; <code>Project</code> -&gt; <code>New uVision Project</code> -&gt; 设置工程文件名(project) -&gt; 选择芯片型号</p><ul><li><p>此时工程目录下将会有一个 <code>project.uvprojx</code> 文件.该文件为 keil 工程文件</p></li><li><p>配合使用 git 管理代码版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init<br></code></pre></td></tr></table></figure></li><li><p>创建 <code>.gitignore</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">.vscode/<br>DebugConfig/<br>Listings/<br>Objects/<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>添加固件库文件: 在工程目录中创建 Start 目录存放下列启动文件(STM32程序从启动文件开始执行)</strong></p><p><img src="/2024/04/01/Embedded/STM32/2-Start-directory.png"></p></li><li><p><strong>将文件添加到工程</strong></p><ul><li><p>将左侧的 <code>Source Group 1</code> 改名为 <code>Start</code> -&gt; 右击后选择 <code>Add Existing Files to Group</code> 添加文件</p><p><img src="/2024/04/01/Embedded/STM32/2-add-start-file.png"></p></li><li><p>启动文件需要根据型号选择(这里选择仅 <code>startup_stm32f10x_md.s</code>)</p></li></ul></li><li><p><strong>添加文件夹的头文件路径</strong>: <code>Options</code> -&gt; <code>C/C++</code> -&gt; 在 <code>Include Paths</code> 栏添加路径</p></li><li><p><strong>编写测试函数</strong>: 首先创建 User 目录用于存放用户代码</p><ul><li><p>创建 <code>main.c</code> 文件并添加到工程</p><ul><li><p>右键 <code>Target</code> -&gt; <code>Add Group</code> 并将名称改为 <code>User</code> -&gt; 右键 <code>Add New item...</code></p></li><li><p>选择 <code>C File</code> -&gt; 名称设为 <code>main</code> -&gt; 修改文件存放路径为 <code>User</code> 目录</p></li></ul></li><li><p>测试配置: 打开 <code>main</code> 文件在空白处右击,选择 insert <code>#include file stm32f10x.h</code> -&gt; 编写任意代码 -&gt; <code>Build</code></p></li><li><p>若编译没有错误说明工程建立正常.到此可以进行<strong>基于寄存器的开发</strong>.如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;  <span class="hljs-comment">/* 点亮 PC13 的 LED */</span><br>RCC-&gt;APB2ENR |= <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<span class="hljs-comment">/* 开启 APB2 的 GPIOC 时钟 */</span><br>GPIOC-&gt;CRH |= <span class="hljs-number">3</span> &lt;&lt; (<span class="hljs-number">4</span> * (<span class="hljs-number">13</span> - <span class="hljs-number">8</span>));<span class="hljs-comment">/* 指定 GPIO_Pin_13 为推挽输出.50MHz */</span><br>GPIOC-&gt;ODR &amp;= !(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">13</span>);<span class="hljs-comment">/* 指定 GPIO_Pin_13 引脚的电压为低 */</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>连接最小系统板时需要选择对应的调试方式(这里使用 STLink)</p><ul><li><code>Options</code> -&gt; <code>Debug</code> -&gt; Use 栏选择 <code>ST-Link Debugger</code> -&gt; <code>Settings</code> -&gt; <code>Flash Download</code> -&gt; 勾选 <code>Reset and Run</code></li></ul></li></ol><h3 id="2-3-标准库开发"><a href="#2-3-标准库开发" class="headerlink" title="2.3 标准库开发"></a>2.3 标准库开发</h3><ol><li><p>在工程新建 <code>Library</code> 目录,添加 <code>Libraries\STM32F10x_StdPeriph_Driver\src, inc</code> 目录下的所有文件(各23个)</p></li><li><p>将 <code>Project\STM32F10x_StdPeriph_Template</code> 目录下的三个文件添加到工程的 <code>User</code> 目录</p><p><img src="/2024/04/01/Embedded/STM32/2-User-directory.png"></p></li><li><p>添加全局宏定义</p><ul><li><p>打开 <code>&quot;stm32f10x.h&quot;</code> 文件,在文件末尾有条件编译语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_STDPERIPH_DRIVER</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x_conf.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>因此需要宏定义 <code>USE_STDPERIPH_DRIVER</code>: <code>Options</code> -&gt; 在 <code>C/C++ Define</code> 栏填 <code>USE_STDPERIPH_DRIVER</code></p></li></ul></li><li><p>需要再次完成 <strong>将文件添加到工程,添加文件夹的头文件路径</strong> 步骤</p></li><li><p>至此可以进行<strong>基于库函数的开发</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-comment">/* 配置 GPIOC.并设置为: 推挽输出,引脚选中13, 速率50MHz */</span><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);<br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOC, &amp;GPIO_InitStructure);<br>GPIO_ResetBits(GPIOC, GPIO_Pin_13);  <span class="hljs-comment">// 将 PC13 置为低电平</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>库函数调用逻辑: 复位中断函数才是程序的入口(在复位后执行).其职责为调用 <code>SystemInit, main</code> 函数</p><p><img src="/2024/04/01/Embedded/STM32/2-Engineering-architecture.png"></p></li></ol><h3 id="2-4-Keil5-使用"><a href="#2-4-Keil5-使用" class="headerlink" title="2.4 Keil5 使用"></a>2.4 Keil5 使用</h3><ol><li><strong>界面设置(Configuration)</strong><ul><li><code>Configuration</code> -&gt; <code>Color &amp; Fonts</code> -&gt; <code>C/C++ Editor files</code> -&gt; 设置字体及其大小</li><li><code>Configuration</code> -&gt; <code>Editor</code> -&gt; <code>Encoding</code> 改为 <code>UTF-8</code> 编码, <code>Tab Size</code> 改为4</li><li><code>Manage Project Items</code> -&gt; 可以调整左侧文件显示的顺序</li></ul></li><li>Keil 中直接写入汉字报错的解决方式<ul><li><code>Options</code> -&gt; <code>C/C++</code> -&gt; <code>Misc Controls</code> 栏填入 <code>--no-multibyte-chars</code></li></ul></li></ol><h3 id="2-5-串口下载"><a href="#2-5-串口下载" class="headerlink" title="2.5 串口下载"></a>2.5 串口下载</h3><ol><li><p>启动模式</p><table><thead><tr><th>BOOT1</th><th>BOOT 0</th><th>启动模式</th><th>说明</th></tr></thead><tbody><tr><td>X</td><td>0</td><td>主闪存存储器</td><td><strong>主闪存存储器被选为启动区域(主要使用方式)</strong></td></tr><tr><td>0</td><td>1</td><td>系统存储器</td><td>系统存储器被选为启动区域.运行 BootLoader(串口下载)</td></tr><tr><td>1</td><td>1</td><td>内置 SRAM</td><td>内置 SRAM 被选为启动区域(程序调试)</td></tr></tbody></table></li><li><p>FlyMcu 串口下载程序</p><ul><li><p>需要连接 USB转串口模块的 RX(PA9), TX(PA10), GND</p></li><li><p>需要工程生成的 HEX 文件(在 Keil 中 <code>Options for target</code> -&gt; <code>output</code> 勾选 <code>Creact HEX File</code>)</p><p><img src="/2024/04/01/Embedded/STM32/2-CreateHEX.png"></p></li><li><p><code>搜索串口</code> -&gt; bps 默认115200 -&gt; 选择下载的程序文件(.hex)</p></li><li><p>单片机引脚配置: 让STM32执行 <code>BootLoader</code> 程序</p><ul><li>将 Boot0 配置为1(插在右边), Boot1 配置为0(插在左边)</li><li>按下复位键,此时 STM32 将不断接收 USART1 的数据.刷新到主闪存</li></ul></li><li><p>点击<code>开始编程</code>.写入完成后,将 Boot0 配置为0(插在左边).按下复位键.程序开始执行</p><p><img src="/2024/04/01/Embedded/STM32/2-FlyMcu.png"></p></li></ul></li><li><p><strong>STM32 一键下载</strong>(需要搭建另外的电路)</p><ul><li>但是仍可以勾选<code>编程后执行</code>,反勾选<code>编程到FLASH时写选项字节</code></li><li>然后 boot0 选为1 -&gt; 按下复位键 -&gt; 下载程序.完成下载后程序会直接运行</li><li>原理为指定运行程序从 0800 0000 开始运行.复位其本质后仍执行 <code>BootLoader</code> 程序</li></ul></li><li><p>ST-LINK Utility(需连接 ST Link 下载)</p><p><img src="/2024/04/01/Embedded/STM32/2-ST-LINK-Utility.png"></p><ul><li><strong><code>Target</code> -&gt; <code>Option Bytes</code>(快捷键 Ctrl + B): 打开选项字节的设置页面</strong></li></ul></li></ol><h3 id="2-6-HAL-库开发"><a href="#2-6-HAL-库开发" class="headerlink" title="2.6 HAL 库开发"></a>2.6 HAL 库开发</h3><ol><li><p>CubeMX <a href="https://www.st.com/en/development-tools/stm32cubemx.html">官网下载</a></p><ul><li><p>运行 <code>SetupSTM32CubeMX-6.12.1-Win.exe</code> 安装 CubeMX(<strong>注意第一次需要使用管理员权限打开</strong>)</p></li><li><p>安装支持包(在线安装): Help -&gt; Manage embedded software packages.选择对应版本下载</p><p><img src="/2024/04/01/Embedded/STM32/2-Cube-pack-manager.png"></p></li><li><p>创建项目: Access to MCU selector -&gt; 选择相应 MCU</p><p><img src="/2024/04/01/Embedded/STM32/2-Cube-pin.png"></p></li><li><p><strong>引脚和配置</strong></p><ul><li><strong>RCC 选择 Crystal&#x2F;Ceramic Resonator</strong></li><li><strong>SYS 中 Debug 选择 Serial Wire</strong></li><li><strong>PC13 选择 GPIO_Output</strong></li></ul></li><li><p><strong>时钟配置: HCLK 设为72MHz</strong></p><p><img src="/2024/04/01/Embedded/STM32/2-Cube-clock.png"></p></li><li><p>项目配置</p><ul><li><p>需要指定项目名称, IDE 选择 <code>MDK-ARM</code></p></li><li><p>在 <code>Code Generator</code> 中勾选 <code>Generate peripheral initialization as a pair of &quot;.c/.h&quot; files per peripheral</code></p><p><img src="/2024/04/01/Embedded/STM32/2-Cube-project-config.png"></p></li></ul></li></ul></li></ol><h3 id="2-7-VSCode-编码"><a href="#2-7-VSCode-编码" class="headerlink" title="2.7 VSCode 编码"></a>2.7 VSCode 编码</h3><ol><li><p>VSCode <a href="https://code.visualstudio.com/">官网下载</a></p><ul><li><p>安装插件: <code>C/C++, Keil Assistant</code></p><p><img src="/2024/04/01/Embedded/STM32/2-VSCode-plug.png"></p></li><li><p>关联 Keil: 设置中搜索 keil, 在 <code>Keil Assistant.MDK: Uv4 Path</code> 栏指定 UV4 路径</p><p><img src="/2024/04/01/Embedded/STM32/2-Keil4-path.png"></p></li><li><p>在资源管理器中将会新增 keil 栏.可以进行编译下载(其本质仍是调用 Keil 的配置)</p><p><img src="/2024/04/01/Embedded/STM32/2-Keil.png"></p></li></ul></li></ol><h2 id="3-GPIO-输入输出"><a href="#3-GPIO-输入输出" class="headerlink" title="3 GPIO 输入输出"></a>3 GPIO 输入输出</h2><h3 id="3-1-GPIO-结构"><a href="#3-1-GPIO-结构" class="headerlink" title="3.1 GPIO 结构"></a>3.1 GPIO 结构</h3><ol><li><p>GPIO 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/3-GPIO-struct.png"></p><ul><li>I&#x2F;O 引脚连接驱动器寄存器到 APB2</li><li>内核写入(读取)输出寄存器(输入寄存器),以此控制(读取) I&#x2F;O 引脚的高低电平</li></ul></li><li><p>IO 口的基本结构</p><p><img src="/2024/04/01/Embedded/STM32/3-IOpin-struct.png"></p></li><li><p>输入电路分析</p><ul><li><code>保护二极管</code>对输入电压进行限幅: 确保输入电压范围在 $V_{SS} \sim V_{DD}$</li><li><code>上拉电阻和下拉电阻</code>: 避免引脚悬空导致的输入数据不确定, 设定一个默认值<ul><li>上方闭合,下方断开: <strong>上拉输入模式,即默认高电平</strong></li><li>上方断开,下方闭合: <strong>下拉输入模式,即默认低电平</strong></li><li>开关均断开: <strong>浮空输入模式</strong></li></ul></li><li><code>施密特触发器</code>(图中翻译错误): 对输入电压整形,然后写入<code>输入数据寄存器</code><ul><li>输入电压大于某个上限,输出瞬间升为高电平;</li><li>输入电压小于某个下限,输出瞬间将为低电平;否则不变</li></ul></li><li>模拟输入, 复用功能输入<ul><li><strong>模拟输入</strong>需要连续量,因此在施密特触发器之前.连接到 ADC.此时 GPIO 失效</li><li><strong>复用功能输入</strong>(如串口的输入引脚)需要数字量,因此在施密特触发器之后</li></ul></li></ul></li><li><p>输出电路分析: 输出可由 <code>输出数据寄存器</code>(普通IO输出) 或 <code>片上外设</code>(<strong>复用功能输出</strong>) 控制</p><ul><li><code>位设置/清除寄存器</code>: 单独操作输出数据寄存器的某一位, 而不影响其他位<br>将需要置1的对应写1,其余写0,即可自动将相应位置置1,其他位不变</li><li><code>输出数据寄存器</code>: 输出整个寄存器的数据.只能整体写入,不能单独操作某一位</li><li><code>数据输出选择器</code>: 选择由输出数据寄存器或是复用功能输出</li><li><code>P-MOS, N-MOS</code>的作用: 输出控制<ul><li>当 P-MOS,N-MOS 均有效时为<strong>推挽输出</strong>, 高低电平均有驱动能力</li><li>当 P-MOS 无效, N-MOS 有效时为<strong>开漏输出</strong>,仅低电平具有驱动能力<ul><li>当数据寄存器为1时,N-MOS 断开,呈现出高阻态</li><li>当数据寄存器为0时,N-MOS 导通,输出低电平</li><li>开漏输出模式可以用于通信协议的驱动,如 I2C</li><li>开漏输出模式输出 5V 信号: 在 I&#x2F;O 口外接一个上拉电阻到 5V 电源正极</li></ul></li><li>当 P-MOS N-MOS 均无效时,输出关闭,端口电平由外部控制</li></ul></li></ul></li></ol><h3 id="3-2-标准库代码分析"><a href="#3-2-标准库代码分析" class="headerlink" title="3.2 标准库代码分析"></a>3.2 标准库代码分析</h3><ol><li><p>对 <code>stm32f10x_gpio.h, stm32f10x_gpio.c</code> 源码的分析</p></li><li><p><strong>头文件中的通用格式</strong>: 防止重复包含以及保证对 C++ 的兼容性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __STM32F10x_GPIO_H  <span class="hljs-comment">/* 防止头文件重复包含 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __STM32F10x_GPIO_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus  <span class="hljs-comment">/* 对 C++ 的兼容 */</span></span><br> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* 对 C++ 的兼容 */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __STM32F10x_GPIO_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>参数合理性判断</strong>: 对于后续编写的函数,需要判断传入参数是否为 GPIO.在调用函数前断言</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOB) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOC) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOD) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOE) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOF) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOG))</span><br><br><span class="hljs-comment">/* 分析: 断言参数 expr.若非零,则通过.否则断言失败,直接在编译时报错,并指出错误位置 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))</span><br></code></pre></td></tr></table></figure></li><li><p><strong>枚举定义</strong>: 初始化时,需要根据手册中的位组合确定模式时,提前对其定义.枚举非常多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 分析: 对于输出最大速率寄存器的组合,在这里直接定义为对应的值,方便使用 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>  GPIO_Speed_10MHz = <span class="hljs-number">1</span>,<span class="hljs-comment">/* MODE = 01 */</span><br>  GPIO_Speed_2MHz,<span class="hljs-comment">/* MODE = 10 */</span><br>  GPIO_Speed_50MHz<span class="hljs-comment">/* MODE = 11 */</span><br>&#125; GPIOSpeed_TypeDef;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-3-HAL-库"><a href="#3-3-HAL-库" class="headerlink" title="3.3 HAL 库"></a>3.3 HAL 库</h3><ol><li><p>使用 HAL 库使 led 闪烁</p><p><img src="/2024/04/01/Embedded/STM32/3-GPIO-HAL.png"></p></li></ol><h2 id="4-EXTI-外部中断"><a href="#4-EXTI-外部中断" class="headerlink" title="4 EXTI 外部中断"></a>4 EXTI 外部中断</h2><h3 id="4-1-中断"><a href="#4-1-中断" class="headerlink" title="4.1 中断"></a>4.1 中断</h3><ol><li><p>中断系统</p><ul><li>中断允许微控制器在执行主程序的同时,对发生的特定事件做出及时响应</li><li>在 STM32 中,中断用于处理外部事件,如按键输入,定时器溢出,串口数据接收等</li><li><strong>中断处理程序: 一段特殊的代码,用于处理中断事件</strong></li><li>当中断发生时,自动跳转到对应中断向量表项中存储的中断处理程序地址,并执行其中的代码</li></ul></li><li><p>中断向量表</p><ul><li><strong>中断处理程序的入口地址存储在中断向量表中</strong></li><li>中断向量表是一个存储中断处理程序地址的数组,每个中断都有一个对应的向量表项</li></ul></li><li><p><strong>中断优先级: 每个中断都有一个优先级,用于确定中断的相对重要性</strong></p><ul><li>较高优先级的中断将优先处理,而较低优先级的中断可能会被延迟处理</li><li><strong>中断嵌套: 即在一个中断处理程序中,可以允许更高优先级的中断打断当前正在执行的中断处理程序.以确保对于紧急事件的及时响应</strong></li></ul></li></ol><h3 id="4-2-NVIC"><a href="#4-2-NVIC" class="headerlink" title="4.2 NVIC"></a>4.2 NVIC</h3><ol><li><p><strong>NVIC(Nested Vectored Interrupt Controller, 嵌套向量中断控制器)是内核外设</strong></p><p><img src="/2024/04/01/Embedded/STM32/4-NVIC.png"></p><ul><li>中断通道可以将 EXTI, TIM, ADC, USART… 作为输入</li><li>只有一条输出通道,根据中断优先级分配先后顺序</li></ul></li><li><p>优先级分组: 由优先级寄存器的4位决定</p><ul><li>优先级寄存器分为高 n 位的抢占优先级和低 (4-n) 位的响应优先级</li><li><strong>抢占优先级可以中断嵌套,响应优先级则需要进行排队</strong></li></ul></li><li><p>优先级规则</p><ul><li>优先级数字越小,优先级越高.如果不设置优先级,默认为0</li><li>若抢占优先级和响应优先级都一样,则查找中断向量表,值小的先响应</li></ul></li></ol><h3 id="4-3-EXTI"><a href="#4-3-EXTI" class="headerlink" title="4.3 EXTI"></a>4.3 EXTI</h3><ol><li><p><strong>EXTI(Extern Interrupt, 外部中断)</strong></p><p><img src="/2024/04/01/Embedded/STM32/4-EXTI.png"></p><ul><li>EXTI 可以监测指定 GPIO 口的电平信号,当其指定的 GPIO 口产生电平变化时,EXTI 将立即向 NVIC 发出中断申请,经过 NVIC 裁决后即可中断 CPU 主程序,使 CPU 执行 EXTI 对应的中断程序</li><li>支持所有的 GPIO 口.但同 Pin 不能同时触发</li><li><strong>触发方式: 上升 &#x2F; 下降 &#x2F; 双边沿, 软件触发</strong></li><li>通道数: 16个 GPIO_Pin, PVD 输出, RTC 闹钟, USB 唤醒, 以太网唤醒</li></ul></li><li><p>响应方式</p><ul><li><strong>中断响应: 正常中断流程,申请中断</strong></li><li><strong>事件响应: 不申请中断,通向其他外设,触发其他外设的操作</strong></li></ul></li><li><p>判断代码是否成功进入中断的方法</p><ul><li>进入调试模式,在中断函数设置一个断点</li><li>选择全速运行代码,手动触发一个中断条件,使代码进入中断</li><li>如果代码运行到设置的断点处,说明进入了中断</li></ul></li></ol><h3 id="4-4-AFIO"><a href="#4-4-AFIO" class="headerlink" title="4.4 AFIO"></a>4.4 AFIO</h3><ol><li><p><strong>AFIO 功能: 引脚复用功能重映射, 中断引脚选择</strong></p></li><li><p>中断引脚选择: PA0~PG0 只能有一个通过 AFIO 的选择到达 EXTI</p><p><img src="/2024/04/01/Embedded/STM32/4-AFIO.png"></p></li><li><p>AFIO 引脚重映射(以 TIM2 的 CH1 为例)</p><ul><li><p>TIM2 的 CH1 原本位于 PA0.可以将其重映射到 PA15</p><p><img src="/2024/04/01/Embedded/STM32/4-AFIO-redefine.png"></p></li><li><p>因此,可以使用部分重映射1或完全重映射实现使用 PA15 作为 TIM2 的 CH1</p></li><li><p>需要注意的是,PA15 原本的功能是作为 JTAG 的调试功能,因此还需要将其关闭,作为普通 GPIO 引脚</p><p><img src="/2024/04/01/Embedded/STM32/4-JTAG-disable.png"></p></li></ul></li></ol><h3 id="4-5-HAL-库操作"><a href="#4-5-HAL-库操作" class="headerlink" title="4.5 HAL 库操作"></a>4.5 HAL 库操作</h3><ol><li><p>直接在引脚上选择 GPIO_EXTI</p><p><img src="/2024/04/01/Embedded/STM32/4-HAL-EXTI-pin.png"></p></li><li><p>在 GPIO 中选择其配置</p><p><img src="/2024/04/01/Embedded/STM32/4-HAL-EXTI-pin-config.png"></p></li><li><p>enable EXTI 中断线</p><p><img src="/2024/04/01/Embedded/STM32/4-NVIC-enable.png"></p></li><li><p>在 NVIC 中配置优先级(注意 hal_delay 的实现依赖于 SysTick 中断,因此若在中断使用 delay 需要 SysTick 优先级高于当前中断)</p><p><img src="/2024/04/01/Embedded/STM32/4-NVIC-priority.png"></p></li><li><p>生成的代码主要关注 <code>stm32f1xx_it.c</code> 文件,会增加一个中断处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* This function handles EXTI line1 interrupt. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">EXTI1_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  HAL_GPIO_EXTI_IRQHandler(key1_Pin);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>其底层会调用到一个弱实现的回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span> &#123;<br>  <span class="hljs-comment">/* EXTI line interrupt detected */</span><br>  <span class="hljs-keyword">if</span> (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != <span class="hljs-number">0x00u</span>) &#123;<br>    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);<br>    HAL_GPIO_EXTI_Callback(GPIO_Pin);<br>  &#125;<br>&#125;<br><br>__weak <span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_Callback</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span> &#123;<br>  UNUSED(GPIO_Pin);  <span class="hljs-comment">/* Prevent unused argument(s) compilation warning */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>因此可以通过重新实现回调函数来执行逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_Callback</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span> &#123;<br>  <span class="hljs-keyword">if</span> (GPIO_Pin == key1_Pin)<br>      <span class="hljs-comment">// 具体逻辑...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="5-TIM-定时器"><a href="#5-TIM-定时器" class="headerlink" title="5 TIM 定时器"></a>5 TIM 定时器</h2><h3 id="5-1-定时器"><a href="#5-1-定时器" class="headerlink" title="5.1 定时器"></a>5.1 定时器</h3><ol><li><p><strong>定时器: 对输入时钟计数,在计数值达到设定值时触发中断</strong></p><ul><li>基本定时功能: 每隔一段时间产生一个中断</li><li>定时器输出比较: 常用来产生 PWM 波形</li><li>定时器输入捕获: 测量方波频率</li><li>定时器编码器接口: 读取正交编码器的输出波形</li></ul></li><li><p>定时器类型</p><table><thead><tr><th><strong>类型</strong></th><th align="left"><strong>编号</strong></th><th><strong>总线</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>基本定时器</td><td align="left">TIM6 &amp; TIM7</td><td>APB1</td><td>定时中断, 主模式触发 DAC</td></tr><tr><td>通用定时器</td><td align="left">TIM2 ~ TIM5</td><td>APB1</td><td>拥有基本定时器全部功能. 额外具有: 内外时钟源选择,<br />输入捕获输出比较, 编码器接口, 主从触发模式等功能</td></tr><tr><td>高级定时器</td><td align="left">TIM1 &amp; TIM8</td><td>APB2</td><td>拥有通用定时器全部功能. 额外具有: 重复计数器,<br />死区生成, 互补输出, 刹车输入等功能</td></tr></tbody></table></li><li><p>基本定时器</p><p><img src="/2024/04/01/Embedded/STM32/5-basic-timer.png"></p><ul><li><strong>时基单元: 最基本的计数计时电路</strong><ul><li><code>PSC 预分频器</code>: 对 72MHz 的时钟进行预分频.实际分频系数 &#x3D; PSC + 1</li><li><code>CNT 计数器</code>: 对预分频后的时钟进行计数.每有一个上升沿,CNT ++</li><li><code>ARR 自动重装载寄存器</code>: 存储计数目标.<strong>当计数值 &#x3D;&#x3D; 重装值时,产生一个中断信号,并清零计数器</strong></li></ul></li><li><strong>主模式输出: 可以将定时器的更新事件映射到触发控制器(TRGO),TRGO 接到 DAC 的触发转换引脚</strong></li></ul></li><li><p>通用定时器</p><p><img src="/2024/04/01/Embedded/STM32/5-universal-timer.png"></p><ul><li><strong>通用计时器的时基单元: 通用定时器包含基本定时器的电路.时基单元是相似的</strong></li><li>内外时钟选择:<code>TIMx_ETR</code>引脚接一个外部方波时钟.经过<code>极性选择,边沿检测,预分频器,输入滤波</code>后分为两路<ul><li>向上进入<code>触发控制器</code>,作为时基单元的时钟</li><li>向下进入<code>TRGI</code>,用作触发输入.触发定时器的从模式</li></ul></li><li><code>ITR</code> 信号: 来自其他定时器从 <code>TRGO</code> 的输出</li><li><code>TIIF_ED</code>: 连接到输入捕获单元的 CH1 引脚</li><li><code>TI1FP1, TI2FP2</code>: 连接到输入滤波器和边沿检测器的后面</li><li><strong>主模式输出: TRGO 可将内部的事件映射到 TRGO 引脚</strong></li></ul></li><li><p>高级定时器</p><p><img src="/2024/04/01/Embedded/STM32/5-advanced-timer.png"></p><ul><li>高级定时器包含了通用定时器的电路.额外增加了下列内容<ul><li>申请中断的后面加入一个 <code>REP</code> 重复次数计数器,可以每个几个计数周期才发生一次更新事件&#x2F;中断</li><li><code>DTG</code> 寄存器: 死区生成电路.右侧输出引脚变为了两个,可以输出一对互补的 PWM 波</li><li><code>TIMxBKIN</code>: 若 <code>TIMxBKIN</code> 引脚产生刹车信号或内部时钟失效,将由控制电路自动切断电机输出</li></ul></li></ul></li></ol><h3 id="5-2-时基单元"><a href="#5-2-时基单元" class="headerlink" title="5.2 时基单元"></a>5.2 时基单元</h3><ol><li><p>预分频时序图</p><p><img src="/2024/04/01/Embedded/STM32/5-count-timing-sequence-1-2.png"></p><ul><li><p><code>预分频缓冲器(影子寄存器)</code>: 实际上起作用的寄存器.预分频控制寄存器修改后,为保证此计数周期内频率一致.<br>该修改并不立即生效,在本次计数结束后才生效.<code>自动加载寄存器, 捕获 / 比较寄存器</code>同样有影子寄存器</p></li><li><p>计数器计数频率公式<br>$$<br>\mathrm{CK_CNT} &#x3D; \frac{\mathrm{CK_PSC}}{\mathrm{(PSC +1)}}<br>$$</p></li></ul></li><li><p>计数器时序图</p><p><img src="/2024/04/01/Embedded/STM32/5-count-timing-sequence.png"></p><ul><li><strong>计数器溢出频率公式</strong><br>$$<br>\mathrm{freq} &#x3D; \frac{\mathrm{CK_CNT}}{\mathrm{(ARR + 1)}}<br>&#x3D; \frac{\mathrm{CK_PSC}}{\mathrm{(PSC +1)(ARR + 1)}}<br>$$</li></ul></li></ol><h3 id="5-3-RCC-时钟树"><a href="#5-3-RCC-时钟树" class="headerlink" title="5.3 RCC 时钟树"></a>5.3 RCC 时钟树</h3><ol><li><p>RCC 产生和配置时钟,然后发送给各个外设的系统</p><p><img src="/2024/04/01/Embedded/STM32/5-RCC-clock-tree.png"></p><ul><li><strong>时钟是所有外设运行的基础,需要最先配置</strong></li><li>左侧为时钟产生电路,右侧为时钟分配电路.中间的 <code>SYSCLK</code> 为系统时钟(72MHz)</li></ul></li><li><p><strong>程序在 <code>main</code> 函数之前会执行 <code>SystemInit</code> 函数,以配置时钟树</strong></p><ul><li>首先尝试以 线路1 按照 8MHz 频率运行,稳定后切换为 线路2</li><li>CSS 可以检测时钟运行是否正常.若出错会切换到内部时钟</li></ul></li></ol><h3 id="5-4-定时中断"><a href="#5-4-定时中断" class="headerlink" title="5.4 定时中断"></a>5.4 定时中断</h3><ol><li><p>定时中断基本结构</p><p><img src="/2024/04/01/Embedded/STM32/5-timer-interrupt-struct.png"></p></li><li><p>基本定时中断配置步骤</p><ul><li>开启 RCC 的 TIM 外设时钟</li><li>时基单元的时钟源选择(选择内部时钟模式). 配置时基单元</li><li>配置中断输出控制,允许更新中断输出到 NVIC. 配置 NVIC,打开定时器的中断通道</li></ul></li></ol><h3 id="5-5-输出比较"><a href="#5-5-输出比较" class="headerlink" title="5.5 输出比较"></a>5.5 输出比较</h3><ol><li><p><strong>OC(Output Compare, 输出比较)</strong></p><ul><li><strong>通过比较 CNT 和 CCR 寄存器值(CNT 计数自增,CCR 手动给定).</strong><br><strong>然后对输出电平 置1 &#x2F; 置0 &#x2F; 翻转,实现输出一定频率和占空比的 PWM 波形</strong></li><li>每个高级寄存器(前3个通道拥有死区生成和互补输出功能)和通用寄存器均拥有4个输出比较通道</li><li>CCR 被输入捕获和输出比较共用<ul><li>使用输入捕获时,CCR 作为捕获寄存器</li><li>使用输出比较时,CCR 作为比较寄存器</li></ul></li></ul></li><li><p><strong>PWM(Pulse Width Modulation 脉冲宽度调制)</strong></p><ul><li>在惯性系统中,可以通过对一系列脉冲的宽度进行调制,来等效地获得所需要的模拟参量</li><li>参数: 频率: $freq &#x3D; \frac{1}{T_S}$, 占空比: $duty &#x3D; \frac{T_{ON}}{T_S}$, 分辨率: 占空比变化步距(1%即可)<br>其中 $T_S$ 为周期(高低电平变化一次的时间), $T_{ON}$ 为周期中高电平的维持时间</li></ul></li><li><p>捕获 &#x2F; 比较通道</p><p><img src="/2024/04/01/Embedded/STM32/5-capture-channel.png"></p></li><li><p>输出比较模式(输出模式控制器)</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>冻结</td><td>CNT&#x3D;CCR 时,REF 保持为原状态.即维持为暂停时刻的状态不变</td></tr><tr><td>匹配时置有效电平</td><td>CNT&#x3D;CCR 时,REF 置有效电平</td></tr><tr><td>匹配时置无效电平</td><td>CNT&#x3D;CCR 时,REF 置无效电平</td></tr><tr><td>匹配时电平翻转</td><td>CNT&#x3D;CCR 时,REF 电平翻转</td></tr><tr><td>强制为无效电平</td><td>CNT 与 CCR 无效,REF 强制为无效电平</td></tr><tr><td>强制为有效电平</td><td>CNT 与 CCR 无效.REF 强制为有效电平</td></tr><tr><td><strong>PWM 模式1</strong></td><td><strong>向上计数: CNT &lt; CCR 时,REF 置有效电平;CNT ≥ CCR 时,REF 置无效电平</strong> <br />向下计数: CNT &gt; CCR 时,REF 置无效电平;CNT ≤ CCR 时,REF 置有效电平</td></tr><tr><td><strong>PWM 模式2</strong></td><td><strong>向上计数: CNT &lt; CCR 时,REF 置无效电平,CNT ≥ CCR 时,REF 置有效电平</strong> <br />向下计数: CNT &gt; CCR 时,REF 置有效电平,CNT ≤ CCR 时,REF 置无效电平</td></tr></tbody></table></li><li><p>高级定时器输出比较(相较于通用定时器可以输出互补电平信号和产生死区)</p><p><img src="/2024/04/01/Embedded/STM32/5-advanced-timer-output.png"></p><ul><li>输出 <code>OC1,OC1N</code> 分别接到外部推挽电路的控制极,2个推挽电路构成 H桥,3个推挽电路即可驱动三相无刷电机</li><li><code>死区生成器</code>: 在 MOS 管关闭时,进行一段延时,然后是另一个 MOS 管导通.防止因器件原因造成正负极短路</li></ul></li><li><p>PWM 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/5-PWM-struct.png"></p><ul><li>图示中蓝线为 CNT(不断自增); 红线为 CCR(手动设置); 黄线为 ARR(手动设置).PWM 模式1</li><li>输出 PWM 波形不需要进行中断申请</li></ul></li><li><p><strong>PWM 参数计算</strong></p><ul><li><p>已知 $\mathrm{CK_PSC}$, PSC, ARR, CCR.计算频率, 占空比, 分辨率</p><ul><li><p>频率:     $\mathrm{freq} &#x3D; \frac{\mathrm{CK_PSC}}{\mathrm{(PSC + 1)}\mathrm{(ARR + 1)}}$</p></li><li><p>占空比: $\mathrm{Duty} &#x3D; \frac{\mathrm{CCR}}{\mathrm{(ARR + 1)}}$</p></li><li><p>分辨率: $\mathrm{Reso} &#x3D; \frac{1}{(\mathrm{ARR} + 1)}$</p></li></ul></li><li><p>已知 时钟频率, PWM 频率, 占空比, 分辨率时.计算 PSC, ARR, CCR</p><ul><li>$\mathrm{ARR+1} &#x3D; \frac{1}{\mathrm{Reso}}$</li><li>$\mathrm{CCR} &#x3D; \frac{\mathrm{Duty}}{\mathrm{Reso}}$ </li><li>$\mathrm{PSC + 1} &#x3D; \frac{\mathrm{Reso\cdot CK_{PSC}}}{\mathrm{freq}}$</li></ul></li><li><p><strong>确定 PSC, ARR, CCR 的方式</strong></p><ul><li>首先根据分辨率决定 ARR.如要求分辨率为 1% 时, (ARR + 1) &#x3D; 100.此后固定 ARR 的值,方便计算</li><li>此时 CRR 值即为占空比的百分数.如 CCR &#x3D; 50 时,占空比 duty &#x3D; 50%.代码中改变 CRR,即可调节占空比</li><li>最后确定 PSC 的值.代码中改变 PSC,即可调节频率</li></ul></li></ul></li></ol><h3 id="5-6-输入捕获"><a href="#5-6-输入捕获" class="headerlink" title="5.6 输入捕获"></a>5.6 输入捕获</h3><ol><li><p><strong>IC(Input Capture 输入捕获)</strong></p><ul><li>输入捕获模式下<ul><li>当通道输入引脚出现指定电平跳变时,当前 CNT 的值将被锁存到 CCR 中</li><li>可用于测量 PWM 波形的频率, 占空比, 脉冲间隔, 电平持续时间等参数</li></ul></li><li>每个高级定时器和通用定时器都拥有4个输入捕获通道<ul><li>可配置为 PWMI 模式,同时测量频率和占空比</li><li>可配合主从触发模式,实现硬件全自动测量</li></ul></li></ul></li><li><p><strong>频率测量方法</strong></p><ul><li><strong>测频法</strong>: 在闸门时间 T 内对上升沿计次 N,则频率 $f_x &#x3D; \frac{N}{T}$</li><li><strong>测周法</strong>: 两个上升沿内以标准频率 $f_c$ 计次 N,则频率 $f_x &#x3D; \frac{f_c}{N}$</li><li><strong>中界频率</strong>: 测频法与测周法误差相等的频率 $f_m &#x3D; \sqrt{\frac{f_c}{T}}$</li></ul></li><li><p>捕获比较通道框图</p><p><img src="/2024/04/01/Embedded/STM32/5-capture-channel-block.png"></p></li><li><p>主从触发模式</p><p><img src="/2024/04/01/Embedded/STM32/5-%E4%B8%BB%E4%BB%8E%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F.png"></p><ul><li><strong>主模式: 可将定时器内部的信号映射到 TRGO 引脚,触发其他外设</strong></li><li><strong>从模式: 接收其他外设或使用自身外设的信号.用以控制自身控制器的运行</strong></li><li>触发源选择: 指定 从模式的触发信号 得到 TRGI,然后触发选定的从模式</li></ul></li><li><p>输入捕获基本结构</p><p><img src="/2024/04/01/Embedded/STM32/5-capture-struct.png"></p><ul><li>从GPIO口输入方波信号,经过<code>滤波器, 边沿检测, 极性选择</code>得到 <code>TI1FP1</code>,最后连接到 <code>CCR1</code></li><li>当<code>TI1FP1</code>出现上升沿,不断自增的 <code>CNT</code> 转运到 <code>CCR1</code> 中</li><li>同时,触发源选择为 <code>TI1FP1</code>,从模式配置为 <code>Reset</code>.当 <code>TI1FP1</code> 出现上升沿,<code>CNT</code> 自动清零,再次自增</li></ul></li><li><p>PWMI 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/5-PWMI-struct.png"></p><ul><li>PWMI 与 输入捕获的区别在于使用2个通道捕获同一 GPIO,可以同时测量周期和占空比</li><li>当上升沿来临,<code>TI1FP1</code> 触发,<code>CCR1</code> 捕获,清零 <code>CNT</code></li><li><code>TI1FP2</code>配置为下降沿触发.当下降沿来临,<code>TI1FP2</code> 触发,<code>CCR2</code> 捕获,不清零 <code>CNT</code></li><li>因而 <code>CCR2</code> 的值反映高电平维持时间,<code>CCR1</code> 的值反映周期的时间.占空比为 $\frac{CCR2}{CCR1}$</li></ul></li></ol><h3 id="5-7-编码器"><a href="#5-7-编码器" class="headerlink" title="5.7 编码器"></a>5.7 编码器</h3><ol><li><p>编码器接口(Encoder Interface)</p><ul><li>编码器接口可接收增量(正交)编码器的信号<ul><li>根据编码器旋转产生的正交信号脉冲</li><li>自动控制 CNT 自增或自减,从而指示 编码器的位置, 旋转方向, 旋转速度</li></ul></li><li>每个高级定时器和通用定时器都拥有1个编码器接口</li><li>编码器接口的两个输入引脚借用了输入捕获的通道1和通道2</li></ul></li><li><p>正交编码器</p><p><img src="/2024/04/01/Embedded/STM32/5-encoder.png"></p><ul><li>由于正转和反转输出的波形一致,故仅凭一项输出信号无法判断旋转方向.因此需要 A, B相</li><li>A相与B相 相位差90°.每当出现边沿变化时,判断另一相的状态,对照右侧表格,即可确定旋转方向</li></ul></li><li><p>编码器接口基本结构</p><p><img src="/2024/04/01/Embedded/STM32/5-encoder-struct.png"></p><ul><li><p>当编码器正转时,CNT++; 反转时,CNT–.结合固定的闸门时间,即可完成测速任务</p></li><li><p><code>TI1FP1, TI2FP2</code>来自 GPIO 端口输入.<strong>类似于一个外部时钟源,配置为编码器模式</strong></p><ul><li>因此此时 PSC 建议设为 0,不进行分频.ARR 设为 65535,最大</li></ul></li><li><p>配置 GPIO 为输入模式 -&gt; 配置时基单元 -&gt; 配置输入捕获单元 -&gt; 配置编码器接口(下行代码)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 编码器接口配置.并设置为: 定时器3, 选择编码器模式, TI1, TI2都计数, 不反相</span><br><span class="hljs-comment">** 注意此时参数的 Rising 和 Falling 不再代表上升沿和下降沿了,而是代表是否反相</span><br><span class="hljs-comment">** 此函数必须在输入捕获初始化之后进行,否则输入捕获的配置会覆盖此函数的部分配置 */</span><br>TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12,<br>                           TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="6-ADC"><a href="#6-ADC" class="headerlink" title="6 ADC"></a>6 ADC</h2><h3 id="6-1-ADC-功能"><a href="#6-1-ADC-功能" class="headerlink" title="6.1  ADC  功能"></a>6.1  ADC  功能</h3><ol><li><p><strong>ADC(Analog-Digital Converter, 模拟-数字转换器)</strong></p><ul><li>作用: 可将引脚上连续变化的模拟电压 转换为内存中存储的数字变量</li><li>18个输入通道: 可测量16个外部(GPIO)和2个内部信号源(温度传感器,内部参考电压)<ul><li>输入电压范围: 0 ~ 3.3V</li><li>分辨率为 12位: 即表示范围 $0 \sim 2^{12}-1$</li><li>1$\mu$s 转换时间: 即开始转换到产生结果耗时.对应频率为 1MHz</li></ul></li><li>STM32 增强功能: 规则组和注入组两个转换单元</li></ul></li><li><p>逐次逼近型 ADC 结构(<code>ADC0809</code> 内部结构图, 8位逐次逼近型)</p><p><img src="/2024/04/01/Embedded/STM32/6-approx-ADC.png"></p></li><li><p>ADC 框图</p><p><img src="/2024/04/01/Embedded/STM32/6-ADC-block.png"></p></li><li><p>ADC 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/6-ADC-struct.png"></p><ul><li>配置 GPIO 为模拟输入模式 -&gt; 配置数据选择器 -&gt; 配置 ADC 转换器 -&gt; 开启 ADC</li></ul></li></ol><h3 id="6-2-ADC-模式"><a href="#6-2-ADC-模式" class="headerlink" title="6.2 ADC 模式"></a>6.2 ADC 模式</h3><ol><li><p><strong>规则组的转换模式</strong></p><ul><li>单次转换: 在一次转换结束后,转换结果存放在数据寄存器中,置 EOC 标志位,结束转换</li><li>连续转换: 在一次转换结束后,置 EOC 标志位,立即开始下一轮的转换</li><li>非扫描模式: 规则组的序列只有一个通道有效.即只处理一个通道的信号</li><li>扫描模式: 规则组的序列有效,一次转换多个通道的信号</li></ul></li><li><p>ADC 转换触发控制</p><p><img src="/2024/04/01/Embedded/STM32/6-ADC-external-trigger.png"></p></li><li><p>数据对齐: 对于一个 12bit ADC,其转换结果为 12bit.而数据寄存器为16bit,需进行数据对齐</p><ul><li><strong>右对齐: 有效数据右对齐,左边补0</strong></li><li>左对齐: 有效数据左对齐,右边补0</li></ul></li><li><p>转换时间(采样, 保持, 量化, 编码)</p><ul><li>ADC 的总转换时间: <code>T = 采样时间 + 12.5 * ADC 周期</code></li><li>采样时间可在程序中配置.量化编码因是12位 ADC,需要 12.5 个周期</li><li>例: 采样时间配置为1.5, ADC 频率为14MHz,则总转换时间为14个 ADC 周期,即 1us</li></ul></li></ol><h2 id="7-DMA"><a href="#7-DMA" class="headerlink" title="7 DMA"></a>7 DMA</h2><h3 id="7-1-DMA-功能"><a href="#7-1-DMA-功能" class="headerlink" title="7.1 DMA 功能"></a>7.1 DMA 功能</h3><ol><li><p><strong>DMA(Direct Memory Access, 直接存储器存取)</strong></p><ul><li>DMA 可以提供外设和存储器或者存储器和存储器之间的高速数据传输</li><li>本质上是从某个地址取出数据,转运到另一地址</li><li>作用: DMA 数据传输无须 CPU 干预,节省 CPU 的资源</li><li>12个独立可配置的通道: DMA1(7个通道), DMA2(5个通道)</li><li>每个通道都支持软件触发和特定的硬件触发</li></ul></li><li><p><strong>存储器映像</strong></p><table><thead><tr><th>类型</th><th>起始地址</th><th>存储器</th><th>用途</th></tr></thead><tbody><tr><td>ROM</td><td>0x0800 0000</td><td>程序存储器 Flash</td><td>存储编译后的 C 语言程序代码</td></tr><tr><td></td><td>0x1FFF F000</td><td>系统存储器</td><td>存储 BootLoader,用于串口下载</td></tr><tr><td></td><td>0x1FFF F800</td><td>选项字节</td><td>存储一些独立于程序代码的配置参数</td></tr><tr><td>RAM</td><td>0x2000 0000</td><td>运行内存 SRAM</td><td>存储运行过程中的临时变量</td></tr><tr><td></td><td>0x4000 0000</td><td>外设寄存器</td><td>存储各个外设的配置参数</td></tr><tr><td></td><td>0xE000 0000</td><td>内核外设寄存器</td><td>存储内核各个外设的配置参数</td></tr></tbody></table></li><li><p>DMA 框图</p><p><img src="/2024/04/01/Embedded/STM32/7-DMA-block.png"></p><ul><li>DMA 通过 <code>DMA 总线</code>主动访问各种存储器.DMA 总线是被分时复用的<ul><li><code>仲裁器</code>根据通道的优先级处理 DMA 通道的冲突</li><li><code>总线矩阵</code>也有仲裁器,当 CPU 和 DMA 访问同一目标时.保障 CPU 正常工作</li></ul></li><li>DMA 作为外设,也有寄存器.连接在 <code>AHB 总线</code>上,因此 CPU 可以访问,配置 DMA<ul><li>硬件可通过 DMA 请求线路向 DMA 发出硬件触发信号</li></ul></li></ul></li></ol><h3 id="7-2-DMA-转运"><a href="#7-2-DMA-转运" class="headerlink" title="7.2 DMA 转运"></a>7.2 DMA 转运</h3><ol><li><p><strong>DMA 基本结构</strong></p><p><img src="/2024/04/01/Embedded/STM32/7-DMA-struct.png"></p><ul><li>DMA 数据转运<ul><li>条件: DMA 使能, <code>传输计数器</code> &gt; 0, 触发源有触发信号</li><li>方向: 外设 -&gt; 存储器, 存储器 -&gt; 外设, Flash -&gt; SRAM</li><li>参数: 源端和目标的 <code>起始地址, 数据宽度, 地址是否自增</code></li></ul></li><li><strong>传输计数器</strong>: 在完成一次转运后会进行自减,当其值为0时结束转运,起始地址参数复位<ul><li><code>自动重装器</code>: 可以在传输计数器自减到0后,恢复传输计数器的值,再次自减.使得可以循环转运</li><li>DMA 转运完成后,必须先关闭 DMA,然后再次开启,才能给 <code>传输计数器</code> 写值</li></ul></li><li>触发方式: 由 <code>M2M</code> 控制<ul><li>软件触发: DMA 不断运行,直到 <code>传输计数器</code> 清零.此时不应开启 <code>自动重装器</code>,一般用于存储器间数据转运</li><li>硬件触发: 达到某种条件(如 ADC 转换完成,串口接收到数据,达到定时时间),触发 DMA 运行</li></ul></li></ul></li><li><p>DMA1 请求映像 </p><p><img src="/2024/04/01/Embedded/STM32/7-DMA1-request-map.png"></p><ul><li><strong>每个通道的硬件触发源不同.而软件触发都一样.需要根据触发选择 ADC 通道</strong></li><li>对于外设请求信号的选择: 由外设的 DMA 控制决定,开启就可以发出请求信号</li><li>外设请求信号经过 或门到硬件请求.一般只开启一个外设请求</li></ul></li><li><p>DMA 传输数据宽度</p><ul><li>源端宽度 &#x3D; 目标宽度: 正常传输</li><li>源端宽度 &gt; 目标宽度: 高位舍弃</li><li>源端宽度 &lt; 目标宽度: 高位补0</li></ul></li></ol><h2 id="8-USART-串口"><a href="#8-USART-串口" class="headerlink" title="8 USART 串口"></a>8 USART 串口</h2><h3 id="8-1-通信接口"><a href="#8-1-通信接口" class="headerlink" title="8.1 通信接口"></a>8.1 通信接口</h3><ol><li><p><strong>通信协议</strong></p><table><thead><tr><th>名称</th><th>引脚</th><th>双工</th><th>时钟</th><th>电平</th><th>设备</th></tr></thead><tbody><tr><td>USART</td><td>TX, RX</td><td>全双工</td><td>异步</td><td>单端</td><td>点对点</td></tr><tr><td>I2C</td><td>SCL, SDA</td><td>半双工</td><td>同步</td><td>单端</td><td>多设备</td></tr><tr><td>SPI</td><td>SCLK, MOSI, MISO, CS</td><td>全双工</td><td>同步</td><td>单端</td><td>多设备</td></tr><tr><td>CAN</td><td>CAN_H, CAN_L</td><td>半双工</td><td>异步</td><td>差分</td><td>多设备</td></tr><tr><td>USB</td><td>DP, DM</td><td>半双工</td><td>异步</td><td>差分</td><td>点对点</td></tr></tbody></table><ul><li>全双工: 通信双方能够同时进行双向通信.一般需要2根通信线</li><li>半双工: 通信双方无法同时输入 &#x2F; 输出数据</li><li>单工: 数据传输方向为单向</li><li>时钟: 确定数据的采集时机</li></ul></li><li><p>电平标准: 数据1&#x2F;0的表达方式(当电平信号不一致时,需要加入电平转换芯片)</p><table><thead><tr><th>电平标准</th><th>data: 1</th><th>data: 0</th></tr></thead><tbody><tr><td><strong>TTL</strong></td><td><strong>+3.3V 或 +5V</strong></td><td><strong>0V</strong></td></tr><tr><td>RS232 电平</td><td>-3 ~ -15V</td><td>+3 ~ +15</td></tr><tr><td>RS485 电平(差分信号)</td><td>+2 ~ +6V</td><td>-2 ~ -6V</td></tr></tbody></table></li><li><p>串口时序</p><p><img src="/2024/04/01/Embedded/STM32/8-uart-timing-sequence.png"></p></li><li><p>串口参数</p><ul><li><strong>波特率: 串口通信的速率.每秒传输码元的个数</strong></li><li>比特率: 每秒传输的比特数(bit&#x2F;s).二进制情况下,码元即是 bit,波特率等于比特率</li><li>起始位: 标志一个数据帧的开始,固定为低电平(空闲时为高电平)</li><li><strong>数据位: 数据帧的有效载荷.1为高电平,0为低电平.低位先行</strong></li><li>校验位: 用于数据验证(如奇校验表示连同校验位共有奇数个1,还有 CRC 校验)</li><li>停止位: 用于数据帧间隔.固定为高电平</li></ul></li></ol><h3 id="8-2-USART-外设"><a href="#8-2-USART-外设" class="headerlink" title="8.2 USART 外设"></a>8.2 USART 外设</h3><ol><li><p><strong>USART(Universal Synchronous&#x2F;Asynchronous Receiver&#x2F;Transmitter, 通用同步&#x2F;异步收发器)</strong></p><ul><li>STM32 内部集成 USART 外设<ul><li>可根据数据寄存器的一个字节数据自动生成数据帧时序.由 TX 引脚发送</li><li>可自动接收 RX 引脚的数据帧时序,拼接为一个字节数据,存放于数据寄存器</li><li>自带波特率发生器.最高达4.5Mbits&#x2F;s(本质是一个预分频器)</li></ul></li><li>可配置参数<ul><li>数据位长度(<strong>8</strong> &#x2F; 9). 停止位长度(0.5 &#x2F; <strong>1</strong> &#x2F; 1.5 &#x2F; 2)</li><li>校验位: <strong>无校验,</strong> 奇校验, 偶校验</li><li>支持同步模式, 硬件流控制, DMA, 智能卡, IrDA, LIN</li></ul></li><li>stm32f103 的 usart1 的引脚: tx - PA9, rx - PA10</li></ul></li><li><p>USART 框图</p><p><img src="/2024/04/01/Embedded/STM32/8-USART-block.png"></p><ul><li><code>TX</code> 引脚连接 <code>发送移位寄存器</code>,在<code>发送器控制</code>的控制下,将数据按位移出<ul><li>当 <code>TDR</code>(只写) 被写入数据时,先检查<code>移位寄存器</code>是否有数据正在移位</li><li>若无,则数据发送到<code>移位寄存器</code>,同时,置 <code>TXE 标志位</code>,可以再次向 <code>TDR</code> 写入数据</li><li>若有,则等待移位完成后,立即转移数据</li></ul></li><li><code>RX</code> 连接通向 <code>接收移位寄存器</code>,在<code>接收器控制</code>的控制下,将数据按位移出<ul><li><code>接收移位寄存器</code>按位读取 <code>RX</code> 引脚的信号</li><li>读取满1byte 后,将数据转移到 <code>RDR</code>.同时,置 <code>RXNE 标志位</code>.此时可从 <code>RDR</code>(只读)读出数据</li></ul></li></ul></li><li><p>USART 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/8-USART-struct.png"></p><ul><li>APB的时钟信号到达波特率发生器进行分频</li><li>发送器 &#x2F; 接收器的波特率 &#x3D; $\mathrm{\frac{f_{PCLK}} { {16} \cdot {DIV} } }$. 由 <code>波特率寄存器 BRR</code> 中的 <code>DIV</code> 决定</li></ul></li></ol><h3 id="8-3-重定向-printf"><a href="#8-3-重定向-printf" class="headerlink" title="8.3 重定向 printf"></a>8.3 重定向 <code>printf</code></h3><ol><li><p>格式化打印: 对 <code>printf</code>函数的重定向</p></li><li><p>打开工程文件中的 <code>Options for target</code>,勾选 <code>Use MicroLIB</code>(Keil 为嵌入式平台准备的精简库)</p><p><img src="/2024/04/01/Embedded/STM32/8-UseMicroLib.png"></p></li><li><p><strong>由于<code>printf</code>函数底层调用<code>fput</code>函数不断打印,因此可以将 <code>printf</code> 函数重定向为向串口发送数据</strong></p></li><li><p>方法1: 重写的<code>fputc</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span> &#123;<br>serial_send_byte(ch);  <span class="hljs-comment">// 这是一个串口传输数据的函数,需要自行实现</span><br><span class="hljs-keyword">return</span> ch;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方法2: 对 <code>sprintf</code> 的封装(<code>sprintf</code> 函数: 将内容打印打印到字符串中)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">serial_printf</span><span class="hljs-params">(<span class="hljs-type">char</span> *format, ...)</span> &#123;<br><span class="hljs-type">char</span> <span class="hljs-built_in">string</span>[<span class="hljs-number">100</span>];               <span class="hljs-comment">// 定义字符数组</span><br>va_list arg;                    <span class="hljs-comment">// 定义可变参数列表数据类型的变量 arg</span><br>va_start(arg, format);          <span class="hljs-comment">// 从 format 开始,接收参数列表到 arg 变量</span><br><span class="hljs-built_in">vsprintf</span>(<span class="hljs-built_in">string</span>, format, arg);  <span class="hljs-comment">// 使用 vsprintf 打印格式化字符串和参数列表到字符数组中</span><br>va_end(arg);                    <span class="hljs-comment">// 结束变量 arg</span><br>serial_send_string(<span class="hljs-built_in">string</span>);     <span class="hljs-comment">// 串口发送字符数组的函数,需要自行实现</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="8-4-HAL-库"><a href="#8-4-HAL-库" class="headerlink" title="8.4 HAL 库"></a>8.4 HAL 库</h3><ol><li>配置 UART1</li></ol><p>   <img src="/2024/04/01/Embedded/STM32/8-USART-HAL.png"></p><ol start="2"><li><p>在 <code>stm32f1xx_hal_uart.h</code> 中有很多中断回调函数,以及功能实现函数</p><ul><li><p>收发函数(还有中断和 dma 版本)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_StatusTypeDef <span class="hljs-title function_">HAL_UART_Transmit</span><span class="hljs-params">(UART_HandleTypeDef *huart, </span><br><span class="hljs-params">                                    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *pData, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_UART_Receive</span><span class="hljs-params">(UART_HandleTypeDef *huart, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint8_t</span> *pData, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint32_t</span> Timeout)</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="9-I2C-通信"><a href="#9-I2C-通信" class="headerlink" title="9 I2C 通信"></a>9 I2C 通信</h2><h3 id="9-1-I2C-协议"><a href="#9-1-I2C-协议" class="headerlink" title="9.1 I2C 协议"></a>9.1 I2C 协议</h3><ol><li><p><strong>I2C(Inter IC BUS).由 Philips 公司开发的一种通用数据总线</strong></p><ul><li><strong>通信线: SCL(Serial Clock), SDA(Serial Data)</strong></li><li>属于同步通信,半双工通信.可以数据应答,支持总线挂载多设备</li><li>I2C 外设出厂会有一个地址(7位或10位)</li></ul></li><li><p>硬件电路</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-bus.png"></p><ul><li>SDA 和 SCL 的控制<ul><li>主机拥有对 SCL 线的完全控制权.也可控制空闲状态下的 SDA 线</li><li>从机只能读取 SCL 线,也不允许主动控制 SDA 线</li><li>仅在应答或主机要读取从机时才能获取 SDA 的控制权</li></ul></li><li>接线方式<ul><li>所有 I2C 设备的 SCL 连在一起,SDA 连在一起.均默认为高电平</li><li><strong>设备的 SCL 和 SDA 均要配置成开漏输出模式,禁止输出高电平</strong></li><li>SCL 和 SDA 各添加一个上拉电阻,阻值一般为4.7KΩ</li></ul></li></ul></li><li><p><strong>I2C 时序基本单元</strong></p><ul><li><p><strong>起始与终止</strong>: 始终由主机控制,从机无权发送该指令</p><ul><li><p>起始条件: 主机拉低 SDA 电平(下降沿,此时从机复位).然后拉低 SCL,占用 SCL</p></li><li><p>终止条件: 主机先放开 SCL,然后放开 SDA (上升沿).回到初始态</p></li><li><p><strong>除了起始和终止条件,每个时序单元的 SCL 以低电平开始,也以低电平结束</strong></p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-start-end.png"></p></li></ul></li><li><p><strong>发送数据</strong></p><ul><li><p>起始状态后.SCL,SDA均为低电平.主机将数据置于 SDA 线(高位先行)</p></li><li><p>然后释放 SCL.从机在 SCL 高电平期间读取数据位,需要尽快读取,最好在上升沿时就立即读取</p></li><li><p>当 SCL 高电平时, SDA 不应发生变化,维持一段时间后,主机再次拉低 SCL.完成一位数据的传输</p></li><li><p>循环上述过程8次,即可传输一个字节的数据</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-send-byte.png"></p></li></ul></li><li><p><strong>接收数据</strong></p><ul><li><p>主机需要先释放 SDA.在 SCL 低电平期间,从机将数据置于 SDA 线(高位先行)</p></li><li><p>然后主机释放 SCL.由主机读取数据位</p></li><li><p><strong>SDA 总是在 SCL 低电平(下降沿)时被放置数据,在 SCL 高点平(上升沿)时被读取</strong></p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-receive-byte.png"></p></li></ul></li><li><p><strong>主机发送应答</strong>: 主机接收完一个字节后,在下一个时钟发送一位数据.<strong>0为应答,1为非应答</strong></p></li><li><p><strong>接收从机应答</strong>: 主机发送完一个字节后,在下一个时钟接收一位数据.<strong>0为应答,1为非应答</strong></p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-ack.png"></p></li></ul></li><li><p>指定地址写: 给指定设备(slave addr)的指定地址(reg addr)写入指定数据(data)</p><ul><li><p>起始条件 -&gt; 发送 1byte(前 7bit 为 slave addr, 后 1bit 表示读(1) &#x2F; <strong>写(0)</strong> ) -&gt; 从机应答0 -&gt; </p></li><li><p>发送 1byte 数据(reg addr) -&gt; 从机应答0 -&gt; </p></li><li><p>发送 1byte 数据(data) -&gt; 从机应答0 -&gt; 终止条件</p></li><li><p>后续字节: 传输真正的数据(寄存器的地址将会自增).当完成传输时,主机需要产生一个终止条件</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-write-reg.png"></p></li></ul></li><li><p>当前地址读: 对于指定设备(slave addr),读取从机当前地址指针的数据(data)</p><ul><li><p>起始条件 -&gt; 发送 1byte(前 7bit 为 slave addr, 后 1bit 表示<strong>读(1)</strong> &#x2F; 写(0) ) -&gt; 从机应答0 -&gt;</p></li><li><p>接收 1byte data(此时从机在 scl 低电平写入 sda,主机在 scl 高电平读取 sda) -&gt; 主机应答1 -&gt; 终止条件</p></li><li><p>当主机不想再接收数据时,需要在发送应答时给出非应答,此时从机将不再发送数据</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-read-reg.png"></p></li></ul></li><li><p>指定地址读: 给指定设备(slave addr)的指定地址(reg addr)读取数据(data)</p><ul><li><p>起始条件 -&gt; 发送 1byte(前 7bit 为 slave addr, 后 1bit 表示读(1) &#x2F; <strong>写(0)</strong> ) -&gt; 从机应答0 -&gt; </p></li><li><p>发送 1byte 数据(reg addr) -&gt; 从机应答0 -&gt; </p></li><li><p>重复起始条件 -&gt; 发送 1byte(前 7bit 为 slave addr, 后 1bit 表示<strong>读(1)</strong> &#x2F; 写(0) ) -&gt; 从机应答0 -&gt;</p></li><li><p>接收 1byte data(此时从机在 scl 低电平写入 sda,主机在 scl 高电平读取 sda) -&gt; 主机应答1 -&gt; 终止条件  </p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-set-addr-read-reg.png"></p></li></ul></li></ol><h3 id="9-2-I2C-外设"><a href="#9-2-I2C-外设" class="headerlink" title="9.2 I2C 外设"></a>9.2 I2C 外设</h3><ol><li><p>STM32 内部集成了硬件 I2C 收发电路</p><ul><li>可以由硬件自动执行时钟生成,起始终止条件生成,应答位收发,数据收发等功能.减轻CPU的负担</li><li>支持 7bit &#x2F; 10bit 地址模式(若第一字节的前5位为11110,则表示10位地址)</li><li>支持不同的通讯速度,标准速度(高达100 kHz), 快速(高达400 kHz)</li><li>支持 DMA, 多主机模型, 兼容 SMBus(System Management Bus)协议</li></ul></li><li><p>I2C 基本结构图</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-struct.png"></p></li><li><p>硬件 I2C 波形</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-hardware-wave.png"></p></li></ol><h3 id="9-3-HAL-库"><a href="#9-3-HAL-库" class="headerlink" title="9.3 HAL 库"></a>9.3 HAL 库</h3><ol><li><p>I2C2 配置</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-hal.png"></p></li><li><p>在 <code>stm32f1xx_hal_i2c.h</code> 中有很多中断回调函数,以及功能实现函数.下面是收发函数的声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Write</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> DevAddress,  <span class="hljs-comment">// 注意是 7bit地址 &lt;&lt; 1</span></span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> MemAddress,</span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> MemAddSize, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint8_t</span> *pData, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Read</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> DevAddress, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> MemAddress, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> MemAddSize, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint8_t</span> *pData, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint32_t</span> Timeout)</span>;<br></code></pre></td></tr></table></figure></li></ol><h2 id="10-SPI-通信"><a href="#10-SPI-通信" class="headerlink" title="10 SPI 通信"></a>10 SPI 通信</h2><h3 id="10-1-SPI-协议"><a href="#10-1-SPI-协议" class="headerlink" title="10.1 SPI 协议"></a>10.1 SPI 协议</h3><ol><li><p><strong>SPI(Serial Peripheral Interface): 由Motorola公司开发的一种通用数据总线</strong></p><ul><li>通信线: SCK(Serial Clock), SS(Slave Select),<br>MOSI(Master Output Slave Input), MISO(Master Input Slave Output)</li><li>同步, 全双工.支持总线挂载多设备(一主多从)</li></ul></li><li><p>硬件电路</p><p><img src="/2024/04/01/Embedded/STM32/10-SPI-bus.jpg"></p><ul><li>所有 SPI 设备的 SCK, MOSI, MISO 分别连在一起<ul><li><strong>SCK: 时钟线</strong>.完全由主机掌控.由主机进行输出,从机得到输入</li><li><strong>MOSI: 主机输出从机输入</strong>.在主机上,表现为数据输出.在从机上,表现为数据输入</li><li><strong>MISO: 主机输入从机输出</strong>.在主机上,表现为数据输入.在从机上,表现为数据输出</li></ul></li><li><strong>主机另外引出多条 SS 控制线,分别接到各从机的 SS 引脚</strong><ul><li>当从机的 SS 高电平时,MISO 必须为高阻态,不允许从机输出,防止 MISO 数据冲突</li><li>SS 低电平有效,且只能同时选中一个从机.如需指定从机输入输出数据.则将对应的 SS 拉至低电平</li><li>输出的引脚需配置为推挽输出,保证高低电平均有强驱动能力.输入的引脚需配置为浮空或上拉输入</li></ul></li></ul></li><li><p>SPI 数据交换</p><p><img src="/2024/04/01/Embedded/STM32/10-SPI-swap-byte.png"></p><ul><li><code>波特率发生器</code>时钟上升沿时,所有移位寄存器向左移位,置于引脚</li><li><code>波特率发生器</code>时钟下降沿时,对引脚电平采样,置于移位寄存器的最低位</li><li>主机与从机的数据交换<ul><li>在一个周期内,从机由高位移出的数据传输到主机的低位,主机由高位移出的数据传输到从机的低位</li><li>循环8次后,从机的数据完整到达主机,主机的数据也完整达到从机,完成一次数据交换</li></ul></li><li>如果仅需主机发送数据,仍然需要执行数据交换,忽略接收到的数据即可</li><li>如果仅需接收从机数据,仍然需要执行数据交换,此时主机可使用任意数据交换(一般0x00或0xFF)</li></ul></li><li><p>SPI 基本时序</p><ul><li><p>起始条件: SS 从高电平切换到低电平</p></li><li><p>终止条件: SS 从低电平切换到高电平</p></li><li><p>可选择 上升&#x2F;下降沿 移位.可配置时钟相位提前半个时钟</p><ul><li><code>CPOL(Clock Polarity)</code><ul><li>CPOL&#x3D;0: SCK 空闲时为低电平</li><li>CPOL&#x3D;1: SCK 空闲时为高电平</li></ul></li><li><code>CPHA(Clock phase)</code><ul><li>CPHA&#x3D;0: SCK 奇数边沿时移入数据.偶数边沿移出数据(提前)</li><li>CPHA&#x3D;1: SCK 奇数边沿时移出数据.偶数边沿移入数据(正常)</li></ul></li></ul></li><li><p><strong>模式0 使用最多(CPOL&#x3D;0,CPHA&#x3D;0): 空闲时,SCK为低电平,上升沿采集数据</strong></p><p><img src="/2024/04/01/Embedded/STM32/10-SPI-mode0.jpg"></p></li></ul></li><li><p>SPI 通常使用指令码和读写数据的方式操作从机: 从机选择 -&gt; 发送指令 -&gt; 发送数据<br>向指定设备发送指令 0x02,然后写入数据</p><p><img src="/2024/04/01/Embedded/STM32/10-SPI-timing-sequence.jpg"></p></li></ol><h3 id="10-2-SPI-外设"><a href="#10-2-SPI-外设" class="headerlink" title="10.2 SPI 外设"></a>10.2 SPI 外设</h3><ol><li><p>STM32 内部集成了硬件 SPI 收发电路</p><ul><li>可配置 8 &#x2F; 16位数据帧, 高 &#x2F; 低位先行</li><li>时钟频率: PCLK &#x2F; (2, 4, 8, 16, 32, 64, 128, 256)</li><li>支持多主机模型(主&#x2F;从操作), 可精简为半双工&#x2F;单工通信, 支持 DMA, 兼容 I2S 协议</li></ul></li><li><p>SPI 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/10-SPI-struct.png"></p></li></ol><h3 id="10-3-HAL-库"><a href="#10-3-HAL-库" class="headerlink" title="10.3 HAL 库"></a>10.3 HAL 库</h3><ol><li><p>SPI1 配置</p><p><img src="/2024/04/01/Embedded/STM32/10-SPI-hal.png"></p></li><li><p>spi 基础函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_StatusTypeDef <span class="hljs-title function_">HAL_SPI_TransmitReceive</span><span class="hljs-params">(SPI_HandleTypeDef *hspi, </span><br><span class="hljs-params">                                          <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *pTxData, </span><br><span class="hljs-params">                                          <span class="hljs-type">uint8_t</span> *pRxData,</span><br><span class="hljs-params">                                          <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                          <span class="hljs-type">uint32_t</span> Timeout)</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="11-RTC-实时时钟"><a href="#11-RTC-实时时钟" class="headerlink" title="11 RTC 实时时钟"></a>11 RTC 实时时钟</h2><h3 id="11-1-Unix-时间戳"><a href="#11-1-Unix-时间戳" class="headerlink" title="11.1 Unix 时间戳"></a>11.1 Unix 时间戳</h3><ol><li><p><strong>Unix 时间戳(Timestamp): 从 UTC &#x2F; GMT 的 <code>1970年1月1日00:00:00</code> 开始经过的秒数</strong></p><ul><li>秒计数器为 32 &#x2F; 64bit 的整型变量</li><li>各时区的秒计数器相同,但不同时区通过偏移得到当地时间</li></ul></li><li><p>GMT(Greenwich Mean Time): 格林尼治标准时间,将地球自转一周的时间等分为24小时</p></li><li><p>UTC(Universal Time Coordinated): 协调世界时,以原子钟为基础的时间计量系统</p></li><li><p>时间戳与时间的转换: C语言的 <code>&lt;time.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> tm* <span class="hljs-title function_">gmtime</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">time_t</span>*)</span>;     <span class="hljs-comment">// 秒计数器转换为日期时间</span><br><span class="hljs-keyword">struct</span> tm* <span class="hljs-title function_">localtime</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">time_t</span>*)</span>;  <span class="hljs-comment">// 秒计数器转换为当地时间</span><br><span class="hljs-type">time_t</span> <span class="hljs-title function_">mktime</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tm*)</span>;            <span class="hljs-comment">// 日期时间转换为秒计数器</span><br></code></pre></td></tr></table></figure><p><img src="/2024/04/01/Embedded/STM32/11-timestamp-convert.png"></p></li></ol><h3 id="11-2-BKP-备份寄存器"><a href="#11-2-BKP-备份寄存器" class="headerlink" title="11.2 BKP 备份寄存器"></a>11.2 BKP 备份寄存器</h3><ol><li><p>BKP 可用于存储用户应用程序数据</p><ul><li>当 VDD(2.0 ~ 3.6V)电源被切断时,仍由 VBAT(1.8 ~ 3.6V)维持供电</li><li>就算系统复位,电源复位,BKP 也不会复位</li><li>用户数据存储容量: 20字节(中&#x2F;小容量), 84字节(大容量&#x2F;互联型)</li></ul></li><li><p><strong>TAMPER 引脚产生的侵入事件会将所有备份寄存器内容清除</strong></p></li><li><p>RTC 引脚可以输出: RTC 校准时钟, RTC 闹钟脉冲, 秒脉冲</p></li><li><p>BPK 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/11-BPK-struct.png"></p></li></ol><h3 id="11-3-RTC-实时时钟"><a href="#11-3-RTC-实时时钟" class="headerlink" title="11.3 RTC 实时时钟"></a>11.3 RTC 实时时钟</h3><ol><li><p><strong>RTC(Real Time Clock): 实时时钟,RTC是一个独立的定时器,可为系统提供时钟 &#x2F; 日历功能</strong></p><ul><li>RTC 和 时钟配置系统处于后备区域,系统复位时数据不清零</li><li>拥有32位可编程计数器,对应 Unix 时间戳的秒计数器</li><li>拥有20位可编程预分频器,适配不同频率的输入时钟.可选时钟源有<ul><li>HSE 时钟除以128(8MHz&#x2F;128)</li><li><strong>LSE 振荡器时钟(32.768KHZ)</strong></li><li>LSI 振荡器时钟(40KHz)</li></ul></li></ul></li><li><p>RTC 框图</p><p><img src="/2024/04/01/Embedded/STM32/11-RTC-block.png"></p></li><li><p>RTC 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/11-RTC-struct.png"></p></li></ol><h2 id="12-PWR-电源控制"><a href="#12-PWR-电源控制" class="headerlink" title="12 PWR 电源控制"></a>12 PWR 电源控制</h2><h3 id="12-1-PWR"><a href="#12-1-PWR" class="headerlink" title="12.1 PWR"></a>12.1 PWR</h3><ol><li><p><strong>PWR(Power Control, 电源控制): 负责 STM32 内部的电源供电部分,可实现可编程电压检测器和低功耗模式</strong></p></li><li><p>电源框图</p><p><img src="/2024/04/01/Embedded/STM32/12-power-block.png"></p></li><li><p>上电复位和掉电复位</p><p><img src="/2024/04/01/Embedded/STM32/12-reset.png"></p></li><li><p><strong>可编程电压检测器(PVD): 监控 VDD 电源电压,当 VDD 上升&#x2F;下降到 PVD 阈值时,触发中断,执行紧急关闭任务</strong></p><p><img src="/2024/04/01/Embedded/STM32/12-PVD-threshold.png"></p></li></ol><h3 id="12-2-低功耗模式"><a href="#12-2-低功耗模式" class="headerlink" title="12.2 低功耗模式"></a>12.2 低功耗模式</h3><ol><li><p><strong>低功耗模式: 在系统空闲时,降低 STM32 的功耗,延长设备的使用时间</strong></p><p><img src="/2024/04/01/Embedded/STM32/12-low-power-mode.png"></p></li><li><p><strong>芯片在低功耗模式下无法直接下载程序: 下载程序步骤:按住复位键,点击下载程序,然后及时松开复位键</strong></p></li><li><p>修改芯片主频(修改文件 <code>Start/system_stm32f10x.c</code>)</p><ul><li>外部可见变量 <code>SystemCoreClock</code>: 系统主频的值</li><li>搜索 <code>SYSCLK_FREQ_xxMHz</code>,在此处进行的宏定义将会决定运行哪个设置系统时钟的函数</li></ul></li><li><p>进入睡眠模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">__WFI();  <span class="hljs-comment">// 进入睡眠模式,等待中断唤醒.一般置于主循环的最后一行</span><br>__WFE();  <span class="hljs-comment">// 进入睡眠模式,等待唤醒事件</span><br></code></pre></td></tr></table></figure></li><li><p>进入停机 &#x2F; 待机模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);      <span class="hljs-comment">// 停机和待机模式需开启 PWR 的时钟</span><br><br>PWR_EnterSTOPMode(PWR_Regulator_ON, PWR_STOPEntry_WFI);  <span class="hljs-comment">// 进入停止模式,并等待外部中断唤醒</span><br>PWR_EnterSTANDBYMode();  <span class="hljs-comment">// 进入待机模式,并等待指定的唤醒事件.唤醒后程序从头执行</span><br><br>SystemInit();  <span class="hljs-comment">// 从停止模式唤醒后,需重新配置时钟为 HSE(72MHz).而待机模式不需要</span><br></code></pre></td></tr></table></figure></li><li><p>设置闹钟或 PA0 上升沿唤醒待机模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">PWR_WakeUpPinCmd(ENABLE);  <span class="hljs-comment">// 使能 WakeUp 引脚(PA0)唤醒待机的功能(默认下拉低电平,高电平有效)</span><br>RTC_SetAlarm(RTC_GetCounter() + <span class="hljs-number">10</span>);  <span class="hljs-comment">// 设置 RTC 闹钟的值.为 10s 后</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="13-WDG-看门狗"><a href="#13-WDG-看门狗" class="headerlink" title="13 WDG 看门狗"></a>13 WDG 看门狗</h2><h3 id="13-1-看门狗功能"><a href="#13-1-看门狗功能" class="headerlink" title="13.1 看门狗功能"></a>13.1 看门狗功能</h3><ol><li><p><strong>看门狗(WDG, Watchdog)</strong></p><ul><li>监测程序的运行状态,当程序卡死时复位程序.保证安全性和可靠性</li><li><strong>看门狗本质是定时器,在指定的时间范围内,若未重置计数器,则硬件电路将产生复位信号</strong></li></ul></li><li><p><strong>独立看门狗(Independent WDG)</strong></p><p><img src="/2024/04/01/Embedded/STM32/13-independent-wdg.png"></p><ul><li><p>键寄存器 IWDG_KR: 控制寄存器,用于控制硬件电路的工作,避免干扰发生</p><table><thead><tr><th>写入键寄存器的值</th><th>作用</th></tr></thead><tbody><tr><td>0xCCCC</td><td>启用独立看门狗</td></tr><tr><td>0xAAAA</td><td>IWDG_RLR 中的值重新加载到计数器(喂狗)</td></tr><tr><td>0x5555</td><td>解除 IWDG_PR, IWDG_RLR 的写保护</td></tr><tr><td>0x5555之外的值</td><td>启用 IWDG_PR, IWDG_RLR 的写保护</td></tr></tbody></table></li><li><p>超时时间</p><p><img src="/2024/04/01/Embedded/STM32/13-wdg-timeout.png"></p><ul><li>超时时间: $T_{IWDG}$ &#x3D; 时钟周期 * PR 预分频系数 * (重装计数值 + 1)</li><li>其中,时钟周期&#x3D;1&#x2F;40KHz, PR 预分频系数只能取表中限定的值, 重装计数值12位(0~4095)</li></ul></li></ul></li><li><p><strong>窗口看门狗(Window WDG): 要求看门狗在精确计时窗口时作用(过早过晚均不行)</strong></p><p><img src="/2024/04/01/Embedded/STM32/13-wdg-block.png"></p></li><li><p>对比独立看门狗与窗口看门狗</p><table><thead><tr><th></th><th>独立看门狗</th><th>窗口看门狗</th></tr></thead><tbody><tr><td>复位时机</td><td>计数器减到0</td><td>计数器T[5:0] 减到0 &#x2F; 过早重装计数器</td></tr><tr><td>中断</td><td>&#x2F;</td><td>早期唤醒中断</td></tr><tr><td>时钟源</td><td>LSI(40KHz)</td><td>PCLK1(36MHz)</td></tr><tr><td>预分频系数</td><td>4, 8, 32, 64, 128, 256</td><td>1, 2, 4, 8</td></tr><tr><td>计数器</td><td>12位</td><td>6位</td></tr><tr><td>超时时间</td><td>0.1ms ~ 26214.4ms</td><td>113us ~ 58.25ms</td></tr><tr><td>喂狗方式</td><td>写入键寄存器,重装固定值 RLR</td><td>直接写入计数器</td></tr><tr><td>防误操作</td><td>键寄存器和写保护</td><td>&#x2F;</td></tr><tr><td>用途</td><td>独立工作,对时间精度要求较低</td><td>要求看门狗在精确计时窗口起作用</td></tr></tbody></table></li></ol><h3 id="13-2-看门狗代码"><a href="#13-2-看门狗代码" class="headerlink" title="13.2 看门狗代码"></a>13.2 看门狗代码</h3><ol><li><p>判断复位信号来源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) == SET) &#123;  <span class="hljs-comment">// 成立说明是独立看门狗复位</span><br><span class="hljs-comment">//if (RCC_GetFlagStatus(RCC_FLAG_WWDGRST) == SET) &#123;  // 成立说明是窗口看门狗复位</span><br>RCC_ClearFlag();  <span class="hljs-comment">// 标志位不会自动清除,进入后需要手动清除</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>操作独立看门狗</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* IWDG 初始化.LSI 会在设置看门狗后自动配置,无需手动开启 */</span><br>IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);  <span class="hljs-comment">// 独立看门狗写使能</span><br>IWDG_SetPrescaler(IWDG_Prescaler_16);  <span class="hljs-comment">// 设置预分频为16</span><br>IWDG_SetReload(<span class="hljs-number">2499</span>);  <span class="hljs-comment">// 设置重装值为2499,独立看门狗的超时时间为 1/40000 * 16 * 2500=1s</span><br>IWDG_ReloadCounter();  <span class="hljs-comment">// 重装计数器,初始化喂狗. 主循环中每1秒都需要喂狗,否则复位</span><br>IWDG_Enable();  <span class="hljs-comment">// 独立看门狗使能</span><br><span class="hljs-comment">/* 主循环中喂狗 */</span><br>IWDG_ReloadCounter();  <span class="hljs-comment">//重装计数器</span><br></code></pre></td></tr></table></figure></li><li><p>操作窗口看门狗</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* WWDG 初始化.以窗口时长 30~50ms 为例 */</span><br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);  <span class="hljs-comment">// 开启 WWDG 的时钟</span><br>WWDG_SetPrescaler(WWDG_Prescaler_8);  <span class="hljs-comment">// 设置预分频为8</span><br>WWDG_SetWindowValue(<span class="hljs-number">0x40</span> | <span class="hljs-number">21</span>);  <span class="hljs-comment">// 设置窗口时长 1/36,000,000 * 4096 * 8 * (54-21) = 30ms</span><br>WWDG_Enable(<span class="hljs-number">0x40</span> | <span class="hljs-number">54</span>);  <span class="hljs-comment">// 使能并第一次喂狗,超时时间为 1/36,000,000 * 4096 * 8 * (54+1) = 50ms</span><br><span class="hljs-comment">/* 主循环中喂狗 */</span><br>WWDG_SetCounter(<span class="hljs-number">0x40</span> | <span class="hljs-number">54</span>);  <span class="hljs-comment">//重装计数器</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="14-Flash-闪存"><a href="#14-Flash-闪存" class="headerlink" title="14 Flash 闪存"></a>14 Flash 闪存</h2><h3 id="14-1-Flash-功能"><a href="#14-1-Flash-功能" class="headerlink" title="14.1 Flash 功能"></a>14.1 Flash 功能</h3><ol><li><p>STM32F1 系列中容量产品 Flash 闪存模块组织</p><p><img src="/2024/04/01/Embedded/STM32/14-flash.png"></p></li><li><p><strong>读写 Flash 的用途</strong></p><ul><li><strong>利用程序存储器的剩余空间,保存用户数据(掉电不丢失)</strong></li><li><strong>通过在程序中编程(In-Application Programming),实现程序自我更新</strong></li></ul></li><li><p>下载程序方式</p><ul><li><strong>在线编程(In-Circuit Programming)</strong>: 更新程序存储器的全部内容<ul><li>通过 JTAG, SWD 协议(ST Link)或系统加载程序(Bootloader)下载程序</li></ul></li><li><strong>在程序中编程(In-Application Programming)</strong>: 使用微控制器支持的任意通信接口下载程序<ul><li>需要自己编写 Bootloader 程序(存储于程序更新时不覆盖的地方)</li><li>需要更新程序时,控制程序跳转到 Bootloader,接收通信数据(程序信息)</li><li>然后通过控制 Flash 读写,将程序信息存储于程序正常运行的地方</li></ul></li></ul></li><li><p>Flash 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/14-Flash-struct.png"></p></li><li><p><strong>指针访问存储器</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// #define __IO volatile  // STM32对__IO的宏定义</span><br><span class="hljs-type">uint16_t</span> Data = *((__IO <span class="hljs-type">uint16_t</span> *)(<span class="hljs-number">0x08000000</span>));  <span class="hljs-comment">// 读取0x8000 0000地址的数据</span><br>* ((__IO <span class="hljs-type">uint16_t</span> *)(<span class="hljs-number">0x80000000</span>)) = <span class="hljs-number">0x1234</span>;  <span class="hljs-comment">// 给0x8000 0000地址写入数据.需要先解锁,执行相应流程</span><br></code></pre></td></tr></table></figure></li><li><p><strong>器件电子签名: 存放于闪存的系统存储区域,不可更改</strong></p><ul><li>读取方式: 使用指针直接读取指定地址下的存储器获得</li><li>闪存容量(单位kb)寄存器(16位)基地址: <code>0x1FFF F7E0</code></li><li>产品唯一身份标识寄存器(96位)基地址: <code>0x1FFF F7E8</code></li></ul></li></ol><h3 id="14-2-Flash-烧录"><a href="#14-2-Flash-烧录" class="headerlink" title="14.2 Flash 烧录"></a>14.2 Flash 烧录</h3><ol><li><p>读取芯片 ID</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">*((__IO <span class="hljs-type">uint16_t</span> *)(<span class="hljs-number">0x1FFFF7E0</span>));  <span class="hljs-comment">// 闪存容量寄存器的值</span><br>*((__IO <span class="hljs-type">uint32_t</span> *)(<span class="hljs-number">0x1FFFF7E8</span>));  <span class="hljs-comment">// 产品唯一身份标识寄存器的值,共96位</span><br>*((__IO <span class="hljs-type">uint32_t</span> *)(<span class="hljs-number">0x1FFFF7E8</span> + <span class="hljs-number">0x04</span>));<br>*((__IO <span class="hljs-type">uint32_t</span> *)(<span class="hljs-number">0x1FFFF7E8</span> + <span class="hljs-number">0x08</span>));<br></code></pre></td></tr></table></figure></li><li><p><strong>指定烧录程序是的起始地址</strong>: 打开工程选项 -&gt; Target</p><p><img src="/2024/04/01/Embedded/STM32/14-start-addr.png"></p></li><li><p><strong>程序占用空间大小查看</strong></p><ul><li><p>编译完成后会出现提示信息: <code>Program Size: Code=2784 RO-data=1788 RW-data=4 ZI-data=2660</code></p><ul><li><code>Code + RO=-data + Rw-data = 4576</code>: ROM 使用空间</li><li><code>Rw-data + ZI-data = 2664</code>:  RAM 使用空间</li></ul><table><thead><tr><th>数据类型</th><th>存储位置</th><th>说明</th></tr></thead><tbody><tr><td>Code</td><td>Flash</td><td>代码</td></tr><tr><td>RO-Data</td><td>Flash</td><td>只读数据.如 const 修饰</td></tr><tr><td>RW-Data</td><td>Flash &amp; SRAM</td><td>初值非0 可读可写的数据</td></tr><tr><td>ZI-Data</td><td>SRAM</td><td>初值为0 可读可写数据</td></tr></tbody></table></li><li><p>双击 <code>Target 1</code> 出现 <code>Project.map</code> 文件,拉到文件底部,可以直接查看程序占用空间情况</p><p><img src="/2024/04/01/Embedded/STM32/14-total-process-size.png"></p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++</title>
    <link href="/2024/01/19/Computer/C++/"/>
    <url>/2024/01/19/Computer/C++/</url>
    
    <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="0-基础语法"><a href="#0-基础语法" class="headerlink" title="0 基础语法"></a>0 基础语法</h2><h3 id="0-1-关键字"><a href="#0-1-关键字" class="headerlink" title="0.1 关键字"></a>0.1 关键字</h3><ol><li><p>C++ 语言特性直接支持4种程序设计风格(核心哲学: 零开销抽象)</p><ul><li><strong>过程式程序设计</strong>: 专注于处理和设计恰当的数据结构(如 C 语言)</li><li><strong>数据抽象</strong>: 专注于接口的设计, 一般实现细节的隐藏和特殊的表示方式(具体类, 抽象类)</li><li><strong>面向对象程序设计</strong>: 专注于类层次的设计, 实现, 使用(通过封装, 继承, 多态)</li><li><strong>泛型程序设计</strong>: 专注于通用算法的设计, 实现, 使用(通过模板)</li></ul></li><li><p>ANSI C 有32个关键字</p><table><thead><tr><th>auto</th><th>break</th><th>case</th><th>char</th><th>const</th><th>continue</th><th>default</th><th>do</th></tr></thead><tbody><tr><td>double</td><td>else</td><td>enum</td><td>extern</td><td>float</td><td>for</td><td>goto</td><td>if</td></tr><tr><td>int</td><td>long</td><td>register</td><td>return</td><td>short</td><td>signed</td><td>sizeof</td><td>static</td></tr><tr><td>struct</td><td>switch</td><td>typedef</td><td>union</td><td>unsigned</td><td>void</td><td>volatile</td><td>while</td></tr></tbody></table></li><li><p>C99 标准新增5个关键字: <code>inline, restrict, _Bool, _Complex, _Imaginary</code></p></li><li><p>C11 标准新增7个关键字: <code>_Alignas, _Alignof, _Atomic, _Static_assert, _Noreturn, _Thread_local, _Generic</code></p></li><li><p><strong>C++98&#x2F;03 相较 ANSI C 增加的31个关键字(共63个)</strong></p><table><thead><tr><th>asm</th><th>bool</th><th>catch</th><th>class</th><th>const_cast</th></tr></thead><tbody><tr><td>delete</td><td>dynamic_cast</td><td>explicit</td><td>export</td><td>false</td></tr><tr><td>friend</td><td>inline</td><td>mutable</td><td>namespace</td><td>new</td></tr><tr><td>operate</td><td>private</td><td>protected</td><td>public</td><td>reinterpret_cast</td></tr><tr><td>static_cast</td><td>template</td><td>this</td><td>throw</td><td>true</td></tr><tr><td>try</td><td>typeid</td><td>typename</td><td>using</td><td>virtual</td></tr><tr><td>wchar_t</td><td></td><td></td><td></td><td></td></tr></tbody></table></li><li><p><strong>C++11 相较于 C++98 新增的10个关键字(共73个)</strong></p><table><thead><tr><th>alignas</th><th>alignof</th><th>char16_t</th><th>char32_t</th><th>constexpr</th></tr></thead><tbody><tr><td>decltype</td><td>noexcept</td><td>nullptr</td><td>static_assert</td><td>thread_local</td></tr></tbody></table></li><li><p>逻辑运算符: <code>and, or, not, and_eq, or_eq, not_eq, bitand, bitor, compl, xor, xor_eq</code></p></li></ol><h3 id="0-2-命名空间"><a href="#0-2-命名空间" class="headerlink" title="0.2 命名空间"></a>0.2 命名空间</h3><ol><li><p><code>hello, world</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;hello, world&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>using</code> 的使用(以 <code>std::cout</code> 对象为例.注意不要在全局作用域的头文件中使用 <code>using</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;         <span class="hljs-comment">// 使得 std 命名空间中的所有名称都可直接使用.方便但不推荐</span><br><span class="hljs-keyword">using</span> std::cout;             <span class="hljs-comment">// 仅引入需要使用的 std::cout, 并简化为 cout. 推荐的使用方式</span><br>std::coot &lt;&lt; <span class="hljs-string">&quot;Hello,world!&quot;</span>; <span class="hljs-comment">// 不使用 using 编译指令.而是都每次都加上 std:: 前缀.比较麻烦</span><br></code></pre></td></tr></table></figure></li><li><p><code>namespace</code> 的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> 名称 &#123;<br>    <span class="hljs-comment">/* 在此处声明变量, 函数, 类型, 对象... 其他位置进行实现 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>namespace</code> 注意事项</p><ul><li><p>访问方式(与访问类成员类似,但运算符为 <code>::</code>)</p><ul><li>内部访问: 直接访问即可,无需任何条件</li><li><strong>外部访问: 通过 <code>::</code> 作用域解析运算符访问命名空间成员</strong></li></ul></li><li><p>只能在全局范围定义(如函数内不允许定义命名空间)</p></li><li><p>可以嵌套定义.访问时使用多次 <code>::</code> 即可访问</p></li><li><p>实现与声明通常分离(声明于 <code>.h</code> 文件,实现于 <code>.cpp</code> 文件)</p></li><li><p>命名空间可以起别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> alias = std;  <span class="hljs-comment">// 直接赋值.后续即可使用别名</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-3-兼容性"><a href="#0-3-兼容性" class="headerlink" title="0.3 兼容性"></a>0.3 兼容性</h3><ol><li><p>C 与 C++ 的兼容性</p><ul><li><strong>C++ 几乎是 C 的超集.C 语言的语法在 C++ 中可以通用(如预处理器, 变量声明, 函数声明)</strong></li><li><strong>C++ 增加了面向对象(通过类)与泛型编程(通过模板)</strong></li></ul></li><li><p>对 C 程序员的建议</p><ul><li><strong>C++ 几乎不需要宏替换</strong><ul><li>使用 <code>const, constexpr, enum, enum class</code> 定义显式常量</li><li>使用 <code>inline</code> 避免函数调用的开销</li><li>使用 <code>template</code> 指明函数族和类型族</li><li>使用 <code>namespace</code> 避免命名冲突</li></ul></li><li>在需要使用一个变量时才声明,且声明后立即进行初始化</li><li>不要使用 <code>malloc</code>, 而是使用 <code>new</code></li><li>避免使用 <code>void *, 类型转换</code></li><li>没有参数的不需要写 <code>void</code>.形参列表为空就好</li><li>减少 C 风格字符串的使用.而是使用 <code>string</code></li><li>C++ 不推荐使用 C 风格的数组,而是采用 <code>std::array, std::vector</code> 容器</li></ul></li><li><p>文件格式</p><ul><li>C 语言的源代码使用 <code>.c</code>,而 C++ 源代码的拓展名常用 <code>.cpp</code></li><li>C 语言的头文件使用 <code>.h</code>,而 C++ 头文件没有拓展名(如 C 中的 <code>math.h</code> 改为 <code>cmath</code>)</li></ul></li><li><p>API 适配: 假设一个头文件声明了 C 语言的函数和全局变量,但却可能会被 C++ 代码包含,则需要特殊处理</p><ul><li><p>因为 C++ 编译器对符号修饰的处理与 C 不同,因而导致链接出错</p></li><li><p>C++ 具有 <code>extern &quot;C&quot;</code> 关键字,用于处理与 C 的兼容性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>    <span class="hljs-type">int</span> var;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>处理方式: 正常编写 C 程序.而使用预编译指令处理头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus  <span class="hljs-comment">// C++ 编译时会默认定义 __cplusplus 宏</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// C function declarations here</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-4-数据"><a href="#0-4-数据" class="headerlink" title="0.4 数据"></a>0.4 数据</h3><ol><li><p>数值字面量</p><ul><li>整数: <strong>二进制(前缀 0b)</strong>, 八进制(前缀 0), 十进制(默认形式), 十六进制(前缀 0x)</li><li><strong>分隔符 <code>&#39;</code></strong>: 如 <code>100&#39;000, 0.123&#39;456f, 0b1000&#39;000</code></li><li>C 定义 <code>NULL</code> 为 <code>((void *) 0)</code>.而 C++ 定义 <code>NULL</code> 为 0.应该使用 <code>nullptr</code> 表示空指针</li></ul></li><li><p>初始化列表对不同对象的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> l &#123;<span class="hljs-number">5400UL</span>&#125;;  <span class="hljs-comment">// 相当于 unsigned long l = 5400UL;</span><br><span class="hljs-type">int</span> array[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;     <span class="hljs-comment">// 省略了赋值号,并由编译器推断数组长度</span><br><span class="hljs-comment">// 零初始化的行为: 数值类型初始化为 0; 指针类型初始化为 nullptr; 类对象调用默认构造函数</span><br></code></pre></td></tr></table></figure></li><li><p>变量类型转换(<code>static_cast</code> 关键字)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> f = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> a &#123; (<span class="hljs-type">int</span>)f &#125;;               <span class="hljs-comment">// C 风格强制类型转换</span><br><span class="hljs-type">int</span> b &#123; <span class="hljs-built_in">int</span>(f) &#125;;               <span class="hljs-comment">// 使用较少</span><br><span class="hljs-type">int</span> c &#123; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(f) &#125;;  <span class="hljs-comment">// 推荐使用</span><br></code></pre></td></tr></table></figure></li><li><p><strong>枚举类</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// c++ 枚举类定义需要 class 关键字.且枚举类不能与整数混用</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">piece_type</span> &#123;King, Queen, Rook, Pawn&#125;;<br><br><span class="hljs-comment">// 访问枚举类: 与访问类常量相似(因为不同枚举类被当作不同的作用域.这区别于 C 语言的枚举)</span><br>piece_type piece&#123; PieceType::King &#125;;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">piece_type</span>;  <span class="hljs-comment">// C++20 语法</span><br>piece = Queen;          <span class="hljs-comment">// 无需使用全名访问</span><br></code></pre></td></tr></table></figure></li><li><p><code>if, switch</code> 语句的初始化器: 初始化引入的变量作用域局限于条件语句内部</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>( &lt;初始化&gt;; &lt;条件语句&gt; )   &#123; <span class="hljs-comment">/* code */</span> &#125;<br><span class="hljs-keyword">switch</span>( &lt;初始化&gt;; &lt;表达式&gt; ) &#123; <span class="hljs-comment">/* code */</span> &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>基于范围的 <code>for</code> 循环</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>( &lt;初始化&gt;; &lt;范围声明&gt;) &#123; <span class="hljs-comment">/* code */</span> &#125;  <span class="hljs-comment">// C++20 基于范围的 for 循环的初始化器</span><br><br><span class="hljs-keyword">for</span>( array arr&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;; <span class="hljs-type">int</span> i : arr )<br>    cout &lt;&lt; i &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li></ol><h3 id="0-5-内存"><a href="#0-5-内存" class="headerlink" title="0.5 内存"></a>0.5 内存</h3><ol><li><p>C++ 中利用 <code>new</code> 操作符在堆区申请内存,利用操作符 <code>delete</code> 释放空间</p></li><li><p><code>new</code> 申请单个数据的内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 申请1个 int 类型大小的内存空间,且初始化为 10</span><br>cout &lt;&lt; *p &lt;&lt; endl;    <span class="hljs-comment">// 使用 p 存储的数据</span><br><span class="hljs-keyword">delete</span> p;              <span class="hljs-comment">// 释放申请的空间.必须是由 new 创建的</span><br>p = <span class="hljs-literal">nullptr</span>;           <span class="hljs-comment">// 最佳实践.防止悬空指针</span><br></code></pre></td></tr></table></figure></li><li><p><code>new</code> 申请数组内存(注意释放内存时 <code>delete</code> 的格式应与 <code>new</code> 对应)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">// 申请的是 int[],长度为10</span><br><span class="hljs-keyword">delete</span>[] arr;           <span class="hljs-comment">// 对应地,释放时要表明是数组 delete[]</span><br>arr = <span class="hljs-literal">nullptr</span>;          <span class="hljs-comment">// 释放空间后将指针置空.防止再次使用</span><br></code></pre></td></tr></table></figure></li><li><p><code>new, delete</code> 与 <code>malloc, free</code> 对比</p><ul><li><code>new, delete</code> 是 C++ 的操作符(可重载.会调用构造 &#x2F; 析构函数).而 <code>malloc, free</code> 是标准库函数</li><li><code>new</code> 直接返回对应类型指针.而 <code>malloc</code> 需要手动计算字节数并返回 <code>void *</code></li></ul></li><li><p><strong>在现代 C++ 中,应尽量避免直接使用 <code>new</code> 和 <code>delete</code>.转而使用智能指针管理内存生命周期</strong></p></li></ol><h3 id="0-6-引用"><a href="#0-6-引用" class="headerlink" title="0.6 引用"></a>0.6 引用</h3><ol><li><p><strong>引用: 给变量起别名(本质为指针常量).引用必须初始化.且初始化后不可修改其指向对象,而只能修改其值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;b = a;  <span class="hljs-comment">// &amp; 表示引用变量  &lt;==&gt; int* const p = &amp;a;</span><br>b = <span class="hljs-number">100</span>;     <span class="hljs-comment">// 直接修改引用名  &lt;==&gt; *p = 100;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>引用作为函数参数: 可以简化指针修改实参的语法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 1. 值传递: 这无法完成 &quot;值交换功能&quot; */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_swap1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> temp = a; a = b; b = temp;&#125;<br><br><span class="hljs-comment">/* 2. 地址传递: 完成了 &quot;值交换功能&quot;,但需要进行取址/取值操作 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_swap2</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> </span>&#123;<span class="hljs-type">int</span> temp = *a; *a = *b; *b = temp;&#125;<br><br><span class="hljs-comment">/* 3. 引用传递: 完成了 &quot;值交换功能&quot;,且代码中并未直接出现指针 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_swap3</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span> </span>&#123;<span class="hljs-type">int</span> temp = a; a = b; b = temp;&#125;<br></code></pre></td></tr></table></figure></li><li><p>引用作为返回值</p><ul><li>引用可以作为函数的返回值(注意不要返回局部变量引用)</li><li>函数调用可作为左值(因为函数调用后返回的是变量引用).实现链式调用</li></ul></li><li><p>常量引用: 主要用来修饰形参,防止误操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 在函数形参列表中,可以加 const 修饰形参,防止形参改变实参 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_value</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;v)</span> </span>&#123;<br><span class="hljs-comment">// v += 10;  // 对常量进行修改, 将会导致编译报错</span><br>cout &lt;&lt; v &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="0-7-函数"><a href="#0-7-函数" class="headerlink" title="0.7 函数"></a>0.7 函数</h3><ol><li><p><strong>默认参数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 函数的形参可以有默认值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>)</span> </span>&#123;<br>    <span class="hljs-comment">/* code */</span><br>&#125;<br><span class="hljs-comment">// 如果某个位置参数有默认值,那么从这个位置 往后的参数都必须有默认值</span><br><span class="hljs-comment">// 如果函数声明有默认值,函数实现就不能有默认参数(因为导致语义二义性)</span><br></code></pre></td></tr></table></figure></li><li><p><strong>占位参数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 函数占位参数也可以有默认参数.调用函数时必须填补 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> = <span class="hljs-number">10</span>)</span> </span>&#123;<br><span class="hljs-comment">/* code */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>函数重载</strong>: 函数名可以相同,提高复用性</p><ul><li>函数重载条件<ul><li>函数名相同,且位于同一个作用域</li><li>函数的参数不同(类型 &#x2F; 个数 &#x2F; 顺序的任意一种)</li></ul></li><li>注意事项<ul><li>返回值不作为函数重载的条件</li><li>引用可作为重载条件(是否被 <code>const</code> 修饰的引用形参)</li><li><strong>函数重载碰到函数默认参数时.会产生歧义,应避免</strong></li></ul></li><li>函数被调用时,会根据传入参数不同匹配需要调用的函数</li></ul></li><li><p><strong>匿名函数(labmda)</strong>: .属于可调用对象,特点为就地定义,就地使用</p><ul><li><p>C++ 中 lambda 是函数对象的语法糖.在任何需要可调用对象的接口,都可传入 lambda 匿名函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture_clause] (parameters) -&gt; return_type &#123;<br>    <span class="hljs-comment">/* code */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>捕获列表: lambda 所在父作用域定义的变量列表</p></li><li><p>父作用域: 包含 lambda 函数的语句块</p></li><li><p>空捕获列表: 不使用父作用域的任何局部变量</p></li><li><p>隐式捕获: 不在捕获列表中指定局部变量,而是靠编译器推导</p><ul><li><code>[=]</code>: 值传递的方式捕获父作用域的所有变量</li><li><code>[&amp;]</code>: 引用传递的方式捕获父作用域的所有变量</li></ul></li><li><p>捕获 <code>this</code> 指针: 使得 lambda 表达式拥有与当前类成员相同的访问权限</p></li></ul></li></ol><h3 id="0-8-文件"><a href="#0-8-文件" class="headerlink" title="0.8 文件"></a>0.8 文件</h3><ol><li><p>写文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>              <span class="hljs-comment">// 文件操作头文件</span></span><br><br>ofstream ofs;                   <span class="hljs-comment">// 创建流对象</span><br>ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::out); <span class="hljs-comment">// 打开文件</span><br>ofs &lt;&lt; <span class="hljs-string">&quot;姓名:张三&quot;</span> &lt;&lt; endl;      <span class="hljs-comment">// 写入数据</span><br>ofs &lt;&lt; <span class="hljs-string">&quot;性别:男&quot;</span> &lt;&lt; endl;<br>ofs.<span class="hljs-built_in">close</span>();                    <span class="hljs-comment">// 关闭文件</span><br></code></pre></td></tr></table></figure></li><li><p>文件打开模式(利用 <code>|</code> 操作符可以组合模式)</p><table><thead><tr><th>mode</th><th>说明</th></tr></thead><tbody><tr><td><code>ios::in</code></td><td>读文件</td></tr><tr><td><code>ios::out</code></td><td>写文件</td></tr><tr><td><code>ios::ate</code></td><td>将文件指针置于文件尾</td></tr><tr><td><code>ios::app</code></td><td>追加方式写文件</td></tr><tr><td><code>ios::trunc</code></td><td>如果文件存在,先删除,再创建</td></tr><tr><td><code>ios::binary</code></td><td>二进制方式</td></tr></tbody></table></li><li><p>读文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">ifstream ifs;                  <span class="hljs-comment">// 创建流对象</span><br>ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::in); <span class="hljs-comment">// 打开文件</span><br><br><span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>()) &#123;          <span class="hljs-comment">// 使用 is_open 方法判断是否打开成功</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">/* 在此处读取文件... */</span><br>ifs.<span class="hljs-built_in">close</span>();                   <span class="hljs-comment">// 关闭文件</span><br></code></pre></td></tr></table></figure></li><li><p>多种读取方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 1. 右移运算符将 ifs 中数据读入 buf.完毕后返回 false */</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123; <span class="hljs-number">0</span> &#125;; <span class="hljs-comment">// 将 buf 全初始化为0</span><br><span class="hljs-keyword">while</span> (ifs &gt;&gt; buf) &#123; cout &lt;&lt; buf &lt;&lt; endl;&#125;<br><br><span class="hljs-comment">/* 2. getline 方法读入一行.参数 str 为存放数据的地址,count 为最大读入数量 */</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123; <span class="hljs-number">0</span> &#125;; <span class="hljs-comment">// 将 buf 全初始化为0</span><br><span class="hljs-keyword">while</span> (ifs.<span class="hljs-built_in">getline</span>(buf, <span class="hljs-built_in">sizeof</span>(buf))) &#123; cout &lt;&lt; buf &lt;&lt; endl;&#125;<br><br><span class="hljs-comment">/* 3. 全局函数 getline 读入一行 */</span><br>string buf;  <span class="hljs-comment">// 使用 string 对象进行维护</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(ifs, buf)) &#123; cout &lt;&lt; buf &lt;&lt; endl;&#125;<br><br><span class="hljs-comment">/* 4. get 方法每次只读一个字符 */</span><br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span> ((c = ifs.<span class="hljs-built_in">get</span>()) != EOF) &#123;cout &lt;&lt; c;&#125;<br></code></pre></td></tr></table></figure></li><li><p>以二进制的方式对文件进行读写操作.打开方式要指定为 <code>ios::binary</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br><span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">/* 二进制文件操作: 写数据 */</span><br><span class="hljs-function">ofstream <span class="hljs-title">ofs</span><span class="hljs-params">(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;<br>Person p = &#123;<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>&#125;;<br>ofs.<span class="hljs-built_in">write</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)&amp;p, <span class="hljs-built_in">sizeof</span>(p));<br>ofs.<span class="hljs-built_in">close</span>();<br><br><span class="hljs-comment">/* 二进制文件操作: 读数据 */</span><br><span class="hljs-function">ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;<br><span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>()) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;<br>&#125;<br>ifs.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span> *)&amp;p, <span class="hljs-built_in">sizeof</span>(p));<br><br>cout &lt;&lt; <span class="hljs-string">&quot;姓名: &quot;</span> &lt;&lt; p.name &lt;&lt; <span class="hljs-string">&quot; 年龄: &quot;</span> &lt;&lt; p.age &lt;&lt; endl;<br>ifs.<span class="hljs-built_in">close</span>();<br></code></pre></td></tr></table></figure></li></ol><h2 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1 面向对象"></a>1 面向对象</h2><h3 id="1-1-封装"><a href="#1-1-封装" class="headerlink" title="1.1 封装"></a>1.1 封装</h3><ol><li><p><strong>面向对象的三大特性: 封装, 继承, 多态</strong></p></li><li><p>封装的作用</p><ul><li>将属性和行为作为一个整体</li><li>对属性和行为进行权限控制</li></ul></li><li><p>在设计类的时候,属性和行为封装在一起</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> radius &#123;<span class="hljs-number">0</span>&#125; ;  <span class="hljs-comment">// 类内成员初始化器</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">get_perimeter</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span>  <span class="hljs-number">2</span> * PI * radius;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Circle c&#123;&#125;;     <span class="hljs-comment">// 实例化对象</span><br>    c.radius = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 类实例访问方式与结构体类似.使用 . 或 -&gt;</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Circle perimeter: &quot;</span> &lt;&lt; c.<span class="hljs-built_in">get_perimeter</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>属性与方法的权限控制</p><table><thead><tr><th>关键字</th><th>权限类别</th><th>说明</th></tr></thead><tbody><tr><td><code>public</code></td><td>公共权限</td><td>类内 &#x2F; 类外均可访问.用于提供接口</td></tr><tr><td><code>protected</code></td><td>保护权限</td><td>类内可以访问,子类可以访问.但类外不可以访问</td></tr><tr><td><code>private</code></td><td>私有权限</td><td>类内可访问,类外不可访问.用于提供实现细节</td></tr></tbody></table></li><li><p>C++ 中 <code>struct</code> 和 <code>class</code> 区别在于默认的访问权限不同.<code>struct</code> 默认公共; <code>class</code> 默认私有</p></li><li><p>成员属性设为 <code>private</code> 的优点: 控制读写权限</p><ul><li>对于读权限,通过 <code>get</code> 方法(控制访问权限)</li><li>对于写权限,通过 <code>set</code> 方法(检测数据的合法性)</li></ul></li></ol><h3 id="1-2-默认函数"><a href="#1-2-默认函数" class="headerlink" title="1.2 默认函数"></a>1.2 默认函数</h3><ol><li><p><strong>构造函数: 用于创建对象时为对象的成员属性赋值,将由编译器自动调用(只会调用一次)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 构造函数名称与类名相同.没有返回值且不用写 void.支持重载</span><br><span class="hljs-built_in">ClassName</span>() &#123;<br>    <span class="hljs-comment">/* code */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>析构函数: 用于对象销毁前的清理工作,将由编译器自动调用(只会调用一次)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 析构函数没有返回值,但不用写 void.不可以有参数,因此不可重载</span><br>~<span class="hljs-built_in">ClassName</span>() &#123;<br>    <span class="hljs-comment">/* code */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>类内默认函数</p><ul><li><strong>默认情况下,C++ 编译器至少给一个类添加4个函数</strong><ul><li>默认构造函数(无参,函数体为空)</li><li>默认析构函数(无参,函数体为空)</li><li>默认拷贝构造函数, 对属性进行值拷贝</li><li>赋值运算符 <code>operator=</code>: 对属性进行值拷贝.非构造情况下调用</li></ul></li><li>若用户定义有参构造函数,C++ 不再提供默认无参构造,但是仍提供默认拷贝构造</li><li>若用户定义拷贝构造函数,C++ 不再提供其他构造函数</li></ul></li><li><p>深拷贝与浅拷贝</p><ul><li>浅拷贝: 简单的赋值拷贝操作</li><li>深拷贝: 在堆区重新申请空间,进行拷贝操作<ul><li>如果属性有在堆区申请空间的操作,则析构函数应包含释放内存操作</li><li>浅拷贝将会导致重复释放内存.需要自己提供拷贝构造函数避免该问题</li></ul></li></ul></li></ol><h3 id="1-3-类成员"><a href="#1-3-类成员" class="headerlink" title="1.3 类成员"></a>1.3 类成员</h3><ol><li><p><strong>静态成员: 在成员变量和成员函数前加上关键字 <code>static</code></strong></p><ul><li>静态成员变量: 所有对象共享同一份数据; 在编译阶段分配内存; 类内声明,类外初始化</li><li>静态成员函数: 所有对象共享同一个函数; <strong>静态成员函数只能访问静态成员变量</strong></li><li>静态成员可以通过类名直接访问: <code>对象.成员</code> 或 <code>类名::成员</code></li></ul></li><li><p>成员变量和成员函数分开存储.只有非静态成员变量属于类的对象之中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123;mA = <span class="hljs-number">0</span>;&#125;<br><span class="hljs-type">int</span> mA;           <span class="hljs-comment">// 非静态成员变量占对象空间</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> mB;    <span class="hljs-comment">// 静态成员变量不占对象空间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 函数也不占对象空间,所有函数共享一个函数实例</span><br>cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mA &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">sfunc</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// 静态成员函数也不占对象空间</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>C++ 通过特殊的对象指针 <code>this</code> 指针,指向调用方法的对象.是一个指针常量</strong></p><ul><li><p><code>this</code> 指针隐含于每一个非静态成员函数内.也不需要定义,可直接使用</p></li><li><p>形参和成员变量同名时,可用 <code>this</code> 指针来区分</p></li><li><p>在类的非静态成员函数中返回对象本身,可使用 <code>return *this</code></p></li></ul></li><li><p>常函数: 成员函数最后加 <code>const</code></p><ul><li><strong>常函数内不可以修改成员属性</strong></li><li>成员属性声明时加关键字 <code>mutable</code> 后,在常函数中依然可以修改</li></ul></li><li><p>常对象: 声明对象前加 <code>const</code> 称该对象为常对象</p><ul><li><p><strong>常对象不能修改成员变量,只能访问.因此只能调用常函数</strong></p></li><li><p>常对象可以修改 <code>mutable</code> 修饰成员变量.可访问 <code>public</code> 属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123; property1 = <span class="hljs-number">0</span>; property2 = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-comment">/* this 指针的类型为 Type* const this;</span><br><span class="hljs-comment">** this 指针的本质是一个指针常量,指针的指向不可修改</span><br><span class="hljs-comment">** 如果想让指针指向的值也不可以修改,需要声明常函数  */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>     <span class="hljs-comment">/* 成员函数加上 const,本质是在修饰 this 指针指向数据的类型</span><br><span class="hljs-comment">     ** 此时 this 指针类型为 const Type* const pointer</span><br><span class="hljs-comment">     ** 则 this 指向的数据不能修改,除使用 mutable 修饰的变量 */</span><br><span class="hljs-keyword">this</span>-&gt;property2 = <span class="hljs-number">100</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> property1;<br><span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> property2;  <span class="hljs-comment">// mutable: 可修改,可变的</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-4-类初始化"><a href="#1-4-类初始化" class="headerlink" title="1.4 类初始化"></a>1.4 类初始化</h3><ol><li><p>简单的类定义示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/* 无参构造函数.若没有任何构造函数,则编译器默认提供一个空实现.但建议手动添加 */</span><br>    <span class="hljs-built_in">Person</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;&#125;<br><br>    <span class="hljs-comment">/* 有参构造函数.可以重载,可以有默认参数,但建议不要同时出现 */</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a) &#123;<br>         age = a;<br>         cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">/* 拷贝构造函数.编译器默认实现为对属性的简单赋值 */</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person &amp;p) &#123;  <span class="hljs-comment">// p 引用的是右值(将要被拷贝的对象)</span><br>         age = p.age;           <span class="hljs-comment">// 当属性为指针且指向堆空间时.要按需实现拷贝逻辑</span><br>         cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">/* 析构函数 */</span><br>    ~<span class="hljs-built_in">Person</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;&#125;<br><span class="hljs-keyword">public</span>: <span class="hljs-type">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>构造函数的调用方式</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 调用无参构造函数 */</span><br>Person p;    <span class="hljs-comment">// 正确.使用无参构造函数.注意不需要括号</span><br><span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 错误.编译器理解为函数声明</span><br><br><span class="hljs-comment">/* 调用有参的构造函数 */</span><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">// 括号法(常用方式).直接进行初始化,而非使用变量接收</span><br><br><span class="hljs-comment">/* 显式调用 */</span><br>Person p2 = <span class="hljs-built_in">Person</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// Person(10) 是匿名对象.当前行结束之后,会立即析构</span><br>Person p3 = <span class="hljs-built_in">Person</span>(p2);  <span class="hljs-comment">// 使用已有的对象进行初始化.触发拷贝构造</span><br><br><span class="hljs-comment">/* 隐式转换 */</span><br>Person p4 = <span class="hljs-number">10</span>;  <span class="hljs-comment">// Person p4 = Person(10); </span><br>Person p5 = p4;  <span class="hljs-comment">// Person p5 = Person(p4); 触发拷贝构造</span><br><br><span class="hljs-comment">/* 不能利用拷贝构造函数来初始化匿名对象.因为编译器会理解为对象声明 */</span><br><span class="hljs-built_in">Person</span>(p5);  <span class="hljs-comment">// 错误.编译器理解为 Person p5; 对 p5 重定义</span><br></code></pre></td></tr></table></figure></li><li><p><strong>拷贝构造函数</strong>调用时机: 通常有三种情况(用已有的对象创建其他对象)</p><ul><li>用已创建的对象来初始化一个新对象<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;  <span class="hljs-comment">// 使用 p1 创建对象 p2.即拷贝构造</span><br></code></pre></td></tr></table></figure></li><li>以值传递的方式给函数参数传值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Person p)</span></span>;  <span class="hljs-comment">// func 函数以值传递形式接收对象</span><br><span class="hljs-built_in">func</span>(p);              <span class="hljs-comment">// func 调用时,实参传递给形参,触发拷贝构造</span><br></code></pre></td></tr></table></figure></li><li>以值方式返回局部对象<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Person <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    Person p;<br>    <span class="hljs-keyword">return</span> p;  <span class="hljs-comment">// func 函数以值的形式返回局部对象</span><br>&#125;<br>Person p = <span class="hljs-built_in">func</span>();  <span class="hljs-comment">// 接收 func 函数的返回值时,触发拷贝构造</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>初始化成员列表</strong>使用时机</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">ClassName</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b): <span class="hljs-built_in">property1</span>(a), <span class="hljs-built_in">property2</span>(b) &#123;&#125;<br><span class="hljs-function">ClassName <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">8</span>)</span></span>;<span class="hljs-comment">// 创建对象时进行的初始化: property1=2; property2=8;</span><br></code></pre></td></tr></table></figure><ul><li>某个属性为引用(为其赋初值)</li><li>某个属性被 <code>const</code> 修饰(为其赋初值)</li><li>某个属性是其他类的对象(为了构造对象)</li></ul></li></ol><h3 id="1-5-友元"><a href="#1-5-友元" class="headerlink" title="1.5 友元"></a>1.5 友元</h3><ol><li>友元作用: 让函数或者类可以访问另一个类中的私有成员<ul><li>实现: 将类 &#x2F; 函数声明语句置于需要被访问私有成员的类中(无需权限修饰符)</li><li><strong>友元理论上提高程序的运行效率(因为无需进行类型检查,安全检查).但破坏了封装性</strong></li><li>示例: 全局函数做友元<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span> &#123;<br><span class="hljs-comment">/* 声明全局函数 good_guy 是 Building 类的友元 */</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">good_guy</span><span class="hljs-params">(Building * building)</span></span>;<br><span class="hljs-keyword">public</span>:<span class="hljs-built_in">Building</span>() &#123; <span class="hljs-keyword">this</span>-&gt;bed_room = <span class="hljs-string">&quot;卧室&quot;</span>; &#125;<br><span class="hljs-keyword">private</span>: string bed_room; <span class="hljs-comment">// 卧室</span><br>&#125;;<br><br><span class="hljs-comment">/* 全局函数 good_guy 可以访问 Building 类的私有成员 bed_room */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">good_guy</span><span class="hljs-params">(Building * building)</span> </span>&#123;<br>cout &lt;&lt; building-&gt;bed_room &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>友元类: 友元类的所有方法均可访问其私有成员<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>;<br></code></pre></td></tr></table></figure><ul><li>友元关系不能继承.即友元类的子类不是友元类</li><li>友元关系是单向的.即反向的友元关系需要在另一类中手动声明</li><li>友元关系不具有传递性.即友元的友元不是友元</li></ul></li><li>友元函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">ClassName::func</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><ul><li>友元函数没有 <code>this</code> 指针</li><li>两个类需要共享数据时,可以将一个类的方法作为另一个类的友元函数</li></ul></li></ol><h3 id="1-6-运算符重载"><a href="#1-6-运算符重载" class="headerlink" title="1.6 运算符重载"></a>1.6 运算符重载</h3><ol><li><p>运算符重载</p><ul><li>对已有的运算符重定义,赋予其另一种功能 以适应不同的数据类型</li><li><strong>对于内置的数据类型的表达式,运算符含义不可改变,不要滥用运算符重载</strong></li><li>可以重载的运算符<table><thead><tr><th>类别</th><th>符号</th></tr></thead><tbody><tr><td>单目运算符</td><td>+(正), -(负), *(取值), &amp;(取址), ++, –</td></tr><tr><td>算术运算符</td><td><code>+, -, *, /, %</code></td></tr><tr><td>关系运算符</td><td><code>==, !=, &lt;, &gt;, &lt;=, &gt;=</code></td></tr><tr><td>逻辑运算符</td><td>&#96;</td></tr><tr><td>位运算符</td><td>&#96;</td></tr><tr><td>赋值运算符</td><td>&#96;&#x3D;, +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D;, %&#x3D;,</td></tr><tr><td>空间申请释放</td><td><code>new, delete, new[], delete[]</code></td></tr><tr><td>其他</td><td><code>()</code>(函数调用)  <code>,</code>(逗号)  <code>[]</code>(下标)</td></tr></tbody></table></li><li>不可重载的运算符<ul><li><code>.</code>(成员访问)  <code>-&gt;</code>(成员访问)  <code>::</code>(域访问)</li><li><code>sizeof</code>(长度计算)  <code>:?</code>(条件运算)  <code>#</code>(预处理)</li></ul></li></ul></li><li><p><code>+</code> 运算符重载</p><ul><li>示例: 对自定义的数据类型相加运算</li><li>实现方式: <strong>将成员 &#x2F; 全局函数名改为 <code>operator+</code> 即可重载 <code>+</code> 运算符</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">ClassName <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> ClassName&amp; p) &#123;<br>    ClassName temp;<br>    temp.property1 = <span class="hljs-keyword">this</span>-&gt;property1 + p.property1;<br>    temp.property2 = <span class="hljs-keyword">this</span>-&gt;property2 + p.property2;<br>    <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回加法运行后的结果(对象)</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>&lt;&lt;</code> 运算符重载</p><ul><li>示例: 输出自定义的数据类型</li><li>只能用全局函数重载 <code>&lt;&lt;</code>(可在类中加上 <code>friend</code> 通过友元函数实现访问私有成员)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// &lt;&lt; 运算符的参数为: out 以及 p 对象的引用</span><br><span class="hljs-comment">// 返回: ostream 类的引用,便于链式编程</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, ClassName&amp; p) &#123;<br>out &lt;&lt; p.property1 &lt;&lt; p.property2; <span class="hljs-comment">// 输出对象的属性</span><br><span class="hljs-keyword">return</span> out;<span class="hljs-comment">// out 是 ostream 对象</span><br>&#125;<br><span class="hljs-comment">// 本质上调用方式为 operator&lt;&lt;(cout, p) 被编译器简化为 cout &lt;&lt; p</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>++</code> 运算符重载</p><ul><li>示例: 通过重载递增运算符,实现自己的整型数据</li><li>前置递增返回引用,后置递增返回值</li><li>前置 <code>++</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">ClassName&amp; <span class="hljs-keyword">operator</span>++() &#123; <span class="hljs-comment">// 前置++ 返回计算后的引用</span><br>property++;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">// 操作后返回自身.可链式调用</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>后置 <code>++</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 参数列表的 int 为占位符(且只能为 int),表示这是后置++</span><br>ClassName <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>ClassName temp = *<span class="hljs-keyword">this</span>;<span class="hljs-comment">// 用临时对象存储初始对象</span><br>property++;<br><span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回操作后记录的对象.该实现不可链式调用</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>=</code> 运算符重载</p><ul><li>如果类中有属性指向堆区,做赋值操作时也会(拷贝构造也会)出现深浅拷贝问题</li><li>编译器在进行对象之间的赋值时,会进行浅拷贝.即单纯的值拷贝<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">ClassName&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ClassName &amp;p) &#123;  <span class="hljs-comment">// 编译器默认提供浅拷贝实现</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;p)  <span class="hljs-comment">// 处理自赋值</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">if</span> (ptr != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">delete</span> ptr;  <span class="hljs-comment">// 释放自身原本就有的指针成员变量</span><br>        ptr = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 释放后指向空指针</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (p.ptr != <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 解引用指针前保证不为空</span><br>        ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.ptr);  <span class="hljs-comment">// 深拷贝逻辑</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回自身.可链式调用</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>关系运算符重载: 让两个自定义类型对象进行对比操作</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> ClassName&amp; p) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;property == p.property) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br>    <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> ClassName&amp; p) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;property == p.property) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>    <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br>&#125;<br><span class="hljs-comment">// 类似的可以重载 &lt;, &gt;, &lt;=, &gt;=</span><br></code></pre></td></tr></table></figure></li><li><p>函数调用运算符重载: <code>()</code> 重载后使用的方式类似函数的调用,因此称为<strong>仿函数</strong></p></li></ol><h3 id="1-7-继承"><a href="#1-7-继承" class="headerlink" title="1.7 继承"></a>1.7 继承</h3><ol><li><p>使用继承减少重复的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> 子类名: 继承方式 父类名 &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>继承方式(注意三种方式中,子类均无法访问父类 private 成员)</p><table><thead><tr><th>继承方式</th><th>关键字</th><th>特点</th></tr></thead><tbody><tr><td>公共继承</td><td><code>public</code></td><td>除私有成员,其他原封不动地继承</td></tr><tr><td>保护继承</td><td><code>protected</code></td><td>父类 <code>public, protected</code> 成员均继承为 <code>protected</code> 成员</td></tr><tr><td>私有继承</td><td><code>private</code></td><td>父类 <code>public, protected</code> 成员均继承为 <code>private</code> 成员</td></tr></tbody></table><ul><li><strong>父类中所有非静态成员变量(静态成员仍会共享)都会被继承,包括私有成员</strong></li><li><strong>编译器隐藏了父类的私有成员,子类不可访问)</strong></li></ul></li><li><p>父类和子类的构造,析构顺序</p><ul><li><strong>先调用父类构造函数,再调用子类构造函数</strong></li><li>析构顺序与构造顺序相反.先析构子类对象,再析构父类对象</li></ul></li><li><p>继承时子类与父类同名成员处理</p><ul><li>访问子类同名成员: 直接访问.即对象优先访问本类的成员</li><li>访问父类同名成员: 需要加作用域 <code>p.FatherClass::property</code></li><li><strong>当子类与父类拥有同名的成员函数,子类会隐藏父类中所有同名成员函数(包括重载)</strong></li><li><strong>当发生函数隐藏时,子类对象需要加上作用域则可以访问到父类中同名函数</strong></li></ul></li><li><p>多继承: C++ 允许一个类继承多个类(若父类间出现了同名情况,子类访问其成员时要加作用域)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> 子类名: 继承方式 父类<span class="hljs-number">1</span> ,继承方式 父类<span class="hljs-number">2.</span>.. &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>菱形继承: 两个派生类继承同一个基类,而后某个类同时继承这两个派生类</p><ul><li>子类继承两份相同的数据,导致资源浪费以及毫无意义</li><li>利用虚继承(在继承方式前加上  <code>virtual</code> 关键字)可以解决菱形继承浪费资源问题</li></ul></li></ol><h3 id="1-8-虚函数"><a href="#1-8-虚函数" class="headerlink" title="1.8 虚函数"></a>1.8 虚函数</h3><ol><li><p><strong>虚函数目的: 通过父类对象指针(指向子类)访问子类定义的函数</strong></p><ul><li>函数最前面加上 <code>virtual</code> 关键字即成为虚函数</li><li><strong>函数重写: 子类对父类(允许访问的)虚函数的实现过程进行重新编写(形参必须完全一致)</strong></li><li>父类对象指针(指向子类)调用虚函数时,会优先寻找子类是否重写了该方法并调用</li><li><code>override</code> 关键字可以显式的声明该方法是对父类方法的重写</li></ul></li><li><p>纯虚函数</p><ul><li><p>在动态多态中,通常父类中虚函数的实现是毫无意义的</p></li><li><p><strong>调用的都是子类重写的内容.因此可以直接将父类的虚函数改为纯虚函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">virtual</span> 返回值类型 函数名(参数列表) = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>抽象类: 有纯虚函数的类</strong></p><ul><li>抽象类无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数,否则也属于抽象类</li></ul></li><li><p>虚析构</p><ul><li><strong>使用多态时,若父类没有将析构声明为虚析构,将导致析构时仅调用父类析构函数</strong></li><li>若此时子类中有属性开辟到堆区时,没有进行释放,从而导致内存泄露</li><li>解决方式: 将父类中的析构函数改为虚析构或者纯虚析构</li><li>注意: 若子类没有堆区数据待释放,则不需要虚析构函数</li></ul></li><li><p>虚析构和纯虚析构</p><ul><li>均可以通过父类指针释放子类对象</li><li><strong>纯虚析构不仅要声明,还必须有具体的函数实现.否则编译报错</strong></li></ul></li><li><p>虚函数表: 记录虚函数地址</p><ul><li>虚函数指针(vfptr, virtual function pointer): 指向虚函数表</li><li>当子类重写父类的虚函数时,子类的虚函数表存储的函数指针被替换重写函数的地址</li><li><strong>当父类引用子类对象时,调用虚函数会在子类的虚函数表中查找.实现多态</strong></li></ul></li></ol><h3 id="1-9-多态"><a href="#1-9-多态" class="headerlink" title="1.9 多态"></a>1.9 多态</h3><ol><li>多态分为: 静态 &#x2F; 动态<ul><li><strong>静态多态: 父类成员隐藏, 函数重载, 运算符重载, 泛型编程</strong></li><li><strong>动态多态: 子类重写方法和虚函数实现运行时多态</strong></li><li>静态多态的函数地址早绑定: 编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定: 运行阶段确定函数地址</li></ul></li><li>动态多态需满足条件<ul><li>存在继承关系</li><li>子类重写父类中的虚函数</li><li>父类指针(或引用)指向子类的对象</li></ul></li><li>多态案例: 分别利用普通方式和多态方式,实现对两个操作数进行运算的计算器类<ul><li><p>普通方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">(string oper)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;+&quot;</span>) &#123;<span class="hljs-keyword">return</span> num1 + num2;&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;-&quot;</span>) &#123;<span class="hljs-keyword">return</span> num1 - num2;&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;*&quot;</span>) &#123;<span class="hljs-keyword">return</span> num1 * num2;&#125;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> num1;<br><span class="hljs-type">int</span> num2;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>多态方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCalculator</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> num1;<br><span class="hljs-type">int</span> num2;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddCalculator</span>: <span class="hljs-keyword">public</span> AbstractCalculator<br>&#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> num1 + num2;&#125; &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubCalculator</span>: <span class="hljs-keyword">public</span> AbstractCalculator<br>&#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> num1 - num2;&#125; &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulCalculator</span>: <span class="hljs-keyword">public</span> AbstractCalculator<br>&#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> num1 * num2;&#125; &#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="2-现代-C"><a href="#2-现代-C" class="headerlink" title="2 现代 C++"></a>2 现代 C++</h2><h3 id="2-1-类型推断"><a href="#2-1-类型推断" class="headerlink" title="2.1 类型推断"></a>2.1 类型推断</h3><ol><li><p>用于范围 <code>for</code> 循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">/* 拷贝元素(修改 v 不会影响原容器) */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : vec) &#123;<br>    v *= <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">/* 使用引用.避免拷贝,可直接修改元素 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v : vec) &#123;<br>    v *= <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">/* 使用常量引用.避免拷贝,且禁止修改 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;v : vec) &#123;<br>    std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>推断函数返回类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* C++14 编译器推导返回类型为 int */</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">/* 可以接受任何支持 + 操作的类型 */</span><br><span class="hljs-keyword">auto</span> adder = [](<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>结构化绑定: 声明多个变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, std::string&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>)</span></span>;<br><br><span class="hljs-comment">/* 传统方式 */</span><br><span class="hljs-type">int</span> id_old = p.first;<br>std::string name_old = p.second;<br><br><span class="hljs-comment">/* C++17 结构化绑定 */</span><br><span class="hljs-keyword">auto</span> [id, name] = p; <span class="hljs-comment">// id 是 int, name 是 std::string</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-智能指针"><a href="#2-2-智能指针" class="headerlink" title="2.2 智能指针"></a>2.2 智能指针</h3><ol><li><p><strong>RAII(Resource Acquisition Is Initialization): 资源请求即初始化</strong></p><ul><li><p>c++ 特有的资源管理方式.依托于栈和析构函数,对资源进行管理.也是异常安全的管理方式</p></li><li><p>资源在对象初始化时申请,当弹栈时会调用析构函数释放资源</p></li></ul></li><li><p>智能指针基本原理即通过 RAII 实现对内存进行管理</p><ul><li>智能指针会对被引用对象进行计数.新增引用+1,释放时-1.为零时将其释放</li><li>智能指针支持裸指针的所有操作.如 <code>*, ++, --, +=, &lt;, &gt;</code></li><li>C++11 引入 <code>shared_ptr, uniptr_ptr, weak_ptr</code> 三种智能指针,应对不同场景</li><li>智能指针重载了 <code>*  -&gt;  []</code> 运算符,使得它们的使用与裸指针类似</li></ul></li><li><p>标准库在 <code>&lt;memory&gt;</code> 头文件中提供了三种主要的智能指针</p><table><thead><tr><th align="left">智能指针</th><th align="left">所有权模型</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left"><code>std::unique_ptr</code></td><td align="left">独占所有权</td><td align="left">资源只能被一个指针拥有.轻量, 高效, 默认选择</td></tr><tr><td align="left"><code>std::shared_ptr</code></td><td align="left">共享所有权</td><td align="left">资源可以被多个指针共享.通过引用计数管理</td></tr><tr><td align="left"><code>std::weak_ptr</code></td><td align="left">弱引用</td><td align="left">不增加引用计数.与 <code>shared_ptr</code> 配合使用,解决循环引用问题</td></tr></tbody></table></li><li><p><code>std::unique_ptr</code> 独占其所指对象的所有权.没有拷贝语义(拷贝构造和赋值函数).可移动(<code>std::move</code> 转移所有权)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">m_value</span>(value) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; m_value &lt;&lt; std::endl; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_value;<br>&#125;;<br><br><span class="hljs-comment">/* 创建并使用 unique_ptr */</span><br><span class="hljs-keyword">auto</span> u1 = std::<span class="hljs-built_in">make_unique</span>&lt;MyClass&gt;(<span class="hljs-number">100</span>);<br>u1-&gt;<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 输出 100</span><br><br><span class="hljs-comment">/* 可以移动但不能拷贝 */</span><br><span class="hljs-comment">// std::unique_ptr&lt;int&gt; u2 = u1; // 错误.不能拷贝</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; u2 = std::<span class="hljs-built_in">move</span>(u1); <span class="hljs-comment">// 正确.所有权从 u1 转移到 u2. u1 变为 nullptr</span><br><br><span class="hljs-comment">/* 手动释放资源 */</span><br>u<span class="hljs-number">2.</span><span class="hljs-built_in">reset</span>();                  <span class="hljs-comment">// 与 u2 = nullptr 效果相同</span><br><span class="hljs-type">int</span>* raw_ptr = u<span class="hljs-number">2.</span><span class="hljs-built_in">release</span>(); <span class="hljs-comment">// 释放所有权,并返回原始指针.u2 变为 nullptr</span><br><span class="hljs-keyword">delete</span> raw_ptr;              <span class="hljs-comment">// 注意对象并不会被释放,而是需要自己管理</span><br></code></pre></td></tr></table></figure></li><li><p><code>std::shared_ptr</code> 通过引用计数机制实现共享所有权.拥有拷贝语义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 创建 shared_ptr */</span><br><span class="hljs-keyword">auto</span> s1 = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2024</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;s1 use count: &quot;</span> &lt;&lt; s<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 1</span><br><br><span class="hljs-comment">/* 模拟代码块作用域的使用 */</span><br>&#123;<br>    std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; s2 = s1; <span class="hljs-comment">// 拷贝.引用计数+1</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s1 use count: &quot;</span> &lt;&lt; s<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出 2</span><br>    *s2 = <span class="hljs-number">100</span>;<br>    std::cout &lt;&lt; *s1 &lt;&lt; std::endl; <span class="hljs-comment">// 输出 100，s1 和 s2 指向同一对象</span><br>&#125; <span class="hljs-comment">// s2 离开作用域.被销毁,引用计数-1</span><br></code></pre></td></tr></table></figure></li><li><p><code>std::weak_ptr</code> 不增加引用计数,即不拥有对象所有权.目的是解决 <code>shared_ptr</code> 循环引用问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 创建 weak_ptr.引用计数不变 */</span><br><span class="hljs-keyword">auto</span> shared = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">99</span>);<br>std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; weak = shared;<br><br><span class="hljs-comment">/* 要使用 weak_ptr.必须将其转换为 shared_ptr */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> temp_shared = weak.<span class="hljs-built_in">lock</span>()) &#123; <span class="hljs-comment">// 如果对象还存在.lock() 返回一个有效的 shared_ptr</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; *temp_shared &lt;&lt; std::endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Object has been destroyed&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>shared.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">// 释放资源.引用计数变为0</span><br><br><span class="hljs-comment">/* 释放后再次检查 */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> temp_shared = weak.<span class="hljs-built_in">lock</span>()) &#123;<br>    <span class="hljs-comment">// 不会执行到这里</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Object has been destroyed&quot;</span> &lt;&lt; std::endl; <span class="hljs-comment">// 这里会执行</span><br>&#125;<br><span class="hljs-comment">// 也可以使用 weak.expired() 来检查对象是否已被销毁</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-移动语义"><a href="#2-3-移动语义" class="headerlink" title="2.3 移动语义"></a>2.3 移动语义</h3><ol><li><p>如何将一个冰箱里的大象放入另一个冰箱</p><ul><li>拷贝复制: 将冰箱1的大象复制,然后放入冰箱2,最后让冰箱1原本的大象消失</li><li>移动: 打开冰箱,移动大象,关上冰箱</li></ul></li><li><p>C++11 之前只有复制语义(通过析构函数, 拷贝构造函数, 赋值函数)</p><ul><li>对于对象的非指针,非引用的行为都会使用复制语义</li><li>在拥有内存对象的资源中,需要定义这三个函数,并实现深拷贝</li><li>在一些场景中,对象拷贝后就立即被销毁.此时使用移动而非拷贝对象可提高性能</li></ul></li><li><p>左值与右值</p><ul><li>左值: 可以对其取址</li><li>右值: 不能取址,只能取值.通常位于赋值号右侧</li><li>将亡值: 如函数返回时的临时对象, 非引用的形参, 将被移动的对象</li></ul></li><li><p>右值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> &amp;&amp;r = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 右值引用.使用 &amp;&amp; 可以引用字面量</span><br></code></pre></td></tr></table></figure><ul><li>返回左值的对象: 返回左值引用的函数, 赋值, 下标, 解引用, 前置递增&#x2F;递减</li><li>返回右值的对象(会产生临时变量): 返回非引用类型的函数, 算术, 关系, 位, 后置递增&#x2F;递减</li><li>左值引用不能引用右值(因为右值不能改变.但 const 左值引用可以指向右值)</li></ul></li><li><p>移动语义: 从源对象窃取资源,而非拷贝资源.源对象不再拥有资源</p></li><li><p><strong>支持移动语义的对象需要定义移动构造函数和移动赋值函数(形参为右值引用)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 相较于 const 左值引用.右值可直接修改对象成员</span><br><span class="hljs-built_in">ClassName</span>(ClassName&amp;&amp; t) <span class="hljs-keyword">noexcept</span> &#123;&#125;  <span class="hljs-comment">// 移动构造函数</span><br>ClassName&amp; <span class="hljs-keyword">operator</span>=(ClassName&amp;&amp; t) <span class="hljs-keyword">noexcept</span> &#123;&#125;  <span class="hljs-comment">// 移动赋值函数</span><br></code></pre></td></tr></table></figure><ul><li>将对象中的资源移走,而非赋值.因此不分配内存</li><li>移动后的源对象因为是右值引用会被销毁.因此内部资源被置为无效</li><li>必须声明为 <code>noexcept</code>.因为若移动时抛出异常会导致源对象资源被破坏</li></ul></li><li><p>编译器有条件的提供默认移动操作(不要依赖编译器,最好自己实现)</p><ul><li>类中没有自定义拷贝控制成员(析构函数, 拷贝构造函数, 赋值函数)</li><li>所有的数据成员都能移动构造或移动赋值</li></ul></li><li><p><code>std::move</code>: 将左值转换为右值引用,其本身不产生移动操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string s = <span class="hljs-string">&quot;abc&quot;</span>;<br>std::string &amp;&amp;s1 = std::<span class="hljs-built_in">move</span>(s);  <span class="hljs-comment">// s1 是对 s 的右值引用</span><br>std::cout &lt;&lt; s.<span class="hljs-built_in">c_str</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 abc.说明并未发生移动语义</span><br><span class="hljs-function">std::string <span class="hljs-title">ss</span><span class="hljs-params">(std::move(s))</span></span>;  <span class="hljs-comment">// 将右值引用传入构造函数,触发移动构造函数</span><br><span class="hljs-comment">// 在移动语义发生后,不应再使用源对象</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-chrono-库"><a href="#2-4-chrono-库" class="headerlink" title="2.4 chrono 库"></a>2.4 chrono 库</h3><ol><li><p>时间处理的需求</p><ul><li>获取当前时间.如记录日志,精确到毫秒</li><li>计算时间间隔.如计算代码块的运行时长</li><li>获取日期,进行换算</li><li>定时器(chrono 不支持)</li></ul></li><li><p>chrono: C++11 提供的跨平台,强类型的时间日期处理库.使用前需要包含头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>clock</code>: 时钟.使用时间点(time point)与间隔(duration)的方式确定当前时间</p><ul><li><p><code>system_clock</code>: 系统时间.原点时间为 UNIX 1970-01-01 00:00::00 UTC</p><ul><li><p>拥有三个静态方法: <code>now, to_time, from_time_c</code></p></li><li><p>不稳定性: 如果修改了系统时间,将会导致 <code>system_clock</code> 变化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> timePoint = std::chrono::system_clock::<span class="hljs-built_in">now</span>();  <span class="hljs-comment">// 先获取当前时间</span><br><span class="hljs-keyword">auto</span> duration = timePoint.<span class="hljs-built_in">time_since_epoch</span>();  <span class="hljs-comment">// 转为时间间隔</span><br>std::cout &lt;&lt; duration.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 17370304141602793</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>steady_clock</code>: 处理器 tick 时间.原点时间为机器启动的时刻</p><ul><li>拥有 <code>now</code> 静态方法.一般用于度量时间间隔</li><li>稳定性: <code>now</code> 方法确保返回值不小于上次调用的返回值(就算修改系统时间也是)</li></ul></li><li><p><code>high_resolution_clock</code>: 当前系统支持的最高精度.使用场景和用法与 <code>steady_clock</code> 一致</p></li></ul></li><li><p><code>duration</code>: 时间间隔</p><ul><li><p>比率(<code>std::ratio</code>)模板类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">intmax_t</span> Num, std::<span class="hljs-type">intmax_t</span> Denom = <span class="hljs-number">1</span>&gt; <span class="hljs-keyword">class</span> ratio &#123;&#125;<br><span class="hljs-comment">// Num: 分子</span><br><span class="hljs-comment">// Denom: 分母.不可为零,不可为最小的负数.且已经约分到最简</span><br></code></pre></td></tr></table></figure></li><li><p>Duration 模板类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Rep</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Period</span> = ratio&lt;<span class="hljs-number">1</span>&gt; &gt; <span class="hljs-keyword">class</span> duration &#123;&#125;<br><span class="hljs-comment">// Period: 精度.如 ratio&lt;1&gt; 为秒, ratio&lt;1, 1000&gt; 为毫秒</span><br><span class="hljs-comment">// duration 支持算术运算符和比较运算符</span><br></code></pre></td></tr></table></figure></li><li><p><code>system_clock, steady_clock, high_resolution_clock</code> 各自拥有精度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::chrono::system_clock::period::num;  <span class="hljs-comment">// 分子默认为 1</span><br>std::chrono::system_clock::period::den;  <span class="hljs-comment">// 分母代表精度. 10e7</span><br></code></pre></td></tr></table></figure></li><li><p>预定义的基本时间单元</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> nanoseconds  = duration&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, nano&gt;;   <span class="hljs-comment">// 纳秒</span><br><span class="hljs-keyword">using</span> microseconds = duration&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, micro&gt;;  <span class="hljs-comment">// 微秒</span><br><span class="hljs-keyword">using</span> milliseconds = duration&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, milli&gt;;  <span class="hljs-comment">// 毫秒</span><br><span class="hljs-keyword">using</span> seconds      = duration&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;;<br><span class="hljs-keyword">using</span> minutes      = duration&lt;<span class="hljs-type">int</span>, ratio&lt;<span class="hljs-number">60</span>&gt;&gt;;<br><span class="hljs-keyword">using</span> hours        = duration&lt;<span class="hljs-type">int</span>, ratio&lt;<span class="hljs-number">3600</span>&gt;&gt;;<br></code></pre></td></tr></table></figure></li><li><p>自定义时间单元</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> std::chrono::duration&lt;<span class="hljs-type">long</span>, std::ratio&lt;<span class="hljs-number">1</span>, <span class="hljs-number">25</span>&gt;&gt; FrameRate;  <span class="hljs-comment">// 25帧率</span><br><span class="hljs-built_in">Frame</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 3帧的时间间隔 1/25*3 = 120ms</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>time point</code>: 时间点模板类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Duration</span>=<span class="hljs-keyword">typename</span> Clock::duration&gt; <span class="hljs-keyword">class</span> time_point &#123;&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-模板"><a href="#3-模板" class="headerlink" title="3 模板"></a>3 模板</h2><h3 id="3-1-函数模板"><a href="#3-1-函数模板" class="headerlink" title="3.1 函数模板"></a>3.1 函数模板</h3><ol><li><p><strong>函数模板: 对类型进行参数化(建立通用函数,其返回值类型和形参类型可以不具体指定,用虚拟类型来代表)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-comment">// 函数模板声明</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> </span>&#123;<br>T temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">my_swap</span>(a, b);       <span class="hljs-comment">// 自动进行类型推导</span><br><span class="hljs-built_in">my_swap</span>&lt;<span class="hljs-type">int</span>&gt;(a, b); <span class="hljs-comment">// 显式地指定类型.此时 T 被明确指定为 int</span><br></code></pre></td></tr></table></figure><ul><li><p><code>template</code>: 声明创建模板</p></li><li><p><code>typename</code>: 声明后面的符号是一种数据类型,也可以用 <code>class</code> 代替</p></li><li><p><code>T</code>: 通用的数据类型.名称可以替换,通常大写</p></li></ul></li><li><p>函数模板使用要求</p><ul><li>自动类型推导,必须推导出一致的数据类型 <code>T</code>,才可使用</li><li>模板必须要确定出 <code>T</code> 的数据类型,才可使用</li></ul></li><li><p><strong>普通函数与函数模板的区别</strong></p><ul><li>类型转换<ul><li>普通函数调用时,可以发生自动类型转换(隐式类型转换)</li><li>函数模板进行自动类型推导时,不会发生隐式类型转换(显式指定类型时,则可以)</li></ul></li><li>调用规则<ul><li><strong>若函数模板和普通函数都可以调用,则优先调用普通函数</strong></li><li>可以通过空模板参数列表来强制调用函数模板.即 <code>&lt;&gt;</code> 里为空</li><li>如果函数模板可以产生更好的匹配,则优先调用函数模板</li></ul></li></ul></li><li><p>模板的重载</p><ul><li>为这些特定的类型提供具体化的模板.调用时,具体化参数的函数模板优先于更广泛的模板<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-type">bool</span> <span class="hljs-title">my_compare</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> </span>&#123;&#125;<br><span class="hljs-comment">/* 模板的重载(Person 是具体的数据类型). 开头的 template&lt;&gt; 声明是模板 */</span><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">my_compare</span><span class="hljs-params">(Person &amp;p1, Person &amp;p2)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li>利用具体化的模板,可以解决自定义类型的通用化</li><li><strong>学习模板并不是为了写模板,而是在 STL 能够运用系统提供的模板</strong></li></ul></li></ol><h3 id="3-2-类模板"><a href="#3-2-类模板" class="headerlink" title="3.2 类模板"></a>3.2 类模板</h3><ol><li><p><strong>类模板作用: 建立通用类.类中成员的数据类型可不具体指定,用虚拟的类型来代表</strong></p></li><li><p>类模板和函数模板语法相似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span> = <span class="hljs-type">int</span>&gt;  <span class="hljs-comment">// 类模板声明</span><br><span class="hljs-keyword">class</span> Person &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(T1 name, T2 age) &#123;<br><span class="hljs-keyword">this</span>-&gt;name = name;<br><span class="hljs-keyword">this</span>-&gt;age = age;<br>&#125;<br><br>T1 name;<br>T2 age;<br>&#125;;<br><br><span class="hljs-comment">// 创建对象.此时 string -&gt; T1, int -&gt; T2</span><br>Person&lt;string, <span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure></li><li><p>类模板和函数模板的区别</p><ul><li><strong>类模板不能自动类型推导,必须显式指定</strong></li><li>类模板在模板参数列表中可以有默认参数(写在声明的地方)</li></ul></li><li><p><strong>类模板中的成员函数在调用时才创建(区别于普通方法在编译时即可创建)</strong></p><ul><li>因此类模板的分文件编写会导致链接阶段失败</li><li>解决方法: 将声明和实现写到同一个文件中,并更改后缀名为 <code>.hpp</code></li></ul></li><li><p>类模板对象做为函数参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 1. 指定传入的类型 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Person&lt;string, <span class="hljs-type">int</span>&gt;&amp; p)</span></span>;  <span class="hljs-comment">// 显式指定模板对象的数据类型</span><br><br><span class="hljs-comment">/* 2. 参数模板化 */</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;   <span class="hljs-comment">// 将函数改为函数模板</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Person&lt;T1, T2&gt;&amp; p)</span></span>;  <span class="hljs-comment">// 模板对象中的参数以虚拟类型进行传递</span><br><br><span class="hljs-comment">/* 3. 整个类模板化 */</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T&amp; p)</span></span>;  <span class="hljs-comment">// 将对象类型模板化进行传递</span><br></code></pre></td></tr></table></figure></li><li><p>类模板与继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 当子类继承类模板时.声明时要指定出父类中 T 的类型(若不指定,编译器无法给子类分配内存) */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>: <span class="hljs-keyword">public</span> Person&lt;string, <span class="hljs-type">int</span>&gt; &#123;&#125;;<br><br><span class="hljs-comment">/* 如果想灵活指定出父类中 T 的类型,子类也需变为类模板 */</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>: <span class="hljs-keyword">public</span> Person&lt;T1, T2&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure></li><li><p>类模板成员函数的类外实现,需要加上模板参数列表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 类内声明 */</span><br><span class="hljs-built_in">Person</span>(T1 name, T2 age);<br><span class="hljs-comment">/* 类外实现 */</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>&gt;<br>Person&lt;T1, T2&gt;::<span class="hljs-built_in">Person</span>(T1 name, T2 age) &#123;&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-3-STL"><a href="#3-3-STL" class="headerlink" title="3.3 STL"></a>3.3 STL</h3><ol><li><p>STL(Standard Template Library,标准模板库)</p><ul><li><strong>STL 从广义上分为: 容器(container), 算法(algorithm), 迭代器(iterator)</strong></li><li>容器和算法之间通过迭代器进行无缝连接</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul></li><li><p>STL 组件</p><ul><li><strong>容器</strong>: 各种数据结构,如 <code>vector, list, deque, set, map...</code></li><li><strong>算法</strong>: 各种常用的算法,如 <code>sort, find, copy, for_each...</code></li><li><strong>迭代器</strong>: 容器与算法之间的胶合剂</li><li><strong>仿函数</strong>: 行为类似函数,可作为算法的某种策略</li><li><strong>适配器</strong>: 修饰容器, 仿函数, 迭代器接口</li><li><strong>空间配置器</strong>: 负责空间的配置与管理</li></ul></li><li><p><strong>容器: 存放数据的地方</strong></p><ul><li>序列式容器: 强调排序.每个元素有固定的位置</li><li>关联式容器: 二叉树结构.各元素之间没有严格的物理上的顺序关系</li></ul></li><li><p><strong>算法: 解决问题的有限步骤</strong></p><ul><li><p>质变算法: 运算过程中会更改区间内的元素的内容. 如拷贝, 替换, 删除…</p></li><li><p>非质变算法: 运算过程中不会更改区间内的元素内容. 如查找, 计数, 遍历, 寻找极值…</p></li><li><p>STL 算法主要包含于头文件 <code>&lt;algorithm&gt;, &lt;functional&gt;, &lt;numeric&gt;</code></p><ul><li><code>&lt;algorithm&gt;</code> 是 STL 中最大的一个.涉及比较, 交换, 查找, 遍历操作, 复制, 修改…</li><li><code>&lt;numeric&gt;</code> 体积很小,只包括几个在序列上面进行的简单数学运算的模板函数</li><li><code>&lt;functional&gt;</code> 定义了一些模板类,用于声明函数对象</li></ul></li></ul></li><li><p><strong>迭代器: 容器和算法之间粘合剂</strong></p><ul><li><p>能够依序寻访某个容器的元素,又无需暴露该容器的内部表示方式</p></li><li><p>每个容器都有自己专属的迭代器.算法通过迭代器访问容器的元素</p></li><li><p>迭代器使用非常类似于指针,初学阶段可以先理解迭代器为指针</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读. 支持 ++, &#x3D;&#x3D;, !&#x3D;</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写. 支持 ++</td></tr><tr><td>前向迭代器</td><td>读写操作,并能向前推进迭代器</td><td>读写. 支持 ++, &#x3D;&#x3D;, !&#x3D;</td></tr><tr><td>双向迭代器</td><td>读写操作,并能向前和向后操作</td><td>读写. 支持 ++, –</td></tr><tr><td>随机访问迭代器</td><td>读写操作,可以以跳跃的方式访问任意数据</td><td>读写. 支持 ++, –, [n], -n, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;</td></tr></tbody></table></li><li><p><strong>常用的容器中迭代器种类为双向迭代器, 随机访问迭代器</strong></p></li></ul></li></ol><h3 id="3-4-函数对象"><a href="#3-4-函数对象" class="headerlink" title="3.4 函数对象"></a>3.4 函数对象</h3><ol><li><p><strong>函数对象</strong>: 重载了函数调用操作符 <code>()</code>的类对象.也称仿函数</p><ul><li>函数对象在使用时.可像普通函数那样调用: 有参数,有返回值</li><li>函数对象超出普通函数的概念: 可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul></li><li><p><strong>谓词</strong>: 返回 <code>bool</code> 类型的仿函数.接受一 &#x2F; 二个参数,称为一 &#x2F; 二元谓词</p></li><li><p><strong>STL 内建的函数对象: 算术仿函数, 关系仿函数, 逻辑仿函数</strong></p><ul><li><p>需要内建函数对象需要包含头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>这些仿函数所产生的对象,用法和普通函数完全相同.函数原型形如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T plus&lt;T&gt;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>算术仿函数实现四则运算(<code>+ - * / %</code>)</p><ul><li><p>对应的仿函数名称为: <code>plus, minus, multiplies, divides, modulus</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">plus&lt;<span class="hljs-type">int</span>&gt; p;  <span class="hljs-comment">// 加法仿函数.虽然是二元运算,但要求两者类型相同,仍只需一个类型标识</span><br><span class="hljs-built_in">p</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">// 结果为 30</span><br></code></pre></td></tr></table></figure></li><li><p>另外,还有 <code>negate</code> 是一元运算,表示取负</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">negate&lt;<span class="hljs-type">int</span>&gt; neg;  <span class="hljs-comment">// 取负仿函数</span><br><span class="hljs-built_in">neg</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 结果为 -10</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>关系仿函数实现比较运算(<code>= != &gt; &gt;= &lt; &lt;=</code>)</p><ul><li><p>对应的仿函数名称为: <code>equal_to, not_equal_to, greater, greater_equal, less, less_equal</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-comment">// sort 算法可以使用仿函数指定排序规则.默认升序排列 less&lt;&gt;()</span><br><span class="hljs-comment">// greater&lt;int&gt;() 是匿名对象,实现降序排列</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>逻辑仿函数实现逻辑运算(<code>&amp;&amp; || !</code>).对应的仿函数名称为: <code>logical_and, logical_or, logical_not</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>计算机</tag>
      
      <tag>Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2023/06/02/Tool/Git/"/>
    <url>/2023/06/02/Tool/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1-Git"><a href="#1-Git" class="headerlink" title="1 Git"></a>1 <a href="https://www.bilibili.com/video/BV1HM411377j/?spm_id_from=333.1387.favlist.content.click">Git</a></h2><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><ol><li><p>git 安装</p><ul><li><p>在 <a href="https://git-scm.com/download">git 官网</a> 下载对应系统的安装包.一直下一步安装即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git --version  <span class="hljs-comment"># 验证安装</span><br></code></pre></td></tr></table></figure></li><li><p>在 Windows 中,会自动安装 <code>Git Bash</code>(在文件夹中右键即可看到)</p></li></ul></li><li><p>git 的使用方式分为</p><ul><li>命令行(最基本,最常见)</li><li>图形化界面(GUI)</li><li>IDE 插件&#x2F;扩展(推荐使用 VS Code 中的 git 插件)</li></ul></li><li><p>初始化操作</p><ul><li><p><strong>git 的所有命令均以 git 开头,后面再接具体的命令.如: <code>git init</code> 表示初始化仓库</strong></p></li><li><p>git 安装后需要进行配置用户名和邮箱,以便查看代码提交者(只需设置一次)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;user&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;email&quot;</span><br>git config --list  <span class="hljs-comment"># 检查配置是否成功</span><br></code></pre></td></tr></table></figure></li><li><p>使用 vim 作为默认编辑器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global core.editor &quot;vim&quot;<br></code></pre></td></tr></table></figure></li><li><p>如果用户名参数包含空格,则需要使用双引号包裹</p></li><li><p><code>--global</code> 表示全局配置,对所有仓库有效.如果省略则表示本地配置,只对本地仓库有效</p></li></ul></li><li><p>新建仓库</p><ul><li><p>仓库 &#x2F; 版本库(Repository, 简称 Reop): 是一个文件目录,其中的文件被 git 管理</p></li><li><p>对仓库中文件的 修改, 删除, 添加操作都将被 git 追踪</p></li><li><p><strong>本地创建仓库</strong>: 此时 git 将会创建一个 <code>.git</code> 的隐藏目录.用于存放仓库的数据(不要自己更改其中的内容)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure></li><li><p><strong>从服务器克隆仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> url<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-2-概念"><a href="#1-2-概念" class="headerlink" title="1.2 概念"></a>1.2 概念</h3><ol><li><p>工作区域</p><ul><li><p><strong>工作目录(Working Directory)</strong>: 实际操作的目录</p></li><li><p><strong>暂存区(Staging Area&#x2F;Index)</strong>: 临时存储区域.保存即将提交到 git 仓库的修改内容</p></li><li><p><strong>本地仓库(Local Repository)</strong>: 存储代码和版本信息的主要位置.包含完整的项目历史和元数据</p><p><img src="/2023/06/02/Tool/Git/1-Git-workingArea.png"></p></li></ul></li><li><p>提交流程</p><ul><li><p>在对工作目录的文件进行修改后,需要先提交到暂存区,然后将暂存区的修改提交到本地仓库</p></li><li><p>在上述过程中,可以使用 git 命令进行查看, 比较, 撤销修改</p></li><li><p><strong>添加(git add): 从工作目录 -&gt; 暂存区</strong></p></li><li><p><strong>提交(git commit): 从暂存区 -&gt; 本地仓库</strong></p></li><li><p>在多次添加到暂存区后,到达需要增加版本的地步,就可以进行提交(push)</p></li></ul></li><li><p>文件状态</p><ul><li><p><strong>未跟踪(Untrack)</strong>: 新创建的,未被 git 管理的文件</p></li><li><p><strong>未修改(Unmodified)</strong>: 已经被 git 管理,但内容没有变化</p></li><li><p><strong>已修改(Modified)</strong>: 修改了文件,但未添加到暂存区</p></li><li><p><strong>已暂存(Staged)</strong>: 修改后,并添加到暂存区的文件</p><p><img src="/2023/06/02/Tool/Git/1-Git-fileState.png"></p></li></ul></li></ol><h3 id="1-3-提交"><a href="#1-3-提交" class="headerlink" title="1.3 提交"></a>1.3 提交</h3><ol><li><p>查看状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log    # 查看提交记录.包含: 提交 ID, 作者, 时间, 备注信息<br>git status # 查看目录中的文件的状态<br></code></pre></td></tr></table></figure></li><li><p><strong>添加: 将指定的文件添加到暂存区(会排除 <code>.gitignore</code> 中匹配的文件)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add &lt;filename&gt; # 添加指定文件(无论是修改, 新建, 删除均使用 add 暂存)<br>git add .          # 添加当前目录及其所有子目录下的所有新文件和已修改文件<br></code></pre></td></tr></table></figure></li><li><p><strong>提交: 将暂存区中的修改提交到本地仓库(注意不会提交工作目录的文件)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m &quot;message&quot; # 提交并直接在命令行中提供提交信息的标题<br>git commit --amend      # 修改提交信息 或 添加遗漏的文件<br></code></pre></td></tr></table></figure></li><li><p>放弃修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --&lt;mode&gt; &lt;commit&gt;<br></code></pre></td></tr></table></figure><p><img src="/2023/06/02/Tool/Git/1-Git-Reset.png"></p><ul><li><p><strong><code>git reset</code> 本质上是移动当前分支所指向的提交(即 <code>HEAD</code> 指针)到指定的历史提交</strong></p><table><thead><tr><th>mode 参数</th><th>效果</th></tr></thead><tbody><tr><td><code>soft</code></td><td>自 <code>&lt;commit&gt;</code> 后的提交在提交历史中暂时消失(可以通过 <code>git relog</code> 找回).<br />之前提交的所有修改(相对于 <code>&lt;commit&gt;</code> 的改动)都变成了 <strong>已暂存的更改</strong>.<br />不影响暂存区,也不影响工作目录</td></tr><tr><td><code>mixed</code>(默认参数)</td><td>自 <code>&lt;commit&gt;</code> 后的提交在提交历史中暂时消失.<br />之前提交的所有修改(相对于 <code>&lt;commit&gt;</code> 的改动)都变成了 <strong>未暂存的更改</strong>.<br />重置暂存区,但不影响工作目录</td></tr><tr><td><code>hard</code>(极其危险)</td><td>自 <code>&lt;commit&gt;</code> 以来的所有后续提交在提交历史中暂时消失.<br />暂存区被清空,工作目录中所有未提交(包括未暂存和已暂存)的更改都会被永久丢弃</td></tr></tbody></table></li><li><p><code>commit</code> 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset a1b2c3d # 提交的哈希值.通常只需要前 7 个字符就足够唯一标识<br>git reset main    # 分支名.表示重置到该分支当前指向的提交<br>git reset v1.0    # 标签名.表示重置到该标签指向的提交<br>git reset HEAD    # 表示当前提交<br>git reset HEAD~n  # 表示当前提交的第 n 个提交<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>soft</code> 最佳实践: 多次 <code>commit</code> 后,想要将其合并为一次 <code>commit</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --soft &lt;commit&gt; # 先回退到修改前的 commit,此时所有的改动都回到暂存区<br>git add                   # 如果存在遗漏继续添加,否则不需要该步骤<br>git commit -m &quot;message&quot;   # 再次提交,此时先前的多个提交变成一次提交<br></code></pre></td></tr></table></figure></li><li><p><code>mixed</code> 最佳实践: 提交了不需要的东西,想撤销这些提交,但工作目录中实际修改的代码仍需保留</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset HEAD~1 # 撤销最新一次 commit.但提交的修改以未暂存的状态保留到工作目录<br>git reset file   # 撤销特定文件的 add.但保留文件在工作目录的修改<br></code></pre></td></tr></table></figure></li><li><p><code>hard</code> 最佳实践: 确保不需要工作目录和暂存区中未提交的修改情况下使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard HEAD # 丢弃所有未提交修改<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-4-差异"><a href="#1-4-差异" class="headerlink" title="1.4 差异"></a>1.4 差异</h3><ol><li><p><strong>查看差异</strong>: 后续可以使用 IDE 更美观地查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff           <span class="hljs-comment"># 工作目录 vs 暂存区</span><br>git diff HEAD      <span class="hljs-comment"># 工作目录 + 暂存区 vs 本地仓库</span><br>git diff --cached  <span class="hljs-comment"># 暂存区 vs 本地仓库</span><br>git diff --staged  <span class="hljs-comment"># 暂存区 vs 本地仓库</span><br><br>git diff &lt;commit_hash&gt; &lt;commit_hash&gt;  <span class="hljs-comment"># 比较指定两次提交的差异</span><br>git diff HEAD~ HEAD                   <span class="hljs-comment"># 上一次提交 vs 本地仓库</span><br>git diff &lt;branch_hash&gt; &lt;branch_hash&gt;  <span class="hljs-comment"># 比较两个分支的差异</span><br></code></pre></td></tr></table></figure><p><img src="/2023/06/02/Tool/Git/1-Git-diff.png"></p></li><li><p><strong>删除文件</strong>: 删除工作目录和暂存区中的指定文件.但版本库不变</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> &lt;filename&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>忽略文件</strong>: 通过 <code>.gitignore</code> 文件来指定忽略特定的文件</p><p><img src="/2023/06/02/Tool/Git/1-Gitignore.png"></p><ul><li>新建一个 <code>.gitignore</code> 文件,在其中存储想要被忽略的文件名</li><li>会从上往下逐行匹配,每行表示一个忽略模式</li></ul></li><li><p><strong><code>.gitignore</code> 匹配规则: 使用标准的 Blob 模式匹配</strong></p><ul><li>文件可以使用通配符.如 <code>*.log</code> 表示忽略所有后缀为 log 的文件</li><li>文件夹需要以 <code>/</code> 结尾</li><li>以 <code>#</code> 开头的行表示注释</li></ul></li></ol><h3 id="1-5-分支"><a href="#1-5-分支" class="headerlink" title="1.5 分支"></a>1.5 分支</h3><ol><li><p><strong>分支(Branch): 代码的不同版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch           # 查看分支信息.结果中 * 表示当前所处的分支<br>git branch &lt;name&gt;    # 创建新分支.创建新分支后并不会自动切换分支<br>git branch -d &lt;name&gt; # 删除指定的已合并分支(安全删除,因为必须已合并到其他分支才能被删除)<br>git switch &lt;name&gt;    # 切换分支.同时工作目录的文件会被自动替换为目标分支的状态<br>git merge &lt;name&gt;     # 将指定分支合并到当前分支.该指令会执行一次提交,因此需要输入提交信息<br>git log --graph --oneline --decorate --all # 查看分支图<br></code></pre></td></tr></table></figure></li><li><p>合并冲突</p><ul><li><strong>当合并分支时,出现同一文件被不同分支修改时,会出现冲突,需要手动解决冲突</strong></li><li>此时,使用 <code>git status</code> 命令查看冲突文件的列表.<code>git diff</code> 可以查看冲突的具体内容</li></ul></li><li><p>变基(Rebase)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rebase main # 将当前分支变基到 main 分支<br></code></pre></td></tr></table></figure><ul><li>每个分支都有一个 <code>HEAD</code> 指针,指向当前分支的最新提交记录</li><li>当执行变基时,将寻找两个分支的共同的祖先节点</li><li>然后将当前分支的祖先节点之后的提交移植到目标分支的后面</li><li>变基使得分支始终保持简单的线性结构.但破坏了原分支的提交记录.不要在公共分支 <code>rebase</code></li><li>分支合并不会破坏提交记录,方便回溯.但产生了额外的节点</li></ul></li></ol><h3 id="1-6-暂存"><a href="#1-6-暂存" class="headerlink" title="1.6 暂存"></a>1.6 暂存</h3><ol><li><p><strong>暂存(Stash): 临时保存工作目录和暂存区的修改.可以快速切换上下文而不需要提交未完成的工作</strong></p><ul><li><code>stash</code> 默认管理的对象<ul><li>已追踪的修改(工作目录中)</li><li>已暂存的文件</li></ul></li><li><code>stash</code> 默认不管理的对象<ul><li>未追踪的文件(新创建的文件)</li><li>被 <code>.gitignore</code> 忽略的文件</li></ul></li></ul></li><li><p>基础保存功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">git stash                 # 保存当前修改到新 stash(默认消息)<br>git stash save &quot;message&quot;  # 保存并添加自定义消息<br><br>git stash list            # 查看所有 stash 列表<br><br>git stash pop             # 恢复最新 stash 并删除<br>git stash pop stash@&#123;2&#125;   # 恢复特定 stash<br><br>git stash apply           # 恢复 stash,但不删除<br>git stash apply stash@&#123;1&#125; # 恢复特定 stash,但不删除<br></code></pre></td></tr></table></figure></li><li><p>包含未追踪的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git stash -u  # 包含未跟踪文件(新文件)<br>git stash -a  # 包含所有文件(包括被忽略的文件)<br></code></pre></td></tr></table></figure></li><li><p>查看暂存信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git stash show stash@&#123;0&#125;     # 查看 stash 简略信息<br>git stash show -p stash@&#123;0&#125;  # 查看详细 diff 内容<br>git stash show -u stash@&#123;0&#125;  # 查看包含未跟踪文件的信息<br></code></pre></td></tr></table></figure></li><li><p>管理 <code>stash</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git stash push -m &quot;message&quot;  # 创建带描述的新 stash<br>git stash push file1 file2   # 选择性 stash 部分文件<br>git stash drop stash@&#123;1&#125;     # 删除特定 stash<br>git stash clear              # 清空所有 stash<br></code></pre></td></tr></table></figure></li><li><p>分支操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git stash branch new-branch-name stash@&#123;0&#125;  # 在新分支上应用 stash<br>git log --oneline stash@&#123;0&#125;  # 检查 stash 创建时的提交状态<br></code></pre></td></tr></table></figure></li><li><p>最佳实践: 测试其他分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git stash push -am &quot;message&quot; # 将本地所有的修改暂存<br>git switch other-branch      # 切换到其他进行工作<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进行测试工作...</span><br>git switch original-branch   # 工作完成后切换回来<br>git stash pop                # 将暂存恢复<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-7-最佳实践"><a href="#1-7-最佳实践" class="headerlink" title="1.7 最佳实践"></a>1.7 最佳实践</h3><ol><li><p>保证 <code>master</code> 分支中的代码是可发布的.不允许直接修改,只能合并,每当合并时生成一个版本号</p><p><img src="/2023/06/02/Tool/Git/1-Git-GitHubFlow.png"></p></li><li><p>case1: 接到开发 cpu 的需求,开发完成后 push</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">git switch &lt;main&gt;                   # 1.确保在待开发的分支上.以 main 分支为例<br>git pull origin &lt;main&gt;              # 2.确保更新到最新版本<br>git switch -c &lt;feature/cpu-test&gt;    # 3.创建 cpu 开发分支<br><br>git add .                           # 4.进行开发工作.修改文件,添加功能等<br>git commit -m &quot;update cpu&quot;          # 5.测试完成后在本地提交<br><br>git switch &lt;main&gt;                   # 6.完成对 cpu 的开发后,返回 main 分支<br>git pull origin &lt;main&gt;              # 7.再次更新 main 分支到最新.如果存在冲突需手动解决<br>git merge --squash feature/cpu-test # 8.将 cpu 分支的所有变更压缩成一个提交合并到 main 分支<br>git commit -m &quot;complete cpu test&quot;   # 9.提交到本地 main 分支<br>git push origin main                # 10.推送到远程仓库<br></code></pre></td></tr></table></figure></li><li><p>case2: 在上面开发 cpu 的第 4 或 5 步时可能接收到紧急任务,如需要开发 gpu 驱动.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">git stash push -u -m &quot;cpu developing&quot; # 1. 暂存所有未提交的修改(包括已跟踪和未跟踪文件)<br>git stash list                        # 2. 验证暂存列表<br>git switch &lt;main&gt;                     # 3. 切换到 main 分支<br>git pull origin &lt;main&gt;                # 4. 确保更新到最新版本<br>git switch -c &lt;feature/gpu-test&gt;      # 5. 创建并切换到干净的 gpu 开发分支<br><br>git add drivers/gpu/                  # 6.模拟本地对文件的修改<br>git commit -m &quot;update gpu&quot;            # 7.测试完成后在本地提交<br>git switch &lt;main&gt;                     # 8.完成对 gpu 的开发后,返回 main 分支<br>git pull origin &lt;main&gt;                # 9.更新 main 分支到最新<br>git merge --squash feature/gpu-test   # 10.将 gpu 分支的所有变更压缩成一个提交合并到 main 分支<br>git commit -m &quot;complete cpu test&quot;     # 11.提交到本地 main 分支<br>git push origin main                  # 12.推送到远程仓库<br>git branch -d feature/gpu-test        # 13.删除已合并的本地 gpu 开发分支<br><br>git switch feature/cpu-test           # 14.回到 cpu 开发分支,继续开发<br>git stash pop                         # 15.恢复工作现场<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-GitHub-Pages"><a href="#2-GitHub-Pages" class="headerlink" title="2 GitHub Pages"></a>2 GitHub Pages</h2><h3 id="2-1-关联-github"><a href="#2-1-关联-github" class="headerlink" title="2.1 关联 github"></a>2.1 关联 github</h3><ol><li><p><a href="https://github.com/">github</a>: 代码托管平台</p><ul><li><p>要关联本地仓库与远程仓库,首先需要设置 SSH 密钥</p></li><li><p>检查主机是否已经存在 ssh key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls ~/.ssh/id_rsa.pub  # 查看是否已经生成过密钥 id_rsa(私钥) id_rsa.pub(公钥)<br>cat ~/.ssh/id_rsa.pub # 查看生成的密钥(复制输出的内容.以 ssh-rsa AAA... 开头)<br></code></pre></td></tr></table></figure></li><li><p>如果没有 ssh key.则需要先生成(如果有 ssh key.则直接获取)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~/.ssh                 # 切换到.ssh目录<br>ssh-keygen -t rsa -b 4096 # 生成 rsa 密钥,大小为 4096<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在 GitHub 账号中添加公钥</p><ul><li><p>回到 GitHub,点击头像 -&gt; <code>Settings</code> -&gt; <code>SSH and GPG keys</code> -&gt; <code>New SSH key</code></p><p><img src="/2023/06/02/Tool/Git/1-Git-github-sshkey.png"></p></li><li><p>将 <code>id_rsa.pub</code> 文件中的内容复制到 Key 中即可</p></li><li><p>验证设置是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br><span class="hljs-meta prompt_"># </span><span class="language-bash">成功将显示: Hi Fxs21! You<span class="hljs-string">&#x27;ve successfully authenticated...</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>完成 SSH 的设置后,可以直接使用 SSH 进行 <code>git clone</code> 操作</p></li><li><p>本地仓库和远程仓库是不同的仓库.想要将两者的文件同步.需要 <code>git pull, git push</code> 指令</p><p><img src="/2023/06/02/Tool/Git/1-Git-push.png"></p></li><li><p>此时,完成了关联本地仓库与远程仓库的准备工作</p></li><li><p>在 github 上创建一个新仓库.然后进行操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add &lt;shortname&gt; &lt;url&gt; # 将本地仓库关联到远程仓库.同时创建了远程库的别名<br>git remote -v # 查看当前仓库对应的远程仓库的别名和地址(默认 shortname == origin)<br>git branch -M main # 指定分支名为 main<br>git push -u origin main # 将本地的 main 分支与远程仓库 origin 的 main 分支关联.并推送<br>git pull # 拉取远程仓库中的分支.默认为 origin 的 main 分支<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-创建-pages"><a href="#2-2-创建-pages" class="headerlink" title="2.2 创建 pages"></a>2.2 创建 pages</h3><ol start="2"><li><p>创建仓库: 名称格式为 <code>username.github.io</code></p><p><img src="/2023/06/02/Tool/Git/1-Git-githubCreateRepo.png"></p></li><li><p>在 <code>settings</code> 中找到 <code>Pages</code>.此时 <code>Source</code> 为空.因此需要上传静态页面</p></li><li><p>拉取代码到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone git@github.com:Fxs21/Fxs21.github.io.git<br></code></pre></td></tr></table></figure></li><li><p>上传代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加 git@github.com:Fxs21/Fxs21.github.io.git 远程仓库. 别名为 origin</span><br>git remote add origin git@github.com:Fxs21/Fxs21.github.io.git<br><br>git remote -v             # 检查是否已经添加了远程仓库<br>ssh -T git@github.com     # 测试 SSH 连接<br>git push -u origin master # 提交代码.并建立本地分支与远程分支的跟踪关系<br>git pull                  # 等同于 git pull origin master<br></code></pre></td></tr></table></figure></li><li><p>此时再次进入 github. 在 <code>settings</code> 中找到 <code>Pages</code>.此时 <code>Source</code> 就有了 <code>master</code> 分支</p><p><img src="/2023/06/02/Tool/Git/2-Git-githubSource.png"></p></li><li><p>显示 Your site is live at <a href="https://fxs21.github.io/">https://fxs21.github.io/</a>: 表示成功部署可以在网页中打开</p></li></ol><h2 id="3-hexo"><a href="#3-hexo" class="headerlink" title="3 hexo"></a>3 hexo</h2><h3 id="3-1-hexo-环境"><a href="#3-1-hexo-环境" class="headerlink" title="3.1 hexo 环境"></a>3.1 <a href="https://hexo.io/zh-cn/">hexo</a> 环境</h3><ol><li><p>安装 git 并配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;fxs&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;yshuang68@163.com&quot;</span><br>git config --list<br></code></pre></td></tr></table></figure></li><li><p>安装 NodeJS: <a href="https://nodejs.org/en">官网下载</a>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">node -v  # 验证安装<br>npm config set prefix &quot;D:\code\npm_path&quot;  # 配置 npm 的全局安装路径<br></code></pre></td></tr></table></figure></li><li><p>安装 <code>hexo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g  <span class="hljs-comment"># 安装 hexo</span><br>hexo -v                  <span class="hljs-comment"># 验证安装</span><br></code></pre></td></tr></table></figure></li><li><p>初始化 <code>hexo</code>(新建一个空目录,然后使用 <code>git bash</code> 打开)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init  <span class="hljs-comment"># 从 github 拉取代码</span><br>git init   <span class="hljs-comment"># 初始化 git 仓库</span><br></code></pre></td></tr></table></figure></li><li><p><code>hexo</code> 的 hello world</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s<br></code></pre></td></tr></table></figure></li><li><p>打开网址 <a href="http://localhost:4000/">http://localhost:4000/</a>. 能看到 hello world 网页表示配置成功</p></li></ol><p>  <img src="/2023/06/02/Tool/Git/3-hexo-hello-world.png"></p><h3 id="3-2-hexo-部署"><a href="#3-2-hexo-部署" class="headerlink" title="3.2 hexo 部署"></a>3.2 hexo 部署</h3><ol><li><p>配置 SSH 免密登录</p><ul><li><p>先检查是否已经生成过密钥(<code>PowerShell </code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls ~/.ssh/id_rsa.pub  # 查看是否已经生成过密钥 id_rsa(私钥) id_rsa.pub(公钥)<br>cat ~/.ssh/id_rsa.pub # 查看生成的密钥(复制输出的内容.以 ssh-rsa AAA... 开头)<br></code></pre></td></tr></table></figure></li><li><p>若没有生成过则生成密钥(默认保存路径为 <code>C:\Users\你的用户名\.ssh\id_rsa</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -b 4096<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在 GitHub 上添加公钥(参考 [2.1章](# 2.1 关联 github))</p></li><li><p>安装部署插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li><li><p>配置 hexo 上传的地址(打开 <code>_config.yml</code> 文件,在最后添加内容.<strong>注意这里的配置决定了仓库地址</strong>)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">&#x27;git&#x27;</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:Fxs21/Fxs21.github.io.git</span><br></code></pre></td></tr></table></figure></li><li><p>使用 hexo 命令将代码部署到远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl <span class="hljs-comment"># 清除文件</span><br>hexo g  <span class="hljs-comment"># 生成静态文件.路径为 ./public/</span><br>hexo d  <span class="hljs-comment"># 上传到服务器</span><br></code></pre></td></tr></table></figure></li><li><p>对于调试不需要生成静态文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo cl &amp;&amp; hexo s<br></code></pre></td></tr></table></figure></li><li><p>hexo 文章按照 <code>date</code> 字段(建立日期)排序.下面是 Windows 中修改创建日期的指令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">(<span class="hljs-built_in">Get-Item</span> <span class="hljs-string">&quot;文件路径&quot;</span>).CreationTime = <span class="hljs-string">&quot;新时间&quot;</span>  <span class="hljs-comment"># 修改单个文件的创建时间</span><br>(<span class="hljs-built_in">Get-Item</span> <span class="hljs-string">&quot;文件路径&quot;</span>).CreationTime.ToString(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>) <span class="hljs-comment"># 查看创建时间</span><br><br><span class="hljs-comment"># 示例: 将 D:\blog\post.md 创建时间设为 2023-01-01 12:00</span><br>(<span class="hljs-built_in">Get-Item</span> <span class="hljs-string">&quot;D:\blog\post.md&quot;</span>).CreationTime = <span class="hljs-string">&quot;2023-01-01 12:00&quot;</span><br><br><span class="hljs-comment"># 批量修改文件夹内所有文件</span><br><span class="hljs-built_in">Get-ChildItem</span> <span class="hljs-string">&quot;文件夹路径&quot;</span> | <span class="hljs-built_in">ForEach-Object</span> &#123; <span class="hljs-variable">$_</span>.CreationTime = <span class="hljs-string">&quot;新时间&quot;</span> &#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-3-hexo-配置"><a href="#3-3-hexo-配置" class="headerlink" title="3.3 hexo 配置"></a>3.3 hexo 配置</h3><ol><li><p><strong>更换主题</strong>: 在 <a href="https://hexo.io/themes/">Themes | Hexo</a> 选择合适的主题.这里以 <code>Fluid</code> 为例,根据 <a href="https://github.com/fluid-dev/hexo-theme-fluid">参考文档</a> 安装</p><ul><li><p>安装 <code>Fluid</code> 主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure></li><li><p>在博客目录下创建 <code>_config.fluid.yml</code> 文件</p></li><li><p>将 <code>./node_modules/hexo-theme-fluid/_config.yml</code> 的内容复制到 <code>_config.fluid.yml</code> 文件</p></li><li><p>更改默认的主题: 打开 <code>_config.yml</code> 文件,修改 <code>theme, language</code> 项</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>     <span class="hljs-comment"># 指定主题</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CH</span>  <span class="hljs-comment"># 指定语言</span><br></code></pre></td></tr></table></figure></li><li><p>创建关于页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about<br></code></pre></td></tr></table></figure></li><li><p>在 <code>./source/about/index.md</code> 文件中添加一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">layout: about<br></code></pre></td></tr></table></figure></li></ul></li><li><p>工作目录(初始化之后的目录)</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br><span class="hljs-string">|   ├── _drafts</span><br><span class="hljs-string">|   └── _posts</span><br>└── themes<br></code></pre></td></tr></table></figure><ul><li><strong><code>_config.yml</code>: 网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 文件.可以在此配置大部分的参数</strong></li><li><code>package.json</code>: 应用程序的信息. <a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> 渲染引擎 已默认安装</li><li><code>scaffolds</code>: 模板文件夹.新建文章时根据此文件创建</li><li><strong><code>source</code>: 存放用户资源</strong><ul><li>除 <code>_posts</code> 文件夹之外,开头命名为 <code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略</li><li>Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹,而其他文件会被拷贝过去</li></ul></li><li><code>themes</code>: 主题文件夹.Hexo 会根据主题来生成静态页面</li></ul></li><li><p><strong>站点配置</strong>: Hexo 博客目录下的 <code>_config.yml</code> 文件</p><ul><li><p>站点名称</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Shuang</span> <span class="hljs-string">blog</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">&#x27;Shuang blog&#x27;</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;Shuang blog&#x27;</span><br><span class="hljs-attr">keywords:</span> <span class="hljs-string">Shuang</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">Shuang</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">&#x27;Asia/Shuanghai&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>资源文件夹</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ul><li>启用后,资源图片将会被自动解析为其对应文章的路径</li><li>如: <code>image.jpg</code> 位置为 <code>/2020/01/02/foo/image.jpg</code>.表示是 <code>/2020/01/02/foo/</code> 文章的一张图片</li><li><code>![](image.jpg)</code> 将会被解析为 <code>&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt;</code></li></ul></li></ul></li></ol><h3 id="3-4-Fluid-主题"><a href="#3-4-Fluid-主题" class="headerlink" title="3.4 Fluid  主题"></a>3.4 <a href="https://hexo.fluid-dev.com/docs/start/">Fluid </a> 主题</h3><ol><li><p>配置文件的修改</p><ul><li><strong>主题配置</strong>: <code>theme/fluid/_config.yml</code> 或者 <code>_config.fluid.yml</code> 文件</li></ul></li><li><p>Fluid 主题默认总体概览</p><p><img src="/2023/06/02/Tool/Git/3-fluid-appearance.png"></p></li><li><p>主题字体</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 主题字体配置</span><br><span class="hljs-attr">font:</span><br>  <span class="hljs-attr">font_size:</span> <span class="hljs-string">16px</span><br>  <span class="hljs-attr">font_family:</span> <span class="hljs-string">consolas</span>  <span class="hljs-comment"># 使用 consolas 字体</span><br>  <span class="hljs-attr">letter_spacing:</span> <span class="hljs-number">0.</span><span class="hljs-string">02em</span><br>  <span class="hljs-attr">code_font_size:</span> <span class="hljs-number">85</span><span class="hljs-string">%</span><br></code></pre></td></tr></table></figure></li><li><p>导航栏左侧标题(默认为 <code>Fluid</code>)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">blog_title:</span> <span class="hljs-string">&quot;windsand&quot;</span>  <span class="hljs-comment"># 将会以文本的形式显示</span><br></code></pre></td></tr></table></figure></li><li><p>首页背景图以及 slogan 文本</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">index:</span><br>  <span class="hljs-comment"># 首页 Banner 头图,可以是相对路径或绝对路径,以下相同</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/train.png</span>  <span class="hljs-comment"># 首页背景图.注意要自己存放图片资源到路径</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">100</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br>  <span class="hljs-comment"># 首页副标题的独立设置</span><br>  <span class="hljs-attr">slogan:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">text:</span> <span class="hljs-string">&quot;人生如逆旅,我亦是行人&quot;</span>  <span class="hljs-comment"># 首页 slogan</span><br></code></pre></td></tr></table></figure></li><li><p>文章页背景图(归档页, 分类页, 标签页, 关于页, 自定义页, 404 页, 友链页 同理)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/train.png</span>  <span class="hljs-comment"># 与上面的首页背景图配置方法相同</span><br></code></pre></td></tr></table></figure></li><li><p>文章内数学公式</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">math:</span><br>  <span class="hljs-comment"># 开启后文章默认可用,自定义页面如需使用,需在 Front-matter 中指定 math: true</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>   <br>  <span class="hljs-comment"># 开启后,只有在文章 Front-matter 里指定 math: true 才会在文章页启动公式转换</span><br>  <span class="hljs-comment"># 以便在页面不包含公式时提高加载速度</span><br>  <span class="hljs-attr">specific:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-5-文章属性"><a href="#3-5-文章属性" class="headerlink" title="3.5 文章属性"></a>3.5 文章属性</h3><ol><li><p>以本文为例,在 <code>front-matter</code> 中编写内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">typora-root-url:</span> <span class="hljs-string">./Git</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Git</span> <span class="hljs-string">使用</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Git</span>, <span class="hljs-string">工具箱</span>, <span class="hljs-string">笔记</span>, <span class="hljs-string">Code</span>]<br><span class="hljs-attr">categories:</span> <span class="hljs-string">工具箱</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">|</span><br><span class="hljs-string">  - Git 的使用方式介绍;</span><br><span class="hljs-string">  - GitHub Pages 页面的配置方法;</span><br><span class="hljs-string">  - 在 IDE 中使用 Git;</span><br><span class="hljs-string">  - hexo 的安装使用;</span><br><span class="hljs-string">  * typora 的配置;</span><br><span class="hljs-string">  * MarkDown 语法.</span><br><span class="hljs-string"></span><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/Git.svg</span><br><span class="hljs-attr">math:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><img src="/2023/06/02/Tool/Git/3-Hexo-front-matter.png"></p></li><li><p><code>typora-root-url</code>: typora 中图片的根目录</p></li><li><p><code>title</code>: 文章的标题.将会在主页中显示</p></li><li><p><code>tags</code>: 文章的标签.将会在主页中显示,点击可以跳转.一篇文章可以有多个 tag</p></li><li><p><code>categories</code>: 文章的类别.分类下面可以有多篇文章</p></li><li><p><code>excerpt</code>: 文章的摘要</p></li><li><p><code>index_img</code>: 文章封面图的路径.本示例的路径为 <code>./source/img/Git.svg</code></p></li></ol><h2 id="4-typora"><a href="#4-typora" class="headerlink" title="4 typora"></a>4 typora</h2><h3 id="4-1-typora-配置"><a href="#4-1-typora-配置" class="headerlink" title="4.1 typora 配置"></a>4.1 typora 配置</h3><ol><li><p><strong>为了与 hexo 部署兼容(主要是图片存放路径),对 typora 进行配置</strong></p><ul><li><p>文件 -&gt; 偏好设置 -&gt; 图像 -&gt; 插入图片时 -&gt; 复制到指定路径 <code>./$&#123;filename&#125;</code></p><p><img src="/2023/06/02/Tool/Git/5-typora-image-setting.png"></p></li><li><p>格式 -&gt; 图像 -&gt; 设置图片根目录 -&gt; 将 <code>./$&#123;filename&#125;</code> 目录设置为根目录</p></li></ul></li><li><p>图片命令不要包含中文或空格.否则可能显示异常</p></li><li><p>为了更好的结构化管理,图片命名时前缀加上图片所在的章节</p></li></ol><h3 id="4-2-MarkDown"><a href="#4-2-MarkDown" class="headerlink" title="4.2 MarkDown"></a>4.2 MarkDown</h3><ol><li><p>基础使用</p><ul><li>标题: 使用 <code>#</code> 表示(数量 1~6, 对应 html 的 <code>&lt;h1&gt; ~ &lt;h6&gt;</code>)</li><li>段落: 在文本之间插入空行,即是新段落</li><li>换行: 在行的末尾加上2个空格,然后回车</li><li>字体: 使用 <code>*</code> 包裹为 <em>斜体</em>; 使用 <code>**</code> 包裹为 <strong>粗体</strong>; 使用 <code>***</code> 包裹为 <em><strong>斜粗体</strong></em>; 使用 <code>~~</code> 包裹为 <del>删除线</del></li><li>列表: 使用 <code>*, +, -</code> 进行标记(后面需要空格)</li><li>有序列表: 使用 <code>数字.</code> 进行标记(后面需要空格.数字本身并不重要,渲染时会自动排序)</li><li>图片: 使用 <code>![替代文本](路径)</code> 进行标记(markdown 本身无法处理图片的对齐和大小)</li><li>链接: 使用 <code>[链接文本](url)</code> 进行标记</li><li>代码: 使用 &#96; 包裹进行标记</li><li>代码块: 使用 &#96;&#96;&#96; 包裹进行标记(指定语言名称可以实现高亮)</li><li>引用: 使用 <code>&gt;</code> 进行标记</li><li>分隔线: 使用三个或以上的 <code>*, -, _</code> 进行标记</li><li>转义字符: 使用 <code>\</code> 显示原本用于 markdown 格式的字符</li><li>目录: 使用 <code>[TOC]</code> 或 <code>&lt;!--- TOC ---&gt;</code> 进行标记</li></ul></li><li><p>表格: 使用 <code>|, -</code> 创建表格. 表头与内容行之间使用分隔线.使用 <code>:</code> 指定对齐方式</p><ul><li><p>示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">| 左对齐 | 居中对齐 | 右对齐 |<br>| :----- | :------: | -----: |<br>| 单元格 |  单元格  |  单元格 |<br>| 单元格 |  单元格  |  单元格 |<br></code></pre></td></tr></table></figure></li><li><p>效果</p><table><thead><tr><th align="left">左对齐</th><th align="center">居中对齐</th><th align="right">右对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="center">单元格</td><td align="right">单元格</td></tr><tr><td align="left">单元格</td><td align="center">单元格</td><td align="right">单元格</td></tr></tbody></table></li></ul></li><li><p>任务列表: 使用 <code>[]</code> 比松hi未完成的任务, <code>[x]</code> 表示已完成的任务</p><ul><li><p>示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> [x] 完成文章大纲<br><span class="hljs-bullet">-</span> [ ] 撰写初稿<br><span class="hljs-bullet">-</span> [ ] 校对并发布<br></code></pre></td></tr></table></figure></li><li><p>效果</p><ul><li><input checked="" disabled="" type="checkbox"> 完成文章大纲</li><li><input disabled="" type="checkbox"> 撰写初稿</li><li><input disabled="" type="checkbox"> 校对并发布</li></ul></li></ul></li></ol><h3 id="4-3-数学公式"><a href="#4-3-数学公式" class="headerlink" title="4.3 数学公式"></a>4.3 数学公式</h3><ol><li><p>行内公式: 使用 <code>$</code> 包裹.如 <code>$a^2 + b^2 = c^2$</code> 显示为 $a^2 + b^2 &#x3D; c^2$</p></li><li><p>完整公式: 使用 <code>$$</code> 包裹</p><ul><li><p>示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$$<br>x = \frac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125;<br>$$<br></code></pre></td></tr></table></figure></li><li><p>效果<br>$$<br>x &#x3D; \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}<br>$$</p></li></ul></li><li><p><a href="https://katex.org/docs/support_table.html">常用符号</a></p><table><thead><tr><th>功能</th><th>语法</th><th>示例</th><th>效果</th></tr></thead><tbody><tr><td>分组</td><td><code>&#123; &#125;</code></td><td><code>x^&#123;10&#125;</code></td><td>$x^{10}$</td></tr><tr><td>上标</td><td><code>^</code></td><td><code>x^2</code></td><td>$x^2$</td></tr><tr><td>下标</td><td><code>_</code></td><td><code>a_n</code></td><td>$a_n$</td></tr><tr><td>分式</td><td><code>\frac&#123;分子&#125;&#123;分母&#125;</code></td><td><code>\frac&#123;x&#125;&#123;y+z&#125;</code></td><td>$\frac{x}{y+z}$</td></tr><tr><td>平方根</td><td><code>\sqrt&#123;表达式&#125;</code></td><td><code>\sqrt&#123;2&#125;</code></td><td>$\sqrt{2}$</td></tr><tr><td>无穷大</td><td><code>\infty</code></td><td><code>\infty</code></td><td>$\infty$</td></tr><tr><td>点乘</td><td><code>\cdot</code></td><td><code>x \cdot y</code></td><td>$x \cdot y$</td></tr><tr><td>加减</td><td><code>\pm \mp</code></td><td><code>a \pm b</code></td><td>$a \pm b$</td></tr><tr><td>不等于</td><td><code>\ne</code></td><td><code>a \ne b</code></td><td>$a \ne b$</td></tr><tr><td>约等于</td><td><code>\approx</code></td><td><code>\pi \approx 3.14</code></td><td>$\pi \approx 3.14$</td></tr></tbody></table></li><li><p>大型运算符</p><table><thead><tr><th>功能</th><th>语法</th><th>示例</th><th>效果</th></tr></thead><tbody><tr><td>求和</td><td><code>\sum_&#123;下标&#125;^&#123;上标&#125;</code></td><td><code>\sum_&#123;i=1&#125;^&#123;n&#125; i</code></td><td>$\sum_{i&#x3D;1}^{n} i$</td></tr><tr><td>求积</td><td><code>\int_&#123;下限&#125;^&#123;上限&#125;</code></td><td><code>\int_&#123;0&#125;^&#123;\infty&#125; f(x)dx</code></td><td>$\int_{0}^{\infty} f(x)dx$</td></tr><tr><td>积分</td><td><code>\prod_&#123;下标&#125;^&#123;上标&#125;</code></td><td><code>\prod_&#123;i=1&#125;^&#123;n&#125; i</code></td><td>$\prod_{i&#x3D;1}^{n} i$</td></tr><tr><td>极限</td><td><code>\lim_&#123;变量 \to 值&#125;</code></td><td><code>\lim_&#123;x \to 0&#125; \frac&#123;\sin x&#125;&#123;x&#125;</code></td><td>$\lim_{x \to 0} \frac{\sin x}{x}$</td></tr></tbody></table></li><li><p>矩阵: 使用 <code>matrix</code>(无括号), <code>pmatrix</code>(小括号), <code>bmatrix</code>(方括号), <code>vmatrix</code>(单竖线)环境.用 <code>&amp;</code> 分隔列,用 <code>\\</code> 换行</p><ul><li><p>示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$$<br>\begin&#123;matrix&#125;<br>a &amp; b \\<br>c &amp; d<br>\end&#123;matrix&#125;<br>$$<br></code></pre></td></tr></table></figure></li><li><p>效果<br>$$<br>\begin{matrix}<br>a &amp; b \<br>c &amp; d<br>\end{matrix}<br>$$</p></li></ul></li><li><p>分段函数: 使用 <code>case</code> 环境.用 <code>&amp;</code> 分隔列,用 <code>\\</code> 换行</p><ul><li><p>示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$$<br>n! = <br>\begin&#123;cases&#125;<br><span class="hljs-code">    1 &amp; \text&#123;if &#125; n = 0 \\</span><br><span class="hljs-code">    n \cdot (n-1)! &amp; \text&#123;if &#125; n \geq 1</span><br><span class="hljs-code">\end&#123;cases&#125;</span><br><span class="hljs-code">$$</span><br></code></pre></td></tr></table></figure></li><li><p>效果<br>$$<br>n! &#x3D;<br>\begin{cases}<br>1 &amp; \text{if } n &#x3D; 0 \<br>n \cdot (n-1)! &amp; \text{if } n \geq 1<br>\end{cases}<br>$$</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具箱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Code</tag>
      
      <tag>Git</tag>
      
      <tag>工具箱</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2023/06/01/Tool/Linux/"/>
    <url>/2023/06/01/Tool/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-使用"><a href="#Linux-使用" class="headerlink" title="Linux 使用"></a>Linux 使用</h1><h2 id="0-环境搭建"><a href="#0-环境搭建" class="headerlink" title="0 环境搭建"></a>0 环境搭建</h2><h3 id="0-1-VMware"><a href="#0-1-VMware" class="headerlink" title="0.1 VMware"></a>0.1 VMware</h3><ol><li>Linux 环境搭建目标: 在 Windows 中创建一个虚拟机,然后安装 <code>CentOS</code>(wsl 更方便,搭配 <code>Ubuntu</code>)</li><li>安装 <code>VMware</code><ul><li>先在 BIOS 中开启 <code>虚拟化设备支持</code></li><li>安装只需一直下一步即可</li></ul></li><li>安装 <code>CentOS</code><ul><li>将界面修改为中文: 在快捷方式的目标栏添加 <code> --locale zh_CN</code></li></ul></li><li>如果遇到打开虚拟机就蓝屏: 在 Windows 功能中打开 <code>虚拟机监控程序平台, 虚拟机平台</code></li><li><strong>网络连接模式</strong><ul><li>桥接模式: 虚拟系统可和外部系统通讯,但容易造成 IP 冲突</li><li>NAT 模式: 网络地址转化模式.可和外部系统通讯,而不造成 IP 冲突</li><li>主机模式: 独立的系统.不进行通讯</li></ul></li><li>虚拟机功能<ul><li>克隆: 直接复制文件,系统也是文件,复制文件即可克隆系统</li><li>快照: 保存快照后,可以在快照管理回到之前的状态</li><li>删除和迁移: 与克隆类似,直接操作文件</li></ul></li></ol><h3 id="0-2-远程登陆"><a href="#0-2-远程登陆" class="headerlink" title="0.2 远程登陆"></a>0.2 远程登陆</h3><ol><li><p>Xshell &amp; Xftp 使用(Xshell 用于执行指令.Xftp 用于文件传输)</p><ul><li><p>在 Linux 终端查询 ip 地址(inet 后面即为 ip 地址)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig<br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>Windows 中命令行输入 <code>ping ip</code>,检查是否联通</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ping &lt;ip&gt;<br></code></pre></td></tr></table></figure></li><li><p>进入 Xshell -&gt; 新建会话 -&gt; 主机输入 Linux 的 ip -&gt; 完成</p></li><li><p>双击左侧主机名 -&gt; 接收并保存 -&gt; 输入用户名和密码.即可登录</p></li></ol></li><li><p>ssh 登录(直接在 powershell 中使用)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ssh [用户名]<span class="hljs-selector-tag">@</span>[服务器地址] <span class="hljs-literal">-p</span> [端口号]<br></code></pre></td></tr></table></figure><ul><li>用户名: 远程服务器上的用户名</li><li>服务器地址: ip 地址或域名</li><li>-p 端口号: ssh 服务监听的端口.默认为 <code>22</code></li></ul></li></ol><h3 id="0-3-wsl-安装"><a href="#0-3-wsl-安装" class="headerlink" title="0.3 wsl 安装"></a>0.3 wsl 安装</h3><ol><li><p>先在 BIOS 中开启 <code>虚拟化设备支持</code>(任务管理器中显示 <code>虚拟化已开启</code> 即可)</p><p><img src="/2023/06/01/Tool/Linux/0-Virtualization.png"></p></li><li><p>win + R 输入 <code>control</code> 进入控制面板 -&gt; 程序和功能 -&gt; 启用或关闭 Windows 功能.<br>开启 <code>Virtual Machine Platform</code> 和 <code>适用于 Linux 的 Windos 子系统</code>(完成该步骤后需要重启电脑)</p><p><img src="/2023/06/01/Tool/Linux/0-Windows-feature.png"></p></li><li><p>打开 <code>powershell</code> 执行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--update</span>                <span class="hljs-comment"># 更新 wsl</span><br>wsl <span class="hljs-literal">--version</span>               <span class="hljs-comment"># 检查版本信息</span><br>wsl <span class="hljs-literal">--list</span> <span class="hljs-literal">--online</span>         <span class="hljs-comment"># 列出可以在线安装的版本 </span><br>wsl <span class="hljs-literal">--install</span> Ubuntu<span class="hljs-literal">-24</span>.<span class="hljs-number">04</span>  <span class="hljs-comment"># 安装 Ubuntu 24.04</span><br>wsl                         <span class="hljs-comment"># 启动 wsl.然后根据提示新建用户</span><br></code></pre></td></tr></table></figure></li><li><p>更新 <code>wsl</code> 中的软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/os-release         # 查看发行版信息.Ubuntu 24.04.2 LTS<br>sudo apt update             # 拉取可更新软件列表<br>sudo apt upgrade -y         # 更新所有软件<br></code></pre></td></tr></table></figure></li></ol><h3 id="0-4-wsl-使用"><a href="#0-4-wsl-使用" class="headerlink" title="0.4 wsl 使用"></a>0.4 wsl 使用</h3><ol><li><p>安装 <code>neofetch, htop</code>(非必需)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install neofetch htop  # 安装 neofetch, htop<br>neofetch                        # 运行 neofetch.显示系统信息<br>htop                            # 交互式界面显示系统资源使用情况<br></code></pre></td></tr></table></figure></li><li><p>修改 <code>wsl</code> 主机名(非必需)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">hostname          # 查看主机名<br>vim /etc/wsl.conf # 编辑 wsl 的配置文件<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">增加下面内容.然后退出重启</span><br>[network]<br>hostname = wsl         # 设置你想要的固定主机名<br>generateHosts = false  # 阻止 WSL 自动覆盖 /etc/hosts<br></code></pre></td></tr></table></figure></li><li><p>取消 <code>wsl</code> 的 <code>beep</code>(非必需)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/inputrc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">找到下面的内容,将其取消注释.然后退出重启</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">set</span> bell-style none</span><br></code></pre></td></tr></table></figure></li><li><p>图形界面应用(非必需).以一些图形操作密集的软件为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install gimp blender kdenlive krita -y<br></code></pre></td></tr></table></figure><ul><li>gimp: GNU Image Manipulation Program(GNU 图像处理程序)</li><li>blender: 开源的 3D 建模, 动画, 渲染和视频编辑软件</li><li>kdenlive: 免费开源的非线性视频编辑软件</li><li>krita: 免费开源的专业绘画软件</li></ul></li><li><p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/connect-usb">访问 USB 设备</a></p><ul><li><p>在 Windows 安装 <a href="https://github.com/dorssel/usbipd-win">usbipd-win</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">winget install <span class="hljs-literal">--interactive</span> <span class="hljs-literal">--exact</span> dorssel.usbipd<span class="hljs-literal">-win</span><br></code></pre></td></tr></table></figure></li><li><p>查看 usb 设备</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">usbipd list<br><span class="hljs-comment"># 输出结果形如</span><br><span class="hljs-comment"># Connected:</span><br><span class="hljs-comment"># BUSID  VID:PID    DEVICE                              STATE</span><br><span class="hljs-comment"># 1-1    1a86:55d3  USB-Enhanced-SERIAL CH343 (COM5)    Not shared</span><br></code></pre></td></tr></table></figure></li><li><p>这里需要共享的是 <code>1-1</code> 设备</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">usbipd bind <span class="hljs-literal">--busid</span> <span class="hljs-number">1</span><span class="hljs-literal">-1</span> <span class="hljs-comment"># 需要管理员权限.只需共享一次</span><br></code></pre></td></tr></table></figure></li><li><p>附加 usb 设备到 <code>wsl</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">usbipd attach <span class="hljs-literal">--wsl</span> <span class="hljs-literal">--busid</span> <span class="hljs-number">1</span><span class="hljs-literal">-1</span><br></code></pre></td></tr></table></figure></li><li><p>在 <code>ubuntu</code> 中查看设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsusb<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Bus 001 Device 002: ID 1a86:55d3 QinHeng Electronics USB Single Serial</span><br></code></pre></td></tr></table></figure></li><li><p>断开 usb 设备</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">usbipd detach <span class="hljs-literal">--busid</span> &lt;busid&gt;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-Linux-基础"><a href="#1-Linux-基础" class="headerlink" title="1 Linux 基础"></a>1 Linux 基础</h2><h3 id="1-1-目录结构"><a href="#1-1-目录结构" class="headerlink" title="1.1 目录结构"></a>1.1 目录结构</h3><ol><li><p><strong>Linux 一切皆文件</strong></p><p><img src="/2023/06/01/Tool/Linux/1-Linux-Struct.jpg"></p></li><li><p><code>/</code>: 根目录,包含整个文件系统</p><ul><li><code>/bin</code>: 二进制文件目录.包含一些常用的命令和工具.如 ls, cp, mv…</li><li><code>/sbin</code>: 系统二进制文件目录.包含一些系统管理命令和工具.如 shutdown, reboot…</li><li><code>/boot</code>: 启动目录.包含启动 Linux 系统所需的文件,如内核文件和引导程序</li><li><strong><code>/dev</code>: 设备目录.包含系统中的设备文件.如 硬盘, 光驱, 键盘…</strong></li><li><code>/etc</code>: 配置文件目录.包含系统和应用程序的配置文件.如网络配置, 用户配置…</li><li><strong><code>/home</code>: 用户主目录.包含系统中所有用户的主目录</strong></li><li><code>/lib</code>: 库文件目录.包含系统和应用程序所需的共享库文件</li><li><code>/media</code>: 挂载目录.包含可移动设备的挂载点,如 U盘, 光盘…</li><li><strong><code>/mnt</code>: 挂载目录.包含临时挂载的文件系统</strong></li><li><strong><code>/opt</code>: 可选目录.包含第三方应用程序的安装目录</strong></li><li><code>/proc</code>: 进程目录.包含系统和进程的信息.如 内存使用, CPU使用…</li><li><code>/root</code>: root 用户主目录</li><li><code>/tmp</code>: 临时目录.包含系统和应用程序的临时文件</li><li><code>/usr</code>: 用户程序目录.包含系统和用户安装的应用程序和文件</li><li><code>/var</code>: 可变目录.包含系统和应用程序的可变数据.如日志文件, 缓存文件…</li></ul></li></ol><h3 id="1-2-vim"><a href="#1-2-vim" class="headerlink" title="1.2 vim"></a>1.2 vim</h3><ol><li><p>vim 键盘图</p><p><img src="/2023/06/01/Tool/Linux/1-vi-vim-cheat-sheet-sch.gif"></p></li><li><p>vim 的工作模式: 命令模式, 输入模式, 命令行模式</p><p><img src="/2023/06/01/Tool/Linux/1-vim-vi-workmodel.png"></p></li><li><p>命令模式: 当启动 vi &#x2F; vim 时,默认为命令模式</p><ul><li><kbd>x</kbd>: 删除当前光标所在处的字符</li><li><kbd>G</kbd>: 定位到最后一行, <kbd>gg</kbd> 定位到首行</li><li><strong><kbd>yy</kbd>: 复制当前行,在前面加一个数字可以选定行数,如 5yy</strong></li><li><strong><kbd>dd</kbd>: 剪切当前行,在前面加一个数字可以选定行数,如 3dd</strong></li><li><strong><kbd>p</kbd>: 粘贴复制的内容</strong></li><li><kbd>u</kbd>: 撤销操作</li><li><kbd>Ctrl</kbd><kbd>r</kbd>: 重做上一次的撤销</li><li>定位到指定行: 输入行数然后 <kbd>Shif</kbd><kbd>g</kbd></li></ul></li><li><p>插入模式: 可以直接输入文本</p><ul><li><strong><kbd>ESC</kbd>: 进入命令行模式</strong></li><li><kbd>Page Up</kbd> &#x2F; <kbd>Page Down</kbd>: 上下翻页</li></ul></li><li><p>命令行模式: 保存或退出文件,设置编辑环境</p><ul><li><code>:w</code>: 保存文件</li><li><code>:q</code>: 退出编辑器</li><li><code>:q!</code>: 强制退出,且不保存</li><li><code>:set nu</code>: 显示行号.<code>:set nonu</code>: 隐藏行号. <code>:整数</code>:跳转到某行</li><li><strong><code>/text</code>: 查找文本信息.此时输入 <kbd>n</kbd> 查找下一个. <kbd>N</kbd> 查找下一个</strong></li><li><code>?text</code>: 向上查找文本信息</li></ul></li></ol><h2 id="2-Linux-命令"><a href="#2-Linux-命令" class="headerlink" title="2. Linux 命令"></a>2. Linux 命令</h2><h3 id="2-1-用户"><a href="#2-1-用户" class="headerlink" title="2.1 用户"></a>2.1 用户</h3><ol><li><p>linux 的命令格式为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">command [-options] [parameter]<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">command</span>: 命令名称也可以是 Shell 脚本</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">options: 长格式(man --<span class="hljs-built_in">help</span>) / 短格式(man -h)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">parameter: 通常是命令的指向目标.如文件, 目录等资源</span><br></code></pre></td></tr></table></figure></li><li><p>开 &#x2F; 关机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">shutdown -h now # 立即关机<br>shutdown -h 1   # 1分钟后关机.是 shutdown 的默认形式<br>shutdown -r now # 立即重启<br><br>halt   # 立即关机<br>reboot # 立即重启<br>sync   # 把内存里的数据同步到磁盘(建议在关机前先执行该指令)<br></code></pre></td></tr></table></figure></li><li><p>登录 Linux(一般仅使用普通用户登录,而非 root)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">su &lt;username&gt; # 切换到指定用户<br>logout        # 注销当前登录用户.Ubuntu 使用 exit<br></code></pre></td></tr></table></figure></li><li><p>用户管理(要想使用 Linux 系统资源,需要向管理员申请账号)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd &lt;username&gt; # 添加用户.登陆后将默认进入 /home/username 目录<br>userdel &lt;username&gt; # 删除用户,但保留目录<br>passwd &lt;username&gt;  # 指定 / 修改 用户密码<br>id &lt;username&gt;      # 查询用户信息<br>whoami             # 查看当前登录用户<br></code></pre></td></tr></table></figure></li><li><p>用户组(对具有相似权限的用户分组管理)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupadd &lt;groupname&gt; # 创建用户组(若创建用户时未指定组,默认创建同名组)<br>groupdel &lt;groupname&gt; # 删除用户组<br><br>groupmod -n &lt;newname&gt; &lt;oldname&gt;   # 更改用户组名<br>usermod -g &lt;groupname&gt; &lt;username&gt; # 修改用户的组别<br>gpasswd -d &lt;groupname&gt; &lt;username&gt; # 从组中删除用户<br></code></pre></td></tr></table></figure></li><li><p>帮助指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">man &lt;command&gt;  # 获取帮助信息.如 man ls<br>help &lt;command&gt; # 获取 shell 内置命令的帮助信息.如 help cd<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-文件目录"><a href="#2-2-文件目录" class="headerlink" title="2.2 文件目录"></a>2.2 文件目录</h3><ol><li><p>路径切换</p><ul><li><p><strong><code>pwd</code>: 显示当前目录的绝对路径</strong></p></li><li><p><strong><code>ls &lt;path&gt;</code>: 列出文件和目录.默认显示当前目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -a # 显示所有文件和目录(包括隐藏文件,即以 . 开头的文件)<br>ls -l # 以列表形式显示<br>ls -h # 以易于阅读的形式,列出文件大小<br></code></pre></td></tr></table></figure></li><li><p><strong><code>cd &lt;path&gt;</code>: 切换到指定目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~  # 回到 home 目录<br>cd .. # 回到上一级目录<br>cd -  # 返回上一次目录<br></code></pre></td></tr></table></figure></li></ul></li><li><p>目录与文件</p><ul><li><p>创建 &#x2F; 删除目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir &lt;directory&gt; # 创建目录(默认只能创建一级目录)<br>rmdir &lt;directory&gt; # 删除目录(只能删除空目录)<br><br>mkdir -p &lt;directory1/directory2&gt; # 创建多级目录<br></code></pre></td></tr></table></figure></li><li><p>删除文件 &#x2F; 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm &lt;path&gt;    # 删除文件或目录<br>rm -r &lt;path&gt; # 递归删除整个文件夹<br>rm -f &lt;path&gt; # 强制删除不提示<br></code></pre></td></tr></table></figure></li><li><p>拷贝文件 &#x2F; 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp    &lt;src_path&gt; &lt;dst_path&gt; # 将文件 / 目录复制到指定路径<br>\cp   &lt;src_path&gt; &lt;dst_path&gt; # 直接覆盖同名文件,不进行提示<br>cp -r &lt;src_path&gt; &lt;dst_path&gt; # 递归复制整个目录<br></code></pre></td></tr></table></figure></li><li><p>移动文件 &#x2F; 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv &lt;src_path&gt; &lt;dst_path&gt; # 移动文件或目录到指定路径<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果位于同一目录,则作用为重命名</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo             # 输出内容到控制台(如 echo $PATH)<br>touch &lt;filename&gt; # 创建空文件<br>cat   &lt;filename&gt; # 查看文件内容.不能修改.(-n: 显示行号)<br>more  &lt;filename&gt; # 分批显示文件内容.Space 翻页, Enter 下一行, Q 离开<br>less  &lt;filename&gt; # 分批查看文件内容<br>tail  &lt;filename&gt; # 查看文件尾部内容(-f实时追踪文件的所有更新)<br><br>diff &lt;path1&gt; &lt;path2&gt; # 比较文件 / 目录的差异.(-c: 查看具体信息)<br></code></pre></td></tr></table></figure></li><li><p><strong>指令 <code>&gt;</code> 和 <code>&gt;&gt;</code>: 重定向和追加</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat file1 &gt; file2         # 将 file1 内容覆盖到 file2<br>echo &quot;string&quot; &gt;&gt; filename # 将内容追加到文件中<br></code></pre></td></tr></table></figure></li><li><p><strong>创建软链接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s &lt;path&gt; &lt;linkname&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong><code>history</code>: 查看 &#x2F; 执行历史指令</strong></p></li></ol><h3 id="2-3-查找"><a href="#2-3-查找" class="headerlink" title="2.3 查找"></a>2.3 查找</h3><ol><li><p><strong><code>find</code>: 从指定目录向下递归遍历各个子目录,将满足条件的文件 &#x2F; 目录显示在终端</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">find &lt;path&gt; &lt;options&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-name: 按文件名查找</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-user: 按用户所属查找</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-size: 按文件大小查找(+n 大于, -n 小于, n 等于)</span><br></code></pre></td></tr></table></figure></li><li><p><code>find</code> 使用示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /home -name hello.txt # 查找 /home 目录的 hello.txt 文件<br>find /opt -user nobody     # 查找 /opt 目录中拥有者为 nobody 的文件<br>find / -size +200M         # 查找整个系统中大于 200M 的文件<br></code></pre></td></tr></table></figure></li><li><p><strong><code>locate</code>: 事先建立系统中所有文件名称及路径的 <code>locate</code> 数据库</strong></p><ul><li>第一次运行时,必须先使用 <code>updatedb</code> 指令创建 <code>locate</code> 数据库</li><li>查询速度快,但需要及时更新 <code>locate</code> 时刻</li></ul></li><li><p><strong><code>which command</code>: 查看 command 所在的路径</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">which python3 # 查看 python3 命令所在的路径. /usr/bin/python3<br></code></pre></td></tr></table></figure></li><li><p><strong><code>grep</code>: 过滤查找(实际常和 | 结合使用)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep &quot;content&quot; &lt;path&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-n: 显示匹配行及行号</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-i: 忽略大小</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-r: 递归查找</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-v: 反向过滤</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-压缩解压"><a href="#2-4-压缩解压" class="headerlink" title="2.4 压缩解压"></a>2.4 压缩解压</h3><ol><li><p><strong><code>gzip filename</code>: 压缩为 <code>*.gz</code> 文件</strong></p></li><li><p><strong><code>gunzip 文件名</code>: 解压 <code>*.gz</code> 解压文件</strong></p></li><li><p>zip 格式压缩解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zip -r file.zip &lt;path&gt;   # 递归的压缩 path 目录<br>unzip file.zip -d &lt;path&gt; # 解压 file.zip 到 path 目录<br></code></pre></td></tr></table></figure></li><li><p><strong><code>tar</code>: 打包指令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -cvf file.tar file1 file2 ...     # 将文件打包为 file.tar<br>tar -czvf file.tar.gz file1 file2 ... # 将文件压缩到 file.tar.gz<br><br>tar -xvf file.tar -C &lt;path&gt;           # 解包 file.tar 到 path 目录<br>tar -xzvf file.tar.gz -C &lt;path&gt;       # 解包 file.tar.gz 到 path 目录<br></code></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>打包.产生 <code>.tar</code> 打包文件</td></tr><tr><td>-z</td><td>gzip 模式</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后文件名</td></tr><tr><td>-x</td><td>解包 <code>.tar</code> 文件</td></tr></tbody></table></li></ol><h3 id="2-5-运行级别"><a href="#2-5-运行级别" class="headerlink" title="2.5 运行级别"></a>2.5 运行级别</h3><ol><li><p>运行级别一般为 3 或 5</p><ul><li>0: 系统停机状态,即关机状态</li><li>1: 单用户模式,只有 root 用户可以登录.用于系统维护和修复</li><li>2: 多用户模式,没有 NFS 服务.但可以使用网络</li><li>3: <strong>多用户模式,完全启动系统.可以使用所有服务</strong></li><li>4: 保留,未使用</li><li>5: <strong>多用户模式,与运行级别3相同.但是在此级别下启动X Window系统,即图形界面</strong></li><li>6: 系统重启级别</li></ul></li><li><p>运行级别指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">init 1   # 切换到运行级别1<br>runlevel # 查看当前运行级别<br></code></pre></td></tr></table></figure></li><li><p>时间与日期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">date     # 显示当前日期<br>date +%Y # 显示当前年份<br>date +%m # 显示当前月份<br>date +%d # 显示当前天数<br><br>date &quot;+%Y-%m-%d %H:%M:%S&quot;     # 显示时间.年-月-日 时:分:秒<br>date -s &quot;2021-06-18 08:00:00&quot; # 设置时间<br><br>cal      # 显示本月日历<br>cal 2025 # 显示 2025年日历<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-权限管理"><a href="#3-权限管理" class="headerlink" title="3 权限管理"></a>3 权限管理</h2><h3 id="3-1-用户组"><a href="#3-1-用户组" class="headerlink" title="3.1 用户组"></a>3.1 用户组</h3><ol><li><p><strong>Linux 每个用户都属于某个组.每个文件有 所有者, 所在组, 其他组</strong></p></li><li><p>所有者: 文件的创建者自然成为文件的所有者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -ahl # 查看文件 / 目录的所有者<br>chown username filename           # 修改文件 / 目录的所有者<br>chown username:groupname filename # 修改所有者以及所在组<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-R: 将目录的子目录和文件进行递归修改</span><br></code></pre></td></tr></table></figure></li><li><p>所在组: 文件 &#x2F; 目录的所在组 为 所有者的所在组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chgrp &lt;groupname&gt; &lt;filename&gt; # 修改文件 / 目录所在组<br></code></pre></td></tr></table></figure></li><li><p>其他组: 除所有者和所在组之外的用户</p></li></ol><h3 id="3-2-文件权限"><a href="#3-2-文件权限" class="headerlink" title="3.2 文件权限"></a>3.2 文件权限</h3><ol><li><p><strong>文件所属分为 拥有者(owner), 所属群组(group), 其他人(other).</strong><br><strong>而三种身份各有 读(read), 写(write), 执行(execute)权限</strong></p></li><li><p>考虑 <code>ls -l</code> 命令,显示的信息形如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">文件权限, 链接数, 文件拥有者, 文件所属用户组, 文件大小(Bytes), 最后被修改的时间, 文件名</span><br>-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc<br></code></pre></td></tr></table></figure></li><li><p>文件权限共 9位.其含义为</p><ul><li><strong>第 0 位: 文件类型(d ,-, l, c, b)</strong><ul><li><code>d</code>: 目录.相当于文件夹</li><li><code>-</code>: 普通文件</li><li><code>l</code>: 链接.相当于快捷方式</li><li><code>c</code>: 字符设备.如鼠标键盘</li><li><code>b</code>: 块设备.如硬盘</li></ul></li><li><strong>1 ~ 3位: 文件所有者的权限.如 rwx 表示可读可写可执行</strong></li><li><strong>4 ~ 6位: 所在组用户的权限.如 rw- 表示可读可写,但不能执行</strong></li><li><strong>7 ~ 9位: 其他用户对该文件的权限.如 r– 表示仅能读</strong></li></ul></li><li><p><strong>目录权限表示方式</strong></p><ul><li><code>r</code>: 可读.可以查看文件 或 可用 <code>ls</code> 查看目录内容</li><li><code>w</code>: 可写.可创建, 删除, 重命名, 移动其中的文件或目录</li><li><code>x</code>: 可执行.可以执行文件 或 可进入该目录(成为工作目录)</li><li><code>-</code>: 对应位置如果出现 <code>-</code>,表示没有该类型权限</li><li><code>rwx</code> 还可以用数字形式表示(<code>r = 4, w = 2, x = 1</code>).如 rwx &#x3D; 4 + 2 +1 &#x3D; 7</li></ul></li><li><p><strong><code>chmod</code>: 修改文件 &#x2F; 目录的权限</strong></p><ul><li><p><code>u</code>: 所有者, <code>g</code>: 所在组, <code>o</code>: 其他人, <code>a</code>: 所有人. 使用 <code>+, -, =</code>赋予权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod u=rwx,g=rx,o=x filename # 对文件设置权限<br>chmod o+w filename # 对其他组增加 w 可写权限<br>chmod a-x filename # 对所有人取消 x 可执行权限<br>chmod 751 filename # 与 chmod u=rwx,g=rx,o=x filename 等价<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="3-3-环境变量"><a href="#3-3-环境变量" class="headerlink" title="3.3 环境变量"></a>3.3 环境变量</h3><ol><li><p><code>env</code>: 查看系统中记录的环境变量(以 key-value 的形式存储)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">env # 结果形如 SHELL=/bin/bash<br></code></pre></td></tr></table></figure></li><li><p><code>PATH</code> 变量中记录了系统执行命令的搜索路径(使用 <code>:</code> 分隔)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">env | grep PATH # 结果形如 PATH=/usr/local/sbin:/usr/local/bin<br></code></pre></td></tr></table></figure></li><li><p><code>$</code> 用于取值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo $PATH # 结果与 env | grep PATH 相同<br></code></pre></td></tr></table></figure></li><li><p>设置环境变量</p><ul><li><p>临时设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=$PATH:&lt;path&gt;  # 将 path 追加到 PATH 中.仅当前终端有效<br></code></pre></td></tr></table></figure></li><li><p>永久设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim ~/.bashrc  # 将 export 语句追加到末行<br>source .bashrc # 使 .bashrc 生效<br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意 .bashrc 仅对当前用户生效.对所有用户生效需要修改 /etc/profile 文件</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="3-4-定时任务"><a href="#3-4-定时任务" class="headerlink" title="3.4 定时任务"></a>3.4 定时任务</h3><ol><li><p>任务调度: 系统在某个时间执行的特定命令或程序</p><ul><li>系统工作.需要周期性的执行,如病毒扫描</li><li>用户工作.如对 mysql 数据库的备份</li></ul></li><li><p><code>crond</code> 定时任务</p><ul><li>基础语法: <code>crontab [选项]</code><ul><li><code>-e</code>: 编辑 <code>crontab</code> 任务</li><li><code>-l</code>: 查询 <code>crontab</code> 任务</li><li><code>-r</code>: 删除当前用户的所有 <code>crontab</code> 任务</li></ul></li><li>示例: <code>*/1**** ls -l /etc &gt; /tmp/to.txt</code> 将会每分钟都执行一次</li></ul></li><li><p>时间规则</p><ul><li><p>5个占位符的含义</p><table><thead><tr><th>序号</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>1</td><td>每小时的分钟数</td><td>0 ~ 59</td></tr><tr><td>2</td><td>每天的小时数</td><td>0 ~ 23</td></tr><tr><td>3</td><td>每月的天数</td><td>1 ~ 31</td></tr><tr><td>4</td><td>每天的月份</td><td>1 ~ 12</td></tr><tr><td>5</td><td>每周星期数</td><td>0 ~ 7(0和7均为星期天)</td></tr></tbody></table></li><li><p>特殊符号</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>通配符,表示任意时间</td></tr><tr><td>,</td><td>分隔不连续的时间.如 <code>08,17***</code> 表示每天的8时0分,17时0分</td></tr><tr><td>-</td><td>连续的时间范围.如 <code>05**1-6</code> 表示周一到周六的5时0分</td></tr><tr><td>*&#x2F;n</td><td>每次的间隔时间.如 <code>*/10****</code> 表示每次间隔10分钟</td></tr></tbody></table></li></ul></li></ol><h3 id="3-5-进程"><a href="#3-5-进程" class="headerlink" title="3.5 进程"></a>3.5 进程</h3><ol><li><p>进程</p><ul><li>Linux 中每个执行的程序都是一个进程.每个进程都会分配一个ID号(pid)</li><li>每个进程可以以前台或后台的形式存在</li><li>一般系统服务均以后台进程形式存在,且常驻于系统,直到关机才结束</li></ul></li><li><p><strong><code>ps</code>: 查看当前系统中正在执行的进程</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -a # 显示当前终端的所有进程信息<br>ps -u # 以用户的格式显示进程信息<br>ps -x # 显示后台进程运行的参数<br></code></pre></td></tr></table></figure></li><li><p>父子进程</p><ul><li><strong><code>ps -ef</code>: 全格式显示当前所有进程</strong></li><li>显示的 ppid 指出该进程的父进程</li><li>搭配 <code>| grep</code> 可以进行过滤</li></ul></li><li><p>终止进程</p><ul><li><strong><code>kill [选项] 进程号</code>: 通过进程号终止进程</strong></li><li><code>killall 进程名称</code>: 通过进程名称终止进程,同时会终止其所有子进程</li></ul></li><li><p><code>pstree</code>: 查看进程树</p><ul><li><code>-p</code>: 显示进程的 pid</li><li><code>-u</code>: 显示进程的用户</li></ul></li><li><p>服务(service): 其本质仍然是进程.通常会监听某个端口,等待其他程序的请求</p><ul><li><code>service 服务名 [start | stop | restart | reload | status]</code></li><li>CentOS7.0后,很多服务不再使用 <code>service</code> 指令管理,而使用 <code>systemctl</code></li><li><code>systemctl [start | stop | restart | status] 服务名</code></li><li><code>systemctl</code> 管理的服务在 <code>/user/lib/systemd/system</code> 查看</li></ul></li></ol><h2 id="4-开发环境"><a href="#4-开发环境" class="headerlink" title="4 开发环境"></a>4 开发环境</h2><h3 id="4-1-rpm"><a href="#4-1-rpm" class="headerlink" title="4.1 rpm"></a>4.1 rpm</h3><ol><li><p><strong>rpm(RedHat Package Manager) 用于互联网下载包的打包,安装.生成 <code>.RPM</code> 的文件</strong></p></li><li><p>查询软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -qa                # 查询所有安装的 rpm 软件包<br>rpm -qa | grep firefox # 查询具体的某个软件包<br>rpm -qi firefox        # 查询软件包的具体信息<br></code></pre></td></tr></table></figure></li><li><p>安装与删除软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -ivh &lt;path&gt; # 安装软件包需要有全路径<br>rpm -e firefox  # 删除软件包<br></code></pre></td></tr></table></figure></li><li><p>yum: Shell 前端软件包管理器</p><ul><li>yum 基于 rpm 包管理.能从指定服务器自动下载 rpm 包并安装</li><li>yum 将会自动处理依赖性关系,并一次安装所有依赖的软件包</li></ul></li><li><p>yum 指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum list | grep firefox # 查询 yum 服务器中的相关软件包信息<br>yum install firefox     # 下载安装软件包及依赖<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-2-Ubuntu"><a href="#4-2-Ubuntu" class="headerlink" title="4.2 Ubuntu"></a>4.2 Ubuntu</h3><ol><li><p><strong>Ubuntu: 一个以桌面应用为主的开源 GNU&#x2F;Linux 操作系统</strong></p><ul><li>基于 GNU&#x2F;Linux.支持 x86, amd64, ppc 架构.由 Canonical 打造</li><li>Python 开发者一般选择 Ubuntu 作为生产平台</li><li>下载桌面版: <a href="https://cn.ubuntu.com/download">Ubuntu系统下载 | Ubuntu</a></li></ul></li><li><p>中文支持</p><ul><li>Ubuntu 默认只有英文.需要安装中文语言包(需要联网)</li><li>打开 Language Support 菜单 -&gt; Language Support 选项卡 -&gt; Install</li><li>选中 Chinese(Simplified) -&gt; Apply Changes 提交.此时系统将会自动下载</li><li>默认显示中文需要将 <code>汉语(中国)</code> 拖动到第一位</li></ul></li><li><p>root 权限</p><ul><li><strong>Ubuntu 安装后只有普通用户权限.若需要 root 权限,应在命名前加上 <code>sudo</code></strong></li><li>当使用 <code>su root</code> 切换到 root 用户时,因还未设置密码,将会抛出 <code>error</code></li><li>设置 root 用户的密码并使用<ul><li><code>sudo password</code>: 给 root 用户设置密码</li><li><code>su root</code>: 切换到 root 用户</li><li>提示符 <code>$</code> 表示一般用户.<code>#</code> 表示 root 用户</li><li><code>exit</code>: 退出 root 用户</li></ul></li></ul></li><li><p>python</p><ul><li>Ubuntu 默认安装 python 的开发环境</li><li><code>python3</code> 将会展示版本信息</li></ul></li><li><p><strong>apt(Advanced Packaging Tool): 安装包管理工具</strong></p><ul><li><p>Ubuntu 使用 <code>apt</code> 命令进行软件包的安装, 删除, 清理…</p></li><li><p><code>/etc/apt/sources.list</code> 文件中存放着 apt 服务器的地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update              # 更新源<br>sudo apt install &lt;package&gt;   # 安装 package<br>sudo apt remove &lt;package&gt;    # 删除 package<br><br>sudo apt search &lt;package&gt;    # 搜索软件包<br>sudo apt show &lt;package&gt;      # 获取包的相关信息<br>sudo apt install &lt;package&gt; --reinstall  # 重新安装包<br><br>sudo apt --fix-broken install # 修复安装<br>sudo apt purge &lt;package&gt;      # 删除包，包括配置文件<br>sudo apt build-dep &lt;package&gt;  # 安装相关编译环境<br><br>sudo apt upgrade             # 更新已安装的包<br>sudo apt full-upgrade        # 升级系统<br>sudo apt depends &lt;package&gt;   # 查看该包所依赖的包<br>sudo apt rdepends &lt;package&gt;  # 查看该包被哪些包依赖<br>sudo apt source &lt;package&gt;    # 下载软件包的源代码<br></code></pre></td></tr></table></figure></li></ul></li><li><p>修改 apt 更新源(镜像网站: 因为服务器位于美国,连接缓慢,由镜像网站获取其资源)</p><ul><li><p>备份文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cp /ect/apt/sources.list /etc/apt/sources.list.backup # Ubuntu 24.04 之前<br>sudo cp /etc/apt/sources.list.d/ubuntu.sources /etc/apt/sources.list.d/ubuntu.sources.backup # Ubuntu 24.04 之后<br></code></pre></td></tr></table></figure></li><li><p>使用 root 用户,清空源文件中的所有内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;&#x27; &gt; source.list<br></code></pre></td></tr></table></figure></li><li><p>将需要的<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">镜像地址(清华源)</a>拷贝到 <code>source.list</code> 文件中</p></li></ul></li><li><p>远程登录</p><ul><li><p>SSH(Secure Shell): 建立于应用层和传输层基础上的安全协议</p></li><li><p>与 CentOS 不同,Ubuntu 默认没有安装 SSHD 服务</p></li><li><p>安装 SSH</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install openssh-server<br></code></pre></td></tr></table></figure></li><li><p>启动 SSH</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service sshd restart<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Linux 登录到 Ubuntu</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh 目标主机的用户名@目标主机IP地址 # 登录<br>logout # 退出<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-Shell"><a href="#5-Shell" class="headerlink" title="5 Shell"></a>5 Shell</h2><h3 id="5-1-脚本"><a href="#5-1-脚本" class="headerlink" title="5.1 脚本"></a>5.1 脚本</h3><ol><li><p><strong>Shell: 命令行解释器.为用户提供一个向 Linux 内核发送请求以便运行程序的界面系统级程序</strong></p><ul><li>运维工程师对服务器集群进行管理时,需要编写 Shell 程序进行服务器管理</li><li>JavaEE, Python程序员需要编写 Shell 维护程序和服务器</li><li>大数据程序员需要编写 Shell 程序管理集群</li></ul></li><li><p>Shell 脚本</p><ul><li><p>文件内容需要以 <code>#!/bin/bash</code> 开头,一般后缀为 <code>.sh</code></p></li><li><p>文件本身需要有可执行权限.赋予权限: <code>chmod u+x hello.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>echo &quot;Hello,world!&quot;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>执行脚本</p><ul><li><code>脚本的绝对路径或相对路径</code>: 即可执行(需要有 <code>+x</code> 权限)</li><li><code>sh 脚本路径</code>: 这样执行无需 <code>+x</code> 执行权限</li></ul></li><li><p>注释</p><ul><li>单行注释: <code># content</code></li><li>多行注释: <code>:&lt;&lt;! content !</code></li></ul></li></ol><h3 id="5-2-变量"><a href="#5-2-变量" class="headerlink" title="5.2 变量"></a>5.2 变量</h3><ol><li><p>系统变量</p><ul><li>如: <code>$HOME, $PWD, $SHELL, $USER</code>.可使用 <code>echo $HOME</code> 打印当前用户的家目录</li><li>显示当前 Shell 的所有系统变量</li></ul></li><li><p>自定义变量</p><ul><li>语法: <code>变量名=value</code>.注意语句中不要加入空格.变量名的命名限制与C相同</li><li>销毁变量: <code>unset 变量名</code>.Shell 编程变量名一般大写</li><li>声明静态变量: <code>readonly 变量名</code>.不能使用 <code>unset</code> 销毁</li><li>打印变量: <code>echo $变量名</code>.注意需要加上 <code>$</code> 符号</li></ul></li><li><p>将命令的返回值赋给变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">A=`command` # 将 command 作为一个命令执行,然后将结果赋值给变量 A<br>A=$(date)   # 与上述写法等价.变量 A 将会存储当前时间信息<br></code></pre></td></tr></table></figure></li><li><p>环境变量</p><ul><li><code>export 变量名=值</code>: 将 Shell 变量输出为环境变量 &#x2F; 全局变量</li><li><code>export 配置文件</code>: 使修改后的配置信息立即生效</li><li><code>echo $变量</code>: 查询环境变量的值</li></ul></li><li><p>位置参数</p><ul><li><code>$0</code>: 表示命令本身,<code>$1 ~ $9</code>表示第1 ~ 9个参数.对于超过10的,要用 <code>&#123;&#125;</code> 包裹</li><li><code>$*</code>: 表示所有的参数.且将所有参数当作整体处理</li><li><code>$@</code>: 表示所有的参数.但将每个参数分开处理</li><li><code>$#</code>: 获取命令行中所有参数的个数</li></ul></li><li><p>预定义变量: Shell 已定义的变量,可以直接在 Shell 脚本中使用</p><ul><li><code>$$</code>: 当前进程的进程号 pid</li><li><code>$!</code>: 后台运行的最后一个进程的进程号 pid</li><li><code>#?</code>: 最后一次执行的命令的返回状态.0表示正确执行</li></ul></li><li><p>运算</p><ul><li>语法: <code>$((运算式))</code> 或 <code>$[运算式]</code></li></ul></li></ol><h3 id="5-3-控制流"><a href="#5-3-控制流" class="headerlink" title="5.3 控制流"></a>5.3 控制流</h3><ol><li><p>条件表达式: <code>[ condition ]</code>.注意两端的空格,非空返回 true</p></li><li><p>分支语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ condition1 ]<br>then<br>code block1<br>elif [ condition2 ]<br>then<br>code block2<br>fi<br></code></pre></td></tr></table></figure></li><li><p>case</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $变量名 in<br>&quot;value1&quot;)<br>code block1<br>;;<br>&quot;value2&quot;)<br>code block2<br>*)<br>code block<br>esac<br></code></pre></td></tr></table></figure></li><li><p>for</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for 变量名 in value1 value2...<br>do<br>code block<br>done<br></code></pre></td></tr></table></figure></li><li><p>while</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">while [ condition ]<br>do<br>code block<br>done<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-4-函数"><a href="#5-4-函数" class="headerlink" title="5.4 函数"></a>5.4 函数</h3><ol><li><p>读取控制台输入</p><ul><li>基础语法: <code>read 选项 参数</code></li><li>选项: <code>-p</code> 指定读取值时的提示符. <code>-t</code> 指定等待的秒数</li><li>参数: 指定存储输入值的变量名</li></ul></li><li><p>系统函数</p><ul><li><code>basename</code>: 返回完整路径最后一个 <code>/</code> 后的内容,常用于获取文件名</li><li><code>basename [pathname] [suffix]</code></li><li><code>dirname</code>: 返回完整路径最后一个 <code>/</code> 前的内容,常用于获取路径</li></ul></li><li><p>自定义函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ function ] funname[()]<br>&#123;<br>Action;<br>[return int;]<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具箱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Code</tag>
      
      <tag>工具箱</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Language Advanced</title>
    <link href="/2023/05/03/Computer/C-Language-Advanced/"/>
    <url>/2023/05/03/Computer/C-Language-Advanced/</url>
    
    <content type="html"><![CDATA[<h1 id="C-语言进阶"><a href="#C-语言进阶" class="headerlink" title="C 语言进阶"></a>C 语言进阶</h1><h2 id="0-库函数"><a href="#0-库函数" class="headerlink" title="0 库函数"></a>0 库函数</h2><h3 id="0-1-标准输出"><a href="#0-1-标准输出" class="headerlink" title="0.1 标准输出"></a>0.1 标准输出</h3><ol><li><p><code>printf</code>: 将字符串进行格式化转换,然后进行标准化输出.等价于 <code>fprintf(stdout, ...)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br><span class="hljs-comment">// format: 格式化字符串, 包含普通字符和格式说明符</span><br><span class="hljs-comment">// ...: 可变参数列表, 对应格式字符串中的格式说明符</span><br><span class="hljs-comment">// 返回值: 成功时返回输出的字符数, 失败时返回负值</span><br></code></pre></td></tr></table></figure></li><li><p>格式化字符串结构分为</p><ul><li><p>普通字符: 原样输出</p></li><li><p>转义序列: 如 <code>\n, \t</code></p></li><li><p>格式说明符: 以 <code>%</code> 开头,形式为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">%[flags][width][.precision][length]specifier<br></code></pre></td></tr></table></figure></li></ul></li><li><p>基本格式说明符(若<code>%</code>后的字符不是转换字符,则为未定义行为)</p><table><thead><tr><th align="left">specifier</th><th align="left">用途</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>%d</code> 或 <code>%i</code></td><td align="left">有符号十进制整数</td><td align="left"><code>printf(&quot;%d&quot;, 123);</code> → <code>123</code></td></tr><tr><td align="left"><code>%u</code></td><td align="left">无符号十进制整数</td><td align="left"><code>printf(&quot;%u&quot;, 255);</code> → <code>255</code></td></tr><tr><td align="left"><code>%o</code></td><td align="left">无符号八进制整数</td><td align="left"><code>printf(&quot;%o&quot;, 10);</code> → <code>12</code></td></tr><tr><td align="left"><code>%x</code> 或 <code>%X</code></td><td align="left">无符号十六进制整数</td><td align="left"><code>printf(&quot;%x&quot;, 255);</code> → <code>ff</code></td></tr><tr><td align="left"><code>%f</code> 或 <code>%F</code></td><td align="left">十进制浮点数</td><td align="left"><code>printf(&quot;%f&quot;, 3.14);</code> → <code>3.140000</code></td></tr><tr><td align="left"><code>%e</code> 或 <code>%E</code></td><td align="left">科学计数法浮点数</td><td align="left"><code>printf(&quot;%e&quot;, 123.45);</code> → <code>1.234500e+02</code></td></tr><tr><td align="left"><code>%g</code> 或 <code>%G</code></td><td align="left">自动选择 <code>%f</code> 或 <code>%e</code></td><td align="left"><code>printf(&quot;%g&quot;, 0.000123);</code> → <code>0.000123</code></td></tr><tr><td align="left"><code>%c</code></td><td align="left">单个字符</td><td align="left"><code>printf(&quot;%c&quot;, &#39;A&#39;);</code> → <code>A</code></td></tr><tr><td align="left"><code>%s</code></td><td align="left">字符串</td><td align="left"><code>printf(&quot;%s&quot;, &quot;hello&quot;);</code> → <code>hello</code></td></tr><tr><td align="left"><code>%p</code></td><td align="left">指针地址</td><td align="left"><code>printf(&quot;%p&quot;, &amp;var);</code> → <code>0x7ffd42a1b2cc</code></td></tr><tr><td align="left"><code>%%</code></td><td align="left">输出百分号</td><td align="left"><code>printf(&quot;%%&quot;);</code> → <code>%</code></td></tr></tbody></table></li><li><p>标志(flags 出现顺序不限): 用于修改转换说明</p><table><thead><tr><th align="left">flags</th><th align="left">作用</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>-</code></td><td align="left">左对齐</td><td align="left"><code>printf(&quot;%-10s&quot;, &quot;hello&quot;);</code> → <code>hello</code></td></tr><tr><td align="left"><code>+</code></td><td align="left">强制显示正负号</td><td align="left"><code>printf(&quot;%+d&quot;, 5);</code> → <code>+5</code></td></tr><tr><td align="left"><kbd>space</kbd></td><td align="left">正数前显示空格</td><td align="left"><code>printf(&quot;% d&quot;, 5);</code> → <code>5</code></td></tr><tr><td align="left"><code>0</code></td><td align="left">用零填充而非空格</td><td align="left"><code>printf(&quot;%05d&quot;, 42);</code> → <code>00042</code></td></tr><tr><td align="left"><code>#</code></td><td align="left">替代形式</td><td align="left"><code>printf(&quot;%#x&quot;, 10);</code> → <code>0xa</code></td></tr></tbody></table></li><li><p>宽度(width) &amp;&amp; 精度(precision)</p><table><thead><tr><th align="left">width.precision</th><th align="left">作用</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>数字</code></td><td align="left">最小字段宽度</td><td align="left"><code>printf(&quot;%10s&quot;, &quot;hi&quot;);</code> → <code>hi</code></td></tr><tr><td align="left"><code>.*</code></td><td align="left">精度(动态指定)</td><td align="left"><code>printf(&quot;%.*f&quot;, 2, 3.14159);</code> → <code>3.14</code></td></tr><tr><td align="left"><code>.数字</code></td><td align="left">精度</td><td align="left"><code>printf(&quot;%.2f&quot;, 3.14159);</code> → <code>3.14</code></td></tr></tbody></table></li><li><p>长度修饰符(length): 用于将参数指定为某种类型</p><table><thead><tr><th align="left">length</th><th align="left">用途</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>h</code></td><td align="left"><code>short int</code></td><td align="left"><code>printf(&quot;%hd&quot;, (short)32767);</code></td></tr><tr><td align="left"><code>l</code></td><td align="left"><code>long int</code></td><td align="left"><code>printf(&quot;%ld&quot;, 123456789L);</code></td></tr><tr><td align="left"><code>ll</code></td><td align="left"><code>long long int</code></td><td align="left"><code>printf(&quot;%lld&quot;, 123456789012LL);</code></td></tr><tr><td align="left"><code>L</code></td><td align="left"><code>long double</code></td><td align="left"><code>printf(&quot;%Lf&quot;, 3.1415926535L);</code></td></tr></tbody></table></li></ol><h3 id="0-2-标准输入"><a href="#0-2-标准输入" class="headerlink" title="0.2 标准输入"></a>0.2 标准输入</h3><ol><li><p><code>scanf</code>: 从标准输入读取输入,根据 format 进行匹配, 赋给后续的各个参数.等价于 <code>scanf(stdout, ...)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">scanf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br><span class="hljs-comment">// format: 格式化字符串,指定输入数据的预期格式</span><br><span class="hljs-comment">// ...: 可变参数列表, 对应格式字符串中的格式说明符.注意必须是变量的地址</span><br><span class="hljs-comment">// 返回值: 成功时返回成功读取的数据项数量.失败或到达文件末尾时返回 EOF</span><br></code></pre></td></tr></table></figure></li><li><p>格式串字符串结构</p><ul><li><p>空白字符: 空格, 制表符, 换行符</p></li><li><p>非空白字符: 必须与输入精确匹配的字符</p></li><li><p>格式说明符: 以 <code>%</code> 开头,形式为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">%[*][width][length]specifier<br></code></pre></td></tr></table></figure></li></ul></li><li><p>基本格式说明符</p><table><thead><tr><th align="left">specifier</th><th align="left">用途</th><th align="left">示例</th><th align="left">输入示例</th></tr></thead><tbody><tr><td align="left"><code>%d</code></td><td align="left">有符号十进制整数</td><td align="left"><code>scanf(&quot;%d&quot;, &amp;num);</code></td><td align="left"><code>123</code></td></tr><tr><td align="left"><code>%i</code></td><td align="left">整数(自动检测进制)</td><td align="left"><code>scanf(&quot;%i&quot;, &amp;num);</code></td><td align="left"><code>123</code>, <code>0x7B</code>, <code>0173</code></td></tr><tr><td align="left"><code>%u</code></td><td align="left">无符号十进制整数</td><td align="left"><code>scanf(&quot;%u&quot;, &amp;num);</code></td><td align="left"><code>255</code></td></tr><tr><td align="left"><code>%o</code></td><td align="left">无符号八进制整数</td><td align="left"><code>scanf(&quot;%o&quot;, &amp;num);</code></td><td align="left"><code>12</code> (十进制10)</td></tr><tr><td align="left"><code>%x, %X</code></td><td align="left">无符号十六进制整数</td><td align="left"><code>scanf(&quot;%x&quot;, &amp;num);</code></td><td align="left"><code>ff</code> (十进制255)</td></tr><tr><td align="left"><code>%f, %e, %g</code></td><td align="left">浮点数</td><td align="left"><code>scanf(&quot;%f&quot;, &amp;f);</code></td><td align="left"><code>3.14</code></td></tr><tr><td align="left"><code>%lf</code></td><td align="left">双精度浮点数</td><td align="left"><code>scanf(&quot;%lf&quot;, &amp;d);</code></td><td align="left"><code>3.14159</code></td></tr><tr><td align="left"><code>%c</code></td><td align="left">单个字符</td><td align="left"><code>scanf(&quot;%c&quot;, &amp;ch);</code></td><td align="left"><code>A</code></td></tr><tr><td align="left"><code>%s</code></td><td align="left">字符串(不包含空白符)</td><td align="left"><code>scanf(&quot;%s&quot;, str);</code></td><td align="left"><code>hello</code></td></tr><tr><td align="left"><code>%[ ]</code></td><td align="left">扫描字符集合</td><td align="left"><code>scanf(&quot;%[a-z]&quot;, str);</code></td><td align="left"><code>hello</code></td></tr><tr><td align="left"><code>%p</code></td><td align="left">指针地址</td><td align="left"><code>scanf(&quot;%p&quot;, &amp;ptr);</code></td><td align="left"><code>0x7ffd42a1b2cc</code></td></tr><tr><td align="left"><code>%%</code></td><td align="left">匹配百分号</td><td align="left"><code>scanf(&quot;%%&quot;);</code></td><td align="left"><code>%</code></td></tr></tbody></table></li><li><p>修饰符</p><table><thead><tr><th align="left">修饰符</th><th align="left">作用</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>*</code></td><td align="left">赋值抑制符(读取但不存储)</td><td align="left"><code>scanf(&quot;%*d %d&quot;, &amp;num);</code></td></tr><tr><td align="left"><code>数字</code></td><td align="left">最大字段宽度</td><td align="left"><code>scanf(&quot;%5s&quot;, str);</code></td></tr><tr><td align="left"><code>h</code></td><td align="left"><code>short int</code></td><td align="left"><code>scanf(&quot;%hd&quot;, &amp;s_num);</code></td></tr><tr><td align="left"><code>l</code></td><td align="left"><code>long int</code> 或 <code>double</code></td><td align="left"><code>scanf(&quot;%ld&quot;, &amp;l_num);</code></td></tr><tr><td align="left"><code>ll</code></td><td align="left"><code>long long int</code></td><td align="left"><code>scanf(&quot;%lld&quot;, &amp;ll_num);</code></td></tr><tr><td align="left"><code>L</code></td><td align="left"><code>long double</code></td><td align="left"><code>scanf(&quot;%Lf&quot;, &amp;ld_num);</code></td></tr></tbody></table></li></ol><h3 id="0-3-排序查找"><a href="#0-3-排序查找" class="headerlink" title="0.3 排序查找"></a>0.3 排序查找</h3><ol><li><p>快速排序算法 <code>&lt;stdlib.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// qsort 函数是类型无关的通用排序函数.实现了 Quick Sort</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">qsort</span><span class="hljs-params">(<span class="hljs-type">void</span> *base, <span class="hljs-type">size_t</span> nmemb, <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">           <span class="hljs-type">int</span> (*compare)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *))</span>;<br><span class="hljs-comment">// base:    目标数组</span><br><span class="hljs-comment">// nmemb:   数组中元素数量</span><br><span class="hljs-comment">// size:    每个元素的大小(单位为 byte)</span><br><span class="hljs-comment">// compare: 比较函数的指针.返回值小于 0 时.表示 param1 排在 param2 前(即默认升序)</span><br></code></pre></td></tr></table></figure></li><li><p>二分查找 <code>&lt;stdlib.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 二分查找成功返回指向该元素的指针.未找到返回 NULL</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">bsearch</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *base, <span class="hljs-type">size_t</span> nmemb, <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">              <span class="hljs-type">int</span> (*compare)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *))</span>;<br><span class="hljs-comment">// key:     查找元素的指针.注意数据类型应该与数组元素保持相同</span><br><span class="hljs-comment">// base:    目标数组</span><br><span class="hljs-comment">// nmemb:   数组中元素数量</span><br><span class="hljs-comment">// size:    每个元素的大小(单位为 byte)</span><br><span class="hljs-comment">// compare: 比较函数的指针</span><br></code></pre></td></tr></table></figure></li><li><p>快排使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">// 数据结构.其中 key 为排序依据</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">char</span> key[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> value;<br>&#125; Record;<br><br><span class="hljs-comment">// 比较函数(字典序)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">record_compare</span><span class="hljs-params">(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *a, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *b)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(((Record *)a)-&gt;key, ((Record *)b)-&gt;key);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Record records[<span class="hljs-number">4</span>] = &#123;<br>        &#123;<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">100</span>&#125;, &#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">200</span>&#125;, &#123;<span class="hljs-string">&quot;date&quot;</span>, <span class="hljs-number">300</span>&#125;, &#123;<span class="hljs-string">&quot;cherry&quot;</span>, <span class="hljs-number">400</span>&#125;&#125;;<br><br>    <span class="hljs-comment">// 排序</span><br>    qsort(records, <span class="hljs-number">4</span>, <span class="hljs-keyword">sizeof</span>(Record), record_compare);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;records[%d] %s - %d\n&quot;</span>, i, records[i].key, records[i].value);<br><br>    <span class="hljs-comment">// 查找</span><br>    Record key = &#123;<span class="hljs-string">&quot;cherry&quot;</span>, <span class="hljs-number">0</span>&#125;;<br>    Record *result = bsearch(&amp;key, records, <span class="hljs-number">4</span>, <span class="hljs-keyword">sizeof</span>(Record), record_compare);<br><br>    <span class="hljs-keyword">if</span> (result)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Found: %s, data: %d\n&quot;</span>, result-&gt;key, result-&gt;value);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not found\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1 内存管理"></a>1 内存管理</h2><h3 id="1-1-内存布局"><a href="#1-1-内存布局" class="headerlink" title="1.1 内存布局"></a>1.1 内存布局</h3><ol><li><p>C 程序在运行时,内存分为以下几个主要区域(Segments)</p><table><thead><tr><th align="left"><strong>内存区域</strong></th><th align="left"><strong>存储内容</strong></th><th align="left"><strong>特点</strong></th></tr></thead><tbody><tr><td align="left">代码段(Text)</td><td align="left">存放编译后的机器指令(二进制代码)</td><td align="left">只读.程序运行时不可修改</td></tr><tr><td align="left">数据段(Data)</td><td align="left">已初始化全局变量 &amp; 静态变量</td><td align="left">程序启动时分配.生命周期直到程序结束</td></tr><tr><td align="left">BSS 段(BSS)</td><td align="left">未初始化全局变量 &amp; 静态变量</td><td align="left">程序启动时清零.生命周期直到程序结束</td></tr><tr><td align="left">堆(Heap)</td><td align="left">动态分配(<code>malloc, calloc, realloc, free</code>)</td><td align="left">手动管理.增长方向从低地址向高地址</td></tr><tr><td align="left">栈(Stack)</td><td align="left">局部变量,函数参数,返回地址等</td><td align="left">自动管理(函数调用时入栈,返回时出栈).<br />增长方向从高地址向低地址,大小有限</td></tr></tbody></table></li><li><p>内存布局图示(linux 64bit)</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss">高地址<br>┌─────────────────────┐<br>│        Stack        │ ← 由高地址向低地址增长<br>├─────────────────────┤<br>│          ↓          │<br>│          ↑          │<br>├─────────────────────┤<br>│        Heap         │ ← 由低地址向高地址增长<br>├─────────────────────┤<br>│        BSS          │ (未初始化全局变量)<br>├─────────────────────┤<br>│        Data         │ (已初始化全局变量)<br>├─────────────────────┤<br>│        <span class="hljs-selector-tag">Text</span>         │ (程序指令)<br>低地址<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-2-内存分配"><a href="#1-2-内存分配" class="headerlink" title="1.2  内存分配"></a>1.2  内存分配</h3><ol><li><p>需要使用到 <code>&lt;stdlib.h&gt;</code> 头文件中的库函数</p></li><li><p><code>malloc</code>: 向系统申请分配 <code>size</code> 个字节的内存空间,返回一个指向该空间的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-comment">// 调用成功返回一个申请的内存空间指针,类型为 void *</span><br><span class="hljs-comment">// 调用失败返回 NULL.若设置 size = 0,同样返回 NULL</span><br></code></pre></td></tr></table></figure></li><li><p><code>calloc</code>: 在内存中动态的申请 <code>nmemb</code> 个长度为 <code>size</code> 的连续内存空间,并全部初始化为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> nmemb, <span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-comment">// 调用成功返回一个申请的内存空间指针,类型为 void *</span><br><span class="hljs-comment">// 调用失败返回 NULL.若设置 size = 0,同样返回 NULL</span><br></code></pre></td></tr></table></figure></li><li><p><code>realloc</code>: 重新分配内存空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><ul><li>可以增大或减小已分配内存的大小</li><li>其实现通常为新分配内存,然后复制内容,最后释放原内存.注意新内存仍不会初始化</li><li><code>ptr</code> 指向先前分配的内存空间.当参数 <code>ptr==NULL</code> 时,等同于调用 <code>malloc</code></li></ul></li><li><p><code>free</code>: 释放动态空间内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>free</code> 释放的内存空间必须是由 <code>malloc, calloc, realloc</code> 函数申请.否则会导致未定义行为</li><li>若参数 <code>ptr==NULL</code>,则不执行任何操作.多次对同一指针调用 <code>free</code>,将导致未定义行为</li><li><code>free</code> 函数不改变参数 <code>ptr</code> 的值.为避免悬空指针,释放空间后需将指针的值置为 <code>NULL</code></li></ul></li></ol><h3 id="1-3-内存池"><a href="#1-3-内存池" class="headerlink" title="1.3 内存池"></a>1.3 内存池</h3><ol><li><p>内存泄漏</p><ul><li>C 语言不具备垃圾回收机制,需要手动释放内存.<code>malloc</code> 和 <code>free</code> 应该成对编写</li><li><code>malloc</code> 可以申请任意尺寸的内存空间.得到的空间是连续的,经常使用数组索引</li></ul></li><li><p>内存池: 预先从系统申请分配一大块内存.然后由程序自己管理这块内存的分配和释放,而不是每次需要时都想操作系统申请</p><ul><li>频繁使用 <code>malloc</code> 和 <code>free</code> 手动分配和释放内存很容易产生大量的内存碎片</li><li>系统调用开销: <code>malloc</code> 函数向操作系统申请堆内存经历了从应用层切入系统内核层的过程</li><li><code>malloc</code> 的执行时间是不确定的.取决于当前堆的状态,对于实时系统是致命的</li></ul></li><li><p>内存池的工作流程</p></li></ol><ul><li>预分配: 在程序初始化或对象创建时,一次性向系统申请一大块连续内存<ul><li>自定义分配: 当程序需要内存时,从这块预分配的内存中划出一部分给程序使用</li><li>自定义释放: 当程序释放内存时,并不真正还给系统.而是将其标记为空闲,放回池中供下次分配使用</li><li>集中销毁: 当整个池不再需要时(如程序退出或对象销毁), 一次性将整块大内存归还给系统</li></ul></li></ul><ol start="4"><li>固定大小内存池(Fixed-Size Pool)</li></ol><ul><li>思想: 池中所有内存块都是固定大小的</li><li>优点: 分配和释放仅为 O(1),速度块; 不会产生无法利用的小空闲块; 分配 &#x2F; 释放的时间固定</li><li>缺点: 申请的大小与池中块大小不匹配时无法使用.通常用于频繁分配单一类型对象的场景</li><li>工作流程<ul><li>将大内存块分割为一个个大小相等的小块</li><li>用一个空闲链表将这些小块连接</li><li>分配时,从链表头部取下一块,返回给用户</li><li>释放时,将用户还回的块重新插回链表头部</li></ul></li></ul><h2 id="2-文件-IO"><a href="#2-文件-IO" class="headerlink" title="2 文件 IO"></a>2 文件 IO</h2><h3 id="2-1-打开文件"><a href="#2-1-打开文件" class="headerlink" title="2.1 打开文件"></a>2.1 打开文件</h3><ol><li><p>文件操作的思想</p><ul><li>流(stream): C 将 文件, 设备, 内存缓冲区抽象为 流.是一个单向流动的数据序列</li><li>缓冲机制(buffering): 程序不直接与硬件交互,而是与一块内存区域(缓冲)交互.直接满足特定条件时进行 flush</li><li>文件指针(file pointer): 流的具体实现通过 <code>FILE</code> 的结构体来管理.而 <code>FILE *</code> 变量即为操作文件的句柄</li></ul></li><li><p>程序启动时,会自动打开三个标准流,无需 <code>fopen</code></p><ul><li><code>stdin</code>: 标准输入(通常对应键盘).用于 <code>scanf, getchar</code> 等</li><li><code>stdout</code>: 标准输出(通常对应显示器).用于 <code>printf, puts</code> 等</li><li><code>stderr</code>: 标准错误(通常对应显示器).用于输出错误信息</li></ul></li><li><p>缓冲区</p><ul><li><p>对于写入操作,程序会先将数据写入缓冲区,直到缓冲区被写满或文件关闭时才一次性写入设备中</p></li><li><p>对于读取操作,如果数据已经在缓冲区中,则立即返回给程序.否则,系统会将一大块数据从设备读入缓冲区</p></li><li><p>如果需要立即将数据写入设备中,可使用 <code>fflush</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fflush</span><span class="hljs-params">(FILE *stream)</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>fopen</code>: 打开一个文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *<span class="hljs-title function_">fopen</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode )</span>;<br><span class="hljs-comment">// 调用成功返回一个指向 FILE 结构的文件指针.通过该指针对文件进行操作.失败返回 NULL</span><br></code></pre></td></tr></table></figure></li><li><p>打开模式</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>“r”</td><td>只读.文件必须存在</td></tr><tr><td>“w”</td><td>只写.文件存在则清空,不存在则创建</td></tr><tr><td>“a”</td><td>追加.文件存在则追加到末尾,不存在则创建</td></tr><tr><td>“r+”</td><td>读写.文件必须存在</td></tr><tr><td>“w+”</td><td>读写.文件存在则清空,不存在则创建</td></tr><tr><td>“a+”</td><td>读写.文件存在则可读可追加,不存在则创建</td></tr><tr><td>b</td><td>可与以上6种模式结合(如 “rb, “r+b”); 表示操作对象为二进制文件</td></tr></tbody></table></li><li><p><code>fclose</code> 函数: 关闭一个文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fclose</span><span class="hljs-params">( FILE *fp )</span>;<br><span class="hljs-comment">/* fp: 使用 fopen 获取的文件指针</span><br><span class="hljs-comment"> * 调用成功返回0,失败返回 EOF</span><br><span class="hljs-comment"> * 调用 fclose 后系统才会将缓冲区的数据写入文件,并释放该文件的相关资源*/</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-顺序读写"><a href="#2-2-顺序读写" class="headerlink" title="2.2 顺序读写"></a>2.2 顺序读写</h3><ol><li><p>读取单个字符(下列函数均声明于 <code>&lt;stdio.h&gt;</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fgetc, getc: 从文件流中读取下一个字符,并推进文件的位置指示器 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fgetc</span><span class="hljs-params">(FILE *stream)</span>;  <span class="hljs-comment">// 函数原型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getc</span><span class="hljs-params">(FILE *stream)</span>;   <span class="hljs-comment">// 通常实现为宏</span><br></code></pre></td></tr></table></figure></li><li><p>写入单个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fputc, putc 函数: 向文件流写入单个字符 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *stream)</span>;  <span class="hljs-comment">// 函数原型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *stream)</span>;   <span class="hljs-comment">// 通常实现为宏</span><br><span class="hljs-comment">/* 返回值: 遇到错误或文件结束时返回 EOF.否则返回已写入的字符本身 */</span><br></code></pre></td></tr></table></figure></li><li><p>读取字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fgets 函数: 从指定的文件中读取字符串 */</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> size, FILE *stream)</span>;<br><span class="hljs-comment">/* s: 指向存放读取得到字符串的位置</span><br><span class="hljs-comment"> * size: 指定读取的字符数(包括自动添加的 &#x27;\0&#x27;).想读取10个字符,应令 size = 11</span><br><span class="hljs-comment"> * stream: 指定一个待操作的数据流</span><br><span class="hljs-comment"> * 返回值: 调用成功,返回 s 指向的地址.若发生错误,返回 NULL</span><br><span class="hljs-comment"> * 当遇到换行符 &#x27;\n&#x27; 就会停止本次字符串的读取</span><br><span class="hljs-comment"> * 注意 gets 函数不安全,已被 C99 弃用并从 C11 除名 */</span><br></code></pre></td></tr></table></figure></li><li><p>写入字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fputs 函数: 将字符串写入到指定的文件中,结尾的 &#x27;\0&#x27; 不会被写入 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, FILE *stream)</span>;<br><br><span class="hljs-comment">/* puts 函数: 将字符串写入 stdout 并自动追加换行符.方便打印消息 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">puts</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;<br></code></pre></td></tr></table></figure></li><li><p>格式化读写文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fscanf 函数: f 表示 file,对文件进行读取 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fscanf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br><br><span class="hljs-comment">/* fprintf 函数: f 表示 file,对文件进行写入 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br></code></pre></td></tr></table></figure></li><li><p>二进制读写文件</p><ul><li><code>fopen</code> 函数可以指定文件的打开模式(文本, 二进制).但后续对文件的操作并不一定是对应的形式</li><li>无论以哪种模式打开文件,都不能决定写入数据的形式.它们只是影响换行符的表现形式.</li><li>真正决定数据写入模式的是 相关的文件读写函数</li></ul></li><li><p><code>fread</code> 函数: 从指定文件中读取指定尺寸的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">fread</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span>;<br><span class="hljs-comment">/* ptr:     指向存放数据的内存块地址</span><br><span class="hljs-comment"> * size:    待读取的每个元素的尺寸</span><br><span class="hljs-comment"> * nmemb:   指定待读取的元素个数</span><br><span class="hljs-comment"> * stream:  指向一个待读取的文件流</span><br><span class="hljs-comment"> * 返回值:  调用成功返回实际读取到的元素个数,即 nmemb</span><br><span class="hljs-comment"> * 如果返回值小于 nmemb,说明读取到文件末尾或发生错误 */</span><br></code></pre></td></tr></table></figure></li><li><p><code>fwrite</code> 函数: 将指定数据写入到指定文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">fwrite</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span>;<br><span class="hljs-comment">/* ptr:    指向存放数据的内存块地址</span><br><span class="hljs-comment"> * size:   待写入的每个元素的尺寸</span><br><span class="hljs-comment"> * nmemb:  指定待写入的元素个数</span><br><span class="hljs-comment"> * stream: 指向一个待写入的文件流 */</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-随机读写"><a href="#2-3-随机读写" class="headerlink" title="2.3 随机读写"></a>2.3 随机读写</h3><ol><li><p>系统为每个打开的文件设置了一个位置指示器,用于表示当前的读写位置</p></li><li><p><code>ftell</code> 函数: 返回当前的读写位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">ftell</span><span class="hljs-params">(FILE *stream)</span>;<br><span class="hljs-comment">/* stream: 指定待操作的文件流</span><br><span class="hljs-comment"> * 返回值: 指定文件的当前读写位置</span><br><span class="hljs-comment"> * 如果将文件看作一个数组,那么 ftell 的返回值就是&quot;数组&quot;的下标 */</span><br></code></pre></td></tr></table></figure></li><li><p><code>fseek</code> 函数: 设置文件位置指示器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">long</span> <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> whence)</span>;<br><span class="hljs-comment">/* stream: 指定待操作的文件流</span><br><span class="hljs-comment"> * offset: 指定偏移的字节数量</span><br><span class="hljs-comment"> * whence: 指定开始偏移的位置 */</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>whence</th><th>说明</th></tr></thead><tbody><tr><td>SEEK_SET</td><td>文件开头</td></tr><tr><td>SEEK_CUR</td><td>当前位置</td></tr><tr><td>SEEK_END</td><td>文件末尾</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">fseek(fp, <span class="hljs-number">100</span>, SEEK_SET); <span class="hljs-comment">// 定位到文件的第100字节位置</span><br>fseek(fp, <span class="hljs-number">-5</span>, SEEK_END);  <span class="hljs-comment">// 定位到文件的倒数第5个字节位置</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>fseek</code> 需要考虑可移植性</p><ul><li>不同操作系统对换行符的处理不同,导致定位会出现误差</li><li>对于二进制模式打开的文件, <code>fseek</code> 在某些操作系统中可能不支持 SEEK_END</li><li>对于文本模式打开的文件, <code>whence</code> 参数只有取 SEEK_SET 才有意义</li><li>传递给 offset 的参数值要么为 0,要么是上一次对同一文件调用 <code>ftell</code> 函数获得的返回值</li></ul></li></ol><h2 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3 面向对象"></a>3 面向对象</h2><h3 id="3-1-封装"><a href="#3-1-封装" class="headerlink" title="3.1 封装"></a>3.1 封装</h3><ol><li><p><strong>封装: 隐藏实现细节,仅暴露必要接口</strong></p></li><li><p>实现方式: 使用 <code>struct</code> 存储数据,使用头文件(<code>.h</code>)声明公共接口,而源文件(<code>.c</code>)隐藏私有实现</p></li><li><p><code>person.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 不完整类型(此处仅声明,不定义)隐藏数据细节 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> <span class="hljs-title">Person</span>;</span><br><br><span class="hljs-comment">/* 构造函数 / 析构函数 */</span><br>Person* <span class="hljs-title function_">person_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">person_destroy</span><span class="hljs-params">(Person *p)</span>;<br><br><span class="hljs-comment">/* 公共方法(接口)隐藏实现细节 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_name</span><span class="hljs-params">(Person *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">person_get_name</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_age</span><span class="hljs-params">(Person *p, <span class="hljs-type">int</span> age)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">person_get_age</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">person_greet</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>person.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span></span><br><br><span class="hljs-comment">/* 完整定义 Person(仅在此文件可见) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">/* 实现构造函数 / 析构函数 */</span><br>Person* <span class="hljs-title function_">person_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age)</span> &#123;<br>    Person *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Person));<br>    p-&gt;name = strdup(name);<br>    p-&gt;age = age;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_destroy</span><span class="hljs-params">(Person *p)</span> &#123;<br>    <span class="hljs-built_in">free</span>(p-&gt;name);<br>    <span class="hljs-built_in">free</span>(p);<br>&#125;<br><br><span class="hljs-comment">/* 公共方法实现 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_greet</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, I&#x27;m %s, age %d!\n&quot;</span>, p-&gt;name, p-&gt;age);<br>&#125;<br><br><span class="hljs-comment">/* set, get 方法实现 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_name</span><span class="hljs-params">(Person *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span> &#123;<br>    <span class="hljs-built_in">free</span>(p-&gt;name);<br>    p-&gt;name = strdup(name);<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">person_get_name</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span> &#123;<br>    <span class="hljs-keyword">return</span> p-&gt;name;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_age</span><span class="hljs-params">(Person *p, <span class="hljs-type">int</span> age)</span> &#123;<br>    p-&gt;age = age;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">person_get_age</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span> &#123;<br>    <span class="hljs-keyword">return</span> p-&gt;age;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code> 使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;student.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    Person *p = person_create(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>);<br>    person_greet(p);  <span class="hljs-comment">// 输出: Hello, I&#x27;m Alice, age 25!</span><br>    person_set_age(p, <span class="hljs-number">10</span>);<br>    person_set_name(p, <span class="hljs-string">&quot;Bob&quot;</span>);<br>    person_greet(p);  <span class="hljs-comment">// 输出: Hello, I&#x27;m Bob, age 10!</span><br>    person_destroy(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-2-继承"><a href="#3-2-继承" class="headerlink" title="3.2 继承"></a>3.2 继承</h3><ol><li><p><strong>继承: 子类继承父类的属性和方法</strong></p></li><li><p>实现方式: 结构体嵌套(父结构体作为子结构体的第一个成员),通过类型转换模拟继承</p></li><li><p><code>student.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">Student</span>;</span><br>Student* <span class="hljs-title function_">student_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *university)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">student_destroy</span><span class="hljs-params">(Student *s)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">student_study</span><span class="hljs-params">(<span class="hljs-type">const</span> Student *s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *subject)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>student.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;student.h&quot;</span></span><br><br><span class="hljs-comment">/* Student 的私有定义 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> &#123;</span><br>    Person *base;     <span class="hljs-comment">// 通过指针持有 Person(避免不完整类型问题)</span><br>    <span class="hljs-type">char</span> *university; <span class="hljs-comment">// 子类特有的数据</span><br>&#125;;<br><br><span class="hljs-comment">/* Student 的构造函数.通过调用 Person 的构造函数工作 */</span><br>Student* <span class="hljs-title function_">student_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *university)</span> &#123;<br>    Student *s = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Student));<br>    s-&gt;base = person_create(name, age);<br>    s-&gt;university = strdup(university);<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-comment">/* Student 的析构函数.通过调用 Person 的析构函数工作 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">student_destroy</span><span class="hljs-params">(Student *s)</span> &#123;<br>    person_destroy(s-&gt;base);<br>    <span class="hljs-built_in">free</span>(s-&gt;university);<br>    <span class="hljs-built_in">free</span>(s);<br>&#125;<br><br><span class="hljs-comment">/* 子类 Student 独有的方法 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">student_study</span><span class="hljs-params">(<span class="hljs-type">const</span> Student *s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *subject)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s is studying %s at %s.\n&quot;</span>, person_get_name(s-&gt;base), subject, s-&gt;university);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code> 使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;student.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">/* 创建 Student 对象(已经完全隐藏了 Person 的细节) */</span><br>    Student *s = student_create(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Stanford&quot;</span>);<br>    student_study(s, <span class="hljs-string">&quot;Computer Science&quot;</span>);  <span class="hljs-comment">// 只能依赖公共接口工作</span><br>    student_destroy(s);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-3-多态"><a href="#3-3-多态" class="headerlink" title="3.3 多态"></a>3.3 多态</h3><ol><li><p><strong>多态: 同一接口,不同实现</strong>(使用函数指针实现动态绑定.类似 C++ 的虚函数表)</p></li><li><p><code>shape.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Shape 基类前向声明 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Shape</span> <span class="hljs-title">Shape</span>;</span><br><br><span class="hljs-comment">/* Shape 虚函数表(模拟 C++ 的 vtable).并为子类提供必要的定义 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ShapeVTable</span> &#123;</span><br>    <span class="hljs-type">void</span> (*draw)(<span class="hljs-type">const</span> Shape *);<br>    <span class="hljs-type">double</span> (*area)(<span class="hljs-type">const</span> Shape *);<br>&#125; ShapeVTable;<br><br><span class="hljs-comment">/* Shape 基类结构体(子类需要了解布局) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Shape</span> &#123;</span><br>    <span class="hljs-type">const</span> ShapeVTable *vtable; <span class="hljs-comment">// 每个对象绑定自己的虚表</span><br>&#125;;<br><br><span class="hljs-comment">/* Shape 公共接口(多态方法) */</span><br><span class="hljs-type">void</span>   <span class="hljs-title function_">shape_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">shape_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span>;<br><span class="hljs-type">void</span>   <span class="hljs-title function_">shape_delete</span><span class="hljs-params">(Shape *shape)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>shape.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><br><span class="hljs-comment">/* 多态方法: 通过虚表调用具体实现 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">shape_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-keyword">if</span> (shape &amp;&amp; shape-&gt;vtable &amp;&amp; shape-&gt;vtable-&gt;draw) &#123;<br>        shape-&gt;vtable-&gt;draw(shape);<br>    &#125;<br>    <span class="hljs-comment">// 可以添加错误处理</span><br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">shape_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-keyword">if</span> (shape &amp;&amp; shape-&gt;vtable &amp;&amp; shape-&gt;vtable-&gt;area) &#123;<br>        <span class="hljs-keyword">return</span> shape-&gt;vtable-&gt;area(shape);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>; <span class="hljs-comment">// 可以添加错误处理</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">shape_delete</span><span class="hljs-params">(Shape *shape)</span> &#123;<br>    <span class="hljs-built_in">free</span>(shape);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>circle.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> <span class="hljs-title">Circle</span>;</span><br>Circle *<span class="hljs-title function_">circle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>circle.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;circle.h&quot;</span></span><br><br><span class="hljs-comment">/* Circle 的私有定义 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> &#123;</span><br>    Shape base;  <span class="hljs-comment">// 继承 Shape(必须放在首位)</span><br>    <span class="hljs-type">double</span> radius;<br>&#125;;<br><br><span class="hljs-comment">/* Circle 的 draw 实现 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">circle_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Circle *circle = (<span class="hljs-type">const</span> Circle *)shape; <span class="hljs-comment">// 向下转型</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Circle (radius=%.2f)\n&quot;</span>, circle-&gt;radius);<br>&#125;<br><br><span class="hljs-comment">/* Circle 的 area 实现 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">circle_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Circle *circle = (<span class="hljs-type">const</span> Circle *)shape;<br>    <span class="hljs-keyword">return</span> M_PI * circle-&gt;radius * circle-&gt;radius;<br>&#125;<br><br><span class="hljs-comment">/* Circle 的虚表 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> ShapeVTable circle_vtable = &#123;<br>    .draw = circle_draw,<br>    .area = circle_area<br>&#125;;<br><br><span class="hljs-comment">/* Circle 构造函数 */</span><br>Circle *<span class="hljs-title function_">circle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br>    Circle *circle = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Circle));<br>    <span class="hljs-keyword">if</span> (circle) &#123;<br>        circle-&gt;base.vtable = &amp;circle_vtable;<br>        circle-&gt;radius = radius;<br>    &#125;<br>    <span class="hljs-keyword">return</span> circle;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>rectangle.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span> <span class="hljs-title">Rectangle</span>;</span><br>Rectangle *<span class="hljs-title function_">rectangle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>rectangle.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rectangle.h&quot;</span></span><br><br><span class="hljs-comment">/* Rectangle 的私有定义 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span> &#123;</span><br>    Shape base;  <span class="hljs-comment">// 继承 Shape(必须放在首位)</span><br>    <span class="hljs-type">double</span> width, height;<br>&#125;;<br><br><span class="hljs-comment">/* Rectangle 的 draw 实现 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rectangle_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Rectangle *rect = (<span class="hljs-type">const</span> Rectangle *)shape;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Rectangle (%.2f x %.2f)\n&quot;</span>, rect-&gt;width, rect-&gt;height);<br>&#125;<br><br><span class="hljs-comment">/* Rectangle 的 area 实现 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">rectangle_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Rectangle *rect = (<span class="hljs-type">const</span> Rectangle *)shape;<br>    <span class="hljs-keyword">return</span> rect-&gt;width * rect-&gt;height;<br>&#125;<br><br><span class="hljs-comment">/* Rectangle 的虚表 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> ShapeVTable rectangle_vtable = &#123;<br>    .draw = rectangle_draw,<br>    .area = rectangle_area<br>&#125;;<br><br><span class="hljs-comment">/* Rectangle 构造函数 */</span><br>Rectangle *<span class="hljs-title function_">rectangle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height)</span> &#123;<br>    Rectangle *rect = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Rectangle));<br>    <span class="hljs-keyword">if</span> (rect) &#123;<br>        rect-&gt;base.vtable = &amp;rectangle_vtable;<br>        rect-&gt;width = width;<br>        rect-&gt;height = height;<br>    &#125;<br>    <span class="hljs-keyword">return</span> rect;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;circle.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rectangle.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">/* 创建不同子类对象 */</span><br>    Circle *circle = circle_create(<span class="hljs-number">3.0</span>);<br>    Rectangle *rectangle = rectangle_create(<span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>);<br><br>    <span class="hljs-keyword">if</span> (!circle || !rectangle) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Memory allocation failed!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 用基类指针存储 */</span><br>    Shape *shapes[] = &#123;<br>        (Shape *)circle,<br>        (Shape *)rectangle,<br>    &#125;;<br><br>    <span class="hljs-comment">/* 多态调用 */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>        shape_draw(shapes[i]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Area: %.2f\n\n&quot;</span>, shape_area(shapes[i]));<br>    &#125;<br><br>    <span class="hljs-comment">/* 使用统一的删除接口 */</span><br>    shape_delete((Shape *)circle);<br>    shape_delete((Shape *)rectangle);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Circle (radius=3.00)<br>Area: 28.27<br><br>Rectangle (4.00 x 5.00)<br>Area: 20.00<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-重载"><a href="#3-4-重载" class="headerlink" title="3.4 重载"></a>3.4 重载</h3><ol><li><p><code>_Generic</code> 是 C11 引入的编译时类型选择机制.根据表达式的类型在编译期选择不同的代码分支</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">_Generic</span>(expression, \<br>    type1: value1,   \<br>    type2: value2,   \<br>    ...,             \<br>    <span class="hljs-keyword">default</span>: value   \<br>)<br></code></pre></td></tr></table></figure><ul><li><code>_Generic</code> 仅通过 <code>expression</code> 分析类型,不会计算 <code>expression</code></li><li><code>_Generic</code> 可以返回任意类型.如函数指针(然后立即进行函数调用,实现函数重载)</li><li><code>_Generic</code> 支持匹配各种类型.如指针, 数组, 结构体</li><li><code>_Generic</code> 会将 <code>const, volatile</code> 也作为区别类型的依据</li><li>必须有匹配到的类型. 若没有匹配到的类型且没有 <code>default</code>, 将会编译报错</li></ul></li><li><p>根据类型返回不同的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> type_name(X) _Generic((X), \</span><br><span class="hljs-meta">    int:     <span class="hljs-string">&quot;int&quot;</span>,                \</span><br><span class="hljs-meta">    double:  <span class="hljs-string">&quot;double&quot;</span>,             \</span><br><span class="hljs-meta">    char*:   <span class="hljs-string">&quot;string&quot;</span>,             \</span><br><span class="hljs-meta">    default: <span class="hljs-string">&quot;unknown&quot;</span>             \</span><br><span class="hljs-meta">)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, type_name(<span class="hljs-number">10</span>));      <span class="hljs-comment">// 输出 &quot;int&quot;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, type_name(<span class="hljs-number">3.14</span>));    <span class="hljs-comment">// 输出 &quot;double&quot;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, type_name(<span class="hljs-string">&quot;hello&quot;</span>)); <span class="hljs-comment">// 输出 &quot;string&quot;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, type_name(<span class="hljs-string">&#x27;A&#x27;</span>));     <span class="hljs-comment">// 输出 &quot;unknown&quot;(char 未定义)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>模拟函数重载</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">print_int</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;int: %d\n&quot;</span>, x); &#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">print_double</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;double: %f\n&quot;</span>, x); &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> print(X) _Generic((X), \</span><br><span class="hljs-meta">    int:    print_int,         \</span><br><span class="hljs-meta">    double: print_double       \</span><br><span class="hljs-meta">)(X) <span class="hljs-comment">/* 注意: 这里紧接着的 (X) 是函数调用 */</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    print(<span class="hljs-number">10</span>);   <span class="hljs-comment">// 调用 print_int</span><br>    print(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// 调用 print_double</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-算法分析"><a href="#4-算法分析" class="headerlink" title="4 算法分析"></a>4 算法分析</h2><h3 id="4-1-分析方法"><a href="#4-1-分析方法" class="headerlink" title="4.1 分析方法"></a>4.1 分析方法</h3><ol><li>基本概念<ul><li>数据结构: 组织大量数据的方法</li><li>算法分析: 对算法运行时间的评估</li><li><strong>算法(algorithm)</strong>: 为求解一个问题所需遵循的,被清楚指定的简单指令集合</li><li>当某种算法被给定时,则需要确定该算法所需的时间和空间等资源量</li></ul></li><li>建立无穷大量之间的相对级别<ul><li>$\mathrm{if} \quad \exists c,n_0\in N_+,N\geq n_0\quad\mathrm{s.t.} T(N)\leq cf(N), \mathrm{then} \quad T(N)&#x3D;O(f(N))$</li><li>$\mathrm{if} \quad \exists c,n_0\in N_+,N\geq n_0  \quad  \mathrm{s.t.} T(N)\geq cg(N),\mathrm{then} \quad T(N)&#x3D;\Omega(g(N))$</li><li>$T(N)&#x3D;O(h(N))  \quad and\quad T(N)&#x3D;\Omega(h(N)) \iff T(N)&#x3D;\Theta(h(N))$</li><li>$T(N)&#x3D;O(p(N)) \quad and \quad T(N)\neq \Theta(p(N)), \mathrm{then} \quad T(N)&#x3D;o(f(N))$</li></ul></li><li>简要说明<ul><li>$O$: 高阶无穷大</li><li>$\Omega$: 低阶无穷大</li><li>$\Theta$: 同阶无穷大</li><li>$o$: 严格的高阶无穷大</li></ul></li><li><strong>一般采用大 $O$ 记法</strong>.例如 $T(N)&#x3D;2N^2+N&#x3D;O(N^2)$<ul><li>不要将常数或低阶项放入大 $O$,直接忽略即可</li><li>典型的增长率(递增排列): $C, \mathrm{log}N, \mathrm{log}^2N, N, N\mathrm{log}N, N^2, N^3, 2^N$</li><li>可以使用洛必达法则确定两个函数的相对级别</li></ul></li><li>待分析的问题<ul><li>最重要的资源一般为运行时间</li><li>在这里分析对运行时间的影响因素有: 使用的算法, 对该算法的输入(主要方面)</li><li>考虑两个函数<ul><li>$T_{avg}(N)$: 输入为 N 时算法所花费的平均时间</li><li>$T_{worst}(N)$: 输入为 N 时算法在最坏情况下花费的时间</li><li><strong>主要考虑 $T_{worst}(N)$.因为它为所有的输入提供了一个运行时间上界</strong></li></ul></li><li>当两个程序花费的时间大致相同时,判断运行速度的方法是将其编码并运行</li><li>为简化分析,系数,低阶项,常数项直接抛弃.只计算其上界,即 大 $O$</li></ul></li></ol><h3 id="4-2-排序算法"><a href="#4-2-排序算法" class="headerlink" title="4.2 排序算法"></a>4.2 排序算法</h3><ol><li><p>排序算法接受的参数为: 数组首地址, 及一个表示数组元素个数的整数</p><ul><li>基于比较的排序: 假定对于元素而言,运算符 <code>&lt;, &gt;</code> 是存在的</li><li>逆序(inversion): 与线性代数中的关于排列的逆序数定义类似<ul><li>n 个互异数的数组的平均逆序数为 $\frac{n(n-1)}4$</li><li>通过交换相邻元素进行排序的任何算法平均需要 $\Omega(N^2)$</li><li>排序算法通过删除逆序进行,为了有效运行,必须每次删除不止一个逆序</li></ul></li></ul></li><li><p>排序的一般下界</p><ul><li>任何只用到比较的算法在最坏的情况下需要 $\Omega(N\log N)$ 次比较,因而归并排序和堆排序最优</li><li>任何只用到比较的算法在平均的情况下需要 $\Omega(N\log N)$ 次比较,因而快速排序是最优的</li></ul></li><li><p>桶排序(bucket sort)</p><ul><li>问题: 存在 $n$ 个整数 $a_i(0\leq x_i\leq M-1,1\leq i\leq n)$ 需要排序</li><li>预留一个大小为 $M$ 的 count 数组.即 count 有 $M$ 个单元(桶).初始情况下 count 内元素为空</li><li>当 $a_i$ 被读入时,$\mathrm{count}[a_i]$ 自增1;所有的输入被读入后,扫描数组 count,打印排好序的表</li><li>该算法的时间花费为 $O(M+N)$</li></ul></li><li><p>基数排序(radix sort)是桶式排序的推广</p><ul><li><p>考虑当桶的数量远大于数的个数时.桶排序便不再适合</p></li><li><p>若存在 $n$ 个整数 $a_i(0\leq x_i\leq n^p-1,1\leq i\leq n)$ 需要排序.进行多次桶式排序</p></li><li><p>第一步以最低位进行桶式排序,依次按位数桶式排序,直到最高位完成进行桶式排序</p></li><li><p>该算法的时间花费为 $O(p(n+b))$.其中 p 为趟数,n 为元素个数,b 为桶数</p></li><li><p>例: 对 0~9 的立方进行基数排序</p><ul><li>原始数组: [0, 1, 512, 343, 64, 125, 216, 27, 8, 729]</li><li>第一次排序结果: [0, 1, 512 ,343, 64, 125, 216, 27, 8, 729]</li><li>第二次排序结果: [8, 1, 0], [216, 512], [729,27,125],  [343], [64]</li><li>第三次排序结果: [64,27,8,1,0], [125], [216], [343], [512], [729]</li></ul></li></ul></li><li><p>插入排序(insert sort)</p><ul><li><p>将数组假想为两部分: 前面的为已排序数组,后面的为待排序数组</p></li><li><p>初始状态为已排序数组只有第一个元素,剩余为待排序数组</p></li><li><p>遍历待排序数组,将每个未排序元素插入到已排序数组中恰当的位置</p></li><li><p>时间复杂度: $O(N^2)$</p><ul><li>当输入数据为逆序时,达到此上界</li><li>当输入数据已排序时,运行时间为 $O(N)$</li><li>对于几乎已经排序的数据(逆序数 I 较小),插入排序很快,其时间为 $O(I+N)$</li></ul></li></ul></li><li><p>希尔排序(缩小增量排序, diminishing increment sort): 先将整个待排序的序列分割为若干子序列分别进行直接插入排序,待整个序列中的记录基本有序时,在对全体进行直接插入排序</p><ul><li><p>增量序列: $h_1, h_2, \dots,h_t$,其中 $h_1 &#x3D; 1$</p></li><li><p>$h_k$-排序数组: $\forall i,arr[i] \leq arr[i+h_k]$</p></li><li><p>希尔增量通常取 $h_t &#x3D; \lfloor n&#x2F;2 \rfloor, h_k &#x3D; \lfloor h_{k+1}&#x2F;2 \rfloor$</p></li><li><p>时间复杂度(希尔排序算法简单,但分析极其困难)</p><ul><li>希尔增量下的希尔排序的最坏情形运行时间 $\Theta(N^2)$</li><li>Hibbard 增量: 形如 $1, 3, 7, \dots , 2^k-1$.最坏情形运行时间 $\Theta(N^\frac32)$</li></ul></li></ul></li><li><p>堆排序(heap sort): 考虑建立二叉堆 $O(N)$,执行 N 次 <code>deleteMin</code> $O(N\log N)$.按照顺序,最小的元素将会先离开堆,将这些元素记录到第二个数组即可得到排序数组</p><ul><li>上述算法需要额外的数组空间,可以每次在 <code>deleteMin</code> 操作后,将最后空出来的单元用于存放元素.此时得到的将是逆序的排序数组,因而可以构建具有 <code>deleteMax</code> 操作的二叉堆</li><li>堆排序是非常稳定的算法: 平均使用的比较只比最坏情形略少</li></ul></li><li><p>归并排序(merge sort): 以分治递归的形式合并已排序数组 $O(N\log N)$.使用的比较次数几乎最优</p><ul><li>考虑合并2个已排序的数组: 设定2个指针分别指向数组的起始位置.比较2个指针指向的元素,将较小的元素放入输出数组,并移动指针.重复这一过程,直到某一指针到达末尾</li></ul></li><li><p>快速排序(quick sort): 实践中最快的已知排序算法,平均运行时间 $O(N\log N)$</p><ul><li><p>若 S 中元素个数为 0 或 1,则直接返回</p></li><li><p>选取 S 中的任意元素 v,其称为基准(pivot)</p></li><li><p>分区并排序: 将 $S-{v}$ 分为两个不相交集合: $S_1 &#x3D;{x\in S-{v}|x\leq v},S_2 &#x3D;{x\in S-{v}|x\geq v} $ </p></li><li><p>递归地将小于基准元素的子数列和大于基准值元素的子数组排序</p></li><li><p>选取基准</p><ul><li>错误的方式: 选取第一个元素作为基准.若输入是预排序或反序的,将会产生劣质的分割</li><li>安全的方式: 随机选取基准.但考虑到生成随机数是昂贵的,因而无法减少算法其余部分的平均运行时间</li><li>数中值分割法: 基准的最好选择是数组的中值,但这很难算出.因而可以考虑三个元素(左侧,中心,右侧位置)的中值作为基准.消除了预排序输入的坏情形,并减少约 5% 的时间</li></ul></li><li><p>分割策略</p><ul><li>将基准元与最后的元素进行交换,使得基准元离开要被分割的数据段</li><li>设置双指针 i, j. 初始时刻分别指向数组的第一个元素和倒数第二个元素(因为最后一个元素为基准)</li><li>当 i &lt; j 时,将 i 右移,直到遇到大于基准元的数.同理,将 j 左移,直到遇到小于基准元的数</li><li>若停止后的仍满足 i &lt; j,则将 i, j 指向的两个元素互换.重复该过程,直到 i, j 彼此交错</li><li>当 i, j 交错后,将基准元与 i 所指向的元素互换,即可完成分割</li></ul></li><li><p>对于小数组(n &lt; 20),快速排序不如插入排序好</p><ul><li>由于快速排序是递归的,因此小数组排序的情况经常发生</li><li>对小数组不进行递归排序,而进行插入排序将会节约15%的时间.截至范围可选择 n&#x3D;10</li></ul></li></ul></li></ol><h3 id="4-3-贪婪算法"><a href="#4-3-贪婪算法" class="headerlink" title="4.3 贪婪算法"></a>4.3 贪婪算法</h3><ol><li>贪婪算法分阶段工作.在每一个阶段,认为所作的决定是最好的,而不考虑将来的后果(即局部最优)<ul><li>当算法终止时,若局部最优就是全局最优,则算法正确.否则将得到一个次优解(suboptimal solution)</li><li>若不要求绝对最佳答案,也可通过简单的贪婪算法生成近似答案</li></ul></li><li>Huffman 编码<ul><li>ASCII 编码有约100个可打印字符和控制字符组成,需要 $\lceil \log 128\rceil&#x3D;7$ 位表示,可添加第8位作为校验位<ul><li>现实中,许多文件都含有大量的数字,空格和换行,而 q, x 很少</li><li>采用非等长编码,使经常出现的字符代码较短,可以节约磁盘空间</li></ul></li><li>对于代表字符的二进制代码,可以用二叉树来表示<ul><li>只在树叶上有数据.且每个字符从根节点开始,用0指示向左分支,用1指示向右分支</li><li>若字符 $c_i$ 在深度 $d_i$ 处,且出现 $f_i$ 次.则该字符代码的值(cost)为 $\sum d_i f_i$</li></ul></li></ul></li><li>Huffman 算法<ul><li>假设字符数量为 C.算法开始时存在 C 棵单节点树(每个字符一颗)</li><li>任意选取有最小权(树的权等于其树叶频率的和)的两棵树,任意形成以这两棵树为子树的新树</li><li>将这样的过程进行 C-1 次.即可得到最优 Huffman 编码树</li></ul></li></ol><h3 id="4-4-分治算法"><a href="#4-4-分治算法" class="headerlink" title="4.4 分治算法"></a>4.4 分治算法</h3><ol><li>分治(divide and conquer)算法<ul><li>分: 递归解决较小的问题(基本情况除外)</li><li>治: 从子问题的解 构建原问题的解</li></ul></li><li>最近点问题: 找出平面上点列中最近(欧几里得距离)的一对点<ul><li>暴力算法: 计算每个点对之间的距离,找出最小值 $O(N^2)$</li><li>分治算法思路<ul><li>将平面上的点分为两半,最近点对存在三种可能: 均在左, 均在右, 一个在左一个在右</li><li>记不同情况的最近点对的最小距离为: 左侧点集 $d_l$,右侧点集 $d_r$,两侧点间的距离 $d_c$</li><li>对于 $d_l, d_r$,可以递归的进行计算.关键在于如何计算 $d_c$</li></ul></li><li>$d_c$ 的计算<ul><li>令 $\delta &#x3D; \min(d_l, d_r)$.如果 $d_c$ 对 $\delta$ 有改进,则只需计算 $d_c$</li><li>若 $d_c$ 是这样的距离,则定义 $d_c$ 的两个点必然在分割线的 $\delta$ 邻域内(一个带状区域).限制考察点的数量</li><li>对于均匀分布的点集,则平均有 $O(\sqrt N)$ 个点位于邻域内,此时可采用暴力求解 $O(N)$</li></ul></li></ul></li><li>选择问题: 找出含有 N 个元素的表 S 中的第 k 个最小的元素(对于中位数 $k &#x3D; \lceil N&#x2F;2 \rceil$ 特别关注)<ul><li>通过对元素的快速排序,此问题以 $O(N\log N)$ 的最坏情形时间解决</li><li>五分化中项的中项 选择快速排序的基准<ul><li>将 N 个元素分为 $\lfloor N&#x2F;5 \rfloor$ 组,每5个元素一组,最多忽略4个元素</li><li>找出每组的中项,得到 $\lfloor N&#x2F;5 \rfloor$ 个中项的表 M,找出 M 的中项并返回</li></ul></li><li>使用五分化中项的中项的快速选择算法的运行时间为 $O(N)$.但实践中该算法并不实用</li></ul></li></ol><h3 id="4-5-动态规划"><a href="#4-5-动态规划" class="headerlink" title="4.5 动态规划"></a>4.5 动态规划</h3><ol><li><p>动态规划(dynamic programming)</p><ul><li>动态规划将复杂问题分解为相对简单的子问题.并通过存储子问题的解来避免重复计算.提高效率</li><li>数学递归公式均可直接翻译为递归算法,但现实中编译器往往不发正确对待递归算法,而导致低效</li><li>当这种情况发生时,便需要给编译器提供帮助.改写为非递归的算法,并将子问题的答案记录在一个表内</li></ul></li><li><p>示例: Fibonacci 数列</p><ul><li><p>自然递归效率非常低,是指数级别的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-1</span>) + fib(n<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自顶向下的备忘录法(Top-Down with Memoization)</p><ul><li><p>从原问题开始,递归分解问题.在递归过程中检查子问题是否已经解决过(查表)</p></li><li><p>若没解决过,计算并存储结果; 若已经解决过,直接返回存储的结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 自顶向下的备忘录法.不推荐,仍然有递归的开销 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_N 100</span><br><span class="hljs-type">int</span> memo[MAX_N]; <span class="hljs-comment">// 备忘录.初始化为 -1 标记未计算</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fib_memo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 如果已经计算过.直接返回</span><br>    <span class="hljs-keyword">if</span> (memo[n] != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> memo[n];<br>    &#125;<br>    <span class="hljs-comment">// 基础情况直接进行赋值.fib(0) = 0; fib(1) = 1</span><br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>        memo[n] = n;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>    <span class="hljs-comment">// 计算并存储结果</span><br>    memo[n] = fib_memo(n<span class="hljs-number">-1</span>) + fib_memo(n<span class="hljs-number">-2</span>);<br>    <span class="hljs-keyword">return</span> memo[n];<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>自底向上的表格法(Bottom-Up Tabulation)</p><ul><li><p>从最小的子问题开始,逐步构建更大规模问题的解</p></li><li><p>通常使用数组(DP 表)顺序存储所有子问题的解</p></li><li><p>循环迭代填充 DP 表,直到获得原问题的解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 自底向上的表格法.推荐做法 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fib_dp</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br><br>    <span class="hljs-comment">// 1. 创建 DP 表(实际上这里只需要前两个值.但为了演示使用数组)</span><br>    <span class="hljs-type">int</span> dp[n+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 2. 初始化已知的最小子问题的解</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 3. 自底向上填充 DP 表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>        dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];<br><br>    <span class="hljs-comment">// 4. 返回原问题的解</span><br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h2 id="5-数据结构"><a href="#5-数据结构" class="headerlink" title="5 数据结构"></a>5 数据结构</h2><h3 id="5-1-list"><a href="#5-1-list" class="headerlink" title="5.1 list"></a>5.1 list</h3><ol><li><p>表: 形如 $a_1, a_2,\dots ,a_n$ 的有限序列.其中 $a_i$ 为数据元素 </p><ul><li>其大小为 n (当 n&#x3D;&#x3D;0 称为空表,empty list)</li><li>表的操作: 创建空表, 插入, 删除, 查找, 获取, 修改, 清空, 获取长度</li><li>由于数组对于插入和删除元素的运行太慢,一般不用简单数组实现表</li></ul></li><li><p>链表: 由一系列的无需在内存中相连的结构组成</p><ul><li>每个结构含有表元素以及指向该元素后继元结构的指针(next 指针)</li><li>最后一个元素的 next 指针 指向 NULL</li><li>预留一个标志节点作为表头(head).其位置为0</li></ul></li><li><p>双链表: 在数据结构中增加一个域,使其指向前一个单元</p><ul><li><p>增加空间需求.因为需要额外存储一个指针</p></li><li><p>使得插入和删除的开销增加一倍.因为需要维护两个指针</p></li><li><p>简化删除操作.因为不再需要定位前驱元</p></li></ul></li><li><p>循环链表: 循环链表将链表的最后一个结点的指针指向头结点,形成一个环状结构</p></li><li><p>栈(stack): 限制插入和删除只能在一个位置(栈顶, top)进行的表</p><ul><li>栈的基本操作有: 入栈(push), 出栈(pop), 查看栈顶(peek &#x2F; top)</li><li>栈的特点: 后进先出(LIFO),且只有栈顶元素可访问</li><li>栈的链表实现及其操作不涉及栈的大小,因此均为常数时间开销.缺点在于需要承担 <code>malloc,free</code> 的开销</li><li>当栈采用头插法进行入栈,则头节点的后继元即为栈顶,因此出栈只需删除头节点的后继元</li></ul></li><li><p>队列(queue): 限制插入(队尾, rear)和删除(队头, front)只能在两端分别进行的表</p><ul><li>队列的基本操作有 入队(enqueue), 出队(dequeue)</li><li>队列的特点: 先进先出(FIFO);只有队头元素可访问</li><li>队列的链表实现的注意事项<ul><li>队列需要指向队头(front)和队尾(rear)的两个指针</li><li>当进行入队操作时,采用尾插法,且需要将 rear 指针向后移动一位</li><li>当进行出队操作时,需要先判断队列是否为空(front &#x3D;&#x3D; rear),然后删除 front 指针的后继元</li></ul></li></ul></li><li><p><strong>优先队列</strong>(priority queue): 是允许至少插入(入队)和删除最小(出队: 删除最小元素)的数据结构</p><ul><li>使用简单链表: 在表头进行插入 $O(1)$,遍历链表以实现删除最小元 $O(n)$</li><li>始终让表保持排序状态: 进行顺序插入 $O(n)$ 和删除操作 $O(1)$</li><li>二叉查找树: 对插入和删除操作均为 $O(\log n)$</li></ul></li></ol><h3 id="5-2-hash"><a href="#5-2-hash" class="headerlink" title="5.2 hash"></a>5.2 hash</h3><ol><li><p>散列表(hash table): 高效的 <code>key-value</code> 映射数据结构.以 $O(1)$ 实现查找, 插入, 删除</p></li><li><p>映射函数(hash function): 将关键字映射到 [0, Table-Size) 区间中的某个数,且放到适当的单元中</p><ul><li>理想的映射函数应运算简单</li><li>相同的关键字必须始终产生相同的索引</li><li>不同的关键字应该尽可能均匀地映射到不同的索引上,减少冲突</li></ul></li><li><p>散列函数示例</p><ul><li><p>若输入的关键字为整数,一般采用返回 <code>key mod tableSize</code>.保证表的大小为素数时效果较好</p></li><li><p>若输入的关键字为字符串.可将字符串中的字符的 ASCII 码值之和作为关键字(简单,但当表很大时将会分配不均)</p></li></ul></li><li><p>冲突(collision): 两个关键字散列到同一个值</p><ul><li><p>当一个元素被插入处已存在另一个元素(即不同关键字的散列值相同),此时将产生冲突</p></li><li><p>解决冲突的方式有: 分离链接法(separate chaining), 开放定址法(open addressing)</p></li></ul></li><li><p>分离链接法: 将散列到同一个值的所有元素保存到一个表中</p><ul><li><p>插入操作: 遍历相应的表以检查该元素是否以处于适当的位置.如果是新元素,则将其插入到表的前端&#x2F;末尾</p></li><li><p>示例: 关键字为前10个数的平方(0, 1, 4, 9, 16, 25, 36, 49, 64, 81).散列函数为 $hash(x) &#x3D; x \space mod \space 10$</p></li><li><p>则分离链接散列表形如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">+-------+<br>| 索引0 | --&gt; [ (key=0, value=?) | next ] --&gt; NULL<br>+-------+<br>| 索引1 | --&gt; [ (key=81, value=?) | next ] --&gt; [ (key=1, value=?) | next ] --&gt; NULL<br>+-------+<br>| 索引2 | --&gt; NULL<br>+-------+<br>| 索引3 | --&gt; NULL<br>+-------+<br>| 索引4 | --&gt; [ (key=64, value=?) | next ] --&gt; [ (key=4, value=?) | next ] --&gt; NULL<br>+-------+<br>| 索引5 | --&gt; [ (key=25, value=?) | next ] --&gt; NULL<br>+-------+<br>| 索引6 | --&gt; [ (key=36, value=?) | next ] --&gt; [ (key=16, value=?) | next ] --&gt; NULL<br>+-------+<br>| 索引7 | --&gt; NULL<br>+-------+<br>| 索引8 | --&gt; NULL<br>+-------+<br>| 索引9 | --&gt; [ (key=49, value=?) | next ] --&gt; [ (key=9, value=?) | next ] --&gt; NULL<br>+-------+<br></code></pre></td></tr></table></figure></li></ul></li><li><p>开放定址法: 当冲突发生时,按照某种预定的探测序列在数组中寻找下一个空闲的桶</p><ul><li>考虑单元 $h_0(X),h_1(X),h_2(X), \cdots,$相继试选.其中 $h_i(X) &#x3D; (hash(x)+F(i))\mod \mathrm{tableSize}$</li><li>函数 $F$ 是冲突解决方法,且 $F(0) &#x3D; 0$ </li><li>开放地址法需要将所有数据置于表内,因此散列表较大.但省去了给新单元分配地址的时间</li></ul></li></ol><h3 id="5-3-tree"><a href="#5-3-tree" class="headerlink" title="5.3 tree"></a>5.3 tree</h3><ol><li><p>树的递归定义: 一棵<strong>树</strong>是一些节点的集合(可以是空集).若非空,则一棵树由称为<strong>根</strong>(root)的节点 r,以及0个或多个非空的(子)树 $T_1,T_2,\dots,T_k$ 组成,这些<strong>子树</strong>中的每一颗的根都被来自根 r 的一条有向边所连接</p><ul><li><strong>叶</strong>(leaf): 没有子节点的节点</li><li><strong>兄弟</strong>(sibling): 具有相同父节点的节点</li><li><strong>路径</strong>(path): 从节点 $n_1$ 到 $n_k$ 的路径为 $n_1, n_2,\dots,n_k$ 的一个序列.且对于 $1\leq i&lt;k$,有 $n_i$ 是 $n_{i+1}$ 的父节点</li><li><strong>路径的长</strong>(length): 路径上 边的条数,即 $k-1$.每一节点到自身的路径长为0</li><li><strong>深度</strong>(depth): 对于任意节点 $n_i$,其深度为从根到 $n_i$ 的唯一路径的长</li></ul></li><li><p><strong>二叉树</strong>: 每个节点的子节点都不超过2个的树</p><ul><li>平均二叉树的深度通常比节点数 N 小得多,平均深度为 $O(\sqrt N)$</li><li><strong>二叉查找树</strong>(binary search tree)的平均深度为 $O(\log N)$.但在最坏的情况下可以为 N-1</li><li>二叉树经常用于查找.给树中的每个节点指定一个关键字值(假定为整数,且唯一)</li></ul></li><li><p><strong>二叉查找树</strong>: 对于树中的每个节点 X,其左子树所有关键字值小于 X 关键字值,右子树所有关键字值大于 X 关键字值</p><ul><li>考虑到树的递归定义,对二叉查找树的操作通常采用递归处理</li><li>考虑到所有的元素都是有序的,因此假定运算符 <code>&lt;, =, &gt;</code> 均可用于这些元素</li></ul></li><li><p><strong>AVL树</strong>(Adelson-Velskii Landis): 带有平衡条件(需易保持)的二叉查找树.且保证树的深度为$O(\log N)$</p><ul><li>AVL 树要求每个节点的左子树和右子树的高度最多差1(空树的高度定义为-1)</li><li>AVL 树的高度最多为$1.44\log (N+2)-1.328$. 因此可以保证除插入外的操作(删除为惰性)均为 $O(\log N)$</li><li>AVL 树的插入操作可能会破坏平衡条件,因此隐含着困难.但总是可以经过修正(旋转)使得性质恢复</li></ul></li><li><p><strong>堆</strong>(heap): 被完全填满的二叉树(完全二叉树, complete binary tree),底层可以例外(从左到右填入)</p><ul><li>高为 h 的完全二叉树节点数为: $[2^h, 2^{h+1})$.因而完全二叉树的高是 $\lfloor \log N \rfloor$</li><li>完全二叉树可以用数组进行表示,而不需要指针</li><li>考虑位置为 i 的元素,其左子节点位于 2i,右子节点位于左子节点后的 2i+1,父节点位于 $\lfloor i&#x2F;2 \rfloor$ </li><li>堆数据结构将由 一个数组(无论关键字是什么类型), 一个代表最大值的整数, 当前堆大小的整数 组成</li></ul></li><li><p>堆序性质: 在一个堆中,对于任意节点 X, X 父节点的关键字小于 X 的关键字(根节点除外)</p><ul><li>考虑需要找出最小元,因此最小元应该在根上</li><li>将任意子树也视为一个堆,则任意节点应小于其所有后裔</li></ul></li></ol><h3 id="5-4-graph"><a href="#5-4-graph" class="headerlink" title="5.4 graph"></a>5.4 graph</h3><ol><li><p>图(graph): 由顶点(vertex)的集合 V,边(edge)的集合 E 组成</p><ul><li>每条边都是点对(v, w), 其中 $v,w\in V$</li><li>若点对是有序的,则图是有向(directed)的,称为有向图(digraph)</li><li>顶点 v, w 邻接等价于当 $(v,w)\in E$</li><li>边可以有第三种成分: 权(weight) 或 值(cost)</li></ul></li><li><p>图中的路径(path)</p><ul><li>路径是顶点序列: $w_1, w_2, \dots, w_N \space\space \mathrm{s.t.}(w_i,w_{i+1})\in E,1\leq i&lt;E$ </li><li>路径的长(length): 边的数量,即 N-1</li><li>环(loop): 从一个顶点到自身的边</li><li>简单路径: 所有的顶点都互异,但第一个和最后一个顶点可以相同</li></ul></li><li><p>图中的圈(cycle)</p><ul><li>有向图中的圈: 满足 $w_1 &#x3D; w_N$ 且长至少为1的一条路径</li><li>无向图中的圈则额外要求边是互异的</li></ul></li><li><p>连通(connected)</p><ul><li>在无向图中从每一个顶点到每个其他顶点都存在一条路径</li><li>在有向图中,这种性质称为强连通(strongly connected)</li><li>若有向图不是强连通的,但其基础图(underlying graph, 即去掉弧的方向)是连通的,则称为弱连通(weakly connected)</li><li>完全图(complete graph): 每个顶点间都存在一条边</li></ul></li><li><p>图的表示(有向图)</p><ul><li>使用一个二维数组,即**邻接矩阵(adjacent matrix)**表示<ul><li>对于每条边(u, v),置 <code>A[u][v] = 1</code>.其他元素为0</li><li>若该边有一个权,则可置 <code>A[u][v]</code> 等于该权.使用很大&#x2F;小的数表示不存在的边</li><li>若图是稀疏的(sparse), 该方法所需求的空间 $\Theta(|V|^2)$ 过大了</li></ul></li><li><strong>邻接表(adjacent list)</strong>: 对每一个顶点,使用一个表存放所有的邻接点<ul><li>空间需求为 $O(|E|+|V|)$</li><li>邻接表是图的标准表示方法</li></ul></li><li>考虑到实际中顶点都有名字,因此需要使用散列表建立名字到数字的映射<ul><li>散列表中对每个顶点存储一个名字和一个内部编号( 1 ~ |V| 之间)</li></ul></li></ul></li><li><p>输入一个赋权图: 与每条边 $(v_i, v_j)$ 联系的是穿越该弧的代价 $c_{i,j}$</p><ul><li>赋权路径长(weighted path length): $v_1v_2\dots v_N$ 路径的值为 $\sum\limits^{N-1}<em>{i&#x3D;1}c</em>{i,j}$</li></ul></li><li><p>单源最短路径问题: 给定赋权图 $G&#x3D;(V,E)$ 和特定顶点 s 作为输入,找出 s 到 G 每个点的最短赋权路径</p></li><li><p>无权最短路径</p><ul><li><p>广度优先搜索(breadth-first search): 按层处理顶点,距离最近的先辈赋值,最远的最后赋值</p></li><li><p>显然顶点s到自身距离为0,然后考察与s邻接的点,其距离为1.然后考察邻接的邻接,直到完成所有点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unWeigted</span><span class="hljs-params">(table t)</span> &#123;<br>    vertex v, w;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> currDist = <span class="hljs-number">0</span>; currDist &lt; numVetex; ++currDist)<br>        <span class="hljs-keyword">for</span> each vertex v<br>            <span class="hljs-title function_">if</span><span class="hljs-params">(!t[v].known &amp;&amp; t[v].dist == currDist)</span> &#123;<br>                t[v].known = True;<br>                <span class="hljs-keyword">for</span> each w adjacent to v<br>                    <span class="hljs-title function_">if</span><span class="hljs-params">(t[w].dist == infinity)</span> &#123;<br>                        t[w].dist = currDist + <span class="hljs-number">1</span>;<br>                        t[w].path = v;<br>                    &#125;<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Dijkstra 算法: 考虑赋权图的单源最短路径问题.仍借鉴无权时的思路</p><ul><li>顶点 s 到自身的距离为0,将其标记为已知,因为此时多了一个已知点,则可以获得其到达邻接点的距离</li><li>选取距离最小的点(贪心法,greedy algorithm)标记为已知,则有可以更新其到达邻接点的距离</li><li>重复该过程,直到获得到达目标点的最短距离</li><li>对于没有负值边的图,该算法总能完成.一旦出现负值边,则可能出现错误的答案</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>Code</tag>
      
      <tag>C 语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Language Basic</title>
    <link href="/2023/05/01/Computer/C-Language-Basic/"/>
    <url>/2023/05/01/Computer/C-Language-Basic/</url>
    
    <content type="html"><![CDATA[<h2 id="0-开发环境"><a href="#0-开发环境" class="headerlink" title="0 开发环境"></a>0 开发环境</h2><h3 id="0-1-Windows-环境"><a href="#0-1-Windows-环境" class="headerlink" title="0.1 Windows 环境"></a>0.1 Windows 环境</h3><ol><li><p>下载安装 <a href="https://www.mingw-w64.org/downloads/#mingw-w64-builds">MinGW</a>. 并配置环境变量: 在系统 <code>path</code> 中添加 <code>mingw64</code> 路径. 形如: <code>D:\code\mingw64\bin</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc --version<br></code></pre></td></tr></table></figure></li><li><p><a href="https://cmake.org/download/">下载安装 CMake</a>(如 <code>cmake-4.0.2-windows-x86_64.msi</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake --version<br></code></pre></td></tr></table></figure></li><li><p>配置环境使得可以使用 cmake 构建项目, gdb 进行调试</p><ul><li><p>在 vscode 中安装 <code>CMake, CMake Tools, Code Runner</code> 插件</p></li><li><p>创建 <code>.vscode/tasks.json</code> 文件内容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake-configure&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake -B build -DCMAKE_BUILD_TYPE=Debug&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$gcc&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake-build&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake --build build --parallel&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$gcc&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Full Build&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;dependsOn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;cmake-configure&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;cmake-build&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;isDefault&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>创建 <code>.vscode/launch.json</code> 文件.内容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;GDB Debug&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;command:cmake.launchTargetPath&#125;&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 需要 CMake Tools 插件</span><br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Enable pretty-printing for gdb&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Set disassembly flavor to Intel&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-comment">// 调试前自动构建.注意与 tasks.json 匹配</span><br>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Full Build&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>创建 <code>./CmakeLists.txt</code> 文件.内容如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.20</span>)<br><br><span class="hljs-comment"># 项目设置</span><br><span class="hljs-keyword">project</span>(HelloCMake)<br><br><span class="hljs-comment"># 严格编译器设置</span><br><span class="hljs-keyword">set</span>(CMAKE_C_STANDARD <span class="hljs-number">17</span>)          <span class="hljs-comment"># 使用 C17 标准</span><br><span class="hljs-keyword">set</span>(CMAKE_C_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>) <span class="hljs-comment"># 强制要求编译器必须严格支持指定的 C 语言标准</span><br><span class="hljs-keyword">set</span>(CMAKE_C_EXTENSIONS <span class="hljs-keyword">OFF</span>)       <span class="hljs-comment"># 禁用编译器扩展(模拟-pedantic)</span><br><br><span class="hljs-comment"># 启用编译数据库生成.配合 clangd</span><br><span class="hljs-keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-comment"># 强制启用所有警告</span><br><span class="hljs-keyword">add_compile_options</span>(<br>    -Wall     <span class="hljs-comment"># 开启所有警告</span><br>    -Wextra   <span class="hljs-comment"># 启用额外警告</span><br>    -Werror   <span class="hljs-comment"># 将警告视为错误</span><br>    -pedantic <span class="hljs-comment"># 严格遵循标准</span><br>)<br><br><span class="hljs-comment"># 根据构建类型设置优化级别</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">NOT</span> CMAKE_BUILD_TYPE)<br>  <span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE <span class="hljs-string">&quot;Debug&quot;</span>) <span class="hljs-comment"># 默认 Debug 模式(自动包含-g)</span><br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># 显式包含当前目录(确保头文件能找到)</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)<br><br><span class="hljs-comment"># 添加可执行文件(推荐显式列出文件)</span><br><span class="hljs-keyword">add_executable</span>(<br>    <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span><br>    main.c<br>)<br></code></pre></td></tr></table></figure></li><li><p>至此即可点击状态栏的 <code>CMake Tool</code> 相关图标进行构建, 运行项目</p></li></ul></li><li><p><code>clangd</code> 插件</p><ul><li><p>需要下载安装包含 <code>clangd</code> 可执行文件的 LLVM&#x2F;Clang 工具链(直接使用 VS Code 提示安装)</p></li><li><p>解决标准库标红(在项目根目录下创建 <code>.clangd</code> 文件)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">CompileFlags:<br>  Add: [<br>    --target=x86_64-w64-mingw32,<br>    -isystem, D:/code/mingw64/x86_64-w64-mingw32/include,<br>    -isystem, D:/code/mingw64/include,<br>  ]<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-2-Linux-环境"><a href="#0-2-Linux-环境" class="headerlink" title="0.2 Linux 环境"></a>0.2 Linux 环境</h3><ol><li><p>在 linux(发行版为 windows 的 wsl, ubuntu 24.04) 使用 c 语言开发.先安装必要的工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install build-essential gdb gcc g++ make<br></code></pre></td></tr></table></figure></li><li><p>windows 远程连接到 linux(需要先确保 linux 服务器已开启 ssh 服务)</p><ul><li><p>在 powershell 中生成密钥</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ssh<span class="hljs-literal">-keygen</span> <span class="hljs-literal">-t</span> rsa <span class="hljs-literal">-b</span> <span class="hljs-number">4096</span> <span class="hljs-comment"># 生成密钥.默认保存路径: ~/.ssh/id_rsa</span><br><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub     <span class="hljs-comment"># 查看生成的密钥.以 `ssh-rsa AAA...` 开头</span><br></code></pre></td></tr></table></figure></li><li><p>在 linux 上添加公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p ~/.ssh  # 如果目录不存在才需要创建.否则跳过该步骤<br>echo &quot;&lt;复制 Windows 中输出的公钥内容&gt;&quot; &gt;&gt; ~/.ssh/authorized_keys<br>chmod 600 ~/.ssh/authorized_keys  # 设置权限<br></code></pre></td></tr></table></figure></li><li><p>在 powershell 中测试 ssh 连接(若能够直接连接而无需密码,表示配置正确)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ssh username@linux_server_ip <span class="hljs-comment"># 格式为 用户名@ip地址</span><br>logout                       <span class="hljs-comment"># 退出 ssh</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>在 vscode 安装 <code>remote</code> 扩展</p><ul><li><p>按 <kbd>F1</kbd> 或 <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>P</kbd> -&gt; <code>Remote-SSH: Connect to Host...</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh username@linux_server_ip<br></code></pre></td></tr></table></figure></li><li><p>vscode 会提示选择 ssh 配置文件(默认是 <code>C:\Users\你的用户名\.ssh\config</code>),确认保存</p></li><li><p>ssh 连接 <code>config</code> 文件的含义(非必需项,仅了解含义)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host mylinux                   # 自定义别名.将会在插件中显示为主机名<br>    HostName linux_server_ip   # 远程服务器的真实 ip 地址或域名<br>    User username              # 登录远程服务器时使用的用户名<br>    IdentityFile ~/.ssh/id_rsa # 用于认证的私钥文件路径<br>    Port 22                    # ssh 服务端口号.默认为 22,若修改过需要对应调整<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>cmake</code> 使用(<code>.vscode/tasks.json, .vscode/launch.json, CmakeLists.txt</code> 文件内容同上)</p></li><li><p><code>clangd</code> 使用</p><ul><li><p>Ubuntu 中下载, 验证安装 <code>clangd</code>(同时 vscode 安装 <code>clangd</code> 插件)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install clangd<br>clangd --version<br></code></pre></td></tr></table></figure></li><li><p>在 <code>.vscode/settings.json</code> 中添加配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;clangd.path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/clangd&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;clangd.arguments&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;--background-index&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;--clang-tidy&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;--completion-style=detailed&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;--header-insertion=never&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;C_Cpp.intelliSenseEngine&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;disabled&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 禁用微软引擎</span><br>  <span class="hljs-attr">&quot;C_Cpp.codeFolding&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;disabled&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-comment">// 避免冲突</span><br>  <span class="hljs-attr">&quot;editor.semanticHighlighting.enabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><code>clangd</code> 依赖 <code>compile_commands.json</code> 来获取项目的编译信息.CMake 生成该文件位于 <code>build</code> 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s build/compile_commands.json .  # 创建软连接供 clangd 使用<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>clang-format</code> 使用</p><ul><li><p>格式化代码(VS Code 快捷键 <kbd>Shift</kbd><kbd>Alt</kbd><kbd>F</kbd>)</p></li><li><p>安装 <code>clang-format</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install clang-format<br></code></pre></td></tr></table></figure></li><li><p>在项目根目录新建 <code>.clang-format</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">BasedOnStyle: Google  # 使用 Google 风格<br>IndentWidth: 4        # 覆盖为 4 空格缩进<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-3-GCC-编译器"><a href="#0-3-GCC-编译器" class="headerlink" title="0.3 GCC 编译器"></a>0.3 GCC 编译器</h3><ol><li><p>gcc&#x2F;g++ 编译步骤</p><ul><li>预处理器 cpp: 预处理,生成 <code>.i</code> 的文件</li></ul><ul><li>编译器 egcs: 将预处理后的文件转换成汇编语言, 生成 <code>.s</code> 文件</li><li>汇编器 as: 有汇编变为目标代码(机器代码)生成 <code>.o</code> 的文件</li><li>链接器 ld: 连接目标代码, 生成可执行程序</li></ul></li><li><p>gcc 编译选项(gcc 会按照后缀名进行编译.对于 C 程序,应当保持后缀名为 <code>.c</code>)</p><ul><li><p>基础编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc hello.c                    # 直接生成可执行文件(默认输出 a.out)<br>gcc hello.c -o hello           # 指定输出文件名<br>gcc main.c utils.c -o program  # 编译多个源文件<br></code></pre></td></tr></table></figure></li><li><p>编译流程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -E hello.c &gt; hello.i  # 只激活预处理,不生成文件.但可以重定向到一个输出文件<br>gcc -S hello.i -o hello.s # 只激活预处理和编译.将文件编译成汇编代码<br>gcc -c hello.s -o hello.o # 只激活预处理, 编译, 汇编.生成 obj 文件<br>gcc hello.o -o hello      # 完整地编译文件<br></code></pre></td></tr></table></figure></li><li><p>调试, 优化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -g hello.c -o hello  # 生成可供 gdb 调试可执行文件<br>gcc -O2 hello.c -o hello # 优化级别(O0 ~ O3,通常用-O2)<br>gcc -pg hello.c -o hello # 生成性能分析信息(用于 gprof)<br></code></pre></td></tr></table></figure></li><li><p>标准, 警告</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -Wall hello.c    # 打印 gcc 的警告信息<br>gcc -w hello.c       # 关闭 gcc 的警告信息<br>gcc -std=c11 hello.c # 使用 C11 标准<br></code></pre></td></tr></table></figure></li><li><p>头文件与库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -I./include hello.c -o hello # 指定头文件搜索路径<br>gcc -L./lib hello.c -o hello     # 指定库文件搜索路径<br>gcc hello.c -lm -o hello         # 链接特定库(如数学库-lm)<br></code></pre></td></tr></table></figure></li><li><p>编译时定义宏</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -D宏名 hello.c<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-4-GDB-调试器"><a href="#0-4-GDB-调试器" class="headerlink" title="0.4 GDB 调试器"></a>0.4 GDB 调试器</h3><ol><li><p>GDB(GNU Project Debugger) 安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install gbd<br></code></pre></td></tr></table></figure></li><li><p>启动 gdb(注意: 在 gcc 编译时需要加上 <code>-g</code> 选项才能生成可供调试的可执行文件)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gdb filename       # 从头运行程序并调试<br>gdb filename core  # 调试 crash 的程序<br>gdb -p 进程号      # 调试运行中的程序<br></code></pre></td></tr></table></figure></li><li><p>gdb 命令(<kbd>Enter</kbd> 表示重复上一命令)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">run         # 运行<br>start       # 单步执行.停在第一行<br>quit(q)     # 退出<br>list(l)     # 查看代码<br>break(b)    # 设置断点,行数<br>delete(d)   # 删除断点<br>next(n)     # 单步执行,逐过程<br>step(s)     # 单步执行,逐语句<br>finish      # 结束当前函数,跳出<br>continue(c) # 继续运行<br>display     # 追踪变量<br>undisplay   # 取消追踪<br>watch       # 观察点修改时进行打印<br><br>print(p) # 查看变量<br>set var  # 设置变量<br>info(i)  # 查看信息<br>x 0x...  # 查看内存信息<br>!clear   # 清屏<br>thread   # 线程<br>disass   # 汇编<br></code></pre></td></tr></table></figure></li></ol><h3 id="0-5-CMake-环境"><a href="#0-5-CMake-环境" class="headerlink" title="0.5 CMake 环境"></a>0.5 CMake 环境</h3><ol><li><p><strong>cmake: 开源的 跨平台构建工具,用于管理软件编译过程</strong></p><ul><li>cmake 不直接构建项目,而是生成标准的构建文件(如 <code>Makefile</code>)</li><li>再由底层工具(如 <code>make, ninja</code>)完成实际编译</li><li>使用 <code>CMakeLists.txt</code> 文件定义构建规则,语法类似脚本语言</li></ul></li><li><p>cmake 安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">命令行安装</span><br>sudo apt update         # 更新软件包列表<br>sudo apt install cmake  # 安装 CMake<br>cmake --version         # 验证安装<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">源码安装(可选).先安装编译依赖.下载 CMake 源码</span><br>sudo apt update &amp;&amp; sudo apt install -y build-essential libssl-dev<br>wget https://github.com/Kitware/CMake/releases/download/v4.0.3/cmake-4.0.3.tar.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压并编译安装 CMake</span><br>tar -zxvf cmake-4.0.3.tar.gz<br>cd cmake-4.0.3<br>./bootstrap --prefix=/usr/local --parallel=$(nproc) # 指定安装路径并启用多核编译<br>make -j$(nproc)   # 并行编译加速<br>sudo make install # 安装 CMake<br>cmake --version   # 验证安装<br></code></pre></td></tr></table></figure></li><li><p>cmake 卸载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt remove cmake # 通过 apt 方式卸载<br><br>cd cmake-4.0.3/build<br>sudo make uninstall   # 通过源码编译安装的卸载方式<br></code></pre></td></tr></table></figure></li></ol><h3 id="0-6-CMake-构建"><a href="#0-6-CMake-构建" class="headerlink" title="0.6 CMake 构建"></a>0.6 CMake 构建</h3><ol><li><p>编写 <code>CMakeLists.txt</code> 文件.下面是最基础的配置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.20</span>)   <span class="hljs-comment"># CMake 最低版本要求</span><br><span class="hljs-keyword">project</span>(hello)                         <span class="hljs-comment"># 配置项目名称为 hello</span><br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> main.c) <span class="hljs-comment"># 为生成可执行文件所使用到的源文件</span><br></code></pre></td></tr></table></figure></li><li><p>cmake 手动构建命令(若修改了 <code>CMakeLists.txt</code> 文件但并未及时生效,可以删除 <code>./build</code> 目录后重新构建)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">cmake -B build      <span class="hljs-comment"># 创建 build 目录,编译 CMakeList.txt</span><br>cmake --build build <span class="hljs-comment"># 构建项目,生成可执行文件</span><br></code></pre></td></tr></table></figure></li><li><p>cmake 语法</p><ul><li><p>cmake 项目基于 <code>CMakeLists.txt</code> 构建,其中(或 <code>*.cmake</code> 文件)使用的就是 CMake Language</p></li><li><p>cmake 命令行工具由5个可执行文件构成: <code>cmake, ctest, cpack, cmake-gui, ccmake</code></p></li><li><p>不通过 <code>CMakeLists.txt</code> 运行 cmake 的方法(该方法仅学习语法,实际并不会用到)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake -P *.cmake<br></code></pre></td></tr></table></figure></li><li><p>获取 cmake 变量</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>(<span class="hljs-variable">$&#123;CMAKE_VERSION&#125;</span>)  <span class="hljs-comment"># 打印版本号</span><br></code></pre></td></tr></table></figure><ul><li>cmake 的变量(区分大小写)分为: cmake 提供 和 自定义的</li><li>cmake 的变量存储时均为字符串</li></ul></li></ul></li><li><p>cmake  构建项目的方式</p><ul><li><code>add_executable</code> 中直接写入相对路径.此时在源码中引入头文件也需要写相对路径</li></ul></li><li><p>生成静态库和动态库</p><ul><li>静态库: 在连接阶段,将汇编的 <code>.o</code> 文件与引用到的库一起打包到可执行文件中</li><li>动态库: 不会在编译时连接,而是在运行时才载入</li></ul></li><li><p>调用静态库和动态库</p></li></ol><h2 id="1-编译链接"><a href="#1-编译链接" class="headerlink" title="1 编译链接"></a>1 编译链接</h2><h3 id="1-1-编译过程"><a href="#1-1-编译过程" class="headerlink" title="1.1 编译过程"></a>1.1 编译过程</h3><ol><li><strong>预处理(Preprocessing)</strong>: 对源代码(source code file)进行文本替换(宏定义, 条件编译, 文件包含)<ul><li>删除所有注释 <code>//, /* */</code></li><li>展开所有宏定义 <code>#define</code></li><li>处理所有的条件编译指令 <code>#if, #ifdef, #endif...</code></li><li>添加行号和文件名标识</li><li>保留所有的 <code>#pragma</code> 编译器指令,留给编译器</li></ul></li><li><strong>编译(Compilation)</strong>: 将经过预处理之后的程序转换成特定汇编代码(assembly code).生成文本文<ul><li>词法分析: 将代码的字符序列转化为一系列 token(如关键字, 标识符, 特殊符号…)</li><li>语法分析: 生成以表达式为节点的语法树</li><li>语义分析: 进行静态语义分析(如类型转换).此时语法树有了类型</li></ul></li><li><strong>汇编(Assemble)</strong>: 将汇编代码转换成机器码(machine code),生成的文件称目标文件(二进制格式)</li><li><strong>链接(Linking)</strong>: 将多个目标文件以及所需的库文件(.so等)链接成最终的可执行文件(executable file)<ul><li>符号解析: 链接器扫描所有目标文件收集所有符号,为每个符号引用找到对应的定义</li><li>地址空间分配: 将目标文件的段信息进行合并</li><li>重定位: 程序中调用的函数, 全局变量在编译并未确定其地址.此时修正它们的地址</li></ul></li></ol><h3 id="1-2-宏定义"><a href="#1-2-宏定义" class="headerlink" title="1.2 宏定义"></a>1.2 宏定义</h3><ol><li><p><strong>宏定义: 预处理器的一种指令.核心思想为将代码中的宏名简单替换为指定文本</strong></p><ul><li>宏定义中的空格不能忽视</li><li><code>#define</code> 定义的符号可以嵌套,但不能递归</li><li>宏不是语句.因此不需要分号</li></ul></li><li><p>程序扩展 <code>#define</code> 的步骤</p><ul><li>调用宏时,对参数进行检查.如果包含了 <code>#define</code>  定义的符号,将其替换(双引号中的除外)</li><li>替换文本被插入到程序原来的位置.对于带参数的宏,参数名会被值替换</li><li>再次对结果文本进行扫描.如果还有由 <code>#define</code> 定义的符号,重复上述步骤</li><li>预处理在编译之前,因此编译器不会对宏定义进行语法检查</li><li>预处理器搜索 <code>#define</code> 定义的符号时不检查字符串常量的内容</li></ul></li><li><p>编译器预定义宏</p><table><thead><tr><th>符号</th><th>示例值</th><th>含义</th></tr></thead><tbody><tr><td><code>__FILE__</code></td><td>“name.c”</td><td>进行编译的源文件名</td></tr><tr><td><code>__LINE__</code></td><td>25</td><td>文件当前行号</td></tr><tr><td><code>__DATE__</code></td><td>“Aug 24 2023”</td><td>文件被编译的日期</td></tr><tr><td><code>__TIME__</code></td><td>“18:04:30”</td><td>文件被编译的时间</td></tr><tr><td><code>__STDC__</code></td><td>1</td><td>若编译器遵循 ANSI C,其值为1.否则未定义</td></tr></tbody></table></li><li><p><strong>无参宏</strong>: 每当 <code>name</code> 出现,预处理器将其替换为 <code>stuff</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> name stuff</span><br></code></pre></td></tr></table></figure></li><li><p><strong>含参数宏定义</strong>: 每当 <code>name(parameter-list)</code> 出现,将替换为 <code>stuff</code>,且参数对应被替换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#dedine name(parameter-list) stuff</span><br></code></pre></td></tr></table></figure></li><li><p><strong>可变参数宏定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHOWLIST(...) printf(__VA_ARGS__)</span><br>SHOWLIST(Clang, <span class="hljs-number">520</span>, pi); <span class="hljs-comment">// 输出为 Clang, 520, pi</span><br></code></pre></td></tr></table></figure><ul><li><code>...</code> 表示可变参数.可变参数允许空参数</li><li><code>__VA_ARGS__</code> 在预处理中被实际的参数集替换</li></ul></li><li><p><code>#</code>: <strong>记号字符串化运算符</strong></p><ul><li><p>带参数的宏定义中,<code>#</code> 运算符后面应该跟一个参数</p></li><li><p><code>#argument</code> 会被预处理器翻译为字符串 <code>&quot;argument&quot;</code> </p></li><li><p>多个空白字符将被替换为一个空格</p></li><li><p><code>&quot;</code>将被替换为<code>\&quot;</code>,<code>\</code>将被替换为<code>\\</code>.即<code>&quot;</code> 和<code>\</code>被自动转义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT(FORMAT, VALUE) printf(<span class="hljs-string">&quot;The value of &quot;</span> #VALUE <span class="hljs-string">&quot; is &quot;</span> FORMAT <span class="hljs-string">&quot;\n&quot;</span>, VALUE)</span><br> <br>PRINT(<span class="hljs-string">&quot;%d&quot;</span>, x+<span class="hljs-number">3</span>);<br><span class="hljs-comment">/* 上面将会被替换为 printf(&quot;The value of x+3 is %d\n&quot;, x+3); */</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>##</code>: <strong>标记粘贴运算符</strong>: 将两侧的符号连接为一个符号.可用于宏定义中从分离的文本片段创建标识符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADD_TO_SUM(sum_number, value)\</span><br><span class="hljs-meta">   sum ## sum_number += value</span><br><br>ADD_TO_SUM(<span class="hljs-number">5</span>,<span class="hljs-number">25</span>);<br><span class="hljs-comment">/* 上面将被替换为 sum5 += 25; */</span><br></code></pre></td></tr></table></figure></li><li><p>最佳实践</p><ul><li><p>命名约定: 使用宏的语法和函数完全一致,为进行区别.宏名一般全大写</p></li><li><p>宏定义只会被机械地替换.给参数和表达式加上括号,保证不会因运算优先级出错</p></li><li><p>避免让带有副作用的表达式作为宏的参数</p></li><li><p>函数只需出现在代码的某一处.而每个宏出现的地方都会被替换,导致代码变长</p></li><li><p><strong>函数声明时需要指出参数的类型,宏不用</strong></p></li><li><p><strong>函数无法传递将 <code>类型</code> 作为函数参数传递,宏可以</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MALLOC(n, type) ( (type *)malloc( (n) * sizeof(type) ) )</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-3-条件编译"><a href="#1-3-条件编译" class="headerlink" title="1.3 条件编译"></a>1.3 条件编译</h3><ol><li><p><strong>预处理指令</strong></p><table><thead><tr><th align="left">指令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">#define</td><td align="left">定义宏</td></tr><tr><td align="left">#include</td><td align="left">包含一个源代码文件</td></tr><tr><td align="left">#undef</td><td align="left">取消已定义的宏</td></tr><tr><td align="left">#ifdef</td><td align="left">如果宏已经定义返回真</td></tr><tr><td align="left">#ifndef</td><td align="left">如果宏没有定义返回真</td></tr><tr><td align="left">#if</td><td align="left">如果给定条件为真,则编译下面代码</td></tr><tr><td align="left">#else</td><td align="left">#if 的替代方案</td></tr><tr><td align="left">#elif</td><td align="left">如果 #if 的条件不为真,且当前条件为真.则编译下面代码</td></tr><tr><td align="left">#endif</td><td align="left">结束一个 #if……#else 条件编译块</td></tr><tr><td align="left">#error</td><td align="left">当遇到标准错误时,输出错误消息</td></tr><tr><td align="left">#pragma</td><td align="left">使用标准化方法,向编译器发布特殊的命令到编译器中</td></tr></tbody></table></li><li><p><strong>条件编译的常量表达式一般为字面值 ,或是一个由 <code>#define</code> 定义的符号.必须在程序执行前确定该值</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> constant-expression  <span class="hljs-comment">// constant-expression常量表达式,由预处理器进行求值</span></span><br>    statements<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> constant-expression</span><br>    other statements1<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    other statements2<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>检查是否被定义的指令</strong>(<code>defined</code> 的作用在于可以使用 <code>&amp;&amp;, ||</code> 逻辑运算符对多个符号进行判断)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span>     defined(symbol)</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  symbol</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span>     !defined(symbol)</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> symbol</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="1-4-文件包含"><a href="#1-4-文件包含" class="headerlink" title="1.4 文件包含"></a>1.4 文件包含</h3><ol><li><p>头文件(约定后缀为 <code>.h</code>)中通常会包含以下内容</p><ul><li><p>明示常量, 宏函数, 函数声明, 结构体模板定义, 类型定义</p></li><li><p>在头文件中声明外部变量,可实现与其他文件共享变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> status = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 该变量声明于源代码文件中(.c),且具有文件作用域</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> status; <span class="hljs-comment">// 该语句声明于头文件中(.h).则包含了该头文件的代码均可访问 status 变量</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>#include</code> 指令</strong></p><ul><li>预处理器将会删除此指令,然后用包含的文件内容取代</li><li>当头文件被包含时,位于头文件内的所有内容都要被编译</li><li>每个头文件仅需包含一组函数 &#x2F; 数据的声明</li></ul></li><li><p><strong>包含库函数的头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filename.h&gt;</span>  <span class="hljs-comment">// 约定标准库文件以 .h 结尾</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>包含本地文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;filename.h&quot;</span>  <span class="hljs-comment">// 源文件的当前位置查找,若没有,则用查找函数库头文件的方式查找</span></span><br></code></pre></td></tr></table></figure></li><li><p>避免文件重复包含</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __HEADER_NAME_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __HEADER_NAME_H__</span><br><span class="hljs-comment">/* All the stuff that you want in the header file */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>#error</code>: 生成错误信息</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">error</span> text of <span class="hljs-keyword">error</span> message</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="1-5-链接"><a href="#1-5-链接" class="headerlink" title="1.5 链接"></a>1.5 链接</h3><ol><li><p>编译与链接</p><ul><li><strong>C 程序可由多个部分分别编译组成,连接器可以将其合并成一个整体</strong></li><li>编译器一般只处理一个文件,因此无法检测出需要了解多个文件才能察觉的错误</li><li>连接器在许多系统独立于 C 语言实现,因而如果错误与 C 语言相关,连接器是无法察觉的</li></ul></li><li><p>链接器</p><ul><li>思想: 多个源程序分别编译,在恰当的时候整合</li><li>连接器并不需要理解 C 语言.它理解机器语言和内存布局.而编译器将源程序翻译给连接器</li><li>连接器读入目标模块,同时生成载入模块</li><li>对于目标模块的每个外部对象,连接器需要检查载入模块中是否有同名的外部对象<ul><li>若没有,则将该外部对象添加到载入模块</li><li>若有,则处理命名冲突</li></ul></li><li>除了外部对象,目标模块还可能包含对其他模块中外部对象的引用<ul><li>如调用了 <code>printf</code> 函数的程序,包含一个对 <code>printf</code> 函数的引用</li><li>该引用指向一个位于某个库文件中的外部对象</li></ul></li></ul></li></ol><h2 id="2-数据"><a href="#2-数据" class="headerlink" title="2 数据"></a>2 数据</h2><h3 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h3><ol><li><p><strong>C 语言中的所有类型,要么是对象类型,要么是函数类型</strong></p><ul><li>对象: 可以在其中表示值的一块存储区域(注意并非面向对象的对象)</li><li>函数: 并非对象,且其类型由 返回值类型, 参数的数量, 类型 共同决定</li></ul></li><li><p>C 的基本数据类型</p><ul><li>整型(<code>short, int, long, long long</code>)</li><li>浮点型(<code>float, double, long double</code>)</li><li>字符型(<code>char</code>)</li><li>布尔型(<code>_Bool</code>)</li><li>枚举(<code>enum</code>)</li></ul></li><li><p>C 并未给定 int 的具体尺寸为多少字节,只需满足: <code>short &lt;= int &lt;= long &lt;= long int</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 使用 sizeof 运算符获取数据类型或表达式的尺寸</span><br><span class="hljs-keyword">sizeof</span>(type_name);<br><span class="hljs-keyword">sizeof</span>(object);<br><span class="hljs-keyword">sizeof</span> object;<br></code></pre></td></tr></table></figure></li><li><p>默认的 <code>char</code> 并未规定是否有符号.使用 <code>char</code> 型变量时最好将其范围限制在 [0, 127]</p></li><li><p>整型字面值: 默认情况下的十进制字面值将被指定为最短的能容纳该值的类型</p></li><li><p>枚举类型: 其值为符号常量(本质上是整型),而非字面值</p></li><li><p>浮点类型: 默认情况下为 <code>double</code> 类型.后缀为 l&#x2F;L 可指定其为 <code>float</code></p></li></ol><h3 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h3><ol><li><p>变量和常量是程序处理的两种基本数据类型</p><ul><li>通常待处理的数据会被置于内存中</li><li>存放数据的位置即是一个地址,CPU 可以通过地址找到该数据</li></ul></li><li><p><strong>变量命名规则</strong></p><ul><li>只能由英文字母(<code>_</code> 也视为字母)和数字组成</li><li>英文字母开头; 区分大小写; 不能使用关键字</li></ul></li><li><p><strong>ANSI C 有32个关键字</strong></p><table><thead><tr><th>auto</th><th>break</th><th>case</th><th>char</th><th>const</th><th>continue</th><th>default</th><th>do</th></tr></thead><tbody><tr><td>double</td><td>else</td><td>enum</td><td>extern</td><td>float</td><td>for</td><td>goto</td><td>if</td></tr><tr><td>int</td><td>long</td><td>register</td><td>return</td><td>short</td><td>signed</td><td>sizeof</td><td>static</td></tr><tr><td>struct</td><td>switch</td><td>typedef</td><td>union</td><td>unsigned</td><td>void</td><td>volatile</td><td>while</td></tr></tbody></table><ul><li>C99 标准新增5个关键字: <code>inline, restrict, _Bool, _Complex, _Imaginary</code></li><li>C11 标准新增7个关键字: <code>_Alignas, _Alignof, _Atomic, _Static_assert, _Noreturn, _Thread_local, _Generic</code></li></ul></li><li><p>局部变量: C 允许随处定义变量.一个函数定义的变量无法在另一个函数中访问</p></li><li><p>全局变量: 定义于函数之外的即为全局变量.会自动初始化为 0</p></li><li><p>减少全局变量的使用</p><ul><li>全局在程序退出是才会被释放.导致占用更多内存</li><li>使用全局变量将导致: 命名空间污染, 耦合性提高</li></ul></li><li><p>C 语言的变量有用两种生存期</p><ul><li><strong>静态存储期:</strong> 程序执行时一直占据存储空间,程序关闭才释放.如: 具有文件作用域的变量,函数名</li><li><strong>自动存储期</strong>: 代码块结束时自动释放存储空间.如: 具有代码块作用域的变量</li></ul></li><li><p>寄存器变量(通过 <code>register</code> 关键字声明)</p><ul><li>寄存器存在于 CPU 内部,CPU 对寄存器的读取和存储几乎没有延时</li><li><code>register</code> 在编译器看来只是一个建议,编译器会考虑是否将其放入寄存器</li></ul></li><li><p>静态局部变量(仅会被初始化一次)</p><ul><li><code>static</code> 关键字: 用于声明局部变量时,将局部变量设为静态存储期,与全局变量一致</li><li>静态局部变量仍为局部变量,无法在别的函数中直接访问</li></ul></li></ol><h3 id="2-3-常量"><a href="#2-3-常量" class="headerlink" title="2.3 常量"></a>2.3 常量</h3><ol><li><p>基本数据类型中的数据类型可作为常量.常用的还有字符串常量和符号常量</p><ul><li><p><strong>字符串常量: C 语言没有单独的字符串类型,采取字符数组的方式定义字符串</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> 变量名[字符数量];<br><span class="hljs-type">char</span> name[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br><span class="hljs-type">char</span> name[] = <span class="hljs-string">&quot;ys&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>C 约定用转义字符 <code>&#39;\0&#39;</code> (空字符)表示字符串的结束位置</p></li><li><p>以数组形式初始化时,需要给结尾的 <code>&#39;\0&#39;</code> 留出位置</p></li><li><p>使用字符串常量初始化并赋值时,编译器会自动在末尾补上 <code>&#39;\0&#39;</code></p></li><li><p>转义字符</p><table><thead><tr><th>转义字符</th><th>含义</th><th>转义字符</th><th>含义</th></tr></thead><tbody><tr><td><code>\n</code></td><td>换行(LF)</td><td><code>\\</code></td><td>\</td></tr><tr><td><code>\t</code></td><td>水平制表(HT)</td><td><code>\&#39;</code></td><td>‘</td></tr><tr><td><code>\r</code></td><td>回车(CR)</td><td><code>\&quot;</code></td><td>“</td></tr><tr><td><code>\ddd</code></td><td>八进制值</td><td><code>\?</code></td><td>?</td></tr><tr><td><code>\xhh</code></td><td>十六进制值</td><td><code>\0</code></td><td>NUL</td></tr></tbody></table></li></ul></li><li><p><strong><code>const</code> 关键字用来声明常量.常量与变量的区别仅在于其值是只读的</strong></p><ul><li><code>int const a;</code> 与 <code>const int a;</code> 声明方式的效果完全相同</li><li>由于常量的值不可修改.因此声明时一般要进行初始化</li><li>作为形参的常量在函数被调用时会得到实参的值</li></ul></li><li><p><code>const</code> 与指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-type">const</span> *pci;      <span class="hljs-comment">// pci 指向一个整型常量</span><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> pci;      <span class="hljs-comment">// pci 指向一个整型变量,指向不可修改</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *<span class="hljs-type">const</span> pci <span class="hljs-comment">// pci 指向一个整型常量,且指向不可修改</span><br></code></pre></td></tr></table></figure></li><li><p><code>const</code> 与 <code>#define</code></p><ul><li><code>const</code> 只能使用于可以出现变量的地方</li><li><code>#define</code> 可以创建名字常量.只要字面值可以出现的地方均可使用</li></ul></li><li><p>变量初始化</p><ul><li>在程序链接时,静态变量存储位置被指定.若未显式初始化,则会被初始化为0.且只进行一次</li><li>自动变量在链接时其存储位置无法判断.因此没有初始值.对其初始化本质为隐式的赋值语句<ul><li>由于初始化在运行时执行,因此可以用任何表达式作为初始值</li><li>若自动变量创建而未初始化时,则其值没有意义</li></ul></li></ul></li></ol><h3 id="2-4-运算符"><a href="#2-4-运算符" class="headerlink" title="2.4 运算符"></a>2.4 运算符</h3><ol><li><p>使用括号可以完全避免因不清楚运算符优先级导致的问题.但括号太多反而会不好理解</p><table><thead><tr><th>优先级</th><th>运算符</th><th>结合律</th></tr></thead><tbody><tr><td>0</td><td>强制分组: <code>()</code></td><td>—&gt;</td></tr><tr><td>1</td><td>后缀运算符: <code>[]  ()  .  -&gt;</code></td><td>—&gt;</td></tr><tr><td>2</td><td>一元运算符: <code>++ -- ! ~ +  - * &amp; (type) sizeof _Alignof</code></td><td><strong>&lt;—</strong></td></tr><tr><td>3</td><td>乘除法运算符: <code>*  /  %</code></td><td>—&gt;</td></tr><tr><td>4</td><td>加减法运算符: <code>+  -</code></td><td>—&gt;</td></tr><tr><td>5</td><td>移位运算符: <code>&lt;&lt;  &gt;&gt;</code></td><td>—&gt;</td></tr><tr><td>6</td><td>关系运算符: <code>&lt;  &lt;=  &gt;  &gt;=</code></td><td>—&gt;</td></tr><tr><td>7</td><td>相等运算符: <code>==  !=</code></td><td>—&gt;</td></tr><tr><td>8</td><td>位运算符 AND: <code>&amp;</code></td><td>—&gt;</td></tr><tr><td>9</td><td>位运算符 XOR: <code>^</code></td><td>—&gt;</td></tr><tr><td>10</td><td>位运算符 OR: |</td><td>—&gt;</td></tr><tr><td>11</td><td>逻辑运算符 AND: <code>&amp;&amp;</code></td><td>—&gt;</td></tr><tr><td>12</td><td>逻辑运算符 OR: ||</td><td>—&gt;</td></tr><tr><td>13</td><td>条件运算符: <code>? :</code></td><td><strong>&lt;—</strong></td></tr><tr><td>14</td><td>赋值运算符: &#96;&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &amp;&#x3D; ^&#x3D;</td><td>&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D;&#96;</td></tr><tr><td>15</td><td>逗号运算符: <code>,</code></td><td>—&gt;</td></tr></tbody></table></li><li><p>单目运算符</p><ul><li><strong>单目运算符的优先级仅低于后缀运算符</strong></li><li>结合顺序为从右到左.即 <code>*p++</code> 会被认为是 <code>*(p++)</code></li></ul></li><li><p>双目运算符</p><ul><li><p>算术  –&gt;  移位  –&gt;  关系  –&gt;  位  –&gt;  逻辑</p></li><li><p>关系运算符中: 比较  –&gt; 判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 判断 a,b 的相对大小是否和 c,d 相同</span><br>a &lt; b == c &lt; d<br></code></pre></td></tr></table></figure></li></ul></li><li><p>三目运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">taxRate = income &gt; <span class="hljs-number">40000</span> &amp;&amp; residence &lt; <span class="hljs-number">5</span> ? <span class="hljs-number">3.5</span> : <span class="hljs-number">2.0</span>;<br></code></pre></td></tr></table></figure><ul><li>三目运算符优先级低于: 算术, 移位, 关系, 位, 逻辑运算符.因而允许在条件表达式中包括关系运算符</li><li>三目运算符优先级高于: 赋值运算符.因而可以最后进行赋值操作</li></ul></li><li><p>逗号运算符: 优先级最低,其结果为最后一个表达式的值</p></li><li><p>C 采用短路求值: 当前一个运算数的无法确定逻辑运算的结果时,才会对第二个运算数求值</p></li></ol><h3 id="2-5-作用域"><a href="#2-5-作用域" class="headerlink" title="2.5 作用域"></a>2.5 作用域</h3><ol><li>对象, 函数, 宏, 标识符均有作用域(scope)<ul><li>标识符的作用域: 程序中该标识符可以被使用的区域</li><li>C 提供的作用域: 文件, 块, 函数原型, 函数</li><li>对象, 函数, 标识符的作用域由其声明位置决定</li></ul></li><li><strong>文件作用域</strong><ul><li>位于代码块之外的标识符具有文件作用域</li><li>从声明到源文件结尾均可被访问</li><li>函数名具有文件作用域</li></ul></li><li><strong>代码块作用域</strong><ul><li>代码块: 位于一对 <code>&#123;&#125;</code> 之间的所有语句</li><li>代码块中标识符具有代码块作用域</li><li>代码块嵌套时,外层无法用名字访问内层的标识符.如果内层有同名标识符,外层的将会被屏蔽</li></ul></li><li><strong>原型作用域</strong><ul><li>仅适用于函数原型中的参数名</li><li>函数参数名不是必需的,也不用与函数定义的形参名匹配</li></ul></li><li><strong>函数作用域</strong><ul><li>仅适用于语句标签.即 <code>label</code> 语句</li><li>一个函数中所有语句标签必须唯一</li><li>作用: 将标签限制在同一函数内部,防止标签重名</li></ul></li></ol><h3 id="2-6-存储期"><a href="#2-6-存储期" class="headerlink" title="2.6 存储期"></a>2.6 存储期</h3><ol><li><strong>对象的存储期决定其生命周期.分为: 自动, 静态, 线程, 分配</strong></li><li><strong>自动存储期</strong><ul><li>自动存储期对象将在语句块执行结束时被释放</li><li>在语句块或作为函数参数声明的对象将会具有自动存储期</li></ul></li><li><strong>静态存储期</strong><ul><li>静态存储期对象在程序整个执行期间都有效</li><li>文件作用域中声明的对象将会具有静态存储期</li><li><code>static</code> 可将具有自动存储期的变量(位于代码块中)改为静态存储期</li></ul></li><li><strong>分配存储期</strong><ul><li>动态分配内存具有分配存储期.从分配开始,直到释放结束</li><li>动态分配的内存取自堆(heap).由内存管理器管理</li><li>内存管理器负责分配内存和释放内存.分配后由调用者管理内存</li></ul></li><li><strong>线程存储期</strong>(C11 引入)<ul><li>使用<code>_Thread_local</code>关键字声明线程局部变量</li><li>线程局部变量的地址在不同线程中是不同的,在每个线程中都有一份独立的实例</li><li>线程局部变量的析构在线程退出时进行</li></ul></li></ol><h3 id="2-7-链接属性"><a href="#2-7-链接属性" class="headerlink" title="2.7 链接属性"></a>2.7 链接属性</h3><ol><li><p>标识符的链接属性决定如何处理在不同文件中出现的标识符</p><ul><li>外部(<code>external</code>): 无论在哪个源文件,声明多少次.均当作同一实体</li><li>内部(<code>internal</code>): 在同一源文件中被当作同一实体,不同源文件则被看作不同实体</li><li>无(<code>none</code>): 总是被当作不同的独立个体</li><li><strong>具有文件作用域的标识符缺省的链接属性为: <code>external</code></strong></li><li><strong>具有代码块作用域的标识符缺省的链接属性为: <code>none</code></strong></li></ul></li><li><p>修改链接属性</p><ul><li><code>static</code>: 将链接属性为 <code>external</code> 的标识符(位于代码块外)改为 <code>internal</code><ul><li>可用于限制全局变量只能在单个源文件内部访问</li><li>可用于限制内部函数不被其他源文件调用</li></ul></li><li><code>extern</code>: 将链接属性为 <code>none</code> 的变量改为 <code>external</code><ul><li>可用于访问其他文件中的链接属性为 <code>external</code> 的变量</li></ul></li></ul></li><li><p><strong>作用域, 链接属性, 存储类型的总结</strong></p><table><thead><tr><th>变量类型</th><th>声明的位置</th><th>是否存在于堆栈</th><th>作用域</th><th>加上 static</th></tr></thead><tbody><tr><td>全局</td><td>代码块外</td><td>否</td><td>文件作用域</td><td>不允许其他源文件访问</td></tr><tr><td>局部</td><td>代码块内</td><td>是</td><td>代码块作用域</td><td>静态变量</td></tr><tr><td>形参</td><td>函数头部</td><td>是</td><td>函数作用域</td><td>&#x2F;</td></tr></tbody></table></li><li><p>存储类别</p><table><thead><tr><th>存储类别</th><th>存储期</th><th>作用域</th><th>链接</th><th>声明方式</th></tr></thead><tbody><tr><td>自动</td><td>自动</td><td>块</td><td>无</td><td>块内</td></tr><tr><td>寄存器</td><td>自动</td><td>块</td><td>无</td><td>块内, <code>register</code></td></tr><tr><td>静态外部链接</td><td>静态</td><td>文件</td><td>外部</td><td>所有函数外</td></tr><tr><td>静态内部链接</td><td>静态</td><td>文件</td><td>内部</td><td>所有函数外, <code>static</code></td></tr><tr><td>静态无链接</td><td>静态</td><td>块</td><td>无</td><td>块内, <code>static</code></td></tr></tbody></table></li></ol><h2 id="3-控制流"><a href="#3-控制流" class="headerlink" title="3 控制流"></a>3 控制流</h2><h3 id="3-1-分支"><a href="#3-1-分支" class="headerlink" title="3.1 分支"></a>3.1 分支</h3><ol><li><p><code>if</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (expression_1) &#123;<br>    code block <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expression_2) &#123;<br>    code block <span class="hljs-number">2</span>;<br>&#125;<br>...<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expression_n) &#123;<br>    code block n;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    code blcok;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>else if, else</code> 语句是可选的</li><li><code>else</code> 只会和最近的 <code>if</code> 匹配,而与缩进无关</li></ul></li><li><p><code>switch</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (expression) &#123;<br><span class="hljs-keyword">case</span> constant_expression_1:<br>    code block <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> constant_expression_2:<br>    code block <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">break</span>;<br>...<br><span class="hljs-keyword">case</span> constant_expression_n:<br>    code block n;<br>    <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>    code block;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>break</code> 语句是可选的,若没有 <code>break</code>,将发生 <code>break</code> 穿透</li><li><code>default</code> 语句是可选的,用于处理没有成功匹配的情况</li></ul></li></ol><h3 id="3-2-循环"><a href="#3-2-循环" class="headerlink" title="3.2 循环"></a>3.2 循环</h3><ol><li><p><code>while</code>: 先计算表达式,若为真则执行循环体. 重复该步骤,直到条件表达式为假</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (expression) &#123;<br>    code block;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>do-while</code>: 先执行一次循环体,然后计算表达式,若为真则循环再次执行.重复该步骤,直到条件表达式为假</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br>    code block;<br>&#125; <span class="hljs-keyword">while</span> (expression);<br></code></pre></td></tr></table></figure></li><li><p><code>for</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(initialize; expression; adjust) &#123;<br>    code block;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>开始时,先进行一次初始化 -&gt; 判断循环条件 -&gt; 执行循环体 -&gt; 进行调整. 重复该步骤,直到循环条件为假</li><li><code>for</code> 语句的每一部分都是可选的<ul><li>初始化: 可在外部进行</li><li>循环条件: 省略后将默认为真(死循环)</li><li>调整: 也可在内部语句进行</li></ul></li></ul></li><li><p><code>goto</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">goto</span> lable;<br>lable: 语句<br></code></pre></td></tr></table></figure><ul><li><code>:</code> 表示这里有一个标记</li><li><code>label</code> 可以是任何除 C 关键字以外的纯文本.设置在 <code>goto</code> 语句的前后均可</li><li><code>goto</code> 关键字是不被推荐的实践,最好只用于在同一函数内使用</li><li>可用于跳出多层循环, 或者 资源管理</li></ul></li><li><p><code>break</code>: 跳出本层循环</p></li><li><p><code>continue</code>: 跳过本轮循环,进入下一轮</p></li></ol><h3 id="3-3-函数"><a href="#3-3-函数" class="headerlink" title="3.3 函数"></a>3.3 函数</h3><ol><li><p>函数的定义方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">类型名 函数名(参数列表) &#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数的声明方式: 去掉函数体,加上分号即为声明语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">类型名 函数名(参数列表);<br></code></pre></td></tr></table></figure></li><li><p>任何一个 C 函数都有返回类型: <code>void</code> 或函数生成结果的类型</p><ul><li><p><code>main</code> 函数和其他函数一样,如果未显示声明返回类型,则默认返回整型</p></li><li><p>C 通过 <code>main</code> 函数的返回值告知系统是否执行成功(0 表示成功, 非0表示失败)</p></li></ul></li><li><p>参数的传递</p><ul><li>C 是按值调用的(call-by-value),也称按值传递(pass-by-value)</li><li><strong>形参(parameter)</strong>: 函数定义时的参数.仅在函数被调用时分配内存,调用结束后立即释放</li><li><strong>实参(argument)</strong>: 真实传递给函数的值.这种传值方式具有单向性</li><li>传址: 如果形参是指针,那么可以通过间接的方式修改地址存储的值</li><li>传数组: 本质上是传递数组首元素的地址</li></ul></li><li><p><strong>可变参数函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span>                <span class="hljs-comment">// 可变参数需要的头文件</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n, ...)</span> &#123;              <span class="hljs-comment">// ... 是占位符,表明参数个数不确定</span><br>    <span class="hljs-type">int</span> i, sum = <span class="hljs-number">0</span>;<br>    va_list vap;                   <span class="hljs-comment">// 定义参数列表</span><br>    va_start(vap, n);              <span class="hljs-comment">// 初始化参数列表, n 是第一个参数的名称</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        sum += va_arg(vap, <span class="hljs-type">int</span>);   <span class="hljs-comment">// 获取参数值, int 表示参数类型</span><br>    &#125;                              <span class="hljs-comment">// va_arg() 调用后, vap 自动指向下一个参数</span><br>    va_end(vap);                   <span class="hljs-comment">// 关闭参数列表</span><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>内联函数(inline): 编译器像处理宏定义的方式,将整个内联函数直接在被调用处中展开</p><ul><li>使用内联函数会导致代码编译的时间增加,但节省函数调用的时间消耗</li><li>编译器会自动将一些常用的函数优化为内联函数</li></ul></li></ol><h2 id="4-指针"><a href="#4-指针" class="headerlink" title="4 指针"></a>4 指针</h2><h3 id="4-1-指针与变量"><a href="#4-1-指针与变量" class="headerlink" title="4.1 指针与变量"></a>4.1 指针与变量</h3><ol><li><p><strong>指针就是内存地址. 而指针变量是: 存放内存地址的变量</strong></p></li><li><p>定义指针变量的方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">类型名 *指针变量名<br><span class="hljs-type">int</span> *pa<br></code></pre></td></tr></table></figure></li><li><p><code>void</code> 指针: 通用指针,可以指向任意类型的数据</p><ul><li>不要对 <code>void</code> 指针解引用</li><li>任何类型的指针均可转换为 <code>void</code> 指针,而再转换回来需要强制类型转换</li></ul></li><li><p><code>NULL</code> 指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL ((void *)0)</span><br></code></pre></td></tr></table></figure><ul><li><code>(void *)</code>: 强制类型转换,将地址 0 强转为 <code>void</code> 指针</li><li><strong>由于地址 0 通常不被使用,因此,<code>NULL</code> 是一个空指针,即不指向任何东西</strong></li><li>为防止解引用未初始化的指针,经常将其初始化为 <code>NULL</code></li><li>解引用 <code>NULL</code> 会直接使得程序崩溃.因此,在解引用指针时,应先判断是否为 <code>NULL</code></li></ul></li><li><p>指针的运算</p><ul><li><strong>加减: 相当于将指针的位置移动相应的位置.即 <code>p+1</code> 表示指向 <code>p</code> 的下一个元素</strong></li><li>比较: 运用关系运算符进行比较时,可判断指针指向的前后关系</li></ul></li><li><p><code>*</code> 运算符</p><ul><li>在定义指针变量时,用于声明是指针</li><li>在对指针进行取值操作时,获取指针指向元素的值</li><li>定义指针和取值操作是不同的,属于符号的重用</li></ul></li><li><p><code>&amp;</code> 取址运算符: 对变量进行取址操作,获得变量的地址</p></li></ol><h3 id="4-2-指针与函数"><a href="#4-2-指针与函数" class="headerlink" title="4.2 指针与函数"></a>4.2 指针与函数</h3><ol><li><p>指针函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *<span class="hljs-title function_">fp</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// fp 是指针函数</span><br></code></pre></td></tr></table></figure><ul><li><strong>函数的类型由返回值决定.当函数返回值为指针类型时,函数即为指针函数</strong></li><li>指针函数的定义方式类似于定义指针: 在类型后面加上一个 <code>*</code></li><li>注意不要返回局部变量的地址.因为局部变量仅存在于函数内部</li></ul></li><li><p>函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>);   <span class="hljs-comment">// fp 是函数指针</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>;   <span class="hljs-comment">// fun 函数名也是首地址,本质也是一个指针.类型为 int (*)(int)</span><br>                     <span class="hljs-comment">// 对于函数名而言: 它本身是一个指针,且对其取值或取址的值仍是其本身</span><br>fp = func;           <span class="hljs-comment">// 对函数指针的赋值方式.类型匹配可直接赋值</span><br>result = (*fp)(num); <span class="hljs-comment">// K&amp;R C 的调用方式.从声明形式的等价得出</span><br>result = fp(num);    <span class="hljs-comment">// UNIX 推广者的调用方式.从赋值语句的等价得出</span><br></code></pre></td></tr></table></figure></li><li><p>函数指针作为参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>), <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>; <span class="hljs-comment">// 第一个参数为函数指针</span><br><br><span class="hljs-comment">/* 函数名 add 作为实参传入 calc 函数.形参为 fp,是一个函数指针 */</span><br>result = calc(add, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure></li><li><p>函数指针作为返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>), <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><br><span class="hljs-comment">/* select 是一个函数.其参数为 char op.</span><br><span class="hljs-comment">** 返回值为一个函数指针.指向的函数类型为 int (*)(int, int) */</span><br><span class="hljs-type">int</span> (*select(<span class="hljs-type">char</span> op))(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><ul><li><code>select</code> 先与 <code>(char op)</code> 结合,成为一个函数,参数为 <code>char op</code></li><li>去掉 <code>*select(char op)</code> 后,剩余 <code>int (*)(int, int)</code> 成为 <code>select</code> 的返回值</li></ul></li></ol><h3 id="4-3-一维数组"><a href="#4-3-一维数组" class="headerlink" title="4.3 一维数组"></a>4.3 一维数组</h3><ol><li><p>声明方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">数据类型 数组名[数量];<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];  <span class="hljs-comment">// 数组下标索引从 0 开始</span><br></code></pre></td></tr></table></figure><ul><li><code>[]</code>: 后缀运算符,表示声明的对象是数组</li><li>数据类型: 指明当对数组中的元素进行访问时得到的数据类型</li><li>数量: 编译器需要根据 <code>数组类型和数量</code> 确定要分配的内存大小</li><li><strong>数组名: 其本质上是一个常量指针,其值为数组首元素的地址</strong></li></ul></li><li><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>若仅给部分元素进行初始化,则其他元素自动初始化为 0</strong></li><li>若省略数组长度,则将由编译器自行计算数组长度</li></ul></li><li><p>对于一个数组,需要的的数据为: 指向首个元素的指针 和 数组长度</p><ul><li>任何关于数组的操作,实际上均通过指针进行</li><li>任何一个数组下标运算等同于一个对应指针运算</li></ul></li><li><p><strong>访问数组元素: 数组名本质上是常量指针,指向数组的首个元素</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">arr[<span class="hljs-number">1</span>]; <span class="hljs-comment">// arr[1] 被计算为 *(arr+1)</span><br></code></pre></td></tr></table></figure></li><li><p>获取数组长度(数组名只有在作为 <code>sizeof</code> 运算符的参数时是数组)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> length = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);             <span class="hljs-comment">// 获取 arr 长度</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0])) <span class="hljs-comment">// 宏实现</span></span><br></code></pre></td></tr></table></figure></li><li><p>遍历数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;arr[%d]: %d\n&quot;</span>, i, arr[i]);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可变长数组: 可以用变量指定数组的维度</p><ul><li>C99 标准前定义数组时长度必须为常量表达式或 <code>const</code> 常量</li><li>C99 开始支持可变长数组.即数组的长度在程序运行时才决定.但完成定义后仍不能修改长度</li></ul></li></ol><h3 id="4-4-二维数组"><a href="#4-4-二维数组" class="headerlink" title="4.4 二维数组"></a>4.4 二维数组</h3><ol><li><p>定义二维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">数据类型 数组名[行数][列数];<br><span class="hljs-type">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><ul><li><strong>二维数组在内存中线性存储</strong></li><li>根据后缀运算符的结合性分析<ul><li>从左到右,<code>a</code> 与 <code>[4]</code> 结合.因而 <code>a</code> 是一个拥有4个元素的数组</li><li><code>a[4]</code> 与 <code>[5]</code> 结合.因而 <code>a[4]</code> 的每个元素都是一个拥有5个元素的一维数组</li></ul></li></ul></li><li><p>初始化二维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 根据 线性存放特性 进行初始化 */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;;<br><br><span class="hljs-comment">/* 根据 二维数组本质上是数组的数组特性 进行初始化 */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>    &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;,<br>    &#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;<br>&#125;;<br><br><span class="hljs-comment">/* 第一个维度元素可不写,交由编译器计算 */</span><br><span class="hljs-type">int</span> a[][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>访问二维数组元素</p><ul><li><strong>数组名被理解为常量指针,而二维数组又是数组的数组</strong></li><li>因而,<code>a[3][4]</code> 将被计算为 <code>*(*(a+3)+4)</code></li></ul></li><li><p>遍历二维数组: 采用嵌套循环的方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; column; ++j) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;arr[%d][%d]: %d\n&quot;</span>, row, column, arr[row][column]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多维数组: 形式上与二维数组类似,仅需在定义时增加下标数量</p></li></ol><h3 id="4-5-指针的组合"><a href="#4-5-指针的组合" class="headerlink" title="4.5 指针的组合"></a>4.5 指针的组合</h3><ol><li><p>二级指针(指针在定义就表明了如何解引用.定义时用到了多少 <code>*</code>,得到值就需要多少 <code>*</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">520</span>;  <span class="hljs-comment">// int 类型变量</span><br><span class="hljs-type">int</span> *p = &amp;num;  <span class="hljs-comment">// int * 类型指针</span><br><span class="hljs-type">int</span> **pp = &amp;p;  <span class="hljs-comment">// int ** 类型的二级指针</span><br></code></pre></td></tr></table></figure></li><li><p>指针数组 和 二级指针.经常用于字符串数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *book[] = &#123;<br>    <span class="hljs-string">&quot;book1&quot;</span>,<br>    <span class="hljs-string">&quot;book2&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>指向常量的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> cnum = <span class="hljs-number">520</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;cnum;<br></code></pre></td></tr></table></figure><ul><li>指针可以指向被 <code>const</code> 修饰的变量,不能通过指针修改其值.指针指向可改变</li><li><code>const int</code> 表示指向的是一个整型常量</li></ul></li><li><p>常量指针: 指向的是一个变量,其值可以修改,但指针指向不允许修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">520</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p = &amp;num;  <span class="hljs-comment">// const p 表示指针 p 是一个常量</span><br></code></pre></td></tr></table></figure></li><li><p>指向常量的常量指针: 指针自身不允许修改,其指向的值也不允许修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> cnum = <span class="hljs-number">520</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p = &amp;cnum;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-复合数据"><a href="#5-复合数据" class="headerlink" title="5 复合数据"></a>5 复合数据</h2><h3 id="5-1-结构体"><a href="#5-1-结构体" class="headerlink" title="5.1 结构体"></a>5.1 结构体</h3><ol><li><p>结构体定义方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名称 &#123;</span><br>    结构体成员<span class="hljs-number">1</span>;<br>    结构体成员<span class="hljs-number">2</span>;<br>    ...<br>    结构体成员n;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>关键字 <code>struct</code> 是必要的,结构体的声明需要分号</li><li>结构体名称约定第一个字符使用大写</li><li>使用 <code>.</code> 运算符访问结构体变量</li></ul></li><li><p>结构体声明方式(关键字 <code>struct</code> 是必要的)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名称 结构体变量名;</span><br></code></pre></td></tr></table></figure></li><li><p>初始化结构体</p><ul><li>结构体初始化时使用 <code>.成员名</code> 的方式指定成员值</li><li>未初始化的成员将被自动初始化.数值型初始化为 0 ,字符型初始化为 <code>&#39;\0&#39;</code></li></ul></li><li><p>结构体数组: 本质是数组,其成员为结构体类型的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名称 数组名[长度];</span><br></code></pre></td></tr></table></figure></li><li><p>结构体指针: 指向结构体的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Book</span> *<span class="hljs-title">pt</span>;</span>  <span class="hljs-comment">// pt 是一个指向 struct Book 类型的指针</span><br></code></pre></td></tr></table></figure><ul><li><p>数组名是指向第一个元素的地址,但结构体变量名并非指向该结构体的地址</p></li><li><p>结构体的地址需要通过 <code>&amp;</code> 运算符获取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Book</span> <span class="hljs-title">book</span>;</span><br>pt = &amp;book;  <span class="hljs-comment">// 获取结构体变量的地址</span><br></code></pre></td></tr></table></figure></li><li><p><strong>结构体指针访问结构体成员有两种方法(一般使用 <code>-&gt;</code>,简洁直观)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">(*结构体指针).成员名 <span class="hljs-comment">// 先解引用,再访问成员</span><br>结构体指针-&gt;成员名   <span class="hljs-comment">// 使用箭头符号,隐含这是一个指针</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="5-2-typedef"><a href="#5-2-typedef" class="headerlink" title="5.2 typedef"></a>5.2 typedef</h3><ol><li><p>给数据类型起别名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> integer;<br>integer a;<br></code></pre></td></tr></table></figure></li><li><p><strong><code>typedef</code> 与 <code>#define</code> 的区别</strong></p><ul><li><p>顺序并不一样(但可统一为前一个对象作为操作对象,后一个对象为操作后的结果)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> integer int  <span class="hljs-comment">// 将 integer 替换为 int</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> integer; <span class="hljs-comment">// 给 int 起别名为 integer</span><br></code></pre></td></tr></table></figure></li><li><p>有修饰符时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 程序编译通过. integer 被替换为 int a = 4294967295</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> integer int</span><br><span class="hljs-type">unsigned</span> integer a = <span class="hljs-number">-1</span>; <br><br><span class="hljs-comment">// 程序编译报错</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> integer;<br><span class="hljs-type">unsigned</span> integer a = <span class="hljs-number">-1</span>; <br></code></pre></td></tr></table></figure></li><li><p>定义指针变量时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 该语句预处理后替换为 int *a, b */</span><br>ptrInt a, b;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ptrInt int *</span><br><br><span class="hljs-comment">/* a, b 类型均为 int *  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> * ptrInt;<br>ptrInt a, b; <br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>与结构体搭配(数据结构的链表需要该技巧)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 将 struct Date   赋予别名 DATE</span><br><span class="hljs-comment">** 将 struct Date * 赋予别名 PDATE */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Date</span> &#123;</span><br>    <span class="hljs-type">int</span> year;<br>    <span class="hljs-type">int</span> month;<br>    <span class="hljs-type">int</span> day;<br>&#125; DATE, *PDATE;<br><br>DATE date;    <span class="hljs-comment">// 定义结构体不再需要关键字 struct</span><br>PDATE pdate;  <span class="hljs-comment">// 定义的是 结构体指针</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="5-3-简化声明"><a href="#5-3-简化声明" class="headerlink" title="5.3 简化声明"></a>5.3 简化声明</h3><ol><li><p>数组指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*ptr)[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*PTR2ARRAY)</span>[3];<br></code></pre></td></tr></table></figure></li><li><p>函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*PTR2FUN)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure></li><li><p>指针函数与数组指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* array 是一个指针数组,其元素指向指针函数.指针函数参数为 int,返回值为 int *  */</span><br><span class="hljs-type">int</span> *(*<span class="hljs-built_in">array</span>[<span class="hljs-number">3</span>])(<span class="hljs-type">int</span>);<br><br><span class="hljs-comment">/* 直接使用 typedef 会导致数组长度固定为3, 因此分成两句 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> *(*PRT2FUN)(<span class="hljs-type">int</span>);  <span class="hljs-comment">// PRT2FUN 是一个指针,指向指针函数</span><br>PRT2FUN <span class="hljs-built_in">array</span>[<span class="hljs-number">3</span>];              <span class="hljs-comment">// array 是一个拥有3个元素的数组,元素类型为 PRT2FUN</span><br></code></pre></td></tr></table></figure></li><li><p>参数为函数指针,返回值为函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*funA(<span class="hljs-type">int</span>, <span class="hljs-type">void</span> (*funB)(<span class="hljs-type">int</span>)))(<span class="hljs-type">int</span>);<br><span class="hljs-comment">/* funA 是一个指针函数.有两个参数 int, funB</span><br><span class="hljs-comment">** funB 是一个函数指针,指向的类型为 void (int)</span><br><span class="hljs-comment">** 分析 funA 的返回值: 先化简 void (*funA(参数))(int).</span><br><span class="hljs-comment">** 返回值类型为 void (int),即函数指针 */</span><br><br><span class="hljs-comment">/* 提取出共同点,可以有更为清晰的定义方式 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*PTR2FUN)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-comment">// PTR2FUN 是一个函数指针</span><br>PTR2FUN <span class="hljs-title function_">funA</span><span class="hljs-params">(<span class="hljs-type">int</span>, PTR2FUN)</span>;<br></code></pre></td></tr></table></figure></li><li><p>获取类型转换符的方法为: 去掉变量名和分号,再用括号整体封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> (*h)();  <span class="hljs-comment">// 声明 h 是一个指针,指向一个返回值为 float 的函数</span><br>(<span class="hljs-type">float</span> (*)())  <span class="hljs-comment">// 构造出对应的类型转换符</span><br></code></pre></td></tr></table></figure></li><li><p>以显式的方式调用首地址为0的子例程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(*( <span class="hljs-type">void</span> (*)() ) <span class="hljs-number">0</span>)()<br></code></pre></td></tr></table></figure><ul><li><p>先考虑 <code>(* 0)();</code></p><ul><li>本意: 想对地址0进行解引用,然后调用函数</li><li>实际: 无法生效,因为 <code>*</code> 需要一个指针作为操作数,且这里还要求是函数指针</li><li>解决方法: 先将 0 强转为函数指针</li></ul></li><li><p>考虑 <code>(void(*)())</code>.这是就是需要的类型转换符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*funcptr)</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 函数指针</span><br>(*(funcptr)<span class="hljs-number">0</span>)();  <span class="hljs-comment">// 先将0强转为函数指针,然后调用该函数</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="5-4-union"><a href="#5-4-union" class="headerlink" title="5.4 union"></a>5.4 union</h3><ol><li><p><strong>共用体可以将多个成员存储在同一空间中,它们拥有相同的起始地址.最终存储的值取决最后赋值的变量</strong></p></li><li><p>声明方式: 与 struct 类似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> 共用体名称 &#123;</span><br>    共用体成员<span class="hljs-number">1</span>;<br>    共用体成员<span class="hljs-number">2</span>;<br>    ...<br>    共用体成员n;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>共用体的定义与访问方式均与结构体类似</p></li><li><p>初始化共用体: 不能同时对所有成员都初始化</p></li></ol><h3 id="5-5-enum"><a href="#5-5-enum" class="headerlink" title="5.5 enum"></a>5.5 enum</h3><ol><li><p>如果一个变量只有几种可能的值,可以将其定义为枚举类型</p></li><li><p>枚举类型声明方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> 枚举类型名称 &#123;</span><br>    枚举值名称<span class="hljs-number">1</span>, <br>    枚举值名称<span class="hljs-number">2</span>,<br>    ...<br>    枚举值名称n,<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>枚举变量定义方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> 枚举类型名称 枚举变量名;</span><br></code></pre></td></tr></table></figure><ul><li><strong>枚举值名称可以直接像标识符那样命名,称为枚举常量</strong></li><li><strong>默认情况下 枚举常量的值从 0 开始,往后依次递增</strong></li><li>如果不希望从 0 开始,可以在声明时赋值,往后依然递增</li><li>枚举变量允许自增运算,而 C++ 中不允许</li><li>枚举常量的值和名称在编译时已经指定,不再允许修改</li></ul></li></ol><h3 id="5-6-位域"><a href="#5-6-位域" class="headerlink" title="5.6 位域"></a>5.6 位域</h3><ol><li><p><strong>位域将1字节(Byte)的二进制位划分为几个不同的区域,并指定每个区域的位数</strong></p></li><li><p>每个域有一个域名,允许在程序中按域名进行单独的操作</p></li><li><p>使用位域的方法: 在定义结构体时,在结构体成员使用冒号: 和数字表示该成员所占的位数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span> &#123;</span><br>    <span class="hljs-comment">// type [member_name] : width;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a : <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> b : <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> c : <span class="hljs-number">2</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>位域的宽度不能超过它所依附的数据类型的长度.成员变量是有类型的,位域的宽度被该类型所限制</strong></p></li><li><p>位域成员可以没有名称.但需要给出数据类型和位宽.用于填充或调整成员的位置,不能使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> :<span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-位操作"><a href="#6-位操作" class="headerlink" title="6 位操作"></a>6 位操作</h2><h3 id="6-1-位运算符"><a href="#6-1-位运算符" class="headerlink" title="6.1 位运算符"></a>6.1 位运算符</h3><ol><li><p>位操作</p><ul><li><strong>C 语言并未明确规定1字节(Byte)的尺寸.而是将其定义为:</strong><br><strong>可寻址的数据存储单位,其尺寸必须可以容纳运行环境的基本字符集的任何成员</strong></li><li>C 语言仅明确规定了 <code>char</code> 类型占用 1 Byte.其他类型仅给出相对的大小关系.具体尺寸由环境约束</li><li>编译器规定了 1 Byte 的位数.写在头文件 <code>&lt;limits.h&gt;</code> 中</li><li>C 语言允许通过位域的形式来按位存取,且允许精确到 位 的运算</li></ul></li><li><p>左移运算符</p><ul><li><p>左移运算符拥有两个操作数</p></li><li><p>左侧表示被移位的数据,右侧指定移动的位数</p></li><li><p><strong>左移移出的位数全部舍弃.右侧用 0 填充</strong></p></li><li><p>将整数左移 N 位相当于乘以 $2^N$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">result = <span class="hljs-number">0b1001010</span> &lt;&lt; <span class="hljs-number">2</span>;<br><span class="hljs-comment">// result = 0b00101000</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>右移运算符</p><ul><li><p>右移运算符拥有两个操作数</p></li><li><p>左侧表示被移位的数据,右侧指定移动的位数</p></li><li><p><strong>右移移出的位数全部舍弃.左侧用 0 填充(如果是负数,用1填充.因此负数右移永远不会为0)</strong></p></li><li><p>将整数右移 N 位相当于除以 $2^N$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">result = <span class="hljs-number">0b11001010</span> &gt;&gt; <span class="hljs-number">2</span>;<br><span class="hljs-comment">// result = 0b00110010</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>左移运算符,右移运算符均可与赋值号结合</p></li><li><p>未定义行为</p><ul><li>左移 &#x2F; 右移运算符右侧指定移动的位数为 负数 时</li><li>右侧指定移动的位数 大于 左侧操作数的最大宽度时</li></ul></li></ol><h3 id="6-2-掩码"><a href="#6-2-掩码" class="headerlink" title="6.2 掩码"></a>6.2 掩码</h3><ol><li><p>掩码本身的值一般将想要操作的对象位 置1,不变的对象位 置0</p></li><li><p><strong>判断指定位</strong>: 将源数据对指定的掩码进行按位与 <code>&amp;</code>.判断结果是否与掩码本身相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((value &amp; mask) == mask) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>打开位</strong>: 将源数据对指定的掩码进行按位或 <code>|</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">value |= mask;<br></code></pre></td></tr></table></figure></li><li><p><strong>关闭位</strong>: 将源数据对取反后的掩码进行按位与 <code>&amp;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">value &amp;= ~mask;<br></code></pre></td></tr></table></figure></li><li><p><strong>转置位</strong>: 将源数据对指定的掩码进行按位异或 ^</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">value ^= mask;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>Code</tag>
      
      <tag>C 语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
