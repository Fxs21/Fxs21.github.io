<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LVGL</title>
    <link href="/2025/06/07/Embedded/LVGL/"/>
    <url>/2025/06/07/Embedded/LVGL/</url>
    
    <content type="html"><![CDATA[<h1 id="LVGL"><a href="#LVGL" class="headerlink" title="LVGL"></a>LVGL</h1><h2 id="0-开发环境"><a href="#0-开发环境" class="headerlink" title="0 开发环境"></a>0 开发环境</h2><h3 id="0-1-简介"><a href="#0-1-简介" class="headerlink" title="0.1 简介"></a>0.1 简介</h3><ol><li><strong><a href="https://lvgl.io/">LVGL(Light and Versatile Graphics Librar)</a>: 开源的嵌入式图形库.用于创建图形用户界面的嵌入式系统</strong><ul><li>轻量级: 设计用于资源受限的嵌入式系统,内存占用小</li><li>跨平台: 支持多种微控制器和显示器</li><li>丰富的组件: 按钮, 标签, 滑块, 图表, 列表等</li><li>硬件加速: 支持利用 GPU 加速图形渲染</li><li>开源免费: 遵循 MIT 许可证</li></ul></li><li>技术规格<ul><li>架构: 面向对象的 C 语言实现</li><li>内存需求<ul><li>最低配置: ~16KB RAM, ~64KB Flash</li><li>推荐配置: ~48KB RAM, ~180KB Flash</li></ul></li><li>支持的操作系统: 可裸机运行或与 FreeRTOS, Zephyr 等 RTOS 集成</li><li>显示支持: 单缓冲, 双缓冲, 直接模式.支持多显示器</li><li>输入设备: 触摸屏, 鼠标, 键盘, 编码器等</li></ul></li></ol><h3 id="0-2-模拟器"><a href="#0-2-模拟器" class="headerlink" title="0.2 模拟器"></a>0.2 模拟器</h3><ol><li><p><a href="https://www.yuque.com/icheima/vzsofu/fm096ylkxkt6dikd">使用模拟器依赖的源码</a>(统一使用 v8.3)</p><ul><li><a href="https://github.com/lvgl/lv_port_pc_eclipse/tree/release/v8.3">模拟器源码</a>(Eclipse with SDLdriver)</li><li><a href="https://github.com/lvgl/lvgl/tree/release/v8.3">LVGL 源码</a></li><li><a href="https://github.com/lvgl/lv_drivers/tree/release/v8.3">LVGL drivers 源码</a></li></ul></li><li><p>将模拟器源码的文件解压得到 <code>lv_port_pc_eclipse-release-v8.3</code> 目录</p><ul><li>将 LVGL 源码解压并复制到到 <code>lvgl</code> 目录(原目录为空)</li><li>将 LVGL drivers 源码解压并复制到到 <code>lv_drivers</code> 目录(原目录为空)</li></ul></li><li><p><a href="https://github.com/libsdl-org/SDL/releases">下载 SDL2 库</a></p><ul><li><p>将 <code>SDL2-devel-2.32.8-mingw.zip</code> 解压得到 <code>SDL2-2.32.8</code></p></li><li><p>添加环境变量(指向 SDL 安装目录的 <code>bin</code> 目录)</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">D</span>:\code\SDL2-<span class="hljs-number">2</span>.<span class="hljs-number">32</span>.<span class="hljs-number">8</span>\x86_64-w64-mingw32\bin<br></code></pre></td></tr></table></figure></li></ul></li><li><p><a href="https://cmake.org/download/">下载安装 CMake</a>(如 <code>cmake-4.0.2-windows-x86_64.msi</code>)</p></li><li><p>将 <code>main</code> 函数改名为 <code>SDL_main</code>(SDL2 要求 Windows 平台的主函数必须是 <code>SDL_main</code>)</p></li><li><p>将 <code>D:\code\SDL2-2.32.8\x86_64-w64-mingw32\bin\SDL2.dll</code> 动态链接文件复制到工程的 <code>bin</code> 目录下</p></li><li><p>修改 <code>CMakeLists.txt</code> 文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><br><span class="hljs-comment"># SDL2 配置</span><br><span class="hljs-keyword">set</span>(SDL2_DIR <span class="hljs-string">&quot;D:/code/SDL2-2.32.8/r&quot;</span>)  <span class="hljs-comment"># 指向 SDL2 的 cmake 目录</span><br><span class="hljs-keyword">set</span>(CMAKE_MODULE_PATH <span class="hljs-variable">$&#123;CMAKE_MODULE_PATH&#125;</span> <span class="hljs-string">&quot;D:/code/SDL2-2.32.8/cmake&quot;</span>)<br><span class="hljs-keyword">project</span>(lvgl)<br><span class="hljs-keyword">set</span>(CMAKE_C_STANDARD <span class="hljs-number">11</span>)      <span class="hljs-comment"># C11</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)    <span class="hljs-comment"># C17</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-comment"># 包含头文件路径</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>)<br><br><span class="hljs-comment"># 递归收集源文件和头文件</span><br><span class="hljs-keyword">file</span>(GLOB_RECURSE INCLUDES <span class="hljs-string">&quot;lv_drivers/*.h&quot;</span> <span class="hljs-string">&quot;lvgl/demos/*.h&quot;</span> <span class="hljs-string">&quot;lvgl/*.h&quot;</span> <span class="hljs-string">&quot;./*.h&quot;</span>)<br><span class="hljs-keyword">file</span>(GLOB_RECURSE SOURCES <span class="hljs-string">&quot;lv_drivers/*.c&quot;</span> <span class="hljs-string">&quot;lvgl/demos/*.c&quot;</span> <span class="hljs-string">&quot;lvgl/src/*.c&quot;</span>)<br><br><span class="hljs-comment"># 设置输出目录</span><br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;-O3&quot;</span>)<br><br><span class="hljs-comment"># 查找 SDL2 并链接</span><br><span class="hljs-keyword">find_package</span>(SDL2 REQUIRED)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;SDL2_INCLUDE_DIRS&#125;</span>)<br><br><span class="hljs-comment"># 生成可执行文件(关键: 不启用 WIN32 子系统)</span><br><span class="hljs-keyword">add_executable</span>(main main.c mouse_cursor_icon.c <span class="hljs-variable">$&#123;SOURCES&#125;</span> <span class="hljs-variable">$&#123;INCLUDES&#125;</span>)<br><span class="hljs-keyword">add_compile_definitions</span>(LV_CONF_INCLUDE_SIMPLE)<br><br><span class="hljs-comment"># 显式链接 SDL2 库(MinGW 需要 -mconsole)</span><br><span class="hljs-keyword">if</span>(MINGW)<br>    <span class="hljs-keyword">target_link_options</span>(main PRIVATE -mconsole)  <span class="hljs-comment"># MinGW 强制启用控制台</span><br><span class="hljs-keyword">elseif</span>(MSVC)<br>    <span class="hljs-keyword">set_target_properties</span>(main PROPERTIES LINK_FLAGS <span class="hljs-string">&quot;/SUBSYSTEM:CONSOLE&quot;</span>)  <span class="hljs-comment"># MSVC 强制控制台</span><br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># 链接 SDL2 库</span><br><span class="hljs-keyword">target_link_libraries</span>(main <span class="hljs-variable">$&#123;SDL2_LIBRARIES&#125;</span>)<br><br><span class="hljs-comment"># 可选: 添加运行目标</span><br><span class="hljs-keyword">add_custom_target</span>(run <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;EXECUTABLE_OUTPUT_PATH&#125;</span>/main)<br></code></pre></td></tr></table></figure></li><li><p>编译执行代码(使用 CMake Tools 拓展生成)</p><p><img src="/2025/06/07/Embedded/LVGL/0-lvgl-demo.png"></p></li></ol><h3 id="0-3-启动流程"><a href="#0-3-启动流程" class="headerlink" title="0.3 启动流程"></a>0.3 启动流程</h3><ol><li><p>运行 demo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">SDL_main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    (<span class="hljs-type">void</span>)argc; <span class="hljs-comment">/*Unused*/</span><br>    (<span class="hljs-type">void</span>)argv; <span class="hljs-comment">/*Unused*/</span><br><br>    <span class="hljs-comment">/*Initialize LVGL*/</span><br>    lv_init();<br><br>    <span class="hljs-comment">/*Initialize the HAL (display, input devices, tick) for LVGL*/</span><br>    hal_init();<br><br>    LV_LOG_USER(<span class="hljs-string">&quot;hello, lvgl&quot;</span>);<br>    lv_demo_widgets();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">/* Periodically call the lv_task handler.</span><br><span class="hljs-comment">         * It could be done in a timer interrupt or an OS task too.*/</span><br>        lv_timer_handler();<br>        usleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>SDL_main</code>: SDL2 的推荐入口函数,用于跨平台兼容性(Windows 需要此定义)</p></li><li><p><strong><code>lv_init()</code>: 初始化 LVGL 的核心系统(内存管理, 内部数据结构等)</strong></p><ul><li>必须第一个调用,之后才能设置硬件抽象层(HAL)或创建 UI</li></ul></li><li><p><code>hal_init()</code>: 配置 LVGL 与硬件的交互接口</p><ul><li>显示(Display): SDL2 创建的虚拟屏幕</li><li>输入设备(Input Device): 如鼠标, 键盘</li><li>心跳(Tick): 提供时间基准(如 <code>SDL_Delay</code>)</li></ul></li><li><p><code>LV_LOG_USER</code>: LVGL 的日志宏,输出到控制台(需在 <code>lv_conf.h</code> 中启用 <code>LV_USE_LOG</code>)</p></li><li><p><strong><code>lv_timer_handler()</code></strong></p><ul><li>处理定时器: 执行所有注册的 LVGL 定时器</li><li>屏幕刷新: 更新脏区域(dirty areas)并触发屏幕刷新</li><li>输入设备处理: 读取输入设备(如触摸屏, 键盘)事件</li></ul></li></ol><h3 id="0-4-配置选项"><a href="#0-4-配置选项" class="headerlink" title="0.4 配置选项"></a>0.4 配置选项</h3><ol><li><p><strong><code>lv_conf.h</code>: LVGL 的核心配置文件</strong></p><ul><li>用于自定义库的功能, 性能, 内存占用</li><li>允许开发者根据项目需求裁剪 LVGL 的功能, 从而优化资源使用</li></ul></li><li><p><code>lvgl/lv_conf_template.h</code>: LVGL 源码中提供了一个模板文件</p><ul><li><p>使用时需复制并重命名为 <code>lv_conf.h</code>,通常存放于与 <code>lvgl</code> 库同级的目录</p></li><li><p>启用方式: 在 <code>lv_conf.h</code> 开头取消注释以下宏(将 0 改为 1 即可)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0 <span class="hljs-comment">/*Set it to &quot;1&quot; to enable content*/</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>关键参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Color depth: 1 (1 byte per pixel), 8 (RGB332), 16 (RGB565), 32 (ARGB8888) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_COLOR_DEPTH 32</span><br><br><span class="hljs-comment">/* Default display refresh period. LVG will redraw changed areas with this period time */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_DISP_DEF_REFR_PERIOD 16  <span class="hljs-comment">/*[ms] 1000 / 16 = 62.5fps */</span></span><br><br><span class="hljs-comment">/*Input device read period in milliseconds*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_INDEV_DEF_READ_PERIOD 16  <span class="hljs-comment">/*[ms] 1000 / 16 = 62.5fps */</span></span><br><br><span class="hljs-comment">/* Size of the memory available for `lv_mem_alloc()` in bytes (&gt;= 2kB) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_MEM_SIZE (128 * 1024U)  <span class="hljs-comment">/* [bytes] */</span></span><br></code></pre></td></tr></table></figure><ul><li><strong><code>LV_COLOR_DEPTH</code> 需要与显示屏控制器支持的格式一致</strong></li><li><code>LV_INDEV_DEF_READ_PERIOD</code> 应 ≤ <code>LV_DISP_DEF_REFR_PERIOD</code>.确保输入事件能被及时处理</li><li><code>LV_MEM_SIZE</code> 不支持动态拓展内存池大小,必须在初始化时固定(因为是静态数组)</li></ul></li></ol><h3 id="0-5-日志模块"><a href="#0-5-日志模块" class="headerlink" title="0.5 日志模块"></a>0.5 日志模块</h3><ol><li>日志级别</li></ol>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Enable the log module */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_USE_LOG 1                   <span class="hljs-comment">// 1: 启用, 0: 禁用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_LOG_LEVEL LV_LOG_LEVEL_WARN <span class="hljs-comment">// 包含 warn, error, user</span></span><br></code></pre></td></tr></table></figure><ol start="2"><li>输出方式</li></ol>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_LOG_PRINTF 1  <span class="hljs-comment">// 使用标准 printf 输出</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>使用方式</li></ol>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">LV_LOG_TRACE(<span class="hljs-string">&quot;Button %p clicked&quot;</span>, btn);    <span class="hljs-comment">// 跟踪详细流程</span><br>LV_LOG_INFO(<span class="hljs-string">&quot;Loading screen %d&quot;</span>, id);      <span class="hljs-comment">// 关键信息</span><br>LV_LOG_WARN(<span class="hljs-string">&quot;Low memory: %d bytes&quot;</span>, <span class="hljs-built_in">free</span>); <span class="hljs-comment">// 警告</span><br>LV_LOG_ERROR(<span class="hljs-string">&quot;Failed to alloc buffer!&quot;</span>);   <span class="hljs-comment">// 错误</span><br>LV_LOG_USER(<span class="hljs-string">&quot;Custom message&quot;</span>);             <span class="hljs-comment">// 用户自定义</span><br></code></pre></td></tr></table></figure><h3 id="0-6-文件系统"><a href="#0-6-文件系统" class="headerlink" title="0.6 文件系统"></a>0.6 文件系统</h3><ol><li><p><strong>文件系统: 在 LVGL 中启用 标准 C 文件系统 API(如 fopen &#x2F; fread) 的支持</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_USE_FS_STDIO 1  <span class="hljs-comment">// 1: 启用, 0: 禁用</span></span><br></code></pre></td></tr></table></figure><ul><li>作用: 开启基于 <code>stdio.h</code>(如 <code>fopen, fread</code>)的文件系统驱动</li><li>依赖: 需确保目标平台支持标准 C 文件操作(嵌入式系统可能需要实现这些函数)</li></ul></li><li><p><strong>驱动器字母映射</strong>(将逻辑驱动器号(如 <code>&#39;A&#39;</code>)映射到物理文件系统路径)</p></li></ol>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_FS_STDIO_LETTER <span class="hljs-string">&#x27;A&#x27;</span></span><br>lv_img_set_src(img, <span class="hljs-string">&quot;A:/images/logo.png&quot;</span>);  <span class="hljs-comment">// 示例: 对应实际路径 &quot;/images/logo.png&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>工作路径</strong>: 指定文件系统的根目录路径.LVGL 会将所有文件路径附加到该路径后</li></ol>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_FS_STDIO_PATH <span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_FS_STDIO_PATH <span class="hljs-string">&quot;/data&quot;</span>  <span class="hljs-comment">// 示例: 实际路径为 &quot;/data/images/logo.png&quot;</span></span><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>缓存大小</strong></li></ol>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_FS_STDIO_CACHE_SIZE 0  <span class="hljs-comment">// 0: 禁用缓存. &gt; 0: 启用缓存</span></span><br></code></pre></td></tr></table></figure><ol start="5"><li>完整示例</li></ol>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_USE_FS_STDIO 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LV_USE_FS_STDIO</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_FS_STDIO_LETTER <span class="hljs-string">&#x27;A&#x27;</span>       <span class="hljs-comment">// 通过 &quot;A:&quot; 访问文件</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_FS_STDIO_PATH <span class="hljs-string">&quot;/sd&quot;</span>       <span class="hljs-comment">// 根目录为 SD 卡挂载点</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_FS_STDIO_CACHE_SIZE 1024  <span class="hljs-comment">// 1KB 缓存</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ol start="6"><li>使用示例</li></ol>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">lv_obj_t</span> * img = lv_img_create(lv_scr_act());<br>lv_img_set_src(img, <span class="hljs-string">&quot;A:/assets/bg.jpg&quot;</span>);  <span class="hljs-comment">// 实际路径: /sd/assets/bg.jpg</span><br><br><span class="hljs-type">lv_font_t</span> * font = lv_font_load(<span class="hljs-string">&quot;A:/fonts/montserrat_16.bin&quot;</span>);<br><br><span class="hljs-type">lv_fs_file_t</span> file;<br><span class="hljs-type">lv_fs_res_t</span> res = lv_fs_open(&amp;file, <span class="hljs-string">&quot;A:/config.json&quot;</span>, LV_FS_MODE_RD);<br></code></pre></td></tr></table></figure><ul><li>若标准 <code>stdio</code> 不满足需求(如 ROM 文件系统),可参考 <code>lv_fs_stdio.c</code> 实现自定义驱动</li></ul><h2 id="1-对象"><a href="#1-对象" class="headerlink" title="1 对象"></a>1 对象</h2><h3 id="1-1-基类"><a href="#1-1-基类" class="headerlink" title="1.1 基类"></a>1.1 基类</h3><ol><li><p><strong>LVGL 中,<code>lv_obj_t</code> 是所有控件的基类(类似于面向对象编程中的父类)</strong></p><ul><li>是构建用户界面的最基本元素</li><li>所有控件(如按钮, 标签, 滑块等)都继承自 <code>lv_obj_t</code></li></ul></li><li><p><strong>创建对象</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">lv_obj_t</span> *screen = lv_scr_act();       <span class="hljs-comment">// 获取当前屏幕.是没有父对象的特殊 lv_obj_t</span><br><span class="hljs-type">lv_obj_t</span> *obj = lv_obj_create(screen); <span class="hljs-comment">// 在获取的屏幕上创建一个对象</span><br></code></pre></td></tr></table></figure></li><li><p>删除对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">lv_obj_del(obj);<br></code></pre></td></tr></table></figure><ul><li>删除对象本身及其所有子对象(递归删除整个子树)</li><li>自动解除与父对象, 组, 动画等的关联</li><li>释放对象占用的内存资源(如果使用 LVGL 的动态内存分配)</li><li>触发相关事件(如 <code>LV_EVENT_DELETE</code>)</li></ul></li><li><p>父子关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 设置父对象 */</span><br>lv_obj_set_parent(obj, new_parent);<br><br><span class="hljs-comment">/* 获取子对象 */</span><br><span class="hljs-type">lv_obj_t</span> *child = lv_obj_get_child(parent, index);<br><br><span class="hljs-comment">/* 遍历所有子对象 */</span><br><span class="hljs-type">lv_obj_t</span> *child;<br>LV_ITERATE_CHILDREN(child, parent) &#123;<br>    <span class="hljs-comment">// 处理每个子对象</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>父对象通常是容器.如 <code>lv_obj_t, lv_cont_t</code> 或屏幕 <code>lv_scr_act()</code></li><li><strong>视觉层级: 子对象永远显示在父对象之上</strong></li><li>坐标系统: 子对象的坐标是相对于父对象的,移动父对象时所有子对象会同步移动,无需逐个调整</li><li>继承属性: 子对象默认继承父对象的部分属性(如坐标相对父对象偏移, 是否可见, 是否启用等)</li><li>事件传递机制: 事件会从子对象向父对象冒泡(除非被拦截),方便实现复杂交互</li><li>管理生命周期: 删除父对象时会自动递归删除所有子对象</li></ul></li></ol><h3 id="1-2-位置"><a href="#1-2-位置" class="headerlink" title="1.2 位置"></a>1.2 位置</h3><ol><li><p>坐标系: 以左上角为原点 (0,0); 向右为正方向; 向下为正方向</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">lv_coord_t</span> x = lv_obj_get_x(obj);<br><span class="hljs-type">lv_coord_t</span> y = lv_obj_get_y(obj);<br></code></pre></td></tr></table></figure></li><li><p>位置设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">lv_obj_set_pos(obj, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>); <span class="hljs-comment">// 设置绝对坐标.从父对象的偏移 (100, 50) 像素</span><br>lv_obj_set_x(obj, x);         <span class="hljs-comment">// 仅设置X</span><br>lv_obj_set_y(obj, y);         <span class="hljs-comment">// 仅设置Y</span><br></code></pre></td></tr></table></figure></li><li><p>盒子模型: LVGL遵循CSS的 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing">border-box</a> 模型</p><p><img src="/2025/06/07/Embedded/LVGL/1-lvgl-boxmodel.png"></p></li><li><p>对齐设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 基本对齐.对齐后仍然可以设置位置</span><br>lv_obj_set_align(obj, align);<br><br><span class="hljs-comment">// 对齐到特定对象</span><br>lv_obj_align_to(obj, base, align, x_ofs, y_ofs);<br></code></pre></td></tr></table></figure><p><img src="/2025/06/07/Embedded/LVGL/1-lvgl-align.png"></p></li></ol><h3 id="1-3-尺寸"><a href="#1-3-尺寸" class="headerlink" title="1.3 尺寸"></a>1.3 尺寸</h3><ol><li><p>尺寸获取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">lv_coord_t</span> width = lv_obj_get_width(obj);<br><span class="hljs-type">lv_coord_t</span> height = lv_obj_get_height(obj);<br></code></pre></td></tr></table></figure></li><li><p>尺寸设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">lv_obj_set_size(obj, width, height);  <span class="hljs-comment">// 同时设置宽高</span><br>lv_obj_set_size(obj, LV_PCT(<span class="hljs-number">100</span>), LV_PCT(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 设置为父对象的相对大小</span><br></code></pre></td></tr></table></figure></li><li><p>特殊尺寸设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 根据内容自动调整大小</span><br>lv_obj_update_layout(obj);  <span class="hljs-comment">// 强制重新计算布局</span><br>lv_obj_refr_size(obj);      <span class="hljs-comment">// 刷新对象尺寸</span><br><br><span class="hljs-comment">// 设置尺寸模式</span><br>lv_obj_set_width_fit(obj, LV_SIZE_CONTENT);  <span class="hljs-comment">// 宽度适应内容</span><br>lv_obj_set_height_fit(obj, LV_SIZE_CONTENT); <span class="hljs-comment">// 高度适应内容</span><br><br><span class="hljs-comment">// 扩大对象的可点击区域</span><br>lv_obj_set_ext_click_area(obj, left, right, top, bottom);<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-4-布局"><a href="#1-4-布局" class="headerlink" title="1.4 布局"></a>1.4 布局</h3><ol><li><p><strong><code>Flex</code>: 以单行或单列方式动态排列子控件,自动处理空间分配和对齐.适合列表,工具栏</strong></p><ul><li><code>main axis</code>: 主轴.默认为水平方向</li><li><code>cross axis</code>: 交叉轴.与主轴垂直</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 创建 Flex 容器 */</span><br><span class="hljs-type">lv_obj_t</span> *cont = lv_obj_create(lv_scr_act());<br>lv_obj_set_size(cont, <span class="hljs-number">300</span>, <span class="hljs-number">200</span>);<br>lv_obj_set_flex_flow(cont, LV_FLEX_FLOW_ROW_WRAP);  <span class="hljs-comment">// 行排列.自动换行</span><br><br><span class="hljs-comment">/* 添加子控件 */</span><br><span class="hljs-type">lv_obj_t</span> *btn1 = lv_btn_create(cont);<br><span class="hljs-type">lv_obj_t</span> *btn2 = lv_btn_create(cont);<br><span class="hljs-type">lv_obj_t</span> *btn3 = lv_btn_create(cont);<br><br><span class="hljs-comment">/* 设置子控件弹性属性 */</span><br>lv_obj_set_flex_grow(btn1, <span class="hljs-number">1</span>);  <span class="hljs-comment">// btn1 占据剩余空间的1/4</span><br>lv_obj_set_flex_grow(btn2, <span class="hljs-number">2</span>);  <span class="hljs-comment">// btn2 占据剩余空间的2/4</span><br>lv_obj_set_flex_grow(btn3, <span class="hljs-number">1</span>);  <span class="hljs-comment">// btn2 占据剩余空间的1/4</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>Grid</code>: 通过行和列的二维网格系统精确控制子控件位置,适合复杂布局</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 创建 Grid 容器 */</span><br><span class="hljs-type">lv_obj_t</span> *cont = lv_obj_create(lv_scr_act());<br>lv_obj_set_size(cont, LV_PCT(<span class="hljs-number">100</span>), LV_PCT(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 全屏</span><br>lv_obj_set_layout(cont, LV_LAYOUT_GRID);         <span class="hljs-comment">// 启用 Grid 布局</span><br><br><span class="hljs-comment">/* 定义网格列: 左侧卡片(占2份弹性空间) + 右侧卡片(占1份弹性空间) */</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_coord_t</span> col_dsc[] = &#123;LV_GRID_FR(<span class="hljs-number">2</span>), LV_GRID_FR(<span class="hljs-number">1</span>), LV_GRID_TEMPLATE_LAST&#125;;<br><span class="hljs-comment">/* 定义网格行: 标题行高 40px + 内容区弹性填充 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_coord_t</span> row_dsc[] = &#123;<span class="hljs-number">40</span>, LV_GRID_FR(<span class="hljs-number">1</span>), LV_GRID_TEMPLATE_LAST&#125;;<br>lv_obj_set_grid_dsc_array(cont, col_dsc, row_dsc); <span class="hljs-comment">// 应用网格定义</span><br><br><span class="hljs-comment">/* 创建标题栏.居中显示.定位到第0行,跨2列 */</span><br><span class="hljs-type">lv_obj_t</span> *title = lv_label_create(cont);<br>lv_label_set_text(title, <span class="hljs-string">&quot;title&quot;</span>);<br>lv_obj_set_grid_cell(title, LV_GRID_ALIGN_CENTER, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, LV_GRID_ALIGN_CENTER, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">/* 创建温度显示栏.定位到第1行第0列 */</span><br><span class="hljs-type">lv_obj_t</span> *temp_card = lv_obj_create(cont);<br><span class="hljs-type">lv_obj_t</span> *temp_label = lv_label_create(temp_card);<br>lv_label_set_text_fmt(temp_label, <span class="hljs-string">&quot;temperature\n%d&quot;</span>, <span class="hljs-number">25</span>);<br>lv_obj_set_grid_cell(temp_card, LV_GRID_ALIGN_STRETCH, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, LV_GRID_ALIGN_STRETCH, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">/* 创建湿度显示栏.定位到第1行第1列 */</span><br><span class="hljs-type">lv_obj_t</span> *humi_card = lv_obj_create(cont);<br><span class="hljs-type">lv_obj_t</span> *humi_label = lv_label_create(humi_card);<br>lv_label_set_text_fmt(humi_label, <span class="hljs-string">&quot;humidity\n%d%%&quot;</span>, <span class="hljs-number">60</span>);<br>lv_obj_set_grid_cell(humi_card, LV_GRID_ALIGN_STRETCH, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, LV_GRID_ALIGN_STRETCH, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-5-图层"><a href="#1-5-图层" class="headerlink" title="1.5 图层"></a>1.5 图层</h3><ol><li><p>LVGL 的图层系统是管理对象显示层级和特殊覆盖界面的核心机制,它构成了屏幕内容的立体堆叠结构</p><p><img src="/2025/06/07/Embedded/LVGL/1-lvgl-layer.png"></p><ul><li><strong>固定层级关系: 系统维护严格的 z 轴顺序</strong></li><li>全局共享: 所有屏幕共用同一组图层</li><li>事件穿透: 高层可拦截低层的事件</li><li>独立渲染: 每层单独合成最终图像</li></ul></li><li><p>图层类型</p><table><thead><tr><th align="left">图层类型</th><th align="left">描述</th><th align="left">典型用途</th><th align="left">访问函数</th></tr></thead><tbody><tr><td align="left">基础层(Base)</td><td align="left">默认对象层</td><td align="left">常规 UI 内容</td><td align="left"><code>lv_scr_act()</code></td></tr><tr><td align="left">顶部层(Top)</td><td align="left">覆盖层</td><td align="left">系统状态栏</td><td align="left"><code>lv_layer_top()</code></td></tr><tr><td align="left">系统层(Sys)</td><td align="left">最高优先级</td><td align="left">弹窗, 菜单</td><td align="left"><code>lv_layer_sys()</code></td></tr></tbody></table></li><li><p>获取图层对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">lv_obj_t</span> *scr = lv_scr_act();<br><span class="hljs-type">lv_obj_t</span> *layer_top = lv_layer_top();<br><span class="hljs-type">lv_obj_t</span> *layer_sys = lv_layer_sys();<br></code></pre></td></tr></table></figure></li><li><p>图层控制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 设置图层可见性</span><br>lv_obj_add_flag(lv_layer_top(), LV_OBJ_FLAG_HIDDEN);   <span class="hljs-comment">// 隐藏顶部层</span><br>lv_obj_clear_flag(lv_layer_sys(), LV_OBJ_FLAG_HIDDEN); <span class="hljs-comment">// 显示系统层</span><br><br><span class="hljs-comment">// 移动对象到其他图层</span><br>lv_obj_move_to_layer(obj, lv_layer_sys());  <span class="hljs-comment">// 提升到系统层</span><br><br><span class="hljs-comment">// 获取对象所在图层</span><br><span class="hljs-type">lv_layer_t</span> * layer = lv_obj_get_layer(obj);<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-6-事件"><a href="#1-6-事件" class="headerlink" title="1.6 事件"></a>1.6 事件</h3><ol><li><p>事件类型</p><table><thead><tr><th align="left"><strong>事件类型</strong></th><th align="left"><strong>触发场景</strong></th><th align="left"><strong>常见事件码</strong></th></tr></thead><tbody><tr><td align="left">输入事件</td><td align="left">用户触摸, 按键, 编码器操作</td><td align="left"><code>LV_EVENT_PRESSED, LV_EVENT_CLICKED</code></td></tr><tr><td align="left">绘图事件</td><td align="left">对象需要刷新显示时</td><td align="left"><code>LV_EVENT_REFRESH, LV_EVENT_DRAW_MAIN</code></td></tr><tr><td align="left">控件特定事件</td><td align="left">特定控件独有的行为(如滑块值改变)</td><td align="left"><code>LV_EVENT_VALUE_CHANGED</code> (滑块)</td></tr><tr><td align="left">系统事件</td><td align="left">对象生命周期变化(创建, 删除, 动画完成)</td><td align="left"><code>LV_EVENT_DELETE, LV_EVENT_READY</code></td></tr></tbody></table></li><li><p><strong>事件回调: 通过 <code>lv_obj_add_event_cb()</code> 为对象绑定事件处理函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">event_handler</span><span class="hljs-params">(<span class="hljs-type">lv_event_t</span> * e)</span> &#123;<br>    <span class="hljs-type">lv_obj_t</span> *obj = lv_event_get_target(e);       <span class="hljs-comment">// 获取触发事件的对象</span><br>    <span class="hljs-type">lv_event_code_t</span> code = lv_event_get_code(e);  <span class="hljs-comment">// 获取事件类型</span><br>    <span class="hljs-type">int</span> *data = (<span class="hljs-type">int</span> *)lv_event_get_user_data(e); <span class="hljs-comment">// 获取用户数据</span><br><br>    <span class="hljs-comment">/* 根据事件类型,进行相应处理 */</span><br>    <span class="hljs-keyword">switch</span>(code) &#123;<br>    <span class="hljs-keyword">case</span> LV_EVENT_CLICKED:<br>        LV_LOG_USER(<span class="hljs-string">&quot;Button clicked!&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> LV_EVENT_VALUE_CHANGED:<br>        LV_LOG_USER(<span class="hljs-string">&quot;Value changed!&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>监听事件: 以按钮的点击事件为例(可以监听多个事件)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> my_data = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 用户数据,可以有多种类型</span><br><span class="hljs-type">lv_obj_t</span> * btn = lv_btn_create(lv_scr_act());<br>lv_obj_add_event_cb(btn, event_handler, LV_EVENT_CLICKED | LV_EVENT_PRESSED, &amp;my_data);<br></code></pre></td></tr></table></figure></li><li><p>手动触发: 以<code>值改变</code>事件为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">lv_event_send(obj, LV_EVENT_VALUE_CHANGED, <span class="hljs-string">&quot;Custom data&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>事件传递</p><ul><li><strong>冒泡传递(Bubbling): 若子对象未处理事件(返回 <code>lv_RES_INV</code>),则事件向父对象传递</strong></li><li><strong>事件穿透: 对于透明或不可点击区域,可通过返回 <code>lv_RES_INV</code> 允许事件传递到底层对象</strong></li></ul></li></ol><h2 id="2-样式"><a href="#2-样式" class="headerlink" title="2 样式"></a>2 样式</h2><h3 id="2-1-样式概念"><a href="#2-1-样式概念" class="headerlink" title="2.1 样式概念"></a>2.1 样式概念</h3><ol><li><p><strong>样式: 是构建美观界面的核心.LVGL 采用类似 CSS 的样式机制,可以灵活控制对象的外观表现</strong></p><ul><li>层级化: 支持多个样式叠加</li><li>状态敏感: 不同状态(如按下, 禁用)可应用不同样式</li><li><strong>继承机制: 子对象可继承父对象的部分样式属性</strong></li><li>低内存占用: 样式可被多个对象共享</li></ul></li><li><p>样式属性分类</p><ul><li>大小与布局: 宽度, 高度, 对齐等</li><li>背景: 颜色, 透明度, 渐变等</li><li>边框: 宽度, 颜色, 圆角等</li><li>文本: 字体, 颜色, 对齐等</li><li>特效: 阴影, 模糊, 透明度动画等</li></ul></li><li><p>基础使用方式(创建一个 <code>textarea</code> 并添加 <code>style</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 样式初始化 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style;<br>lv_style_init(&amp;style);<br><br><span class="hljs-comment">/* 设置背景样式 */</span><br>lv_style_set_radius(&amp;style, <span class="hljs-number">8</span>);                        <span class="hljs-comment">// 圆角半径</span><br>lv_style_set_bg_opa(&amp;style, LV_OPA_COVER);             <span class="hljs-comment">// 不透明度</span><br>lv_style_set_bg_color(&amp;style, lv_color_hex(<span class="hljs-number">0xF5F5F5</span>)); <span class="hljs-comment">// 浅灰色背景</span><br><br><span class="hljs-comment">/* 设置边框样式 */</span><br>lv_style_set_border_width(&amp;style, <span class="hljs-number">2</span>);                      <span class="hljs-comment">// 边框宽度</span><br>lv_style_set_border_color(&amp;style, lv_color_hex(<span class="hljs-number">0xCCCCCC</span>)); <span class="hljs-comment">// 边框颜色</span><br><br><span class="hljs-comment">/* 设置文本样式 */</span><br>lv_style_set_text_color(&amp;style, lv_color_black());      <span class="hljs-comment">// 黑色文本</span><br>lv_style_set_text_font(&amp;style, &amp;lv_font_montserrat_16); <span class="hljs-comment">// 字体</span><br><br><span class="hljs-comment">/* 设置内边距 */</span><br>lv_style_set_pad_all(&amp;style, <span class="hljs-number">10</span>); <span class="hljs-comment">// 四周内边距</span><br><br><span class="hljs-comment">/* 创建文本框对象 */</span><br><span class="hljs-type">lv_obj_t</span> *textarea = lv_textarea_create(lv_scr_act());<br>lv_obj_set_size(textarea, <span class="hljs-number">200</span>, <span class="hljs-number">80</span>); <span class="hljs-comment">// 大小</span><br>lv_obj_center(textarea);            <span class="hljs-comment">// 居中对齐</span><br>lv_textarea_set_placeholder_text(textarea, <span class="hljs-string">&quot;please input...&quot;</span>);  <span class="hljs-comment">// 提示文本</span><br>lv_textarea_set_one_line(textarea, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// 允许单行模式(按需使用)</span><br><br><span class="hljs-comment">/* 应用样式 */</span><br>lv_obj_add_style(textarea, &amp;style, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-样式状态"><a href="#2-2-样式状态" class="headerlink" title="2.2 样式状态"></a>2.2 样式状态</h3><ol><li><p><strong>添加样式时其状态参数决定了样式何时生效</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">lv_obj_add_style</span><span class="hljs-params">(<span class="hljs-type">lv_obj_t</span> * obj, <span class="hljs-type">lv_style_t</span> * style, <span class="hljs-type">lv_state_t</span> state)</span>;<br></code></pre></td></tr></table></figure></li><li><p>状态参数(<code>lv_state_t</code>)是位掩码,因此可以组合使用</p><table><thead><tr><th align="left">状态</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>LV_STATE_DEFAULT</code> (0x0000)</td><td align="left">默认状态</td></tr><tr><td align="left"><code>LV_STATE_CHECKED</code> (0x0001)</td><td align="left">切换 &#x2F; 选中状态</td></tr><tr><td align="left"><code>LV_STATE_FOCUSED</code> (0x0002)</td><td align="left">通过键盘或编码器聚焦</td></tr><tr><td align="left"><code>LV_STATE_FOCUS_KEY</code> (0x0004)</td><td align="left">通过键盘聚焦</td></tr><tr><td align="left"><code>LV_STATE_EDITED</code> (0x0008)</td><td align="left">由编码器编辑</td></tr><tr><td align="left"><code>LV_STATE_HOVERED</code> (0x0010)</td><td align="left">鼠标悬停(未按下)</td></tr><tr><td align="left"><code>LV_STATE_PRESSED</code> (0x0020)</td><td align="left">被按下</td></tr><tr><td align="left"><code>LV_STATE_SCROLLED</code> (0x0040)</td><td align="left">正在滚动</td></tr><tr><td align="left"><code>LV_STATE_DISABLED</code> (0x0080)</td><td align="left">禁用状态</td></tr></tbody></table></li><li><p>多样式示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 应用到按钮的默认状态 */</span><br>lv_obj_add_style(btn, &amp;style_btn, LV_STATE_DEFAULT);<br><br><span class="hljs-comment">/* 应用到悬停状态 */</span><br>lv_obj_add_style(btn, &amp;style_hover, LV_STATE_HOVERED);<br><br><span class="hljs-comment">/* 应用到按下 + 聚焦状态 */</span><br>lv_obj_add_style(btn, &amp;style_pressed_focused, LV_STATE_PRESSED | LV_STATE_FOCUSED);<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-样式部件"><a href="#2-3-样式部件" class="headerlink" title="2.3 样式部件"></a>2.3 样式部件</h3><ol><li><p><strong>样式部件(style parts): 可以单独设置样式的对象组成部分</strong>.如</p><ul><li>按钮由主体(MAIN)和指示器(INDICATOR)组成</li><li>滑块由主体(MAIN), 指示器(INDICATOR)和旋钮(KNOB)组成</li></ul></li><li><p>常见样式部件</p><table><thead><tr><th align="left">部件</th><th align="left">描述</th><th align="left">适用对象</th></tr></thead><tbody><tr><td align="left"><code>LV_PART_MAIN</code></td><td align="left">主体部分</td><td align="left">所有对象</td></tr><tr><td align="left"><code>LV_PART_SCROLLBAR</code></td><td align="left">滚动条</td><td align="left">可滚动容器</td></tr><tr><td align="left"><code>LV_PART_INDICATOR</code></td><td align="left">指示器</td><td align="left">滑块, 开关等</td></tr><tr><td align="left"><code>LV_PART_KNOB</code></td><td align="left">旋钮</td><td align="left">滑块, 旋钮等</td></tr><tr><td align="left"><code>LV_PART_SELECTED</code></td><td align="left">选中项</td><td align="left">列表, 表格等</td></tr><tr><td align="left"><code>LV_PART_ITEMS</code></td><td align="left">子项</td><td align="left">列表, 菜单等</td></tr></tbody></table></li><li><p>多部件样式示例(精确控制 <code>slide</code> 的指示器部分)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建样式</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_main;<br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_indicator;<br><br><span class="hljs-comment">// 初始化主体样式</span><br>lv_style_init(&amp;style_main);<br>lv_style_set_bg_color(&amp;style_main, lv_palette_main(LV_PALETTE_BLUE));<br>lv_style_set_radius(&amp;style_main, <span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 初始化指示器样式</span><br>lv_style_init(&amp;style_indicator);<br>lv_style_set_bg_color(&amp;style_indicator, lv_palette_main(LV_PALETTE_RED));<br><br><span class="hljs-comment">// 应用到滑块对象</span><br><span class="hljs-type">lv_obj_t</span> *slider = lv_slider_create(lv_scr_act());<br>lv_obj_set_align(slider, LV_ALIGN_CENTER);<br>lv_obj_add_style(slider, &amp;style_main, LV_PART_MAIN);           <span class="hljs-comment">// 主体部分</span><br>lv_obj_add_style(slider, &amp;style_indicator, LV_PART_INDICATOR); <span class="hljs-comment">// 指示器部分</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-样式管理"><a href="#2-4-样式管理" class="headerlink" title="2.4 样式管理"></a>2.4 样式管理</h3><ol><li><p><strong>本地样式(Local Styles)</strong>: 直接为对象设置样式属性,而无需创建独立的样式结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">lv_obj_set_style_bg_color(obj, lv_palette_main(LV_PALETTE_GREEN), <span class="hljs-number">0</span>);  <span class="hljs-comment">// 颜色</span><br>lv_obj_set_style_text_font(obj, &amp;lv_font_montserrat_20, <span class="hljs-number">0</span>);            <span class="hljs-comment">// 字体</span><br></code></pre></td></tr></table></figure></li><li><p>样式继承</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 创建基础样式 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_base;<br>lv_style_init(&amp;style_base);<br>lv_style_set_bg_opa(&amp;style_base, LV_OPA_COVER);<br><br><span class="hljs-comment">/* 创建继承样式 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_child;<br>lv_style_init(&amp;style_child);<br>lv_style_set_bg_color(&amp;style_child, lv_palette_main(LV_PALETTE_RED));<br>lv_style_set_parent(&amp;style_child, &amp;style_base);  <span class="hljs-comment">// 继承基础样式</span><br></code></pre></td></tr></table></figure></li><li><p>样式组织</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 按功能组织样式 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_card;          <span class="hljs-comment">// 卡片样式</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_btn_primary;   <span class="hljs-comment">// 主要按钮</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_btn_secondary; <span class="hljs-comment">// 次要按钮</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_text_title;    <span class="hljs-comment">// 标题文本</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_text_body;     <span class="hljs-comment">// 正文文本</span><br><br><span class="hljs-comment">/* 按状态组织样式 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_btn_default;<br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_btn_pressed;<br><span class="hljs-type">static</span> <span class="hljs-type">lv_style_t</span> style_btn_disabled;<br></code></pre></td></tr></table></figure></li><li><p>性能优化</p><ul><li>共享样式: 多个相似对象使用同一个样式实例</li><li>避免频繁修改: 在界面初始化时集中设置样式</li><li>使用样式缓存: 对频繁切换的样式预先创建好</li><li>合理使用过渡动画: 避免同时激活过多动画效果</li></ul></li></ol><h2 id="3-控件"><a href="#3-控件" class="headerlink" title="3 控件"></a>3 控件</h2><h3 id="3-1-标签"><a href="#3-1-标签" class="headerlink" title="3.1 标签"></a>3.1 标签</h3><ol><li><p>文本显示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">lv_obj_t</span> *label = lv_label_create(lv_scr_act());                <span class="hljs-comment">// 在屏幕上创建 label 对象</span><br>lv_label_set_text(label, <span class="hljs-string">&quot;hello, lvgl&quot;</span>);                        <span class="hljs-comment">// 文本内容</span><br>lv_obj_align(label, LV_ALIGN_CENTER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);                     <span class="hljs-comment">// 居中对齐</span><br>lv_obj_set_style_text_color(label, lv_color_hex(<span class="hljs-number">0xFF0000</span>), <span class="hljs-number">0</span>);  <span class="hljs-comment">// 字体颜色</span><br>lv_obj_set_style_text_font(label, &amp;lv_font_montserrat_20, <span class="hljs-number">0</span>);   <span class="hljs-comment">// 字体及大小</span><br></code></pre></td></tr></table></figure></li><li><p>中文支持: lvgl 自带的字库并不支持中文显示.需要创建自己的字体库</p></li><li><p>进入<a href="https://lvgl.io/tools/fontconverter">字体在线转换网站</a>进行字体转换(转换完成后将得到一个 <code>.c</code> 文件,将其加入工程)</p><img src="./4-lvgl-font-convert.png" style="zoom:67%;" /><ul><li>英文字母, 数字, 基本标点符号(与 ASCII 编码兼容): 0x20-0x7F</li><li><code>中日韩统一表意文字</code>区块包含了汉字(20992个汉字): 0x4E00-0x9FFF</li><li>全角和半角区块: 0xFF00-0xFFEF</li><li>通用标点区块(引号等): 0x2000-0x206F</li><li>CJK 符号和标点区块(句号等): 0x3000-0x303F</li></ul></li><li><p>中文显示只需要知名使用的字体即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">LV_FONT_DECLARE(sy_ky_bold);  <span class="hljs-comment">// 声明外部字体.这里使用的是 思源黑体等宽版</span><br><span class="hljs-type">lv_obj_t</span> * label = lv_label_create(lv_scr_act());    <span class="hljs-comment">// 创建 label 对象</span><br>lv_obj_set_style_text_font(label, &amp;sy_ky_bold, <span class="hljs-number">0</span>);   <span class="hljs-comment">// 使用 sy_ky_bold 字体</span><br>lv_label_set_text(label, <span class="hljs-string">&quot;好好学习，\n天天向上。&quot;</span>);    <span class="hljs-comment">// 设置中文文本</span><br></code></pre></td></tr></table></figure><p><img src="/2025/06/07/Embedded/LVGL/4-lvgl-label-Chinese.png"></p></li></ol><h3 id="3-2-图片"><a href="#3-2-图片" class="headerlink" title="3.2 图片"></a>3.2 图片</h3><ol><li><p>进入<a href="https://lvgl.io/tools/imageconverter">图片转换在线网站</a>进行图片转换(<code>Color format</code> 选择 <code>CF_TRUE_COLOR</code>.转换完成后将得到一个 <code>.c</code> 文件,将其加入工程)</p><p><img src="/2025/06/07/Embedded/LVGL/4-lvgl-image-converter.png"></p></li><li><p>图片显示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">LV_IMG_DECLARE(abao);                         <span class="hljs-comment">// 声明图片数据</span><br><span class="hljs-type">lv_obj_t</span>* img = lv_img_create(lv_scr_act());  <span class="hljs-comment">// 创建 img 对象</span><br>lv_img_set_src(img, &amp;abao);                   <span class="hljs-comment">// 设置图片源数据</span><br></code></pre></td></tr></table></figure></li><li><p>gif 显示: 转换 gif 格式数据时 <code>Color format</code> 选择 <code>CF_RAW</code>(转换完成后将得到一个 <code>.c</code> 文件,将其加入工程)</p><ul><li><p>使用 gif 图像生成文件步骤与上面的 image 生成步骤完全相同(需要在 <code>lv_conf.h</code> 文件中开启 GIF 功能)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*GIF decoder library*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_USE_GIF 1</span><br></code></pre></td></tr></table></figure></li><li><p>显示 gif</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">LV_IMG_DECLARE(astronauts);                  <span class="hljs-comment">// 声明图片数据</span><br><span class="hljs-type">lv_obj_t</span>* gif = lv_gif_create(lv_scr_act()); <span class="hljs-comment">// 创建 gif 对象</span><br>lv_gif_set_src(gif, &amp;astronauts);            <span class="hljs-comment">// 设置 gif 图片源数据</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="3-3-按钮"><a href="#3-3-按钮" class="headerlink" title="3.3 按钮"></a>3.3 按钮</h3><ol><li><p>按钮基础功能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">lv_obj_t</span> *button = lv_btn_create(lv_scr_act());  <span class="hljs-comment">// 创建 button 对象</span><br>lv_obj_align(button, LV_ALIGN_CENTER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);     <span class="hljs-comment">// 设置 button 对齐</span><br><br><span class="hljs-type">lv_obj_t</span> *label = lv_label_create(button);       <span class="hljs-comment">// 创建 label 对象</span><br>lv_label_set_text(label, <span class="hljs-string">&quot;Toggle&quot;</span>);              <span class="hljs-comment">// 设置 label 文本内容</span><br></code></pre></td></tr></table></figure></li><li><p>按钮状态系统</p><table><thead><tr><th align="left"><strong>状态标志</strong></th><th align="left"><strong>描述</strong></th><th align="left"><strong>触发条件</strong></th></tr></thead><tbody><tr><td align="left"><code>LV_STATE_DEFAULT</code></td><td align="left">默认状态</td><td align="left">初始状态</td></tr><tr><td align="left"><code>LV_STATE_PRESSED</code></td><td align="left">按下状态</td><td align="left">用户按下按钮</td></tr><tr><td align="left"><code>LV_STATE_CHECKED</code></td><td align="left">选中状态</td><td align="left">按钮被选中(需设置 CHECKABLE)</td></tr><tr><td align="left"><code>LV_STATE_DISABLED</code></td><td align="left">禁用状态</td><td align="left">按钮被禁用</td></tr><tr><td align="left"><code>LV_STATE_FOCUSED</code></td><td align="left">焦点状态</td><td align="left">按钮获得焦点</td></tr><tr><td align="left"><code>LV_STATE_EDITED</code></td><td align="left">编辑状态</td><td align="left">对象正在被编辑</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 添加状态(可以有多个状态) */</span><br>lv_obj_add_state(btn, LV_STATE_CHECKED | LV_STATE_FOCUSED);<br><br><span class="hljs-comment">/* 移除状态 */</span><br>lv_obj_clear_state(btn, LV_STATE_CHECKED);<br><br><span class="hljs-comment">/* 检查状态 */</span><br><span class="hljs-type">bool</span> is_checked = lv_obj_has_state(btn, LV_STATE_CHECKED);<br></code></pre></td></tr></table></figure></li><li><p>事件处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* clicked 事件回调函数.改变 label 的 text */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">button_handler</span><span class="hljs-params">(<span class="hljs-type">lv_event_t</span> * e)</span> &#123;<br>    <span class="hljs-type">lv_obj_t</span> *obj = lv_event_get_target(e);<br><br>    <span class="hljs-keyword">if</span>(lv_event_get_code(e) == LV_EVENT_CLICKED) &#123;<br>        <span class="hljs-type">lv_obj_t</span> *label = lv_obj_get_child(obj, <span class="hljs-number">0</span>); <span class="hljs-comment">// 获取按钮的第一个子对象(即 label)</span><br>        <span class="hljs-keyword">if</span>(label &amp;&amp; lv_obj_check_type(label, &amp;lv_label_class))<br>            lv_label_set_text(label, <span class="hljs-string">&quot;clicked&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test_button</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">lv_obj_t</span> *button = lv_btn_create(lv_scr_act());  <span class="hljs-comment">// 创建 button 对象</span><br>    lv_obj_align(button, LV_ALIGN_CENTER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);     <span class="hljs-comment">// 设置 button 对齐</span><br>    lv_obj_add_flag(button, LV_OBJ_FLAG_CHECKABLE);  <span class="hljs-comment">// 设置 button 可被选中</span><br>    lv_obj_add_event_cb(button, button_handler,<br>                        LV_EVENT_CLICKED, <span class="hljs-literal">NULL</span>);     <span class="hljs-comment">// 绑定 clicked 事件</span><br><br>    <span class="hljs-type">lv_obj_t</span> *label = lv_label_create(button);       <span class="hljs-comment">// 创建 label 对象</span><br>    lv_label_set_text(label, <span class="hljs-string">&quot;Toggle&quot;</span>);              <span class="hljs-comment">// 设置 label 文本内容</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>LVGL</tag>
      
      <tag>GUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESP32</title>
    <link href="/2024/07/01/Embedded/ESP32/"/>
    <url>/2024/07/01/Embedded/ESP32/</url>
    
    <content type="html"><![CDATA[<h1 id="ESP32-IDF"><a href="#ESP32-IDF" class="headerlink" title="ESP32-IDF"></a>ESP32-IDF</h1><h2 id="0-开发环境"><a href="#0-开发环境" class="headerlink" title="0 开发环境"></a>0 开发环境</h2><h3 id="0-1-开发板"><a href="#0-1-开发板" class="headerlink" title="0.1 开发板"></a>0.1 开发板</h3><ol><li><p>开发板型号: <a href="https://docs.espressif.com/projects/esp-dev-kits/zh_CN/latest/esp32s3/esp32-s3-devkitc-1/index.html">ESP32-S3-DevKitC-1-wroom-1</a> 进入 ESP32 官网查看开发板资料</p><p><img src="/2024/07/01/Embedded/ESP32/0-ESP32-S3-DevKitC-1-wroom-1.png"></p><ul><li>拥有两个 USB 接口.一个是 USB 转串口, 另一个是 USB OTG 接口(JTAG 调试)</li><li>拥有两个按键: RST 是复位键. 若按住 Boot 键的同时按一下 RST 进入 <code>固件下载</code> 模式</li><li>RGB LED: 可寻址 RGB 发光二极管(WS2812). 注意 v1.0 由 GPIO48 驱动, v1.1 由 GPIO38 驱动</li></ul></li><li><p>芯片型号: <code>ESP32-S3 N16R8</code>.模组 <code>ESP32-S3-DevKitC-1-N16R8V</code> 引脚</p><p><img src="/2024/07/01/Embedded/ESP32/0-ESP32-S3-DevKitC-Pin.jpg"></p></li><li><p>本文档实际使用的开发板为 <a href="https://wiki.lckfb.com/zh-hans/szpi-esp32s3/">实战派开发板S3介绍 | 立创开发板技术文档中心</a></p></li><li><p><strong>ESP32-S3-WROOM-1-N16R8: 乐鑫(Espressif)推出的一款高性能 Wi-Fi&#x2F;蓝牙双模模组</strong></p><ul><li>ESP32-S3: 主控芯片型号(Xtensa LX7 双核, 240MHz)</li><li>WROOM-1: 模组系列(集成 PCB 天线)</li><li>N16: 内置 16MB SPI Flash.(四线 SPI, 支持 120MHz, 理论传输速率 60MB&#x2F;s)</li><li>R8: 内置 8MB Octal PSRAM(八线 Octal PSRAM, 最高 120MHz, 理论带宽 120MB&#x2F;s)</li><li>无线: 2.4GHz Wi-Fi 4 (802.11 b&#x2F;g&#x2F;n) + Bluetooth 5 LE</li><li>天线: 板载 PCB 天线</li></ul></li></ol><h3 id="0-2-Linux-环境"><a href="#0-2-Linux-环境" class="headerlink" title="0.2 Linux 环境"></a>0.2 <a href="https://www.bilibili.com/video/BV1eRg7exEcT?spm_id_from=333.788.videopod.episodes&vd_source=ca18f72085fcabc81ea5ba4e594aefe7&p=2">Linux 环境</a></h3><ol><li><p>搭建 Linux 开发环境参考 Linux 文档环境搭建部分(这里默认搭建完成,并使用 Ubuntu)</p></li><li><p>环境搭建</p><ul><li><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install git wget flex bison gperf python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 net-tools<br></code></pre></td></tr></table></figure></li><li><p>拉取 ESP-IDF 源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建工作目录</span><br>mkdir -p ~/esp<br>cd ~/esp<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用脚本,将 github 地址映射为 gitee,减少因网络而导致的配置失败</span><br>git clone https://gitee.com/EspressifSystems/esp-gitee-tools.git<br>cd esp-gitee-tools   # 执行 gitee 工具切换镜像脚本<br>./jihu-mirror.sh set # 执行脚本,将 github 地址映射为 gitee<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拉取 esp-idf 源码(文件较多,耐心等待)</span><br>cd ~/esp<br>git clone --recursive https://github.com/espressif/esp-idf.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到 5.2 版本(包括子模块).保持环境一致(非必需)</span><br>cd esp-idf<br>git checkout v5.2<br>git submodule update --init --recursive<br></code></pre></td></tr></table></figure></li><li><p>配置编译环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">更换 pip 源(非必需).可以使用 pip config list 命令查看当前的 pip 镜像源</span><br>pip config set global.index-url http://mirrors.aliyun.com/pypi/simple<br>pip config set global.trusted-host mirrors.aliyun.com<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装编译工具</span><br>../esp-gitee-tools/install.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置环境变量.该操作每次打开一个终端都要运行,后面介绍解决办法</span><br>source export.sh<br></code></pre></td></tr></table></figure></li></ul></li><li><p>编译示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">copy 官方 example</span><br>cd ~/esp<br>mkdir esp-proj<br>cp -r esp-idf/examples/get-started/hello_world/ esp-proj/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译工程</span><br>cd esp-proj/hello_world/   # 进入工程目录.idf.py 的指令需要在项目的所处的目录中执行<br>idf.py set-target esp32s3  # 配置芯片型号.需查阅开发板原理图<br>idf.py build               # 构建项目<br></code></pre></td></tr></table></figure></li><li><p>烧录示例: 需要将开发板连接到 Linux(如果使用是 WSL, 可参考 Linux 文档的连接 USB 设备部分)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">烧录指令.出现 Done 表示烧录完成.需要进入烧录模式(按住 boot 键,按一次 reset)</span><br>idf.py flash<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时会出现 /dev/ttyUSB0 failed to connect... 因此先修改权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">该操作会随着设备拔插失效,因此每次都要执行.后面描述解决办法</span><br>sudo chmod 777 /dev/ttyUSB0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">烧录并监视串口. Ctrl + ] 退出</span><br>idf.py flash monitor<br></code></pre></td></tr></table></figure></li><li><p>优化配置</p><ul><li><p>永久环境变量: 将添加环境变量的语句添加到 <code>.profile</code> 文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;export IDF_PATH=~/esp/esp-idf&quot; &gt;&gt; ~/.profile<br>echo &quot;source \$IDF_PATH/export.sh&quot; &gt;&gt; ~/.profile<br></code></pre></td></tr></table></figure></li><li><p>解决每次插拔设备后权限不足的问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将当前用户添加到 dialout 组.使其获得串口设备的访问权限</span><br>sudo usermod -aG dialout $USER<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后重新连接客户会话终端.后续不再需要修改权限</span><br>exit              # 完全退出当前 SSH 会话或终端.然后需要手动重新连接<br>id | grep dialout # 验证修改.需要确认当前用户已经加入了 dialout 组<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>ESP-IDF</code> 插件(在 VSCode 中选择虚拟机安装拓展)</p><ul><li>解决 VSCode 会因为不知道源码路径,头文件引入会标红,代码补全也无法使用的问题</li><li>按 <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>P</kbd>, 搜索 <code>esp-idf add VS Code Configuration Folder</code> 将源码路径添加到工程</li></ul></li></ol><h3 id="0-3-IDF-工具"><a href="#0-3-IDF-工具" class="headerlink" title="0.3 IDF 工具"></a>0.3 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/api-guides/tools/idf-py.html">IDF 工具</a></h3><ol><li><p><code>idf.py</code> 命令行工具提供了一个前端界面, 管理工程构建, 工程部署, 工程调试等操作</p><ul><li><code>CMake</code>: 配置要构建的工程</li><li><code>Ninja</code>: 构建工程</li><li><code>esptool</code>: 烧录目标芯片</li><li>注意 <code>idf.py</code> 应在 <code>esp-idf</code> 工程目录下运行.即包含 <code>CMakeLists.txt</code> 文件的目录</li></ul></li><li><p>前置工作相关</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py set-target esp32s3  # 指定芯片类型为 esp32s3<br>idf.py menuconfig          # 打开配置界面.一般第一次需要修改 flash size<br>idf.py save-defconfig      # 生成 sdkconfig.defaults 默认配置文件<br>idf.py create-project test # 创建一个名为 test 的工程<br></code></pre></td></tr></table></figure></li><li><p>构建项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py build       # 编译项目代码, 生成可执行固件.默认输出到 build 目录<br>idf.py clean       # 清除构建生成的临时文件(保留配置)<br>idf.py fullclean   # 彻底清除构建目录和配置(包括 sdkconfig)<br>idf.py reconfigure # 重新运行 CMake 并更新配置<br></code></pre></td></tr></table></figure></li><li><p>烧录固件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py flash          # 构建并烧录. -p &lt;port&gt; 指定串口, -b &lt;baud&gt; 指定烧录波特率<br>idf.py flash-settings # 仅烧录分区表和配置(非完整固件)<br>idf.py erase-flash    # 擦除整个 flash<br>idf.py erase-otadata  # 擦除 OTA 数据<br></code></pre></td></tr></table></figure></li><li><p>调试监控</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py monitor # 启动串口监视器,查看设备日志(默认波特率 115200). Ctrl + ] 退出监视器<br>idf.py gdb     # 启动 GDB 调试器(需提前配置 OpenOCD 或 JTAG)<br>idf.py openocd # 启动 OpenOCD 调试服务<br></code></pre></td></tr></table></figure></li><li><p>其他</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py size             # 显示应用程序大小.包括 RAM 和 flash 及各部分大小<br>idf.py merge bin        # 合并二进制文件<br>idf.py create-component # 创建新组件<br></code></pre></td></tr></table></figure></li><li><p>切换 idf 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前 idf 版本</span><br>idf.py --version<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换 idf 版本</span><br>cd ~/esp/esp-idf    # 需要进入到 esp-idf 目录进行操作<br>git checkout v5.4.1 # 切换到 V5.4.1<br>git submodule update --init --recursive  # 更新子模块<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重新安装工具链</span><br>./install.sh     # 安装匹配的工具链<br>source export.sh # 设置环境变量<br></code></pre></td></tr></table></figure></li><li><p>烧录完成后 esp32 的启动流程</p><ul><li>一级引导程序: 固化于 ROM 中,不可修改.加载二级引导程序到 RAM 执行<ul><li>通过检查 IO0 引脚的电平,选择程序模式</li><li>当芯片上电检测到 IO0 引脚为低电平时,进入下载模式,否则执行二级引导程序</li></ul></li><li>二级引导程序: <code>boot loader</code> 程序.从 0x8000 处读取分区表,处理各种段,加载应用程序</li><li>应用程序: 硬件外设和基本 C 语言运行环境的初始化, <code>freeRTOS</code> 初始化, 最后执行 <code>app_main()</code> 函数</li></ul></li></ol><h3 id="0-4-工程配置"><a href="#0-4-工程配置" class="headerlink" title="0.4 工程配置"></a>0.4 工程配置</h3><ol><li><p>在工程目录下执行下面命令打开交互式配置菜单(基于 Kconfig)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py menuconfig<br></code></pre></td></tr></table></figure><p><img src="/2024/07/01/Embedded/ESP32/0-Ubuntu-idf-menuconfig.png"></p><ul><li><code>menuconfig</code> 用于配置芯片型号, 串口, Wi-Fi 等参数</li><li>配置保存在 <code>sdkconfig</code> 文件中</li></ul></li><li><p>目前阶段可修改的配置</p><ul><li>系统主频: <code>Component config -&gt; ESP system setting -&gt; cpu frequency</code> 选为 240MHz</li><li>Flash 大小: <code>Serial flasher config -&gt; Flash size</code> 选为 16MB(需要根据具体芯片型号选择)</li><li>按 <kbd>S</kbd> 保存, <kbd>Q</kbd> 退出</li></ul></li><li><p>注意: 修改了 <code>menuconfig</code> 后,需要重新编译工程(<code>idf.py build</code>)</p></li></ol><h3 id="0-5-工程结构"><a href="#0-5-工程结构" class="headerlink" title="0.5 工程结构"></a>0.5 工程结构</h3><ol><li><p>最基础的 esp-idf 项目结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">my_esp32_project/   # 项目根目录<br>├── CMakeLists.txt  # 项目顶层 CMake 文件(必需): 设置项目名称和包含 esp-idf 构建系统<br>├── sdkconfig       # 项目配置文件(自动生成): 保存 idf.py menuconfig 的所有配置选项<br>├── build/          # 构建输出目录(自动生成): 包含最终的二进制文件(bootloader, 分区表, 应用程序)<br>├── main/           # main 组件(必需且名称固定): 特殊的必需组件.包含应用程序的入口点<br>│   ├── CMakeLists.txt          # main 组件的 CMake 文件<br>│   └── main.c                  # 应用程序入口文件<br>└── components/                 # 自定义组件目录(名称固定)<br>    └── my_component/           # 示例自定义组件<br>        ├── CMakeLists.txt      # 组件的 CMake 文件(必需)<br>        ├── Kconfig.projbuild   # 组件的配置选项(可选)<br>        ├── include/            # 公共头文件目录(可选)<br>        │   └── my_component.h  # 公共头文件<br>        └── src/<br>            └── my_component.c  # 实现文件<br></code></pre></td></tr></table></figure></li><li><p>项目顶层 <code>CMakeLists.txt</code> </p><ul><li><p>最小项目</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># ./CMakeLists.txt</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.16</span>) <span class="hljs-comment"># 指定构建本项目所需的 CMake 最低版本</span><br><span class="hljs-keyword">include</span>($ENV&#123;IDF_PATH&#125;/tools/cmake/<span class="hljs-keyword">project</span>.cmake) <span class="hljs-comment"># 包含并导入 esp-idf 构建系统</span><br><span class="hljs-keyword">project</span>(hello_world)                 <span class="hljs-comment"># 定义项目名称并完成项目的最终配置</span><br></code></pre></td></tr></table></figure></li><li><p>可选的配置项</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(IDF_TARGET esp32s3)              <span class="hljs-comment"># 可选: 设置目标芯片型号(默认为 esp32)</span><br><span class="hljs-keyword">set</span>(PARTITIONS_TABLE partitions.csv) <span class="hljs-comment"># 可选: 指定自定义分区表文件</span><br></code></pre></td></tr></table></figure></li><li><p>导入组件到工程(idf 路径下的默认组件无需声明就可以使用.这里介绍的其他组件导入方式)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(EXTRA_COMPONENT_DIRS ../../components) <span class="hljs-comment"># 可选: 指定额外的组件目录</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>main</code> 组件</p><ul><li>包含 <code>app_main()</code> 函数.这是程序的起点</li><li>构建系统会自动将其包含在项目中.无需在顶层 CMake 中显式声明</li><li>可以依赖其他组件,但其他组件不能依赖 <code>main</code> 组件</li></ul></li></ol><h3 id="0-6-组件"><a href="#0-6-组件" class="headerlink" title="0.6 组件"></a>0.6 组件</h3><ol><li><p>**组件(Component): 一个独立的代码库.**包含以下内容</p><ul><li>源代码(<code>.c</code> 文件)</li><li>头文件(<code>.h</code> 文件)</li><li>组件配置文件(<code>Kconfig.projbuild</code>)</li><li>编译脚本(<code>CMakeLists.txt</code>)</li><li>版本依赖, 资源文件等</li></ul></li><li><p>ESP-IDF 本身就是由许多这样的组件构成的(如 <code>driver, spi_flash, nvs_flash, freertos</code> 等)</p></li><li><p>组件的 <code>CMakeLists.txt</code>: 定义组件的源文件, 头文件, 依赖</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># components/my_component/CMakeLists.txt</span><br><br><span class="hljs-comment"># 注册组件</span><br>idf_component_register(<br>    SRCS <span class="hljs-string">&quot;src/my_component.c&quot;</span>,  <span class="hljs-comment"># 列出所有源文件</span><br>    INCLUDE_DIRS <span class="hljs-string">&quot;include&quot;</span>,     <span class="hljs-comment"># 列出公共头文件目录.供其他组件包含</span><br>    REQUIRES driver esp_timer   <span class="hljs-comment"># 列出此组件依赖的公共组件</span><br>)<br></code></pre></td></tr></table></figure></li><li><p>组件的配置文件(<code>Kconfig.projbuild</code>): 将你的组件的配置选项添加到 <code>idf.py menuconfig</code> 的图形化配置菜单中</p></li><li><p>依赖</p><ul><li><code>REQUIRES</code>: 声明公共依赖.你的组件的头文件需要这些依赖的头文件.并继续传递下去</li><li><code>PRIV_REQUIRES</code>: 声明私有依赖.这些依赖仅用于你的组件的源文件编译和链接.不会传递给其他组件</li></ul></li><li><p>在 <code>main</code> 组件中使用其他组件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># main/CMakeLists.txt</span><br><br>idf_component_register(<br>    SRCS <span class="hljs-string">&quot;main.c&quot;</span>,<br>    REQUIRES my_component  <span class="hljs-comment"># 声明 main 组件依赖于 my_component</span><br>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="0-7-API-约定"><a href="#0-7-API-约定" class="headerlink" title="0.7 API 约定"></a>0.7 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/api-reference/api-conventions.html">API 约定</a></h3><ol><li><p>编程接口</p><ul><li>在 ESP-IDF 组件的公共头文件中声明的 C 函数, 结构体, 枚举, 类型定义, 预处理器宏</li><li>编译系统函数, 预定义变量, 选项</li><li><code>Kconfig</code> 选项, 可用于代码及编译系统文件</li><li>主机工具及其命令行参数</li></ul></li><li><p>错误处理</p><ul><li>多数 ESP-IDF API 会返回由 <code>esp_err_t</code> 类型定义的错误代码.实质上是带符号的整型<ul><li><code>ESP_OK</code> 代表成功,其值定义为0</li><li>错误代码通常均以 <code>ESP_ERR_</code> 前缀开头</li><li>常见错误(比如内存不足, 超时, 无效参数等)的错误代码则已经在 <code>esp_err.h</code> 文件中定义</li></ul></li><li>向 <code>esp_err_to_name</code> 函数传递错误码作为参数即可转换为具体的错误消息</li><li>宏 <code>ESP_ERROR_CHECK</code> 的功能和 <code>assert</code> 类似.若参数不等于 <code>ESP_OK</code>,则打印错误消息,并调用 <code>abort()</code></li></ul></li><li><p>配置结构体</p><ul><li><p>为确保应用程序与未来 ESP-IDF 版本的兼容性,请正确初始化配置结构体</p></li><li><p>多数 ESP-IDF 中的初始化, 配置, 安装函数: 形如 <code>..._init(), ..._config(), ..._install()</code>,<br>都需要一个指向配置结构体的指针作为参数</p></li><li><p><strong>应用程序必须初始化结构体的所有字段</strong></p></li><li><p>使用 C99 的指定初始化器完成结构体的初始化.以简洁的方式设置字段,并将剩余字段初始化为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">esp_timer_create_args_t</span> my_timer_args = &#123;<br>    .callback = &amp;my_timer_callback,<br>    <span class="hljs-comment">/* 正确.字段 .arg 和 .name 已初始化为零 */</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>私有 API</p><ul><li><strong>某些头文件包含的 API 仅限于在 ESP-IDF 源代码中使用,不支持在应用程序中使用</strong></li><li>此类头文件的名称或路径通常带有 <code>private</code> 或 <code>esp_private</code></li><li>私有 API 可能在次要或补丁版本之间以不兼容的方式被删除或更改</li></ul></li><li><p><code>esp-idf</code> 的 <code>freeRTOS</code></p><ul><li>优先级问题: esp32 有双核,因此任务是可以并行的</li><li>esp-idf 自动创建5个任务: 空闲, 定时器, app_main, IPC, ESP 定时器</li><li>esp-idf 不使用原生的 FreeRTOS 内存堆管理,实现了自己的堆</li><li>删除任务应避免删除另一个核心的任务</li><li>临界区使用自旋锁确保同步(因为还有一个核心)</li><li>若任务中用到浮点运算,则创建任务时必须指定具体运行的核心,而不能由系统安排</li><li>通常负责处理无线网络的任务固定到 cpu0, 处理应用程序其余部分的任务被固定到 cpu1</li></ul></li><li><p>在 <code>esp-idf</code> 中,为了支持双核,重新实现了创建任务的 api</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskCreatePinnedToCore</span> <span class="hljs-params">(</span><br><span class="hljs-params">    TaskFunction_t pxTaskCode,  <span class="hljs-comment">// 指向任务函数的指针</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> pcName,   <span class="hljs-comment">// 任务名,最大长度为 configMax_TASK_NAME_LEN</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> configSTACK_DEPTH_TYPE usStackDepth,  <span class="hljs-comment">// 任务堆栈大小,默认单位为4字节</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span> *<span class="hljs-type">const</span> pvParameters,  <span class="hljs-comment">// 传递给任务函数的参数</span></span><br><span class="hljs-params">    UBaseType_t uxPriority,    <span class="hljs-comment">// 任务优先级, 0 ~ configMAX_PRIORITIES - 1</span></span><br><span class="hljs-params">    TaskHandle_t *<span class="hljs-type">const</span> pxCreatedTask,  <span class="hljs-comment">// 任务句柄,即任务的控制块</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> BaseType_t xCoreID   <span class="hljs-comment">// 分配到哪个内核运行</span></span><br><span class="hljs-params">)</span>;<br><span class="hljs-comment">// 返回值 pdPASS 表示创建成功. errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY 表示失败</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="0-8-开发演示"><a href="#0-8-开发演示" class="headerlink" title="0.8 开发演示"></a>0.8 开发演示</h3><ol><li><p>新建项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">source ~/esp/esp-idf/export.sh    # 环境引入<br>idf.py create-project jlc-esp32s3 # 新建项目<br>cd jlc-esp32s3                    # 进入目录<br>git add .                         # 将所有文件暂存<br>git commit -m &quot;git init&quot;          # 首次提交<br></code></pre></td></tr></table></figure></li><li><p>编译烧录(先编写代码)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py set-target esp32s3<br>idf.py build flash monitor<br></code></pre></td></tr></table></figure></li><li><p>工具引入</p><ul><li><p>使用 C&#x2F;C++ 插件进行文件跳转: 新建文件 <code>.vscode/c_cpp_properties.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ESP-IDF&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;compileCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/build/compile_commands.json&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gcc-x64&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>需要注意 构建时是否生成了 <code>build/compile_commands.json</code></p></li></ul></li><li><p>默认配置</p><ul><li><p>根据 esp 的型号配置 <code>config</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py menuconfig<br></code></pre></td></tr></table></figure></li><li><p>将其保存为 <code>sdkconfig.defaults</code>(若发现该更改未生效,可以将 <code>sdkconfig</code> 文件删除后重新编译)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py save-defconfig<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-9-组件建立"><a href="#0-9-组件建立" class="headerlink" title="0.9 组件建立"></a>0.9 组件建立</h3><ol><li><p>新建 <code>components/esp32s3_szp</code> 目录作为 esp32s3 实战派的板级支持包.具体如下</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nix">your_project<span class="hljs-symbol">/</span><br>├── components<span class="hljs-symbol">/</span><br>│   └── esp32s3_szp<span class="hljs-symbol">/</span>          <span class="hljs-comment"># 板级支持包组件</span><br>│       ├── CMakeLists.txt    <span class="hljs-comment"># 组件构建配置</span><br>│       ├── Kconfig.projbuild <span class="hljs-comment"># 组件配置选项</span><br>│       ├── include<span class="hljs-symbol">/</span><br>│       │   └── esp32s3_szp.h <span class="hljs-comment"># 公共头文件</span><br>│       └── src<span class="hljs-symbol">/</span><br>│           ├── esp32s3_szp.c <span class="hljs-comment"># 主要实现文件</span><br>├── main<span class="hljs-symbol">/</span><br>│   ├── CMakeLists.txt<br>│   └── main.c<br>└── CMakeLists.txt<br></code></pre></td></tr></table></figure></li><li><p>组件 <code>CMake</code> 配置(<code>components/esp32s3_szp/CMakeLists.txt</code>)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 立创实战派 ESP32-S3 板级支持包</span><br>idf_component_register(<br>    SRCS<br>        <span class="hljs-string">&quot;src/esp32s3_szp.c&quot;</span><br>    INCLUDE_DIRS<br>        <span class="hljs-string">&quot;include&quot;</span><br>    REQUIRES<br>        driver        <span class="hljs-comment"># 基础外设驱动(GPIO, SPI, I2C, ADC等)</span><br>        log           <span class="hljs-comment"># 日志系统</span><br>    PRIV_REQUIRES<br>        nvs_flash     <span class="hljs-comment"># 非易失存储</span><br>        esp_timer     <span class="hljs-comment"># 定时器</span><br>        freertos      <span class="hljs-comment"># RTOS 功能</span><br>)<br></code></pre></td></tr></table></figure></li><li><p>组件 <code>Kconfig</code> 配置文件(<code>components/esp32s3_szp/Kconfig.projbuild</code>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kconfig"># components/esp32s3_szp/Kconfig.projbuild<br><br>menu &quot;立创实战派 ESP32-S3 配置&quot;<br><br>    config SZP_BOARD_VERSION<br>        string &quot;板卡版本&quot;<br>        default &quot;V1.0&quot;<br>        help<br>            立创实战派ESP32-S3开发板版本号<br><br>endmenu<br></code></pre></td></tr></table></figure></li><li><p>公共头文件(<code>components/esp32s3_szp/include/esp32s3_szp.h</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 获取板卡信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">szp_get_board_info</span><span class="hljs-params">(<span class="hljs-type">char</span> *info, <span class="hljs-type">int</span> len)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>主要实现文件(<code>components/esp32s3_szp/src/esp32s3_szp.c</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp32s3_szp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sdkconfig.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">szp_get_board_info</span><span class="hljs-params">(<span class="hljs-type">char</span> *info, <span class="hljs-type">int</span> len)</span><br>&#123;<br>    <span class="hljs-built_in">snprintf</span>(info, len, <span class="hljs-string">&quot;立创实战派 ESP32-S3 开发板 %s&quot;</span>, CONFIG_SZP_BOARD_VERSION);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>主程序的使用</p><ul><li><p>在 <code>main/CMakeLists.txt</code> 引入组件依赖</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake">idf_component_register(<br>    SRCS <span class="hljs-string">&quot;main.c&quot;</span><br>    INCLUDE_DIRS <span class="hljs-string">&quot;.&quot;</span><br>    REQUIRES esp32s3_szp<br>)<br></code></pre></td></tr></table></figure></li><li><p>在 <code>main/main.c</code> 中调用函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp32s3_szp.h&quot;</span></span><br>szp_get_board_info(board_info, <span class="hljs-keyword">sizeof</span>(board_info));<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-基础外设"><a href="#1-基础外设" class="headerlink" title="1 基础外设"></a>1 基础外设</h2><h3 id="1-1-GPIO"><a href="#1-1-GPIO" class="headerlink" title="1.1 GPIO"></a>1.1 GPIO</h3><ol><li><p>ESP32-S3 芯片具有 48 个物理 GPIO 管脚</p><ul><li>每个管脚都可用作一个通用的 IO, 或连接一个内部的外设信号</li><li>通过 IO MUX, RTC IO MUX, GPIO 交换矩阵,可配置外设模块的输入信号来源于任何的 IO 管脚</li><li>外设模块的输出信号也可连接到任意 IO 管脚</li></ul></li><li><p>GPIO 管脚作用</p><ul><li>作为简单的 GPIO 输入读取引脚上的电平</li><li>作为简单的 GPIO 输出以输出所需的电平</li><li>作为外设信号的输入 &#x2F; 输出</li></ul></li><li><p>API 参考(需要包含头文件 <code>#include &quot;driver/gpio.h&quot;</code>)</p><ul><li><p>配置 &#x2F; 重置 GPIO 引脚</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span> pin_bit_mask;         <span class="hljs-comment">// 64bit.每个 bit 表示一个 GPIO</span><br>    <span class="hljs-type">gpio_mode_t</span> mode;              <span class="hljs-comment">// GPIO 的模式: input / output</span><br>    <span class="hljs-type">gpio_pullup_t</span> pull_up_en;      <span class="hljs-comment">// 内部上拉是否使能</span><br>    <span class="hljs-type">gpio_pulldown_t</span> pull_down_en;  <span class="hljs-comment">// 内部下拉是否使能</span><br>    <span class="hljs-type">gpio_int_type_t</span> intr_type;     <span class="hljs-comment">// GPIO 中断类型</span><br>&#125; <span class="hljs-type">gpio_config_t</span>;<br><br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_config</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">gpio_config_t</span> *pGPIOConfig)</span>;<br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_reset_pin</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num)</span>;<br></code></pre></td></tr></table></figure></li><li><p>使能 &#x2F; 失能 GPIO 中断(GPIO 36, GPIO39 不能在使用 ADC, WiFi, 蓝牙, 睡眠模式 时开启)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_set_intr_type</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num, <span class="hljs-type">gpio_int_type_t</span> intr_type)</span>;<br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_intr_disable</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num)</span>;<br></code></pre></td></tr></table></figure></li><li><p>指定 GPIO 输出电平 &#x2F; 获取 GPIO 输入电平</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_set_level</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num, <span class="hljs-type">uint32_t</span> level)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">gpio_get_level</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num)</span>;<br></code></pre></td></tr></table></figure></li><li><p>查看 GPIO 配置状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 输出 GPIO4, GPIO18, GPIO26 的配置状态 */</span><br>gpio_dump_io_configuration(<span class="hljs-built_in">stdout</span>, (<span class="hljs-number">1ULL</span> &lt;&lt; <span class="hljs-number">4</span>) | (<span class="hljs-number">1ULL</span> &lt;&lt; <span class="hljs-number">18</span>) | (<span class="hljs-number">1ULL</span> &lt;&lt; <span class="hljs-number">26</span>));<br></code></pre></td></tr></table></figure></li><li><p>安装中断服务: 会为所有 GPIO 中断注册一个全局 ISR. 与 <code>gpio_isr_register</code> 函数不兼容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** 此函数配合通过 gpio_isr_handler_add 函数注册各个引脚处理程序</span><br><span class="hljs-comment">  * @param  intr_alloc_flags: 分配中断的标志 */</span><br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_install_isr_service</span><span class="hljs-params">(<span class="hljs-type">int</span> intr_alloc_flags)</span><br></code></pre></td></tr></table></figure></li><li><p>添加 GPIO 中断服务函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** @param gpio_num: GPIO 引脚号</span><br><span class="hljs-comment">  * @param isr_handler: 指定引脚的中断服务函数</span><br><span class="hljs-comment">  * @param args: 传递给中断服务函数的参数 */</span><br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_isr_handler_add</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num, <span class="hljs-type">gpio_isr_t</span> isr_handler, <span class="hljs-type">void</span> *args)</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-2-EXTI"><a href="#1-2-EXTI" class="headerlink" title="1.2 EXTI"></a>1.2 EXTI</h3><ol><li><p>硬件信息: 立创 S3 开发板的按键为 IO0, 位于右上角.接 10K 上拉电阻</p><p><img src="/2024/07/01/Embedded/ESP32/1-boot-key.png"></p></li><li><p>实验思路</p><ul><li>将 IO0 设为上拉输入模式,并开启下降沿中断,注册其中断函数</li><li>在 <code>app_main</code> 函数中创建一个任务(用于 GPIO0 下降沿触发后待执行), 以及一个消息队列</li><li>当中断触发时,获取到参数 GPIO0.然后通过消息队列传递给任务,该任务将 GPIO 端口和电平打印出来</li></ul></li><li><p>具体实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;freertos/FreeRTOS.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;freertos/task.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;freertos/queue.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/gpio.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USER_KEY_GPIO GPIO_NUM_0            <span class="hljs-comment">// 按键 gpio</span></span><br><span class="hljs-type">static</span> QueueHandle_t user_key_queue = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 队列句柄</span><br><br><span class="hljs-comment">/* GPIO 中断服务函数.该函数只是将消息传递给任务函数,并不进行处理 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> IRAM_ATTR <span class="hljs-title function_">gpio_isr_handler</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-type">uint32_t</span> gpio_num = (<span class="hljs-type">uint32_t</span>) arg;<br>    xQueueSendFromISR(user_key_queue, &amp;gpio_num, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-comment">/* GPIO 中断处理任务.该任务接收消息队列的数据.然后将其打印 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">key_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-type">uint32_t</span> gpio_num;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span>(xQueueReceive(user_key_queue, &amp;gpio_num, portMAX_DELAY))<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;GPIO[%ld] intr. val: %d\n&quot;</span>, gpio_num, gpio_get_level(gpio_num));<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">szp_user_key_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    user_key_queue = xQueueCreate(<span class="hljs-number">10</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint32_t</span>));             <span class="hljs-comment">// 创建消息队列</span><br>    xTaskCreate(key_task, <span class="hljs-string">&quot;key_task&quot;</span>, <span class="hljs-number">2048</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>, <span class="hljs-literal">NULL</span>);  <span class="hljs-comment">// 创建中断任务</span><br><br>    <span class="hljs-type">gpio_config_t</span> io0_conf = &#123;<br>        .intr_type = GPIO_INTR_NEGEDGE,        <span class="hljs-comment">// 下降沿中断</span><br>        .mode = GPIO_MODE_INPUT,               <span class="hljs-comment">// 输入模式</span><br>        .pin_bit_mask = <span class="hljs-number">1ULL</span> &lt;&lt; USER_KEY_GPIO, <span class="hljs-comment">// 选择 GPIO0</span><br>        .pull_down_en = <span class="hljs-number">0</span>,                     <span class="hljs-comment">// 禁能内部下拉</span><br>        .pull_up_en = <span class="hljs-number">1</span>                        <span class="hljs-comment">// 使能内部上拉</span><br>    &#125;;<br>    gpio_config(&amp;io0_conf);  <span class="hljs-comment">// 配置 GPIO</span><br><br>    <span class="hljs-comment">/* 安装 GPIO ISR 服务,设置中断处理函数 */</span><br>    gpio_install_isr_service(<span class="hljs-number">0</span>);<br>    gpio_isr_handler_add(USER_KEY_GPIO, gpio_isr_handler, (<span class="hljs-type">void</span> *)USER_KEY_GPIO);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-3-LEDC"><a href="#1-3-LEDC" class="headerlink" title="1.3 LEDC"></a>1.3 LEDC</h3><ol><li><p>ledc 主要用于控制 LED,也可产生 pwm 信号用于其他设备的控制</p><ul><li>led pwm 控制器可在无需 cpu 干预的情况下自动改变占空比,实现亮度和颜色渐变</li><li>该控制器有 8 路通道,可以产生独立的波形,驱动 rgb led 等设备</li><li>ledc 通道共有两组,分别为 8 路高速通道和 8 路低速通道<ul><li>高速通道模式在硬件中实现,可以自动且无干扰地改变 pwm 占空比</li><li>低速通道模式下,pwm 占空比需要由软件中的驱动器改变,每组通道都可以使用不同的时钟源</li></ul></li></ul></li><li><p>基本的 <code>led</code> 呼吸灯效果(这里采用 lcd 背光进行演示)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;freertos/FreeRTOS.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;freertos/task.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_err.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/ledc.h&quot;</span></span><br><br><span class="hljs-comment">// LED 配置</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDC_GPIO         GPIO_NUM_42         <span class="hljs-comment">// 使用 GPIO42 连接 led</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDC_CHANNEL      LEDC_CHANNEL_0      <span class="hljs-comment">// 使用 channel0(共8个)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDC_TIMER        LEDC_TIMER_0        <span class="hljs-comment">// 使用 timer0(共4个)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDC_MODE         LEDC_LOW_SPEED_MODE <span class="hljs-comment">// 使用 低速模式</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDC_DUTY_RES     LEDC_TIMER_13_BIT   <span class="hljs-comment">// 设置 13bit 分辨率.2^13 = 8192级亮度</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDC_FREQUENCY    5000                <span class="hljs-comment">// PWM 频率 5kHz</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">backlight_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 1. 配置定时器 */</span><br>    <span class="hljs-type">ledc_timer_config_t</span> ledc_timer = &#123;<br>        .speed_mode       = LEDC_MODE,      <span class="hljs-comment">// 速度模式</span><br>        .timer_num        = LEDC_TIMER,     <span class="hljs-comment">// 选择定时器0</span><br>        .duty_resolution  = LEDC_DUTY_RES,  <span class="hljs-comment">// 设置分辨率</span><br>        .freq_hz          = LEDC_FREQUENCY, <span class="hljs-comment">// PWM 频率 5kHz</span><br>        .clk_cfg          = LEDC_AUTO_CLK,  <span class="hljs-comment">// 自动选择时钟源</span><br>    &#125;;<br>    ESP_ERROR_CHECK(ledc_timer_config(&amp;ledc_timer));<br><br>    <span class="hljs-comment">/* 2. 配置通道 */</span><br>    <span class="hljs-type">ledc_channel_config_t</span> ledc_channel = &#123;<br>        .speed_mode     = LEDC_MODE,         <span class="hljs-comment">// 速度模式与定时器一致</span><br>        .channel        = LEDC_CHANNEL,      <span class="hljs-comment">// 选择通道0</span><br>        .timer_sel      = LEDC_TIMER,        <span class="hljs-comment">// 绑定到定时器0</span><br>        .intr_type      = LEDC_INTR_DISABLE, <span class="hljs-comment">// 禁用中断</span><br>        .gpio_num       = LEDC_GPIO,         <span class="hljs-comment">// 绑定引脚</span><br>        .duty           = <span class="hljs-number">0</span>,                 <span class="hljs-comment">// 初始占空比为0</span><br>        .hpoint         = <span class="hljs-number">0</span>                  <span class="hljs-comment">// 相位点.通常设为0</span><br>    &#125;;<br>    ESP_ERROR_CHECK(ledc_channel_config(&amp;ledc_channel));<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">app_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    backlight_init();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 渐亮效果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> duty = <span class="hljs-number">0</span>; duty &lt; (<span class="hljs-number">1</span> &lt;&lt; LEDC_TIMER_13_BIT); duty += <span class="hljs-number">100</span>) &#123;<br>            ESP_ERROR_CHECK(ledc_set_duty(LEDC_MODE, LEDC_CHANNEL, duty));<br>            ESP_ERROR_CHECK(ledc_update_duty(LEDC_MODE, LEDC_CHANNEL));<br>            vTaskDelay(<span class="hljs-number">10</span> / portTICK_PERIOD_MS);<br>        &#125;<br><br>        <span class="hljs-comment">// 渐暗效果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> duty = (<span class="hljs-number">1</span> &lt;&lt; LEDC_TIMER_13_BIT) - <span class="hljs-number">1</span>; duty &gt;= <span class="hljs-number">0</span>; duty -= <span class="hljs-number">100</span>) &#123;<br>            ESP_ERROR_CHECK(ledc_set_duty(LEDC_MODE, LEDC_CHANNEL, duty));<br>            ESP_ERROR_CHECK(ledc_update_duty(LEDC_MODE, LEDC_CHANNEL));<br>            vTaskDelay(<span class="hljs-number">10</span> / portTICK_PERIOD_MS);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-4-UART"><a href="#1-4-UART" class="headerlink" title="1.4 UART"></a>1.4 UART</h3><ol><li><p>uart 控制器</p><ul><li>ESP32-S3 包含3个 uart 控制器<ul><li>uart0: 通常用于编程和调试输出</li><li>uart1: 通用 uart.但某些引脚用于 Flash</li><li>uart2: 通用 uart.最常用于用户应用</li></ul></li><li>可配置的波特率(最高 5Mbps)</li><li>中断驱动和 DMA 支持</li><li>RS485 模式支持</li><li><strong>uart 引脚是高度可配置的.几乎所有 gpio 都可以用作 uart 引脚</strong></li></ul></li><li><p>uart 相关 api 使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/uart.h&quot;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">szp_uart_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">uart_config_t</span> uart_config = &#123;<br>        .baud_rate = <span class="hljs-number">9600</span>,                     <span class="hljs-comment">// 波特率</span><br>        .data_bits = UART_DATA_8_BITS,         <span class="hljs-comment">// 8bit 数据位</span><br>        .parity = UART_PARITY_DISABLE,         <span class="hljs-comment">// 无校验</span><br>        .stop_bits = UART_STOP_BITS_1,         <span class="hljs-comment">// 1bit 停止位</span><br>        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE, <span class="hljs-comment">// 关闭硬件流控</span><br>        .source_clk = UART_SCLK_DEFAULT,       <span class="hljs-comment">// 默认时钟源</span><br>    &#125;;<br>    uart_param_config(UART_NUM_1, &amp;uart_config);<br>    uart_set_pin(UART_NUM_1, <span class="hljs-number">11</span>, <span class="hljs-number">10</span>, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);<br>    uart_driver_install(UART_NUM_1, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">szp_uart_send_data</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* data)</span><br>&#123;<br>    uart_write_bytes(UART_NUM_1, data, <span class="hljs-built_in">strlen</span>(data));         <span class="hljs-comment">// 发送数据</span><br>    uart_wait_tx_done(UART_NUM_1, <span class="hljs-number">100</span> / portTICK_PERIOD_MS);  <span class="hljs-comment">// 等待发送完成</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">szp_uart_receive_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> data[<span class="hljs-number">128</span>];<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 读取数据</span><br>        <span class="hljs-type">int</span> len = uart_read_bytes(UART_NUM_1, data, <span class="hljs-keyword">sizeof</span>(data) - <span class="hljs-number">1</span>, <span class="hljs-number">20</span> / portTICK_PERIOD_MS);<br>        <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>            data[len] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">// 添加字符串结束符</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received: %s\n&quot;</span>, data);<br>        &#125;<br>        vTaskDelay(<span class="hljs-number">10</span> / portTICK_PERIOD_MS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-5-I2C"><a href="#1-5-I2C" class="headerlink" title="1.5 I2C"></a>1.5 I2C</h3><ol><li><p>i2c 控制器</p><ul><li>ESP32-S3 包含2个 i2c 控制器<ul><li>i2c0: 通常用于内部系统功能</li><li>i2c1: 最常用于用户应用</li></ul></li><li>支持 7bit(常用)和 10bit 设备地址</li><li>i2c 引脚是高度可配置的.几乎所有 gpio 都可以用作 i2c 引脚</li></ul></li><li><p>硬件信息: 姿态传感器 QMI8658A.SDA 连接于 IO1, SCL 连接于 IO2</p><p><img src="/2024/07/01/Embedded/ESP32/1-QMI8658A.png"></p></li><li><p>实验目标: 通过 I2C 与 QMI8658A 传感器通信,获取加速度和倾角值(当前只读取 0x0 的 id 寄存器,预期为 0x5)</p></li><li><p>i2c 相关 api 使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/i2c_master.h&quot;</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">i2c_master_bus_handle_t</span> bus_handle;<br><span class="hljs-type">static</span> <span class="hljs-type">i2c_master_dev_handle_t</span> qmi8658_handle;<br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">szp_i2c_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">i2c_master_bus_config_t</span> i2c_mst_config = &#123;<br>        .i2c_port = I2C_NUM_0,                <span class="hljs-comment">// 使用 I2C0 控制器</span><br>        .scl_io_num = GPIO_NUM_2,             <span class="hljs-comment">// SCL 时钟线使用 GPIO2</span><br>        .sda_io_num = GPIO_NUM_1,             <span class="hljs-comment">// SDA 数据线使用 GPIO1</span><br>        .glitch_ignore_cnt = <span class="hljs-number">7</span>,               <span class="hljs-comment">// 毛刺忽略计数为 7.用于抗干扰</span><br>        .clk_source = I2C_CLK_SRC_DEFAULT,    <span class="hljs-comment">// 使用默认的 I2C 时钟源</span><br>        .flags.enable_internal_pullup = <span class="hljs-literal">true</span>, <span class="hljs-comment">// 启用内部上拉电阻</span><br>    &#125;;<br>    ESP_ERROR_CHECK(i2c_new_master_bus(&amp;i2c_mst_config, &amp;bus_handle));<br><br>    <span class="hljs-type">i2c_device_config_t</span> dev_cfg = &#123;<br>        .dev_addr_length = I2C_ADDR_BIT_LEN_7, <span class="hljs-comment">// 7bit 设备地址模式</span><br>        .device_address = <span class="hljs-number">0x6A</span>,                <span class="hljs-comment">// QMI8658 的 I2C 地址为 0x6A</span><br>        .scl_speed_hz = <span class="hljs-number">100000</span>,                <span class="hljs-comment">// SCL 时钟频率为 100kHz(标准模式)</span><br>    &#125;;<br>    ESP_ERROR_CHECK(i2c_master_bus_add_device(bus_handle, &amp;dev_cfg, &amp;qmi8658_handle));<br>    <span class="hljs-keyword">return</span> ESP_OK;<br>&#125;<br><br><span class="hljs-comment">/* 读取 QMI8658 寄存器的值 */</span><br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">szp_qmi8658_register_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> reg_addr, <span class="hljs-type">uint8_t</span> *data, <span class="hljs-type">size_t</span> len)</span> &#123;<br>    <span class="hljs-keyword">return</span> i2c_master_transmit_receive(qmi8658_handle, &amp;reg_addr, <span class="hljs-number">1</span>, data, len, <span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-comment">/* 给 QMI8658 的寄存器写值 */</span><br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">szp_qmi8658_register_write_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> reg_addr, <span class="hljs-type">uint8_t</span> data)</span> &#123;<br>    <span class="hljs-type">uint8_t</span> write_buf[<span class="hljs-number">2</span>] = &#123;reg_addr, data&#125;;<br>    <span class="hljs-keyword">return</span> i2c_master_transmit(qmi8658_handle, write_buf, <span class="hljs-keyword">sizeof</span>(write_buf), <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-6-SPI"><a href="#1-6-SPI" class="headerlink" title="1.6 SPI"></a>1.6 SPI</h3><ol><li><p>spi 控制器</p><ul><li>ESP32-S3包含4个 spi 控制器<ul><li><strong>SPI0</strong>: 用于连接外部 Flash 和 PSRAM(系统专用)</li><li><strong>SPI1</strong>: 用于连接外部 Flash 和 PSRAM(系统专用)</li><li><strong>SPI2</strong>: 通用SPI.也称为HSPI(用户可用)</li><li><strong>SPI3</strong>: 通用SPI.也称为VSPI(用户可用)</li></ul></li><li>最高 80MHz 时钟频率</li></ul></li><li><p>spi 相关 api 使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/spi_master.h&quot;</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">spi_device_handle_t</span> spi_handle;<br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">szp_spi_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">spi_bus_config_t</span> bus_config = &#123;<br>        .mosi_io_num = GPIO_NUM_11,         <span class="hljs-comment">// MOSI 引脚 (主出从入)</span><br>        .miso_io_num = GPIO_NUM_13,         <span class="hljs-comment">// MISO 引脚 (主入从出)</span><br>        .sclk_io_num = GPIO_NUM_12,         <span class="hljs-comment">// SCLK 时钟引脚</span><br>        .quadwp_io_num = GPIO_NUM_NC,       <span class="hljs-comment">// 未使用 Quad SPI 的 WP 引脚</span><br>        .quadhd_io_num = GPIO_NUM_NC,       <span class="hljs-comment">// 未使用 Quad SPI 的 HD 引脚</span><br>        .max_transfer_sz = <span class="hljs-number">4096</span>,            <span class="hljs-comment">// 最大传输大小</span><br>        .flags = SPICOMMON_BUSFLAG_MASTER,  <span class="hljs-comment">// 主模式标志</span><br>    &#125;;<br>    ESP_ERROR_CHECK(spi_bus_initialize(SPI2_HOST, &amp;bus_config, SPI_DMA_CH_AUTO));<br><br>    <span class="hljs-type">spi_device_interface_config_t</span> dev_config = &#123;<br>        .command_bits = <span class="hljs-number">0</span>,                  <span class="hljs-comment">// 命令位数为0(不使用命令相位)</span><br>        .address_bits = <span class="hljs-number">0</span>,                  <span class="hljs-comment">// 地址位数为0(不使用地址相位)</span><br>        .dummy_bits = <span class="hljs-number">0</span>,                    <span class="hljs-comment">// 虚拟位数为0</span><br>        .mode = <span class="hljs-number">0</span>,                          <span class="hljs-comment">// SPI mode0(CPOL=0, CPHA=0)</span><br>        .duty_cycle_pos = <span class="hljs-number">128</span>,              <span class="hljs-comment">// 时钟占空比(默认50%)</span><br>        .cs_ena_pretrans = <span class="hljs-number">0</span>,               <span class="hljs-comment">// 传输前 CS 建立时间</span><br>        .cs_ena_posttrans = <span class="hljs-number">0</span>,              <span class="hljs-comment">// 传输后 CS 保持时间</span><br>        .clock_speed_hz = <span class="hljs-number">1</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>,  <span class="hljs-comment">// 时钟频率 1MHz</span><br>        .input_delay_ns = <span class="hljs-number">0</span>,                <span class="hljs-comment">// 输入延迟</span><br>        .spics_io_num = GPIO_NUM_10,        <span class="hljs-comment">// CS 片选引脚</span><br>        .flags = <span class="hljs-number">0</span>,                         <span class="hljs-comment">// 附加标志</span><br>        .queue_size = <span class="hljs-number">7</span>,                    <span class="hljs-comment">// 传输队列大小</span><br>        .pre_cb = <span class="hljs-literal">NULL</span>,                     <span class="hljs-comment">// 传输前回调函数</span><br>        .post_cb = <span class="hljs-literal">NULL</span>,                    <span class="hljs-comment">// 传输后回调函数</span><br>    &#125;;<br>    ESP_ERROR_CHECK(spi_bus_add_device(SPI2_HOST, &amp;dev_config, &amp;spi_handle));<br>    <span class="hljs-keyword">return</span> ESP_OK;<br>&#125;<br><br><span class="hljs-comment">/* SPI 带命令和地址的传输 */</span><br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">szp_spi_transfer_cmd_addr</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> cmd, <span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *tx_data, <span class="hljs-type">uint8_t</span> *rx_data, <span class="hljs-type">size_t</span> length)</span><br>&#123;<br>    <span class="hljs-type">spi_transaction_t</span> transaction = &#123;<br>        .cmd = cmd,            <span class="hljs-comment">// 命令字节</span><br>        .addr = addr,          <span class="hljs-comment">// 地址(32bit)</span><br>        .length = length * <span class="hljs-number">8</span>,  <span class="hljs-comment">// 数据长度</span><br>        .tx_buffer = tx_data,  <span class="hljs-comment">// 发送数据</span><br>        .rx_buffer = rx_data,  <span class="hljs-comment">// 接收数据</span><br>    &#125;;<br>    <br>    <span class="hljs-keyword">return</span> spi_device_transmit(spi_handle, &amp;transaction);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-7-PSRAM"><a href="#1-7-PSRAM" class="headerlink" title="1.7 PSRAM"></a>1.7 PSRAM</h3><ol><li><p>ESP-IDF 默认不启用 psram,即使硬件支持.需在配置中显式开启</p><ul><li>因为 psram 的时钟配置和电源管理可能影响功耗和稳定性</li></ul></li><li><p>启用 psram</p><ul><li><p>ESP32-S3-WROOM-1-N16R8 的 PSRAM 通过 <strong>Octal SPI</strong> 连接,需确保配置为 <code>OPI</code> 模式</p></li><li><p>在 <code>menuconfig</code> 中开启 <code>external SPI-connected RAM</code> 并选择为 <code>Octal Mode PSRAM</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Component config -&gt; ESP PSRAM -&gt; Support for external, SPI-connected RAM -&gt; SPI RAM config<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Mode (QUAD/OCT) of SPI RAM chip <span class="hljs-keyword">in</span> use (Octal Mode PSRAM) -&gt; Octal Mode PSRAM  <span class="hljs-comment"># 开启 psram</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Set RAM clock speed -&gt; 80MHz  <span class="hljs-comment"># 将频率设为 80MHz(最大)</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>日志分析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">boot.esp32s3: Boot SPI Speed : 80MHz  # SPI Flash 运行频率为 80MHz<br>boot.esp32s3: SPI Mode       : DIO    # DIO 模式(Dual I/O, 双线数据输入输出)<br>boot.esp32s3: SPI Flash Size : 16MB   # 检测到外部 SPI Flash 容量为 16MB<br><br>boot: ## Label     Usage       Type  ST   Offset    Length<br>boot:  0 nvs       WiFi data    01   02  00009000  00006000 # 存储 Wi-Fi 配置等非易失性数据<br>boot:  1 phy_init  RF data      01   01  0000f000  00001000 # 存储 RF 射频校准数据<br>boot:  2 factory   factory app  00   00  00010000  00100000 # 主应用程序固件分区<br><br>I (233) esp_psram: Found 8MB PSRAM device  # 检测到 8MB Octal PSRAM,初始化成功<br>I (238) esp_psram: Speed: 40MHz            # 速度: 40MHz<br>I (973) esp_psram: SPI SRAM memory test OK # PSRAM 自检通过.耗时较长,约 700ms<br><br>cpu_start: Pro cpu start user code # 主核(CPU0)开始执行用户代码<br>cpu_start: cpu freq: 160000000 Hz  # CPU 主频设置为 160MHz<br><br>heap_init: Initializing. RAM available for dynamic allocation: # 初始化堆内存<br>heap_init: At 3FC95C20 len 00053AF0 (334 KiB): RAM  # 内部 RAM<br>heap_init: At 3FCE9710 len 00005724 (21 KiB): RAM   # 内部 RAM<br>heap_init: At 3FCF0000 len 00008000 (32 KiB): DRAM  # 用于 DMA<br>heap_init: At 600FE010 len 00001FD8 (7 KiB): RTCRAM # 深度睡眠可保留内存<br>esp_psram: Adding pool of 8192K of PSRAM memory to heap allocator # PSRAM 加入堆分配器<br><br>I (1104) main_task: Calling app_main() # 调用用户编写的 app_main(),应用程序正式运行<br></code></pre></td></tr></table></figure></li><li><p>psram 内存申请(系统初始化后,psram 已自动加入堆分配器)</p><ul><li><p>标准分配函数(自动选择)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 普通 malloc 可能分配到内部 RAM 或 PSRAM</span><br><span class="hljs-comment">// 系统优先使用内部 RAM,大内存会自动分配到 PSRAM</span><br><span class="hljs-type">uint8_t</span> *buffer = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>); <span class="hljs-comment">// 分配 2MB</span><br></code></pre></td></tr></table></figure></li><li><p>强制分配到 psram</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_heap_caps.h&quot;</span></span><br><br><span class="hljs-comment">// 明确分配在 PSRAM</span><br><span class="hljs-type">uint8_t</span> *psram_buffer = heap_caps_malloc(<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>, MALLOC_CAP_SPIRAM); <br><br><span class="hljs-comment">// 分配并初始化为 0</span><br><span class="hljs-type">uint8_t</span> *psram_buffer_zero = heap_caps_calloc(<span class="hljs-number">1024</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>), MALLOC_CAP_SPIRAM);<br></code></pre></td></tr></table></figure></li><li><p>C++ 对象分配到 psram</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_heap_caps.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SensorData</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">float</span> readings[<span class="hljs-number">2048</span>];<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">heap_caps_malloc</span>(size, MALLOC_CAP_SPIRAM);<br>&#125;<br><br>SensorData *data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SensorData</span>(); <span class="hljs-comment">// 分配到 PSRAM</span><br></code></pre></td></tr></table></figure></li><li><p>检查内存位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_spiram.h&quot;</span></span><br><br><span class="hljs-keyword">if</span> (esp_spiram_is_initialized()) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PSRAM 可用, 总大小: %d MB\n&quot;</span>, esp_spiram_get_size() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (esp_ptr_external_ram(ptr)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;指针指向 PSRAM\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>psram 与 sram 的区别</p><table><thead><tr><th align="left">特性</th><th align="left">内部 RAM (SRAM)</th><th align="left">PSRAM (SPI PSRAM)</th></tr></thead><tbody><tr><td align="left"><strong>物理位置</strong></td><td align="left">芯片内部</td><td align="left">外部 SPI 芯片 (通常 Octal 8线)</td></tr><tr><td align="left"><strong>速度</strong></td><td align="left">160MHz 全速访问 (5-10ns)</td><td align="left">40-80MHz SPI 访问 (25-50ns)</td></tr><tr><td align="left"><strong>容量</strong></td><td align="left">较小 (ESP32-S3: 512KB)</td><td align="left">较大 (通常 2MB&#x2F;4MB&#x2F;8MB)</td></tr><tr><td align="left"><strong>功耗</strong></td><td align="left">低 (集成设计)</td><td align="left">较高 (需 SPI 总线驱动)</td></tr><tr><td align="left"><strong>保留数据</strong></td><td align="left">睡眠时可保留</td><td align="left">断电&#x2F;深度睡眠丢失数据</td></tr><tr><td align="left"><strong>DMA 支持</strong></td><td align="left">完全支持</td><td align="left">不支持 (需复制到内部 RAM)</td></tr><tr><td align="left"><strong>访问方式</strong></td><td align="left">CPU 直接寻址</td><td align="left">通过 SPI 控制器间接访问</td></tr><tr><td align="left"><strong>成本</strong></td><td align="left">较高 (占用芯片面积)</td><td align="left">较低 (独立芯片)</td></tr></tbody></table></li><li><p>性能差异演示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// SRAM 写入耗时: 130152 cycles</span><br><span class="hljs-comment">// PSRAM 写入耗时: 162400 cycles</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">test_speed</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">uint8_t</span> *sram_buf = heap_caps_malloc(<span class="hljs-number">10000</span>, MALLOC_CAP_INTERNAL);<br>    <span class="hljs-type">uint8_t</span> *psram_buf = heap_caps_malloc(<span class="hljs-number">10000</span>, MALLOC_CAP_SPIRAM);<br><br>    <span class="hljs-type">uint32_t</span> start = esp_cpu_get_cycle_count();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) sram_buf[i] = i % <span class="hljs-number">256</span>;<br>    <span class="hljs-type">uint32_t</span> sram_time = esp_cpu_get_cycle_count() - start;<br><br>    start = esp_cpu_get_cycle_count();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) psram_buf[i] = i % <span class="hljs-number">256</span>;<br>    <span class="hljs-type">uint32_t</span> psram_time = esp_cpu_get_cycle_count() - start;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SRAM 写入耗时: %lu cycles\nPSRAM 写入耗时: %lu cycles\n&quot;</span>, <br>           sram_time, psram_time);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最佳实践</p><ul><li>psram: 大型缓冲(图像 &#x2F; 音频), 不频繁访问的配置数据</li><li>内部 ram: 高频访问数据, DMA 缓冲区, RTOS 任务栈</li></ul></li></ol><h2 id="2-设备驱动"><a href="#2-设备驱动" class="headerlink" title="2 设备驱动"></a>2 设备驱动</h2><h3 id="2-1-TF"><a href="#2-1-TF" class="headerlink" title="2.1 TF"></a>2.1 TF</h3><ol><li><p>硬件连接</p><p><img src="/2024/07/01/Embedded/ESP32/2-TFCard.png"></p><ul><li>TF 与 ESP32 的通信方式: spi, sdio(这里采用 sdio 的 1bit 模式.只使用 DAT0 数据线)</li></ul></li><li><p>ESP32-S3(ESP32-S3-WROOM-1) 的 <code>sdmmc</code> 控制器(引脚固定.无法更改)</p><table><thead><tr><th align="left">信号线</th><th align="left">GPIO引脚</th><th align="left">功能描述</th></tr></thead><tbody><tr><td align="left">CMD</td><td align="left">GPIO48</td><td align="left">命令 &#x2F; 响应线</td></tr><tr><td align="left">CLK</td><td align="left">GPIO47</td><td align="left">时钟信号</td></tr><tr><td align="left">DAT0</td><td align="left">GPIO21</td><td align="left">数据线0</td></tr><tr><td align="left">DAT1</td><td align="left">GPIO20</td><td align="left">数据线1 (1位模式不需要)</td></tr><tr><td align="left">DAT2</td><td align="left">GPIO19</td><td align="left">数据线2 (1位模式不需要)</td></tr><tr><td align="left">DAT3</td><td align="left">GPIO18</td><td align="left">数据线3 (1位模式不需要)</td></tr></tbody></table></li><li><p>在 <code>main/CMakeLists.txt</code> 中添加</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">REQUIRES fatfs sdmmc<br></code></pre></td></tr></table></figure></li><li><p><code>sdmmc</code> 相关接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_err.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_log.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_vfs_fat.h&quot;</span> <span class="hljs-comment">// FAT 文件系统虚拟文件系统层.负责文件系统挂载</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sdmmc_cmd.h&quot;</span>   <span class="hljs-comment">// SD / MMC 命令层.提供 SD 卡通信协议</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/sdmmc_host.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SD_MOUNT_POINT   <span class="hljs-string">&quot;/sdcard&quot;</span>  <span class="hljs-comment">// SD 卡在文件系统中的根目录</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *TAG = <span class="hljs-string">&quot;SDMMC_1BIT&quot;</span>;<br><br><span class="hljs-type">sdmmc_card_t</span> *<span class="hljs-title function_">mount_sdcard</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 1. 配置 SDMMC 主机 - 使用 1bit 模式</span><br>    <span class="hljs-type">sdmmc_host_t</span> host = SDMMC_HOST_DEFAULT();<br>    host.max_freq_khz = SDMMC_FREQ_DEFAULT;  <span class="hljs-comment">// 初始频率 20MHz</span><br>    host.flags = SDMMC_HOST_FLAG_1BIT;       <span class="hljs-comment">// 关键: 设置为1位模式</span><br><br>    <span class="hljs-comment">// 2. 配置 SDMMC 槽位 - 只需要3个引脚</span><br>    <span class="hljs-type">sdmmc_slot_config_t</span> slot_config = SDMMC_SLOT_CONFIG_DEFAULT();<br>    slot_config.width = <span class="hljs-number">1</span>;                   <span class="hljs-comment">// 1位总线宽度</span><br><br>    <span class="hljs-comment">// ESP32-S3-WROOM-1 专用引脚配置(DAT1, DAT2, DAT3 不需要配置,会自动忽略)</span><br>    slot_config.clk = GPIO_NUM_47;           <span class="hljs-comment">// 时钟 - GPIO47</span><br>    slot_config.cmd = GPIO_NUM_48;           <span class="hljs-comment">// 命令线 - GPIO48</span><br>    slot_config.d0 = GPIO_NUM_21;            <span class="hljs-comment">// 数据线0 - GPIO21</span><br>    slot_config.flags |= SDMMC_SLOT_FLAG_INTERNAL_PULLUP;  <span class="hljs-comment">// // 启用内部上拉,提高信号稳定性</span><br><br>    <span class="hljs-comment">// 3. 配置挂载参数</span><br>    <span class="hljs-type">esp_vfs_fat_sdmmc_mount_config_t</span> mount_config = &#123;<br>        .format_if_mount_failed = <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 如果挂载不成功是否需要格式化 SD 卡</span><br>        .max_files = <span class="hljs-number">5</span>,                   <span class="hljs-comment">// 允许打开的最大文件数</span><br>        .allocation_unit_size = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span>  <span class="hljs-comment">// 分配单元大小为 8k</span><br>    &#125;;<br><br>    <span class="hljs-comment">// 4. 挂载文件系统</span><br>    <span class="hljs-type">sdmmc_card_t</span> *card;<br>    <span class="hljs-type">esp_err_t</span> ret = esp_vfs_fat_sdmmc_mount(SD_MOUNT_POINT, &amp;host, &amp;slot_config, &amp;mount_config, &amp;card);<br><br>    <span class="hljs-keyword">if</span> (ret != ESP_OK) &#123;<br>        ESP_LOGE(TAG, <span class="hljs-string">&quot;挂载失败: %s&quot;</span>, esp_err_to_name(ret));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 打印 SD 卡信息</span><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;1位模式 SD 卡挂载成功&quot;</span>);<br>    sdmmc_card_print_info(<span class="hljs-built_in">stdout</span>, card);<br><br>    <span class="hljs-comment">// 6. 显示硬件配置信息</span><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;硬件引脚配置:&quot;</span>);<br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;CLK: GPIO%d&quot;</span>, slot_config.clk);<br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;CMD: GPIO%d&quot;</span>, slot_config.cmd);<br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;DAT0: GPIO%d&quot;</span>, slot_config.d0);<br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;当前总线宽度: %d位&quot;</span>, card-&gt;log_bus_width);<br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;当前频率: %d kHz&quot;</span>, card-&gt;max_freq_khz);<br><br>    <span class="hljs-keyword">return</span> card;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">write_sdcard</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span><br>&#123;<br>    FILE *f = fopen(path, <span class="hljs-string">&quot;w&quot;</span>);<br>    <span class="hljs-keyword">if</span> (f != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(f, <span class="hljs-string">&quot;1bit mode下的测试文件内容...\n&quot;</span>);<br>        fclose(f);<br>        ESP_LOGI(TAG, <span class="hljs-string">&quot;测试文件写入成功: %s&quot;</span>, path);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ESP_LOGE(TAG, <span class="hljs-string">&quot;文件创建失败&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">read_sdcard</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span><br>&#123;<br>    FILE *f = fopen(path, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span> (f != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-type">char</span> line[<span class="hljs-number">128</span>];<br>        ESP_LOGI(TAG, <span class="hljs-string">&quot;文件内容:&quot;</span>);<br>        <span class="hljs-keyword">while</span> (fgets(line, <span class="hljs-keyword">sizeof</span>(line), f) != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, line);<br>        &#125;<br>        fclose(f);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ESP_LOGE(TAG, <span class="hljs-string">&quot;文件打开失败&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">app_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">sdmmc_card_t</span> *card = mount_sdcard();              <span class="hljs-comment">// 挂载 sd card</span><br>    write_sdcard(<span class="hljs-string">&quot;/sdcard/hello.txt&quot;</span>);                <span class="hljs-comment">// 写入文件测试</span><br>    read_sdcard(<span class="hljs-string">&quot;/sdcard/hello.txt&quot;</span>);                 <span class="hljs-comment">// 读取文件测试</span><br>    esp_vfs_fat_sdcard_unmount(SD_MOUNT_POINT, card); <span class="hljs-comment">// 卸载文件系统</span><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;SD 卡安全卸载完成&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>menuconfig</code> 配置项</p><ul><li>长文件名支持: 在 <code>Component config</code> -&gt; <code>FAT Filesystem support</code> -&gt; <code>Long filename support</code> 中,<br>选择 <code>Long file name buffer in heap</code>.否则文件名仅支持8个字符</li><li>簇(cluster)字节数: 将 <code>blocksize</code> 改为 4096</li><li>中文支持: 在 <code>OEM Code Page</code> 中选择 <code>Simplified Chinese(DBCS)</code></li><li>编码格式: 在 <code>API character encoding</code> 中选择 <code>API users UTF-8 encoding</code></li></ul></li></ol><h3 id="2-2-LCD"><a href="#2-2-LCD" class="headerlink" title="2.2 LCD"></a>2.2 LCD</h3><ol><li><p>硬件连接</p><p><img src="/2024/07/01/Embedded/ESP32/2-LCD.png"></p></li><li><p>需要注意: <code>LCD_CS</code> 受控于 IO 拓展芯片 <code>PCA9557PW</code>.低电平有效(<code>DVP_PWDN</code> 低有效, <code>PA_EN</code> 高有效)</p><p><img src="/2024/07/01/Embedded/ESP32/2-PCA9557PW.png"></p></li><li><p>需要使用 psram,参考 psram 章节在 <code>menuconfig</code> 中将其打开</p></li><li><p><code>backlight</code> 部分参考 ledc 章节</p></li><li><p><code>lcd</code> 相关 api</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BSP_LCD_PIXEL_CLOCK_HZ     (80 * 1000 * 1000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BSP_LCD_SPI_NUM            (SPI3_HOST)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_CMD_BITS               (8)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_PARAM_BITS             (8)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BSP_LCD_BITS_PER_PIXEL     (16)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_LEDC_CH                LEDC_CHANNEL_0</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BSP_LCD_H_RES              (320)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BSP_LCD_V_RES              (240)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BSP_LCD_SPI_MOSI      (GPIO_NUM_40)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BSP_LCD_SPI_CLK       (GPIO_NUM_41)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BSP_LCD_SPI_CS        (GPIO_NUM_NC)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BSP_LCD_DC            (GPIO_NUM_39)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BSP_LCD_RST           (GPIO_NUM_NC)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BSP_LCD_BACKLIGHT     (GPIO_NUM_42)</span><br><span class="hljs-type">static</span> <span class="hljs-type">esp_lcd_panel_handle_t</span> panel_handle = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 液晶屏初始化</span><br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">bsp_display_new</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">esp_lcd_panel_io_handle_t</span> io_handle = <span class="hljs-literal">NULL</span>; <br>    <span class="hljs-type">esp_err_t</span> ret = ESP_OK;<br>    <span class="hljs-comment">// 背光初始化</span><br>    ESP_RETURN_ON_ERROR(bsp_display_brightness_init(), TAG, <span class="hljs-string">&quot;Brightness init failed&quot;</span>);<br>    <span class="hljs-comment">// 初始化SPI总线</span><br>    ESP_LOGD(TAG, <span class="hljs-string">&quot;Initialize SPI bus&quot;</span>);<br>    <span class="hljs-type">const</span> <span class="hljs-type">spi_bus_config_t</span> buscfg = &#123;<br>        .sclk_io_num = BSP_LCD_SPI_CLK,<br>        .mosi_io_num = BSP_LCD_SPI_MOSI,<br>        .miso_io_num = GPIO_NUM_NC,<br>        .quadwp_io_num = GPIO_NUM_NC,<br>        .quadhd_io_num = GPIO_NUM_NC,<br>        .max_transfer_sz = BSP_LCD_H_RES * BSP_LCD_V_RES * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint16_t</span>),<br>    &#125;;<br>    ESP_RETURN_ON_ERROR(spi_bus_initialize(BSP_LCD_SPI_NUM, &amp;buscfg, SPI_DMA_CH_AUTO), TAG, <span class="hljs-string">&quot;SPI init failed&quot;</span>);<br>    <span class="hljs-comment">// 液晶屏控制 IO 初始化</span><br>    ESP_LOGD(TAG, <span class="hljs-string">&quot;Install panel IO&quot;</span>);<br>    <span class="hljs-type">const</span> <span class="hljs-type">esp_lcd_panel_io_spi_config_t</span> io_config = &#123;<br>        .dc_gpio_num = BSP_LCD_DC,<br>        .cs_gpio_num = BSP_LCD_SPI_CS,<br>        .pclk_hz = BSP_LCD_PIXEL_CLOCK_HZ,<br>        .lcd_cmd_bits = LCD_CMD_BITS,<br>        .lcd_param_bits = LCD_PARAM_BITS,<br>        .spi_mode = <span class="hljs-number">2</span>,<br>        .trans_queue_depth = <span class="hljs-number">10</span>,<br>    &#125;;<br>    ESP_GOTO_ON_ERROR(esp_lcd_new_panel_io_spi((<span class="hljs-type">esp_lcd_spi_bus_handle_t</span>)BSP_LCD_SPI_NUM, &amp;io_config, &amp;io_handle), err, TAG, <span class="hljs-string">&quot;New panel IO failed&quot;</span>);<br>    <span class="hljs-comment">// 初始化液晶屏驱动芯片 ST7789</span><br>    ESP_LOGD(TAG, <span class="hljs-string">&quot;Install LCD driver&quot;</span>);<br>    <span class="hljs-type">const</span> <span class="hljs-type">esp_lcd_panel_dev_config_t</span> panel_config = &#123;<br>        .reset_gpio_num = BSP_LCD_RST,<br>        .rgb_ele_order = LCD_RGB_ELEMENT_ORDER_RGB,<br>        .bits_per_pixel = BSP_LCD_BITS_PER_PIXEL,<br>    &#125;;<br>    ESP_GOTO_ON_ERROR(esp_lcd_new_panel_st7789(io_handle, &amp;panel_config, &amp;panel_handle), err, TAG, <span class="hljs-string">&quot;New panel failed&quot;</span>);<br>    <br>    esp_lcd_panel_reset(panel_handle);               <span class="hljs-comment">// 液晶屏复位</span><br>    lcd_cs(<span class="hljs-number">0</span>);                                       <span class="hljs-comment">// 拉低 CS 引脚</span><br>    esp_lcd_panel_init(panel_handle);                <span class="hljs-comment">// 初始化配置寄存器</span><br>    esp_lcd_panel_invert_color(panel_handle, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// 颜色反转</span><br>    esp_lcd_panel_swap_xy(panel_handle, <span class="hljs-literal">true</span>);       <span class="hljs-comment">// 显示翻转 </span><br>    esp_lcd_panel_mirror(panel_handle, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 镜像</span><br><br>    <span class="hljs-keyword">return</span> ret;<br><br>err:<br>    <span class="hljs-keyword">if</span> (panel_handle) &#123;<br>        esp_lcd_panel_del(panel_handle);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (io_handle) &#123;<br>        esp_lcd_panel_io_del(io_handle);<br>    &#125;<br>    spi_bus_free(BSP_LCD_SPI_NUM);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">// 显示图片</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_draw_pictrue</span><span class="hljs-params">(<span class="hljs-type">int</span> x_start, <span class="hljs-type">int</span> y_start, <span class="hljs-type">int</span> x_end, <span class="hljs-type">int</span> y_end, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *gImage)</span><br>&#123;<br>    <span class="hljs-comment">// 分配内存 分配了需要的字节大小 且指定在外部 SPIRAM 中分配</span><br>    <span class="hljs-type">size_t</span> pixels_byte_size = (x_end - x_start)*(y_end - y_start) * <span class="hljs-number">2</span>;<br>    <span class="hljs-type">uint16_t</span> *pixels = (<span class="hljs-type">uint16_t</span> *)heap_caps_malloc(pixels_byte_size, MALLOC_CAP_8BIT | MALLOC_CAP_SPIRAM);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pixels) &#123;<br>        ESP_LOGE(TAG, <span class="hljs-string">&quot;Memory for bitmap is not enough&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">memcpy</span>(pixels, gImage, pixels_byte_size);  <span class="hljs-comment">// 把图片数据拷贝到内存</span><br>    esp_lcd_panel_draw_bitmap(panel_handle, x_start, y_start, x_end, y_end, (<span class="hljs-type">uint16_t</span> *)pixels); <span class="hljs-comment">// 显示整张图片数据</span><br>    heap_caps_free(pixels);  <span class="hljs-comment">// 释放内存</span><br>&#125;<br><br><span class="hljs-comment">// 设置液晶屏颜色</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_set_color</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> color)</span><br>&#123;<br>    <span class="hljs-comment">// 分配内存 这里分配了液晶屏一行数据需要的大小</span><br>    <span class="hljs-type">uint16_t</span> *buffer = (<span class="hljs-type">uint16_t</span> *)heap_caps_malloc(BSP_LCD_H_RES * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint16_t</span>), MALLOC_CAP_8BIT | MALLOC_CAP_SPIRAM);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == buffer)<br>        ESP_LOGE(TAG, <span class="hljs-string">&quot;Memory for bitmap is not enough&quot;</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; BSP_LCD_H_RES; i++) <span class="hljs-comment">// 给缓存中放入颜色数据</span><br>            buffer[i] = color;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; <span class="hljs-number">240</span>; y++) <span class="hljs-comment">// 显示整屏颜色</span><br>            esp_lcd_panel_draw_bitmap(panel_handle, <span class="hljs-number">0</span>, y, <span class="hljs-number">320</span>, y+<span class="hljs-number">1</span>, buffer);<br><br>        <span class="hljs-built_in">free</span>(buffer); <span class="hljs-comment">// 释放内存</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-LVGL"><a href="#2-3-LVGL" class="headerlink" title="2.3 LVGL"></a>2.3 LVGL</h3><ol><li><p>触控芯片安装 [ft5x06](<a href="https://components.espressif.com/components/espressif/esp_lcd_touch_ft5x06/versions/1.0.7/readme">espressif&#x2F;esp_lcd_touch_ft5x06 • v1.0.7 • ESP Component Registry</a>) 组件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py add-dependency &quot;espressif/esp_lcd_touch_ft5x06^1.0.7&quot;<br></code></pre></td></tr></table></figure></li><li><p>lvgl 相关组件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py add-dependency &quot;lvgl/lvgl^8.3.11&quot;<br>idf.py add-dependency &quot;espressif/esp_lvgl_port^2.6.0&quot;<br></code></pre></td></tr></table></figure></li><li><p>lvgl 相关配置(<code>menuconfig</code> 中 <code>Component config -&gt; LVGL configuration</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Color settings<br>[x] Swap the 2 bytes of RGB565 color. Useful if the display has an 8-bit interface (e.g. SPI).<br>Memory settings<br>[*] If true use custom malloc/free, otherwise use the built-in `lv_mem_alloc()` and `lv_mem_free()`<br></code></pre></td></tr></table></figure></li><li><p>接口适配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BSP_LCD_DRAW_BUF_HEIGHT    (20)</span><br><span class="hljs-type">static</span> <span class="hljs-type">esp_lcd_panel_handle_t</span> panel_handle = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">esp_lcd_panel_io_handle_t</span> io_handle = <span class="hljs-literal">NULL</span>; <br><span class="hljs-type">static</span> <span class="hljs-type">esp_lcd_touch_handle_t</span> tp;   <span class="hljs-comment">// 触摸屏句柄</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_disp_t</span> *disp;      <span class="hljs-comment">// 指向液晶屏</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_indev_t</span> *disp_indev = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 指向触摸屏</span><br><span class="hljs-comment">// LCD显示初始化</span><br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">bsp_lcd_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">esp_err_t</span> ret = ESP_OK;<br><br>    <br>    ret = bsp_display_new(); <span class="hljs-comment">// 液晶屏驱动初始化</span><br>    lcd_set_color(<span class="hljs-number">0x0000</span>); <span class="hljs-comment">// 设置整屏背景黑色</span><br>    ret = esp_lcd_panel_disp_on_off(panel_handle, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 打开液晶屏显示</span><br>    ret = bsp_display_backlight_on(); <span class="hljs-comment">// 打开背光显示</span><br><br>    <span class="hljs-keyword">return</span>  ret;<br>&#125;<br><br><span class="hljs-comment">// 液晶屏初始化+添加LVGL接口</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_disp_t</span> *<span class="hljs-title function_">bsp_display_lcd_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 初始化液晶屏 */</span><br>    bsp_display_new(); <span class="hljs-comment">// 液晶屏驱动初始化</span><br>    lcd_set_color(<span class="hljs-number">0xffff</span>); <span class="hljs-comment">// 设置整屏背景白色</span><br>    esp_lcd_panel_disp_on_off(panel_handle, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 打开液晶屏显示</span><br><br>    <span class="hljs-comment">/* 液晶屏添加LVGL接口 */</span><br>    ESP_LOGD(TAG, <span class="hljs-string">&quot;Add LCD screen&quot;</span>);<br>    <span class="hljs-type">const</span> <span class="hljs-type">lvgl_port_display_cfg_t</span> disp_cfg = &#123;<br>        .io_handle = io_handle,<br>        .panel_handle = panel_handle,<br>        .buffer_size = BSP_LCD_H_RES * BSP_LCD_DRAW_BUF_HEIGHT,   <span class="hljs-comment">// LVGL缓存大小 </span><br>        .double_buffer = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否开启双缓存</span><br>        .hres = BSP_LCD_H_RES, <span class="hljs-comment">// 液晶屏的宽</span><br>        .vres = BSP_LCD_V_RES, <span class="hljs-comment">// 液晶屏的高</span><br>        .monochrome = <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 是否单色显示器</span><br>        <span class="hljs-comment">/* Rotation的值必须和液晶屏初始化里面设置的 翻转 和 镜像 一样 */</span><br>        .rotation = &#123;<br>            .swap_xy = <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 是否翻转</span><br>            .mirror_x = <span class="hljs-literal">true</span>, <span class="hljs-comment">// x方向是否镜像</span><br>            .mirror_y = <span class="hljs-literal">false</span>, <span class="hljs-comment">// y方向是否镜像</span><br>        &#125;,<br>        .flags = &#123;<br>            .buff_dma = <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 是否使用DMA 注意：dma与spiram不能同时为true</span><br>            .buff_spiram = <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否使用PSRAM 注意：dma与spiram不能同时为true</span><br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> lvgl_port_add_disp(&amp;disp_cfg);<br>&#125;<br><br><span class="hljs-comment">// 触摸屏初始化</span><br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">bsp_touch_new</span><span class="hljs-params">(<span class="hljs-type">esp_lcd_touch_handle_t</span> *ret_touch)</span><br>&#123;<br>    <span class="hljs-comment">/* Initialize touch */</span><br>    <span class="hljs-type">esp_lcd_touch_config_t</span> tp_cfg = &#123;<br>        .x_max = BSP_LCD_V_RES,<br>        .y_max = BSP_LCD_H_RES,<br>        .rst_gpio_num = GPIO_NUM_NC, <span class="hljs-comment">// Shared with LCD reset</span><br>        .int_gpio_num = GPIO_NUM_NC, <br>        .levels = &#123;<br>            .reset = <span class="hljs-number">0</span>,<br>            .interrupt = <span class="hljs-number">0</span>,<br>        &#125;,<br>        .flags = &#123;<br>            .swap_xy = <span class="hljs-number">1</span>,<br>            .mirror_x = <span class="hljs-number">1</span>,<br>            .mirror_y = <span class="hljs-number">0</span>,<br>        &#125;,<br>    &#125;;<br>    <span class="hljs-type">esp_lcd_panel_io_handle_t</span> tp_io_handle = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">esp_lcd_panel_io_i2c_config_t</span> tp_io_config = ESP_LCD_TOUCH_IO_I2C_FT5x06_CONFIG();<br><br>    ESP_RETURN_ON_ERROR(esp_lcd_new_panel_io_i2c((<span class="hljs-type">esp_lcd_i2c_bus_handle_t</span>)BSP_I2C_NUM, &amp;tp_io_config, &amp;tp_io_handle), TAG, <span class="hljs-string">&quot;&quot;</span>);<br>    ESP_ERROR_CHECK(esp_lcd_touch_new_i2c_ft5x06(tp_io_handle, &amp;tp_cfg, ret_touch));<br><br>    <span class="hljs-keyword">return</span> ESP_OK;<br>&#125;<br><br><span class="hljs-comment">// 触摸屏初始化+添加LVGL接口</span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_indev_t</span> *<span class="hljs-title function_">bsp_display_indev_init</span><span class="hljs-params">(<span class="hljs-type">lv_disp_t</span> *disp)</span><br>&#123;<br>    <span class="hljs-comment">/* 初始化触摸屏 */</span><br>    ESP_ERROR_CHECK(bsp_touch_new(&amp;tp));<br>    assert(tp);<br><br>    <span class="hljs-comment">/* 添加LVGL接口 */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">lvgl_port_touch_cfg_t</span> touch_cfg = &#123;<br>        .disp = disp,<br>        .handle = tp,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> lvgl_port_add_touch(&amp;touch_cfg);<br>&#125;<br><br><span class="hljs-comment">// 开发板显示初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bsp_lvgl_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 初始化LVGL */</span><br>    <span class="hljs-type">lvgl_port_cfg_t</span> lvgl_cfg = ESP_LVGL_PORT_INIT_CONFIG();<br>    lvgl_port_init(&amp;lvgl_cfg);<br><br>    <span class="hljs-comment">/* 初始化液晶屏 并添加LVGL接口 */</span><br>    disp = bsp_display_lcd_init();<br><br>    <span class="hljs-comment">/* 初始化触摸屏 并添加LVGL接口 */</span><br>    disp_indev = bsp_display_indev_init(disp);<br><br>    <span class="hljs-comment">/* 打开液晶屏背光 */</span><br>    bsp_display_backlight_on();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-MIC"><a href="#2-4-MIC" class="headerlink" title="2.4 MIC"></a>2.4 MIC</h3><ol><li><p>硬件连接</p><p><img src="/2024/07/01/Embedded/ESP32/2-AUDIO-ADC.png"></p><ul><li>使用 I2C 配置 ES7210 芯片</li><li>使用 I2S 接收数据(I2S_DI)</li></ul></li><li><p>引入 <a href="https://components.espressif.com/components/espressif/es7210/versions/1.0.1~1">ES7210</a> 组件: 执行命令(会创建 <code>main/idf_component.yml</code> 文件)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py add-dependency &quot;espressif/es7210^1.0.1~1&quot;<br></code></pre></td></tr></table></figure></li><li><p>使用示例: 录音10s,并保存到 sd card(这里用到的 <code>sd card</code> 可参考已有的示例,主要展示 <code>i2s</code> 接口)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sdkconfig.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_check.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/i2s_tdm.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/i2s_std.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/i2c.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;es7210.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;format_wav.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *TAG = <span class="hljs-string">&quot;ES7210&quot;</span>;<br><span class="hljs-comment">/* I2S configurations */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_I2S_CHAN_NUM       (2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_I2S_SAMPLE_RATE    (48000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_I2S_MCLK_MULTIPLE  (I2S_MCLK_MULTIPLE_256)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_I2S_SAMPLE_BITS    (I2S_DATA_BIT_WIDTH_16BIT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_I2S_TDM_SLOT_MASK  (I2S_TDM_SLOT0 | I2S_TDM_SLOT1)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">i2s_chan_handle_t</span> <span class="hljs-title function_">es7210_i2s_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">i2s_chan_handle_t</span> i2s_rx_chan = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 定义接收通道句柄</span><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Create I2S receive channel&quot;</span>);<br>    <span class="hljs-type">i2s_chan_config_t</span> i2s_rx_conf = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER); <span class="hljs-comment">// 配置接收通道</span><br>    ESP_ERROR_CHECK(i2s_new_channel(&amp;i2s_rx_conf, <span class="hljs-literal">NULL</span>, &amp;i2s_rx_chan)); <span class="hljs-comment">// 创建 i2s 通道</span><br><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Configure I2S receive channel to TDM mode&quot;</span>);<br>    <span class="hljs-comment">// 定义接收通道为 I2S TDM 模式 并配置</span><br>    <span class="hljs-type">i2s_tdm_config_t</span> i2s_tdm_rx_conf = &#123;  <br>        .slot_cfg = I2S_TDM_PHILIPS_SLOT_DEFAULT_CONFIG(EXAMPLE_I2S_SAMPLE_BITS, I2S_SLOT_MODE_STEREO, EXAMPLE_I2S_TDM_SLOT_MASK),<br>        .clk_cfg  = &#123;<br>            .clk_src = I2S_CLK_SRC_DEFAULT,<br>            .sample_rate_hz = EXAMPLE_I2S_SAMPLE_RATE,<br>            .mclk_multiple = EXAMPLE_I2S_MCLK_MULTIPLE<br>        &#125;,<br>        .gpio_cfg = &#123;<br>            .mclk = GPIO_NUM_38,<br>            .bclk = GPIO_NUM_14,<br>            .ws   = GPIO_NUM_13,<br>            .dout = <span class="hljs-number">-1</span>, <span class="hljs-comment">// ES7210 only has ADC capability</span><br>            .din  = GPIO_NUM_12<br>        &#125;,<br>    &#125;;<br><br>    ESP_ERROR_CHECK(i2s_channel_init_tdm_mode(i2s_rx_chan, &amp;i2s_tdm_rx_conf)); <span class="hljs-comment">// 初始化 I2S 通道为 TDM 模式</span><br><br>    <span class="hljs-keyword">return</span> i2s_rx_chan;<br>&#125;<br><br><span class="hljs-comment">/* ES7210 configurations */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_I2C_NUM            (I2C_NUM_0)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">es7210_codec_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 初始化 I2C 接口</span><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Init I2C used to configure ES7210&quot;</span>);<br>    <span class="hljs-type">i2c_config_t</span> i2c_conf = &#123;<br>        .sda_io_num = GPIO_NUM_1,<br>        .scl_io_num = GPIO_NUM_2,<br>        .mode = I2C_MODE_MASTER,<br>        .sda_pullup_en = GPIO_PULLUP_ENABLE,<br>        .scl_pullup_en = GPIO_PULLUP_ENABLE,<br>        .master.clk_speed = <span class="hljs-number">100000</span>,<br>    &#125;;<br>    ESP_ERROR_CHECK(i2c_param_config(EXAMPLE_I2C_NUM, &amp;i2c_conf));<br>    ESP_ERROR_CHECK(i2c_driver_install(EXAMPLE_I2C_NUM, i2c_conf.mode, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 创建 es7210 器件句柄</span><br>    <span class="hljs-type">es7210_dev_handle_t</span> es7210_handle = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">es7210_i2c_config_t</span> es7210_i2c_conf = &#123;<br>        .i2c_port = EXAMPLE_I2C_NUM,<br>        .i2c_addr = <span class="hljs-number">0x41</span>  <span class="hljs-comment">// es7210 i2c addr</span><br>    &#125;;<br>    ESP_ERROR_CHECK(es7210_new_codec(&amp;es7210_i2c_conf, &amp;es7210_handle));<br><br>    <span class="hljs-comment">// 初始化 es7210 芯片</span><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Configure ES7210 codec parameters&quot;</span>);<br>    <span class="hljs-type">es7210_codec_config_t</span> codec_conf = &#123;<br>        .i2s_format = ES7210_I2S_FMT_I2S,<br>        .mclk_ratio = EXAMPLE_I2S_MCLK_MULTIPLE,<br>        .sample_rate_hz = EXAMPLE_I2S_SAMPLE_RATE,<br>        .bit_width = (<span class="hljs-type">es7210_i2s_bits_t</span>)EXAMPLE_I2S_SAMPLE_BITS,<br>        .mic_bias = ES7210_MIC_BIAS_2V87,  <span class="hljs-comment">// es7210 bias</span><br>        .mic_gain = ES7210_MIC_GAIN_30DB,  <span class="hljs-comment">// es7210 mic gain</span><br>        .flags.tdm_enable = <span class="hljs-literal">true</span><br>    &#125;;<br>    ESP_ERROR_CHECK(es7210_config_codec(es7210_handle, &amp;codec_conf));<br>    ESP_ERROR_CHECK(es7210_config_volume(es7210_handle, <span class="hljs-number">0</span>));<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_RECORD_TIME_SEC    (10)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_RECORD_FILE_PATH   <span class="hljs-string">&quot;/RECORD.WAV&quot;</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">record_wav</span><span class="hljs-params">(<span class="hljs-type">i2s_chan_handle_t</span> i2s_rx_chan)</span><br>&#123;<br>    ESP_RETURN_ON_FALSE(i2s_rx_chan, ESP_FAIL, TAG, <span class="hljs-string">&quot;invalid i2s channel handle pointer&quot;</span>);<br>    <span class="hljs-type">esp_err_t</span> ret = ESP_OK;<br><br>    <span class="hljs-type">uint32_t</span> byte_rate = EXAMPLE_I2S_SAMPLE_RATE * EXAMPLE_I2S_CHAN_NUM * EXAMPLE_I2S_SAMPLE_BITS / <span class="hljs-number">8</span>;<br>    <span class="hljs-type">uint32_t</span> wav_size = byte_rate * EXAMPLE_RECORD_TIME_SEC;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">wav_header_t</span> wav_header =<br>        WAV_HEADER_PCM_DEFAULT(wav_size, EXAMPLE_I2S_SAMPLE_BITS, EXAMPLE_I2S_SAMPLE_RATE, EXAMPLE_I2S_CHAN_NUM);<br><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Opening file %s&quot;</span>, EXAMPLE_RECORD_FILE_PATH);<br>    FILE *f = fopen(SD_MOUNT_POINT EXAMPLE_RECORD_FILE_PATH, <span class="hljs-string">&quot;w&quot;</span>);<br>    ESP_RETURN_ON_FALSE(f, ESP_FAIL, TAG, <span class="hljs-string">&quot;error while opening wav file&quot;</span>);<br><br>    <span class="hljs-comment">/* Write wav header */</span><br>    ESP_GOTO_ON_FALSE(fwrite(&amp;wav_header, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">wav_header_t</span>), <span class="hljs-number">1</span>, f), ESP_FAIL, err,<br>                      TAG, <span class="hljs-string">&quot;error while writing wav header&quot;</span>);<br><br>    <span class="hljs-comment">/* Start recording */</span><br>    <span class="hljs-type">size_t</span> wav_written = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int16_t</span> i2s_readraw_buff[<span class="hljs-number">4096</span>];<br>    ESP_GOTO_ON_ERROR(i2s_channel_enable(i2s_rx_chan), err, TAG, <span class="hljs-string">&quot;error while starting i2s rx channel&quot;</span>);<br>    <span class="hljs-keyword">while</span> (wav_written &lt; wav_size) &#123;<br>        <span class="hljs-keyword">if</span>(wav_written % byte_rate &lt; <span class="hljs-keyword">sizeof</span>(i2s_readraw_buff)) &#123;<br>            ESP_LOGI(TAG, <span class="hljs-string">&quot;Recording: %&quot;</span>PRIu32<span class="hljs-string">&quot;/%ds&quot;</span>, wav_written/byte_rate + <span class="hljs-number">1</span>, EXAMPLE_RECORD_TIME_SEC);<br>        &#125;<br>        <span class="hljs-type">size_t</span> bytes_read = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">/* Read RAW samples from ES7210 */</span><br>        ESP_GOTO_ON_ERROR(i2s_channel_read(i2s_rx_chan, i2s_readraw_buff, <span class="hljs-keyword">sizeof</span>(i2s_readraw_buff), &amp;bytes_read,<br>                          pdMS_TO_TICKS(<span class="hljs-number">1000</span>)), err, TAG, <span class="hljs-string">&quot;error while reading samples from i2s&quot;</span>);<br>        <span class="hljs-comment">/* Write the samples to the WAV file */</span><br>        ESP_GOTO_ON_FALSE(fwrite(i2s_readraw_buff, bytes_read, <span class="hljs-number">1</span>, f), ESP_FAIL, err,<br>                          TAG, <span class="hljs-string">&quot;error while writing samples to wav file&quot;</span>);<br>        wav_written += bytes_read;<br>    &#125;<br><br>err:<br>    i2s_channel_disable(i2s_rx_chan);<br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Recording done! Flushing file buffer&quot;</span>);<br>    fclose(f);<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">app_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">i2s_chan_handle_t</span> i2s_rx_chan = es7210_i2s_init(); <span class="hljs-comment">// 初始化 I2S 接口</span><br>    es7210_codec_init();                               <span class="hljs-comment">// 初始化 es7210 芯片</span><br>    <span class="hljs-type">sdmmc_card_t</span> *sdmmc_card = mount_sdcard();         <span class="hljs-comment">// 挂载 SD 卡</span><br>    <span class="hljs-type">esp_err_t</span> err = record_wav(i2s_rx_chan);           <span class="hljs-comment">// 录音</span><br>    esp_vfs_fat_sdcard_unmount(SD_MOUNT_POINT, sdmmc_card);  <span class="hljs-comment">// 弹出 SD 卡</span><br>    <span class="hljs-keyword">if</span>(err == ESP_OK)<br>        ESP_LOGI(TAG, <span class="hljs-string">&quot;Audio was successfully recorded into &quot;</span>EXAMPLE_RECORD_FILE_PATH);<br>    <span class="hljs-keyword">else</span><br>        ESP_LOGE(TAG, <span class="hljs-string">&quot;Record failed, &quot;</span>EXAMPLE_RECORD_FILE_PATH<span class="hljs-string">&quot; on SD card may not be playable.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-5-AMP"><a href="#2-5-AMP" class="headerlink" title="2.5 AMP"></a>2.5 AMP</h3><ol><li><p>硬件连接</p><p><img src="/2024/07/01/Embedded/ESP32/2-AUDIO-DAC.png"></p><ul><li>使用 I2C 配置 ES8311 芯片</li><li>使用 I2S 输出数据(I2S_DO)</li></ul></li><li><p>ES8311 将数据传输到 NS4150B 功放</p><p><img src="/2024/07/01/Embedded/ESP32/2-AUDIO-DAC-NS4150B.png"></p></li><li><p>IO 拓展芯片控制 NS4150B 的开关 <code>PA_EN</code>(高电平有效)</p></li><li><p>引入 [ES8311](<a href="https://components.espressif.com/components/espressif/es8311/versions/1.0.0~1/readme">espressif&#x2F;es8311 • v1.0.0~1 • ESP Component Registry</a>) 组件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py add-dependency &quot;espressif/es8311^1.0.0~1&quot;<br></code></pre></td></tr></table></figure></li><li><p>添加音乐文件(<code>canon.pcm</code>).需要在 <code>main/CMakeLists.txt</code> 文件中声明</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">EMBED_FILES <span class="hljs-string">&quot;canon.pcm&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>播放音频示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sdkconfig.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;freertos/FreeRTOS.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;freertos/task.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/i2s_std.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_system.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_check.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;es8311.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *TAG = <span class="hljs-string">&quot;i2s_es8311&quot;</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> err_reason[][<span class="hljs-number">30</span>] = &#123;<span class="hljs-string">&quot;input param is invalid&quot;</span>, <span class="hljs-string">&quot;operation timeout&quot;</span>&#125;;<br><span class="hljs-type">static</span> <span class="hljs-type">i2s_chan_handle_t</span> tx_handle = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/* Import music file as buffer */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> music_pcm_start[] <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;_binary_canon_pcm_start&quot;</span>);<br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> music_pcm_end[]   <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;_binary_canon_pcm_end&quot;</span>);<br><br><span class="hljs-comment">// 初始化 I2C 接口.并初始化 es8311 芯片</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_I2C_NUM         (I2C_NUM_0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_RECV_BUF_SIZE   (2400)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_SAMPLE_RATE     (16000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_MCLK_MULTIPLE   (384) <span class="hljs-comment">// If not using 24-bit data width, 256 should be enough</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_MCLK_FREQ_HZ    (EXAMPLE_SAMPLE_RATE * EXAMPLE_MCLK_MULTIPLE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_VOICE_VOLUME    (70)</span><br><span class="hljs-type">static</span> <span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">es8311_codec_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 初始化 I2C 接口</span><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Init I2C used to configure ES7210&quot;</span>);<br>    <span class="hljs-type">i2c_config_t</span> i2c_conf = &#123;<br>        .sda_io_num = GPIO_NUM_1,<br>        .scl_io_num = GPIO_NUM_2,<br>        .mode = I2C_MODE_MASTER,<br>        .sda_pullup_en = GPIO_PULLUP_ENABLE,<br>        .scl_pullup_en = GPIO_PULLUP_ENABLE,<br>        .master.clk_speed = <span class="hljs-number">100000</span>,<br>    &#125;;<br>    ESP_ERROR_CHECK(i2c_param_config(EXAMPLE_I2C_NUM, &amp;i2c_conf));<br>    ESP_ERROR_CHECK(i2c_driver_install(EXAMPLE_I2C_NUM, i2c_conf.mode, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">/* 初始化es8311芯片 */</span><br>    <span class="hljs-type">es8311_handle_t</span> es_handle = es8311_create(EXAMPLE_I2C_NUM, ES8311_ADDRRES_0);<br>    ESP_RETURN_ON_FALSE(es_handle, ESP_FAIL, TAG, <span class="hljs-string">&quot;es8311 create failed&quot;</span>);<br>    <span class="hljs-type">const</span> <span class="hljs-type">es8311_clock_config_t</span> es_clk = &#123;<br>        .mclk_inverted = <span class="hljs-literal">false</span>,<br>        .sclk_inverted = <span class="hljs-literal">false</span>,<br>        .mclk_from_mclk_pin = <span class="hljs-literal">true</span>,<br>        .mclk_frequency = EXAMPLE_MCLK_FREQ_HZ,<br>        .sample_frequency = EXAMPLE_SAMPLE_RATE<br>    &#125;;<br><br>    ESP_ERROR_CHECK(es8311_init(es_handle, &amp;es_clk, ES8311_RESOLUTION_16, ES8311_RESOLUTION_16));<br>    ESP_RETURN_ON_ERROR(es8311_sample_frequency_config(es_handle, EXAMPLE_SAMPLE_RATE * EXAMPLE_MCLK_MULTIPLE, EXAMPLE_SAMPLE_RATE), TAG, <span class="hljs-string">&quot;set es8311 sample frequency failed&quot;</span>);<br>    ESP_RETURN_ON_ERROR(es8311_voice_volume_set(es_handle, EXAMPLE_VOICE_VOLUME, <span class="hljs-literal">NULL</span>), TAG, <span class="hljs-string">&quot;set es8311 volume failed&quot;</span>);<br>    ESP_RETURN_ON_ERROR(es8311_microphone_config(es_handle, <span class="hljs-literal">false</span>), TAG, <span class="hljs-string">&quot;set es8311 microphone failed&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> ESP_OK;<br>&#125;<br><br><span class="hljs-comment">// 初始化 I2S 外设</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2S_NUM         (0)</span><br><span class="hljs-type">static</span> <span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">i2s_driver_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 配置 i2s 发送通道 */</span><br>    <span class="hljs-type">i2s_chan_config_t</span> chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM, I2S_ROLE_MASTER);<br>    chan_cfg.auto_clear = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Auto clear the legacy data in the DMA buffer</span><br>    ESP_ERROR_CHECK(i2s_new_channel(&amp;chan_cfg, &amp;tx_handle, <span class="hljs-literal">NULL</span>));<br>    <span class="hljs-comment">/* 初始化 i2s 为 std 模式 并打开 i2s 发送通道 */</span><br>    <span class="hljs-type">i2s_std_config_t</span> std_cfg = &#123;<br>        .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(EXAMPLE_SAMPLE_RATE),<br>        .slot_cfg = I2S_STD_PHILIPS_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_STEREO),<br>        .gpio_cfg = &#123;<br>            .mclk = GPIO_NUM_38,<br>            .bclk = GPIO_NUM_14,<br>            .ws   = GPIO_NUM_13,<br>            .dout = GPIO_NUM_45,<br>            .din = <span class="hljs-number">-1</span>,<br>            .invert_flags = &#123;<br>                .mclk_inv = <span class="hljs-literal">false</span>,<br>                .bclk_inv = <span class="hljs-literal">false</span>,<br>                .ws_inv = <span class="hljs-literal">false</span>,<br>            &#125;,<br>        &#125;,<br>    &#125;;<br>    std_cfg.clk_cfg.mclk_multiple = EXAMPLE_MCLK_MULTIPLE;<br><br>    ESP_ERROR_CHECK(i2s_channel_init_std_mode(tx_handle, &amp;std_cfg));<br>    ESP_ERROR_CHECK(i2s_channel_enable(tx_handle));<br><br>    <span class="hljs-keyword">return</span> ESP_OK;<br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">i2s_music</span><span class="hljs-params">(<span class="hljs-type">void</span> *args)</span><br>&#123;<br>    <span class="hljs-type">esp_err_t</span> ret = ESP_OK;<br>    <span class="hljs-type">size_t</span> bytes_write = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint8_t</span> *data_ptr = (<span class="hljs-type">uint8_t</span> *)music_pcm_start;<br><br>    <span class="hljs-comment">/* (Optional) Disable TX channel and preload the data before enabling the TX channel,</span><br><span class="hljs-comment">     * so that the valid data can be transmitted immediately */</span><br>    ESP_ERROR_CHECK(i2s_channel_disable(tx_handle));  <br>    ESP_ERROR_CHECK(i2s_channel_preload_data(tx_handle, data_ptr, music_pcm_end - data_ptr, &amp;bytes_write));<br>    data_ptr += bytes_write;  <span class="hljs-comment">// Move forward the data pointer</span><br><br>    <span class="hljs-comment">/* Enable the TX channel */</span><br>    ESP_ERROR_CHECK(i2s_channel_enable(tx_handle));<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">/* Write music to earphone */</span><br>        ret = i2s_channel_write(tx_handle, data_ptr, music_pcm_end - data_ptr, &amp;bytes_write, portMAX_DELAY);<br>        <span class="hljs-keyword">if</span> (ret != ESP_OK) &#123;<br>            <span class="hljs-comment">/* Since we set timeout to &#x27;portMAX_DELAY&#x27; in &#x27;i2s_channel_write&#x27;</span><br><span class="hljs-comment">               so you won&#x27;t reach here unless you set other timeout value,</span><br><span class="hljs-comment">               if timeout detected, it means write operation failed. */</span><br>            ESP_LOGE(TAG, <span class="hljs-string">&quot;[music] i2s write failed, %s&quot;</span>, err_reason[ret == ESP_ERR_TIMEOUT]);<br>            <span class="hljs-built_in">abort</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (bytes_write &gt; <span class="hljs-number">0</span>) &#123;<br>            ESP_LOGI(TAG, <span class="hljs-string">&quot;[music] i2s music played, %d bytes are written.&quot;</span>, bytes_write);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ESP_LOGE(TAG, <span class="hljs-string">&quot;[music] i2s music play failed.&quot;</span>);<br>            <span class="hljs-built_in">abort</span>();<br>        &#125;<br>        data_ptr = (<span class="hljs-type">uint8_t</span> *)music_pcm_start;<br>        vTaskDelay(<span class="hljs-number">1000</span> / portTICK_PERIOD_MS);<br>    &#125;<br>    vTaskDelete(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">app_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i2s es8311 codec example start\n-----------------------------\n&quot;</span>);<br>    <span class="hljs-comment">/* 初始化 I2S 外设 */</span><br>    <span class="hljs-keyword">if</span> (i2s_driver_init() != ESP_OK) &#123;<br>        ESP_LOGE(TAG, <span class="hljs-string">&quot;i2s driver init failed&quot;</span>);<br>        <span class="hljs-built_in">abort</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ESP_LOGI(TAG, <span class="hljs-string">&quot;i2s driver init success&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/* 初始化 I2C 以及初始化 es8311 芯片 */</span><br>    <span class="hljs-keyword">if</span> (es8311_codec_init() != ESP_OK) &#123;<br>        ESP_LOGE(TAG, <span class="hljs-string">&quot;es8311 codec init failed&quot;</span>);<br>        <span class="hljs-built_in">abort</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ESP_LOGI(TAG, <span class="hljs-string">&quot;es8311 codec init success&quot;</span>);<br>    &#125;<br><br>    pca9557_init(); <span class="hljs-comment">// 初始化 IO 扩展芯片</span><br>    pa_en(<span class="hljs-number">1</span>);       <span class="hljs-comment">// 打开音频</span><br>    xTaskCreate(i2s_music, <span class="hljs-string">&quot;i2s_music&quot;</span>, <span class="hljs-number">4096</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-6-CAMERA"><a href="#2-6-CAMERA" class="headerlink" title="2.6 CAMERA"></a>2.6 CAMERA</h3><ol><li><p>硬件连接</p><p><img src="/2024/07/01/Embedded/ESP32/2-CAMERA.png"></p></li><li><p>需要注意: <code>DVP_PWDN</code> 受控于 IO 拓展芯片 <code>PCA9557PW</code>.低电平有效</p></li><li><p>由于 <code>camera</code> 需要用到 <code>i2c</code>,需要保证 <code>i2c</code> 驱动新旧兼容问题.在 <code>menuconfig</code> 中选择使用旧的 <code>i2c</code> 驱动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Component config -&gt; Camera configuration -&gt; I2C driver selection for SCCB -&gt; Legacy I2C driver<br></code></pre></td></tr></table></figure></li><li><p>加速程序运行.在下面目录中将 <code>cache</code> 均配置到最大</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Component config -&gt; ESP System Setting -&gt; Cache config<br></code></pre></td></tr></table></figure></li><li><p>引入 [camera](<a href="https://components.espressif.com/components/espressif/esp32-camera/versions/2.1.2/readme">espressif&#x2F;esp32-camera • v2.1.2 • ESP Component Registry</a>) 组件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py add-dependency &quot;espressif/esp32-camera^2.0.13&quot;<br></code></pre></td></tr></table></figure></li><li><p><code>camera</code> 获取数据显示到 <code>lcd</code>(明显存在裂屏问题)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAMERA_PIN_PWDN -1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAMERA_PIN_RESET -1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAMERA_PIN_XCLK 5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAMERA_PIN_SIOD 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAMERA_PIN_SIOC 2</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAMERA_PIN_D7 9</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAMERA_PIN_D6 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAMERA_PIN_D5 6</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAMERA_PIN_D4 15</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAMERA_PIN_D3 17</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAMERA_PIN_D2 8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAMERA_PIN_D1 18</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAMERA_PIN_D0 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAMERA_PIN_VSYNC 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAMERA_PIN_HREF 46</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAMERA_PIN_PCLK 7</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XCLK_FREQ_HZ 24000000</span><br><br><span class="hljs-comment">// 摄像头硬件初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bsp_camera_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    dvp_pwdn(<span class="hljs-number">0</span>); <span class="hljs-comment">// 打开摄像头</span><br><br>    <span class="hljs-type">camera_config_t</span> config;<br>    config.ledc_channel = LEDC_CHANNEL_1;  <span class="hljs-comment">// LEDC通道选择  用于生成XCLK时钟 但是S3不用</span><br>    config.ledc_timer = LEDC_TIMER_1; <span class="hljs-comment">// LEDC timer选择  用于生成XCLK时钟 但是S3不用</span><br>    config.pin_d0 = CAMERA_PIN_D0;<br>    config.pin_d1 = CAMERA_PIN_D1;<br>    config.pin_d2 = CAMERA_PIN_D2;<br>    config.pin_d3 = CAMERA_PIN_D3;<br>    config.pin_d4 = CAMERA_PIN_D4;<br>    config.pin_d5 = CAMERA_PIN_D5;<br>    config.pin_d6 = CAMERA_PIN_D6;<br>    config.pin_d7 = CAMERA_PIN_D7;<br>    config.pin_xclk = CAMERA_PIN_XCLK;<br>    config.pin_pclk = CAMERA_PIN_PCLK;<br>    config.pin_vsync = CAMERA_PIN_VSYNC;<br>    config.pin_href = CAMERA_PIN_HREF;<br>    config.pin_sccb_sda = <span class="hljs-number">-1</span>;   <span class="hljs-comment">// 这里写-1 表示使用已经初始化的I2C接口</span><br>    config.pin_sccb_scl = CAMERA_PIN_SIOC;<br>    config.sccb_i2c_port = <span class="hljs-number">0</span>;<br>    config.pin_pwdn = CAMERA_PIN_PWDN;<br>    config.pin_reset = CAMERA_PIN_RESET;<br>    config.xclk_freq_hz = XCLK_FREQ_HZ;<br>    config.pixel_format = PIXFORMAT_RGB565;<br>    config.frame_size = FRAMESIZE_QVGA;<br>    config.jpeg_quality = <span class="hljs-number">12</span>;<br>    config.fb_count = <span class="hljs-number">2</span>;<br>    config.fb_location = CAMERA_FB_IN_PSRAM;<br>    config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;<br><br>    <span class="hljs-comment">// camera init</span><br>    <span class="hljs-type">esp_err_t</span> err = esp_camera_init(&amp;config); <span class="hljs-comment">// 配置上面定义的参数</span><br>    <span class="hljs-keyword">if</span> (err != ESP_OK)<br>    &#123;<br>        ESP_LOGE(TAG, <span class="hljs-string">&quot;Camera init failed with error 0x%x&quot;</span>, err);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">sensor_t</span> *s = esp_camera_sensor_get(); <span class="hljs-comment">// 获取摄像头型号</span><br><br>    <span class="hljs-keyword">if</span> (s-&gt;id.PID == GC0308_PID) &#123;<br>        s-&gt;set_hmirror(s, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 这里控制摄像头镜像 写1镜像 写0不镜像</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">camera_fb_t</span> *frame = esp_camera_fb_get();<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-7-语音识别"><a href="#2-7-语音识别" class="headerlink" title="2.7 语音识别"></a>2.7 语音识别</h3><h3 id="2-8-人脸识别"><a href="#2-8-人脸识别" class="headerlink" title="2.8 人脸识别"></a>2.8 人脸识别</h3><h2 id="3-WIFI"><a href="#3-WIFI" class="headerlink" title="3 WIFI"></a>3 WIFI</h2><h2 id="4-蓝牙"><a href="#4-蓝牙" class="headerlink" title="4 蓝牙"></a>4 蓝牙</h2><h2 id="5-系统-API"><a href="#5-系统-API" class="headerlink" title="5 系统 API"></a>5 系统 API</h2><h3 id="5-1-分区表"><a href="#5-1-分区表" class="headerlink" title="5.1 分区表"></a>5.1 分区表</h3><h3 id="5-2-NVS"><a href="#5-2-NVS" class="headerlink" title="5.2 NVS"></a>5.2 NVS</h3><h3 id="5-3-SPIFFS"><a href="#5-3-SPIFFS" class="headerlink" title="5.3 SPIFFS"></a>5.3 SPIFFS</h3><h2 id="6-附录"><a href="#6-附录" class="headerlink" title="6 附录"></a>6 附录</h2><h3 id="6-1-Arduino"><a href="#6-1-Arduino" class="headerlink" title="6.1 Arduino"></a>6.1 <a href="https://www.bilibili.com/video/BV1RM4y1a7J5?spm_id_from=333.788.videopod.episodes&vd_source=ca18f72085fcabc81ea5ba4e594aefe7">Arduino</a></h3><ol><li><p><a href="https://www.arduino.cc/">下载安装 IDE</a></p><p><img src="/2024/07/01/Embedded/ESP32/6-Arduino-Main_Menu.png"></p></li><li><p>Arduino IDE 的基础设置</p><ul><li>中文: <code>file</code> -&gt; <code>preference</code> -&gt; <code>language</code> -&gt; 选择中文</li><li>安装开发板资源: 工具 -&gt; 开发板 -&gt; 开发板管理器 -&gt; 搜索 ESP32 并安装(需要能连接 <code>Github</code>)</li></ul></li><li><p>Arduino 基础</p><ul><li>在 <code>void setup()&#123;&#125;</code> 函数中的代码在上电时运行一次,用于初始化</li><li>在 <code>void loop()&#123;&#125;</code> 函数中的代码将会死循环运行</li></ul></li><li><p>Hello,world(在 工具 -&gt; 串口监视器中查看输出)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 初始化串口</span><br>  Serial.<span class="hljs-built_in">begin</span>(<span class="hljs-number">9600</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;<br>  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello,world!\n&quot;</span>);<br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="6-2-PlatformIO"><a href="#6-2-PlatformIO" class="headerlink" title="6.2 PlatformIO"></a>6.2 PlatformIO</h3><ol><li><p>在 VSCode 中安装 PlatformIO IDE 插件.并等待期完成初始化</p><p><img src="/2024/07/01/Embedded/ESP32/6-PlatformIO.png"></p></li><li><p>主界面</p><p><img src="/2024/07/01/Embedded/ESP32/6-PlatformIO-Menu.png"></p></li><li><p>新建项目(点击 <code>New Project</code>)</p><ul><li>Board 选择 <code>ESP32-S3-DevKitC-1</code></li><li>反勾选 <code>use default location</code>.选择工程存放目录</li></ul></li><li><p>生成的工程结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">/my_project<br>  |-- .pio<span class="hljs-comment">// 编译生成的二进制文件,日志...</span><br>  |-- .vscode<br>  |-- include<span class="hljs-comment">// 头文件</span><br>  |-- lib<span class="hljs-comment">// 项目依赖的库文件</span><br>  |-- src  <span class="hljs-comment">// 源代码</span><br>  |-- tests<span class="hljs-comment">// 测试代码,数据.用于单元测试</span><br>   -- .gitignore<br>   -- platformio.ini<span class="hljs-comment">// 配置文件</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="6-3-MicroPython"><a href="#6-3-MicroPython" class="headerlink" title="6.3 MicroPython"></a>6.3 <a href="https://www.bilibili.com/video/BV1G34y1E7tE/?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click&vd_source=ca18f72085fcabc81ea5ba4e594aefe7">MicroPython</a></h3><ol><li><p>开发环境搭建</p><ul><li><p>安装 IDE: <a href="https://thonny.org/">Thonny</a>.界面如下</p><p><img src="/2024/07/01/Embedded/ESP32/6-thonny.png"></p></li><li><p>下载解释器: <a href="https://micropython.org/">MicroPython</a> 官网中 download 找到对应开发板,下载后缀为 <code>.bin</code> 的 Firmware</p><p><img src="/2024/07/01/Embedded/ESP32/6-MicroPython.png"></p></li></ul></li><li><p>烧录固件</p><ul><li><p>连接 ESP32 开发板,并安装 USB 转串口驱动(在设备管理器中查看)</p><p><img src="/2024/07/01/Embedded/ESP32/6-CH343.png"></p></li><li><p>在 Thonny 中配置解释器: <code>运行</code> -&gt; <code>配置解释器</code></p><p><img src="/2024/07/01/Embedded/ESP32/6-Thonny-Interpreter.png"></p></li><li><p>烧录解释器: 在下拉菜单中 <code>Select local MicroPython image...</code> 选择下载的 <code>Firmware</code></p><p><img src="/2024/07/01/Embedded/ESP32/6-Thonny-Download-Interpreter.png"></p></li><li><p>下载时可能需要按住 boot 键才能开始下载.耐心等待,直到出现 <code>Done!</code></p></li><li><p>成功烧录的标志: 左侧文件栏中出现 <code>MicroPython 设备</code> 或 Shell 窗口显示 <code>MicroPython</code></p></li></ul></li><li><p>Hello,world</p><ul><li><p>新建文件,并写入 <code>print(&quot;Hello,world!&quot;)</code>.将其保存到 <code>MicroPython设备</code></p></li><li><p>点击 <code>运行当前脚本</code>,即可运行.此时 Python 程序已运行于 ESP32</p><p><img src="/2024/07/01/Embedded/ESP32/6-Hello-world.png"></p></li></ul></li><li><p>对于 MicroPython 的 api,需参考其<a href="http://www.micropython.com.cn/en/latet/esp32/quickref.html">官网文档</a></p></li><li><p>MicroPython REPL(交互解释器) 位于 UART0.波特率115200</p></li></ol><h3 id="6-4-WIFI"><a href="#6-4-WIFI" class="headerlink" title="6.4 WIFI"></a>6.4 WIFI</h3><ol><li><p><code>Wi-Fi</code> 是基于 <code>IEEE 802.11</code> 标准的无线网络技术.让联网设备以无线电波的形式,加入采用 <code>TCP/IP</code> 通信协议的网络</p><ul><li>**Access Point(<code>AP</code>) 无线接入点: 提供无线接入的设备.**如光猫是结合 WiFi 和 internet 路由功能的AP</li><li>**Station(<code>STA</code>) 无线终端: 连接到 AP 的装置.**如手机,电脑等设备处于 STA 模式.这个模式不允许其他设备接入</li></ul></li><li><p>SSID</p><ul><li><strong>BSSID</strong>: 无线路由器的 MAC 地址(本质是<strong>MAC 地址</strong>)</li><li><strong>SSID</strong>: 搜索到的 wifi 名字(本质是<strong>字符串</strong>)</li><li><strong>ESSID</strong>: 实际上与 ssid 相同,但可以多个路由器为同一名字</li></ul></li><li><p>ESP32 连接 WIFI(注意: ESP32 不支持 5G 路由器)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">do_connect</span>():<br>    <span class="hljs-keyword">import</span> network<br>    wlan = network.WLAN(network.STA_IF)  <span class="hljs-comment"># 创建 STA 接口</span><br>    wlan.active(<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 激活接口</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> wlan.isconnected():  <span class="hljs-comment"># 若未连接 WIFI,则尝试连接指定 WIFI</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;connecting to network...&#x27;</span>)<br>        wlan.connect(<span class="hljs-string">&#x27;ssid&#x27;</span>, <span class="hljs-string">&#x27;key&#x27;</span>)<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> wlan.isconnected():<br>            <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># 一次连接未成功后处理.若未连接这里将会阻塞</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;network config:&#x27;</span>, wlan.ifconfig())<br></code></pre></td></tr></table></figure></li><li><p>测试 ESP32 连接状态</p><ul><li><p>当 ESP32 连接到路由器后,用同一局域网下的电脑发送 &#x2F; 接收数据</p></li><li><p>使用 <code>NetAssist</code> 网络调试助手软件测试</p></li><li><p>ESP32 发送 &#x2F; 接收数据</p><ul><li><p>在 <code>NetAssist</code> 中打开网络(配置左上角的 <code>选项</code> -&gt; <code>字符集编码</code> 选择 <code>uft-8</code>)</p><p><img src="/2024/07/01/Embedded/ESP32/6-NetAssist-RX.png"></p></li><li><p>在 ESP32 中发送数据.查看电脑端接收的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 1. 创建 udp 套接字</span><br>udp_socket = socket(AF_INET, SOCK_DGRAM)<br><span class="hljs-comment"># 2. 准备接收方的地址.需要与 NetAssist 配置对应</span><br>dest_addr = (<span class="hljs-string">&#x27;192.168.0.102&#x27;</span>, <span class="hljs-number">8080</span>)<br><span class="hljs-comment"># 3. 从键盘获取数据</span><br>send_data = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-comment"># 4. 发送数据到指定的电脑上,并接收一次数据</span><br>udp_socket.sendto(send_data.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), dest_addr)<br>recv_data = udp_socket.recvfrom(<span class="hljs-number">1024</span>)<br><span class="hljs-built_in">print</span>(send_data)<br><span class="hljs-comment"># 5. 关闭套接字</span><br>udp_socket.close()<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ESP32</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS</title>
    <link href="/2024/06/01/Embedded/FreeRTOS/"/>
    <url>/2024/06/01/Embedded/FreeRTOS/</url>
    
    <content type="html"><![CDATA[<h1 id="FreeRTOS"><a href="#FreeRTOS" class="headerlink" title="FreeRTOS"></a>FreeRTOS</h1><h2 id="0-基本概念"><a href="#0-基本概念" class="headerlink" title="0 基本概念"></a>0 基本概念</h2><h3 id="0-1-简介"><a href="#0-1-简介" class="headerlink" title="0.1 简介"></a>0.1 简介</h3><ol><li>FreeRTOS 优势<ul><li><strong>开源免费</strong>: 通过 MIT 许可证发布,可免费使用, 修改, 分发.活跃的社区支持</li><li><strong>轻量级设计</strong>: 内核代码精简,适用资源受限的嵌入式系统(通常 6-12KB ROM, 1-2KB RAM)</li><li><strong>模块化设计</strong>: 支持动态加载组件(如 TCP&#x2F;IP 栈, 文件系统 FatFS).可根据需求裁剪功能</li><li><strong>可移植性</strong>: 代码主要用 C 编写,支持多种处理器架构.提供统一的 API,移植只需修改相关硬件层</li><li><strong>功能丰富</strong>: 提供了多任务调度, 任务通信, 同步等功能.适用复杂的嵌入式应用场景</li></ul></li><li>FreeRTOS 特点<ul><li><strong>任务管理</strong>: 可创建多个任务,每个任务独立栈空间,支持优先级继承和动态优先级调整</li><li><strong>内存管理</strong>: 提供多种内存管理机制(heap_1 ~ heap_5),如静态分配,动态分块,适应不同硬件资源</li><li><strong>任务调度</strong>: 通过任务调度器管理多个任务,支持不同优先级的任务,实现任务有序执行</li><li><strong>低功耗支持</strong>: 提供 Tickless 模式,在空闲时暂停系统节拍,显著降低功耗</li><li><strong>任务通信和同步</strong>: 提供了队列, 信号量等机制,支持任务间的通信和同步,确保数据安全传递</li><li><strong>定时器和中断处理</strong>: 支持定时器功能,能够处理中断</li></ul></li></ol><h3 id="0-2-多任务系统"><a href="#0-2-多任务系统" class="headerlink" title="0.2 多任务系统"></a>0.2 多任务系统</h3><ol><li><strong>多任务(Multitasking)</strong><ul><li>多任务操作系统能够同时管理多个任务,通过任务间快速切换制造并发执行的假象</li><li>在单核 CPU 上,任务依然是分时运行的,但调度器的高效切换,感知上像是同时执行多个任务</li></ul></li><li>多任务操作系统的优势<ul><li>提高 CPU 利用率: 对比在单任务系统中阻塞时,CPU 只能空转.多任务可以让其他任务在等待期间运行</li><li>并行处理: 如一个任务处理用户输入,一个进行数据计算,一个控制电机</li><li>增强实时性: 高优先级任务可以立即抢占低优先级任务,确保关键操作以及执行</li><li>模块化设计: 将不同功能拆分为独立任务,代码结构更清晰,易于维护</li><li>简化延时: 单任务的延时会阻塞整个程序.而多任务系统中可以通过 <code>vTaskDelay()</code> 让出 CPU</li><li>资源管理: 通过信号量,互斥量等机制对共享资源进行保护</li><li>内存隔离: 每个任务拥有独立栈空间,避免变量冲突</li><li>空闲任务优化: 当所有任务处于阻塞状态时,FreeRTOS 可进入低功耗模式,显著降低功耗</li></ul></li></ol><h3 id="0-3-任务状态"><a href="#0-3-任务状态" class="headerlink" title="0.3 任务状态"></a>0.3 任务状态</h3><ol><li><p><strong>FreeRTOS 任务有四种状态(FreeRTOS 优先级数值越大,表示优先级越高)</strong></p><p><img src="/2024/06/01/Embedded/FreeRTOS/0-FreeRTOS-status.png"></p></li><li><p><strong>运行态(Running)</strong></p><ul><li>当前正在执行的任务,占用 CPU 资源</li><li>单核 CPU 上,同一时刻只有一个任务处于运行态</li></ul></li><li><p><strong>就绪态(Ready)</strong></p><ul><li>任务已准备好运行,但尚未被调度器选中.可能因更高优先级任务正在运行</li><li>任务存放在就绪列表(Ready List)中,按优先级排序</li></ul></li><li><p><strong>阻塞态(Blocked)</strong></p><ul><li>任务在等待某个事件或超时,不占用 CPU</li><li>任务被移至阻塞列表(Blocked List),直到事件发生或超时</li><li>延时阻塞: <code>vTaskDelay(1000)</code> 等待 1 秒</li><li>同步阻塞: <code>xQueueReceive()</code> 等待队列数据</li><li>资源阻塞: <code>xSemaphoreTake()</code> 等待信号量</li></ul></li><li><p><strong>挂起态(Suspended)</strong></p><ul><li>任务被手动暂停,不参与调度,即使事件就绪也不会运行</li><li>常用于调试或临时禁用某个任务</li><li>挂起任务: <code>vTaskSuspend(TaskHandle_t xTask)</code></li><li>恢复任务: <code>vTaskResume(TaskHandle_t xTask)</code></li></ul></li><li><p>状态总结</p><table><thead><tr><th align="left">状态</th><th align="left">说明</th><th align="left">触发条件</th></tr></thead><tbody><tr><td align="left">运行态</td><td align="left">当前正在 CPU 上执行的任务</td><td align="left">被调度器选中执行</td></tr><tr><td align="left">就绪态</td><td align="left">已准备好运行,但尚未被调度</td><td align="left">任务创建 &#x2F; 从阻塞或挂起恢复 &#x2F; 高优先级任务释放 CPU</td></tr><tr><td align="left">阻塞态</td><td align="left">任务在等待延时或某个事件</td><td align="left">调用 <code>vTaskDelay()</code> &#x2F; 等待队列 &#x2F; 等待信号量</td></tr><tr><td align="left">挂起态</td><td align="left">任务被显式暂停,不会被调度</td><td align="left">调用 <code>vTaskSuspend()</code> &#x2F; 被其他任务挂起</td></tr></tbody></table></li></ol><h3 id="0-4-任务调度"><a href="#0-4-任务调度" class="headerlink" title="0.4 任务调度"></a>0.4 任务调度</h3><ol><li><strong>任务调度器(Scheduler)</strong>: 决定某一时刻要执行哪个任务,并管理任务之间的切换<ul><li><strong>抢占式调度(Preemptive Scheduling)</strong>: 高优先级任务可以立即抢占低优先级任务的 CPU 使用权</li><li><strong>时间片轮询(Time Slicing)</strong>: 相同优先级的任务按固定时间片(Tick)轮流执行</li></ul></li><li>调度器工作流程<ul><li><strong>任务创建</strong>: 调用 <code>xTaskCreate()</code> 创建任务,任务进入就绪态</li><li><strong>任务调度</strong><ul><li>调度器选择最高优先级的就绪任务运行</li><li>如果使用时间片轮转,相同优先级的任务会轮流执行</li></ul></li><li><strong>任务切换</strong>: 发生以下情况时,调度器会触发任务切换<ul><li>任务主动让出 CPU(如 <code>vTaskDelay(), taskYIELD()</code>)</li><li>高优先级任务就绪(抢占当前任务)</li><li>中断发生(某些中断会触发调度)</li></ul></li><li><strong>任务状态变化</strong><ul><li>运行 → 阻塞: 任务等待事件(如信号量, 队列)</li><li>阻塞 → 就绪: 事件发生(如数据到达)</li><li>挂起: 任务被手动暂停(<code>vTaskSuspend()</code>)</li></ul></li></ul></li><li>FreeRTOS 调度器的核心依赖<ul><li><strong>SysTick 定时器</strong>: 提供时间基准(Tick).用于时间片轮转和任务超时管理</li><li><strong>PendSV 中断(ARM Cortex-M)</strong>: 用于低优先级上下文切换,确保关键中断(如硬件 SPI)不被延迟</li><li><strong>任务控制块(TCB)</strong>: 存储任务状态, 栈指针, 优先级等信息,供调度器决策</li></ul></li></ol><h3 id="0-5-滴答时钟"><a href="#0-5-滴答时钟" class="headerlink" title="0.5 滴答时钟"></a>0.5 滴答时钟</h3><ol><li><strong>FreeRTOS 的滴答(Tick)是操作系统的时间基准,是任务调度和时间管理的基础</strong><ul><li>滴答时钟是 FreeRTOS 内部的时间基准,由硬件定时器周期性中断产生</li><li><strong>频率</strong>: 由 <code>configTICK_RATE_HZ</code> 宏定义,通常设置为 1000Hz(1ms) 或 100Hz(10ms)</li></ul></li><li>FreeRTOS 实时内核通过滴答计数变量测量时间(一般将 Systick 作为时钟来源)<ul><li>休眠时,RTOS 任务需指定唤醒的时间</li><li>阻塞时,需指定等待的最长时间</li></ul></li><li>定时器中断(RTOS 滴答中断)按严格的时间精度增加滴答数<ul><li>每次滴答数增加时,实时内核必须检查是否为解除阻塞或唤醒任务的时间</li><li>在滴答 ISR 期间唤醒或解除阻塞的任务优先级可能高于被中断任务的优先级</li></ul></li></ol><h3 id="0-6-上下文切换"><a href="#0-6-上下文切换" class="headerlink" title="0.6 上下文切换"></a>0.6 上下文切换</h3><ol><li><strong>上下文(Context)</strong>: 任务运行时 CPU 的状态<ul><li>程序计数器(PC)</li><li>处理器状态寄存器(如 xPSR)</li><li>通用寄存器(R0-R12)</li><li>栈指针(SP)</li></ul></li><li><strong>上下文切换(Context Switching)</strong>: 保存当前任务的上下文,恢复下一个任务的上下文的过程</li><li><strong>上下文切换时机</strong>: 任务切换时<ul><li>任务调用阻塞 API: 如 <code>vTaskDelay(), xQueueReceive()</code> 等</li><li>任务主动放弃 CPU: 调用 <code>taskYIELD()</code></li><li>滴答中断(Systick): 时间片轮转调度时</li><li>其他中断: 高优先级任务就绪时(如信号量, 队列等操作)</li><li>任务执行完毕</li></ul></li><li>FreeRTOS 中的实现方式<ul><li>真正切换上下文的执行在 PendSV(可挂起的系统调用)中断</li><li>PendSV 可以手动触发,且可以在其他更高中断优先级的 ISR 中设置</li><li>FreeRTOS 会将 PendSV 设置为最低中断优先级,以免任务切换导致影响到其他 ISR</li></ul></li></ol><h3 id="0-7-空闲任务"><a href="#0-7-空闲任务" class="headerlink" title="0.7 空闲任务"></a>0.7 空闲任务</h3><ol><li><strong>RTOS 调度器启动时,自动创建空闲任务,确保始终存在一个能够运行的任务</strong><ul><li>每个任务调度器都有一个空闲任务</li><li>创建时机: 在调用 <code>vTaskStartScheduler()</code> 时自动创建</li><li>以最低优先级创建,确保有更高优先级任务处于准备就绪状态时,空闲任务不使用 CPU 时间</li></ul></li><li><strong>空闲任务功能</strong><ul><li>负责删除已被终止的任务(调用 <code>vTaskDelete()</code> 的任务)</li><li>回收被删除任务的内存资源</li><li>实现 Tickless 空闲模式(当启用 <code>configUSE_TICKLESS_IDLE</code> 时)</li><li>执行用户定义的空闲任F务钩子函数(Idle Hook)</li></ul></li></ol><h2 id="1-移植"><a href="#1-移植" class="headerlink" title="1 移植"></a>1 移植</h2><h3 id="1-1-源码结构"><a href="#1-1-源码结构" class="headerlink" title="1.1 源码结构"></a>1.1 源码结构</h3><ol><li><p>获取源码: <a href="https://www.freertos.org/">官网下载</a></p></li><li><p>FreeRTOS 目录结构</p><blockquote><p>├── <strong>FreeRTOS</strong> (内核)<br>│   ├── Demo (例程)<br>│   ├── License (证书)<br>│   ├── Source (内核源码)<br>│   │   ├── include (头文件)<br>│   │   └── portable (移植文件,编译器环境相关)<br>│   └── Test (测试)<br>├── FreeRTOS-Plus (扩展组件,一般使用第三方组件)<br>└── tools (工具集)</p></blockquote></li></ol><h3 id="1-2-HAL-库移植"><a href="#1-2-HAL-库移植" class="headerlink" title="1.2 HAL 库移植"></a>1.2 HAL 库移植</h3><ol><li><p>在工程根目录创建 FreeRTOS 目录,在其中创建 <code>source, include, portable</code> 目录.然后将下面文件复制过来</p><ul><li><code>source</code> 目录: FreeRTOS&#x2F;Source 下的所有 .c 文件</li><li><code>include</code> 目录: FreeRTOS&#x2F;Source&#x2F;include 整个目录</li><li><code>portable</code> 目录:<ul><li>FreeRTOS&#x2F;Source&#x2F;portable&#x2F;RVDS 的相关文件(根据内核选择)</li><li>FreeRTOS&#x2F;Source&#x2F;portable&#x2F;MemMang 的 <code>heap_4.c</code></li></ul></li><li><code>FreeRTOSConfig.h</code>: 工程配置文件.可以在 DEMO 中寻找</li></ul></li><li><p>在 Keil 中添加路径…….</p></li><li><p>在系统配置文件 <code>FreeRTOSConfig.h</code> 中添加必须下面的3个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortPendSVHandler  PendSV_Handler <span class="hljs-comment">// 适配 stm32 的 PendSV_Handler 中断</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vPortSVCHandler     SVC_Handler    <span class="hljs-comment">// 适配 stm32 的 SVC_Handler 中断</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetSchedulerState 1   <span class="hljs-comment">// 查询调度器的当前状态</span></span><br></code></pre></td></tr></table></figure></li><li><p>在 <code>stm32f1xx_it.c</code> 文件中注释掉 <code>PendSV_Handler, SVC_Handler</code> 函数.否则会重复定义</p></li><li><p>配置时钟源: 在 <code>stm32f1xx_it.c</code> 文件中包含 <code>FreeRTOS.h, task.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FreeRTOS.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task.h&quot;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">xPortSysTickHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) &#123;  <span class="hljs-comment">// 如果开启了任务调度器</span><br>        xPortSysTickHandler();  <span class="hljs-comment">// 启动 freeRTOS 的滴答 ISR</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>hal</code> 库的延时函数默认使用 <code>SysTick</code>.将 FreeRTOS 的时钟配置为 <code>SysTick</code> 后可能引发问题</p><ul><li><strong>在中断调用 hal 库中提供的 <code>hal_delay()</code> 时,因为其优先级被设置为最低,</strong><br><strong>会等待外设中断结束.而外设中断又在等待 delay 结束,因此计数器无法累加,时间卡死</strong></li><li>因此不要在中断函数调用 <code>hal_delay()</code></li></ul></li><li><p>修改 <code>Hal timebase</code> 时钟源以解决 <code>hal_delay()</code> 的问题</p><ul><li>在 CubeMX 中选择 <code>Timebase Source</code> 默认为 <code>SysTick</code>, 改为其他未使用的定时器.如 TIM7</li><li>在 NVIC 中找到 <code>Time base interrupt</code>,将其优先级改为1.此时可以正常使用 <code>hal_delay()</code></li></ul></li></ol><h3 id="1-3-寄存器移植"><a href="#1-3-寄存器移植" class="headerlink" title="1.3 寄存器移植"></a>1.3 寄存器移植</h3><ol><li><p>前置步骤与 hal 库一致,直到第 4 步,因为寄存器开发没有 <code>stm32f1xx_it.c</code> 文件</p></li><li><p>在某一个文件中实现滴答定时器的中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">xPortSysTickHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) &#123;  <span class="hljs-comment">// 如果开启了任务调度器</span><br>        xPortSysTickHandler();  <span class="hljs-comment">// 启动 freeRTOS 的滴答 ISR</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自己实现的延时函数不应再依赖 <code>SysTick</code>, 防止卡死</p></li></ol><h3 id="1-4-系统配置文件"><a href="#1-4-系统配置文件" class="headerlink" title="1.4 系统配置文件"></a>1.4 系统配置文件</h3><ol><li>在系统配置文件 <code>FreeRTOSConfig.h</code> 中有很多配置项.可在 <a href="https://www.freertos.org/zh-cn-cmn-s/Documentation/02-Kernel/03-Supported-devices/02-Customization">官方文档</a> 查看详细信息</li><li>主要分为 <code>config</code> 参数 和 <code>INCLUDE</code> 宏<ul><li><code>config</code>: 功能配置.如基本配置, 内存配置, 钩子配置, 中断配置…</li><li><code>INCLUDE</code>: 裁剪功能(使用条件编译实现.1 表示可用,0 表示禁用)</li></ul></li></ol><h3 id="1-5-命名规范"><a href="#1-5-命名规范" class="headerlink" title="1.5 命名规范"></a>1.5 命名规范</h3><ol><li>数据类型<ul><li><code>TickType_t</code>: 用于表示系统节拍计数器的值<ul><li><code>configUSE_16_BIT_TICKS</code> 为 <code>true</code> 时, <code>TickType_t</code> 是16bit.否则为 32bit</li><li>记录 FreeRTOS 中系统过去的节拍次数</li></ul></li><li><code>BaseType_t</code>: 架构中最有效, 自然的类型. 32位架构下被定义为 32位类型</li><li><code>UBaseType_t</code>: <code>BaseType_t</code> 的 <code>unsigned</code> 版</li><li><code>StackType_t</code>: 用于存储堆栈的类型</li></ul></li><li>变量名采用驼峰式大小写,一般不用缩写<ul><li><code>uint32_t</code> 类型变量用 <code>ul</code> 前缀,即 <code>unsigned long</code></li><li><code>uint16_t</code> 类型变量用 <code>us</code> 前缀,即 <code>unsigned short</code></li><li><code>uint8_t</code> 类型变量用 <code>uc</code> 前缀,即 <code>unsigned char</code></li><li>非 <code>stdint</code> 类型的变量用 <code>x</code> 前缀,无符号变量用 <code>u</code> 前缀</li><li>枚举变量用 <code>e</code> 前缀, 指针变量用 <code>p</code> 前缀</li></ul></li><li>函数使用驼峰式大小写,一般不用缩写<ul><li>文件作用域静态(私有)函数用 <code>prv</code> 前缀</li><li>API 函数以其返回类型为前缀.对于 <code>void</code> 用 <code>v</code> 前缀</li><li>API 函数名称用定义 API 函数文件为前缀</li><li>如 <code>vTaskDelay</code>: 返回类型 <code>void</code>,定义于 <code>task.c</code>, 作用为 <code>delay</code></li></ul></li><li>宏使用完整的单词拼写<ul><li>宏用定义宏的文件为前缀.如 <code>FreeRTOSConfig.h</code> 定义 <code>configUSE_PREEMPTION</code></li><li>除前缀外,宏全大写,并使用下划线分隔</li></ul></li></ol><h2 id="2-任务控制"><a href="#2-任务控制" class="headerlink" title="2 任务控制"></a>2 任务控制</h2><h3 id="2-1-任务控制-API"><a href="#2-1-任务控制-API" class="headerlink" title="2.1 任务控制 API"></a>2.1 任务控制 API</h3><ol><li><p>任务创建可以动态(<code>xTaskCreate</code>)或静态的(<code>xTaskCreateStatic</code>).区别在于</p><ul><li>动态创建: 任务的控制块和栈空间由 FreeRTOS 管理</li><li>静态创建: 任务的控制块和栈空间由用户分配提供(在 <code>malloc</code> 受限时使用)</li></ul></li><li><p>动态创建任务步骤</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskCreate</span> <span class="hljs-params">(</span><br><span class="hljs-params">    TaskFunction_t pxTaskCode,  <span class="hljs-comment">// 指向任务函数的指针</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> pcName,   <span class="hljs-comment">// 任务名,最大长度为 configMax_TASK_NAME_LEN</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> configSTACK_DEPTH_TYPE usStackDepth,  <span class="hljs-comment">// 任务堆栈大小,默认单位为4字节.最小为128</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span> *<span class="hljs-type">const</span> pvParameters,  <span class="hljs-comment">// 传递给任务函数的参数</span></span><br><span class="hljs-params">    UBaseType_t uxPriority,    <span class="hljs-comment">// 任务优先级, 0 ~ configMAX_PRIORITIES - 1</span></span><br><span class="hljs-params">    TaskHandle_t *<span class="hljs-type">const</span> pxCreatedTask  <span class="hljs-comment">// 任务句柄,即任务的控制块</span></span><br><span class="hljs-params">)</span>;<br><span class="hljs-comment">// 返回值 pdPASS 表示创建成功. errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY 表示失败</span><br></code></pre></td></tr></table></figure></li><li><p>删除任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelete</span><span class="hljs-params">(TaskHandle_t xTaskToDelete)</span>;<br><span class="hljs-comment">// xTaskToDelete: 待删除任务的任务句柄</span><br><span class="hljs-comment">// 若传入 NULL: 删除任务自身(当前正在运行的任务)</span><br></code></pre></td></tr></table></figure><ul><li>被删除的任务将从就绪态任务列表, 阻塞态任务列表, 挂起态任务列表, 事件列表中移除</li><li>由空闲任务负责释放被删除任务中系统分配的内存</li></ul></li></ol><h3 id="2-2-任务控制示例"><a href="#2-2-任务控制示例" class="headerlink" title="2.2 任务控制示例"></a>2.2 任务控制示例</h3><ol><li><p>目标: 使用 <code>xTaskCreate</code> 和 <code>vTaskDelete</code></p><ul><li><code>start_task</code>: 启动任务,用于创建其他任务</li><li><code>task1</code>: 让 LED1 每 500ms 闪烁一次</li><li><code>task2</code>: 让 LED2 每 500ms 闪烁一次</li><li><code>task3</code>: 判断 KEY1 是否按下,按下时删除 <code>task1</code></li></ul></li><li><p>创建 <code>task_test.h</code> 文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __TASK_TEST_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __TASK_TEST_H__</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">freertos_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>创建 <code>task_test.c</code> 文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task_test.h&quot;</span></span><br><span class="hljs-comment">/* freeRTOS 必须的相关头文件 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FreeRTOS.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task.h&quot;</span></span><br><br><span class="hljs-comment">/* 所有任务的声明 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">start_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">task1</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">task2</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">task3</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>;<br><br><span class="hljs-comment">/* 任务句柄的声明 */</span><br><span class="hljs-type">static</span> TaskHandle_t task1_handler;<br><span class="hljs-type">static</span> TaskHandle_t task2_handler;<br><span class="hljs-type">static</span> TaskHandle_t task3_handler;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">freertos_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">/* 1. 创建启动任务 */</span><br>    TaskHandle_t start_task_handler;<br>    xTaskCreate((TaskFunction_t)start_task, <span class="hljs-string">&quot;start_task&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, &amp;start_task_handler);<br>    <span class="hljs-comment">/* 2. 启动调度器 */</span><br>    vTaskStartScheduler();<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">start_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    taskENTER_CRITICAL();  <span class="hljs-comment">// 进入临界区.临界区的代码不会被打断</span><br>    <span class="hljs-comment">/* 1. 创建需要运行的任务 */</span><br>    xTaskCreate( (TaskFunction_t)task1, <span class="hljs-string">&quot;task1&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, &amp;task1_handler);<br>    xTaskCreate( (TaskFunction_t)task2, <span class="hljs-string">&quot;task2&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, &amp;task2_handler);<br>    xTaskCreate( (TaskFunction_t)task3, <span class="hljs-string">&quot;task3&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, &amp;task3_handler);<br>    taskEXIT_CRITICAL();  <span class="hljs-comment">// 退出临界区.与进入临界区成对出现</span><br><br>    <span class="hljs-comment">/* 2. 删除自身(启动任务),退出任务.因为启动任务只需执行一次 */</span><br>    vTaskDelete(<span class="hljs-literal">NULL</span>);  <span class="hljs-comment">// 删除当前任务会立即停止运行,因此最后运行</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">task1</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;task1 working...\n&quot;</span>);<br>        LED_Toggle(LED1_Pin);<br>        vTaskDelay(<span class="hljs-number">500</span>);  <span class="hljs-comment">// 该延时函数会让任务进入阻塞态</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">task2</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;task2 working...\n&quot;</span>);<br>        LED_Toggle(LED2_Pin);<br>        vTaskDelay(<span class="hljs-number">500</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">task3</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-type">uint8_t</span> key = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;task3 working...\n&quot;</span>);<br>        key = key_detect();<br>        <span class="hljs-keyword">if</span>(key == KEY1 &amp;&amp; task1_handler != <span class="hljs-literal">NULL</span>) &#123;<br>            vTaskDelete(task1_handler);<br>            task1_handler = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        vTaskDelay(<span class="hljs-number">500</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 <code>main.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task_test.h&quot;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    freertos_start();  <span class="hljs-comment">// 程序开启任务调度器后不会执行之后的代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-挂起和恢复"><a href="#2-3-挂起和恢复" class="headerlink" title="2.3 挂起和恢复"></a>2.3 挂起和恢复</h3><ol><li><p>挂起任务.类似暂停</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 需要将宏 INCLUDE_vTaskSuspend 配置为1</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSuspend</span><span class="hljs-params">( TaskHandle_t xTaskToSuspend )</span>;<br><span class="hljs-comment">// xTaskToSuspend: 待挂起任务的任务句柄.为 NULL 表示挂起任务自身</span><br></code></pre></td></tr></table></figure></li><li><p>恢复任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 需要将宏 INCLUDE_vTaskResume 配置为1</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskResume</span><span class="hljs-params">( TaskHandle_t xTaskToResume )</span>;<br><span class="hljs-comment">// 无论 suspend 多少次,只需 resume 一次.被恢复的任务重新进入就绪态</span><br></code></pre></td></tr></table></figure></li><li><p>在中断恢复被挂起的任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 需要将宏 INCLUDE_vTaskResume 和 INCLUDE_vTaskResumeFromISR 配置为1</span><br>BaseType_t <span class="hljs-title function_">xTaskResumeFromISR</span><span class="hljs-params">( TaskHandle_t xTaskToResume )</span>;<br><span class="hljs-comment">// 返回值: pdTRUE(pdFALSE) 表示任务恢复后需要(不需要)进行任务切换</span><br><span class="hljs-comment">// 在中断服务程序调用 Freertos 的 API 函数,要求中断优先级不高于 FreeRTOS 管理的最高中断优先级</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-中断管理"><a href="#2-4-中断管理" class="headerlink" title="2.4 中断管理"></a>2.4 中断管理</h3><ol><li><p>优先级配置</p><ul><li>STM32 通过优先级配置寄存器支持16级不同优先级中断.数字越小表示优先级越高(FreeRTOS 任务相反)</li><li>FreeRTOS 将 PendSV, SysTick 设为最低中断优先级(15),保证任务切换不会阻塞系统对其他中断的响应</li><li>FreeRTOS 通过 BASEPPRI 寄存器实现中断管理,屏蔽优先级低于某一阈值的中断</li><li><strong>建议将所有的优先级指定为抢占优先级,方便 FreeRTOS 管理</strong></li><li><strong>在中断服务函数中调用 FreeRTOS 的 API 函数,必须使用 <code>From_ISR</code> 后缀的函数</strong></li></ul></li><li><p><strong>临界区</strong>: 必须在不被打断的情况下完整运行的代码段.如对外设初始化有严格时序要求的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">taskENTER_CRITICAL();  <span class="hljs-comment">// 进入临界区</span><br>taskEXIT_CRITICAL();   <span class="hljs-comment">// 退出临界区</span><br><br>taskENTER_CRITICAL_FROM_ISR(); <span class="hljs-comment">// 中断函数安全 API</span><br>taskEXIT_CRITICAL_FROM_ISR();  <span class="hljs-comment">// 中断函数安全 API</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-5-时间片调度"><a href="#2-5-时间片调度" class="headerlink" title="2.5 时间片调度"></a>2.5 时间片调度</h3><ol><li><p>在 FreeRTOS 中,同等优先级的任务轮流分享相同的 CPU 时间.一个时间片的长度等同于 SysTick 中断的周期</p></li><li><p>相对延时: 从函数调用时刻开始计算.适合任务无需严格周期.或每次循环时间不确定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 使当前任务阻塞指定的 时钟节拍数(Ticks) */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelay</span><span class="hljs-params">(<span class="hljs-type">const</span> TickType_t xTicksToDelay)</span>;<br><br><span class="hljs-comment">/* pdMS_TO_TICKS 宏将毫秒时间转换为节拍数 */</span><br>vTaskDelay(pdMS_TO_TICKS(<span class="hljs-number">1000</span>));  <span class="hljs-comment">// 延时 1000ms</span><br></code></pre></td></tr></table></figure></li><li><p>相对延时示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskExample</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 任务逻辑代码</span><br>        vTaskDelay(<span class="hljs-number">1000</span> / portTICK_PERIOD_MS); <span class="hljs-comment">// 延时 1000ms(从调用时刻开始)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>绝对延时: 使当前任务阻塞到绝对时间点(基于上一次唤醒时间 + 固定周期)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskDelayUntil</span><span class="hljs-params">(TickType_t *pxPreviousWakeTime,  <span class="hljs-comment">// 指向任务上一次唤醒时间的变量</span></span><br><span class="hljs-params">                          <span class="hljs-type">const</span> TickType_t xTimeIncrement)</span>; <span class="hljs-comment">// 期望的任务周期(Ticks)</span><br><span class="hljs-comment">// 返回 pdTRUE 表示正常延时,pdFALSE 表示因调度器挂起等原因导致计算的时间已过期</span><br></code></pre></td></tr></table></figure></li><li><p>绝对延时示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vStrictPeriodicTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    TickType_t xLastWakeTime = xTaskGetTickCount(); <span class="hljs-comment">// 初始化基准时间</span><br>    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 任务逻辑代码(执行时间可能变化)</span><br>        xTaskDelayUntil(&amp;xLastWakeTime, <span class="hljs-number">100</span> / portTICK_PERIOD_MS); <span class="hljs-comment">// 严格 100ms 周期</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-6-任务状态查询"><a href="#2-6-任务状态查询" class="headerlink" title="2.6 任务状态查询"></a>2.6 <a href="https://www.freertos.org/zh-cn-cmn-s/Documentation/02-Kernel/04-API-references/03-Task-utilities/00-Task-utilities">任务状态查询</a></h3><ol><li><p>获取任务优先级</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">UBaseType_t <span class="hljs-title function_">uxTaskPriorityGet</span><span class="hljs-params">(TaskHandle_t xTask)</span>;<br></code></pre></td></tr></table></figure></li><li><p>设置任务优先级</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskPrioritySet</span><span class="hljs-params">(TaskHandle_t xTask, UBaseType_t uxNewPriority)</span>;<br></code></pre></td></tr></table></figure><ul><li>传入 <code>NULL</code> 表示当前任务</li><li>修改优先级后.若新优先级高于当前运行任务的优先级,会立即触发任务切换(抢占)</li></ul></li><li><p>获取任务运行历史上剩余堆栈的最小值(预留至少 10%~20% 的堆栈余量)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">UBaseType_t <span class="hljs-title function_">uxTaskGetStackHighWaterMark</span><span class="hljs-params">(TaskHandle_t xTask)</span>;<br></code></pre></td></tr></table></figure><ul><li><p><strong>数值越大: 堆栈剩余越多,安全性越高; 数值接近 0: 堆栈即将溢出,需增大堆栈空间</strong></p></li><li><p>FreeRTOS 默认 <strong>不提供堆栈溢出检测</strong>(需手动启用 <code>configCHECK_FOR_STACK_OVERFLOW</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configCHECK_FOR_STACK_OVERFLOW 1  <span class="hljs-comment">// 方法1(检测调用链)或 2(检测栈尾)</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>获取所有任务信息(以表格形式).用于快速监控任务运行状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 开启追踪 task 信息 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TRACE_FACILITY 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_STATS_FROMATTING_FUNCTIONS 1</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskList</span><span class="hljs-params">(<span class="hljs-type">char</span> *pcWriteBuffer)</span>;<br><span class="hljs-comment">// 输出格式形如:</span><br>名称   状态  优先级  堆栈剩余  任务编号<br>task1   x      <span class="hljs-number">1</span>       <span class="hljs-number">79</span>       <span class="hljs-number">3</span><br><span class="hljs-comment">// 状态标志: X(运行), B(阻塞), R(就绪), S(挂起), D(删除)</span><br></code></pre></td></tr></table></figure></li><li><p>获取系统中所有任务的 CPU 占用率 和 运行时间信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 开启追踪 运行时间信息 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configGENERATE_RUN_TIME_STATS        1 <span class="hljs-comment">// 启用运行时统计</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_STATS_FORMATTING_FUNCTIONS 1 <span class="hljs-comment">// 启用统计格式化函数</span></span><br><br><span class="hljs-comment">/* 需要实现的宏(提供计时基准) */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">get_run_time_counter</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>; <span class="hljs-comment">// 示例: 获取系统运行时间(需用户实现)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() \  </span><br>    (<span class="hljs-type">void</span>)get_run_time_counter() <span class="hljs-comment">// 初始化统计计时器</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portGET_RUN_TIME_COUNTER_VALUE() \  </span><br>    get_run_time_counter() <span class="hljs-comment">// 获取当前计时值</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskGetRunTimeStats</span><span class="hljs-params">(<span class="hljs-type">char</span> *pcWriteBuffer)</span>;<br><span class="hljs-comment">// 输出格式形如:</span><br>Task       Runtime  Stats:<br>main        <span class="hljs-number">125000</span>    <span class="hljs-number">32</span>%  <br>IDLE        <span class="hljs-number">250000</span>    <span class="hljs-number">64</span>%  <br>Tmr Svc      <span class="hljs-number">18750</span>     <span class="hljs-number">4</span>%  <br>Monitor       <span class="hljs-number">6250</span>     <span class="hljs-number">1</span>%<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3 消息队列"></a>3 消息队列</h2><h3 id="3-1-队列概念"><a href="#3-1-队列概念" class="headerlink" title="3.1 队列概念"></a>3.1 队列概念</h3><ol><li><strong>队列是任务间通信的主要形式,实现 任务间异步通信 或 任务与中断间通信,传递结构化数据或信号</strong><ul><li><strong>线程安全</strong>: 自带互斥访问,无需额外同步</li><li><strong>阻塞机制</strong>: 任务在队列空 &#x2F; 满时可选择阻塞等待</li></ul></li><li>列队的运作原理<ul><li>本质是一个环形缓冲区,存储固定大小的数据项</li><li>包含头尾指针,支持 FIFO(默认) 或 LIFO 存取方式</li></ul></li><li>队列中的项可以是不同长度的数据块,而非固定大小</li></ol><h3 id="3-2-队列-API"><a href="#3-2-队列-API" class="headerlink" title="3.2 队列 API"></a>3.2 队列 API</h3><ol><li><p>创建队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">QueueHandle_t <span class="hljs-title function_">xQueueCreate</span><span class="hljs-params">(     <span class="hljs-comment">// 创建队列.成功则返回队列句柄</span></span><br><span class="hljs-params">    UBaseType_t uxQueueLength,  <span class="hljs-comment">// 队列容量</span></span><br><span class="hljs-params">    UBaseType_t uxItemSize)</span>;    <span class="hljs-comment">// 每个队列项所占内存的大小.单位为字节</span><br></code></pre></td></tr></table></figure></li><li><p>发送 &#x2F; 接收消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueSend</span><span class="hljs-params">(QueueHandle_t xQueue,        <span class="hljs-comment">// 队列句柄</span></span><br><span class="hljs-params">                      <span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvItemToQueue,   <span class="hljs-comment">// 待发送消息的指针</span></span><br><span class="hljs-params">                      TickType_t xTickToWait)</span>;     <span class="hljs-comment">// 等待时间</span><br>BaseType_t <span class="hljs-title function_">xQueueReceive</span><span class="hljs-params">(QueueHandle_t xQueue,     <span class="hljs-comment">// 队列句柄</span></span><br><span class="hljs-params">                         <span class="hljs-type">void</span> *pvBuffer,           <span class="hljs-comment">// 接收消息缓冲区的指针</span></span><br><span class="hljs-params">                         TickType_t xTickToWait)</span>   <span class="hljs-comment">// 等待时间</span><br></code></pre></td></tr></table></figure></li><li><p>中断版本(<code>FromISR</code> 后缀)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueSendFromISR</span><span class="hljs-params">(QueueHandle_t xQueue,       <span class="hljs-comment">// 队列句柄</span></span><br><span class="hljs-params">                             <span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvItemToQueue,  <span class="hljs-comment">// 待发送消的指针</span></span><br><span class="hljs-params">                             BaseType_t *pxHigherPriorityTaskWoken)</span>;<br><span class="hljs-comment">// pxHigherPriorityTaskWoken: 如果被系统设为 pdTRUE,则中断退出前要执行上下文切换函数</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-3-队列使用"><a href="#3-3-队列使用" class="headerlink" title="3.3 队列使用"></a>3.3 队列使用</h3><ol><li><p><strong>示例: 任务间传递整数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">QueueHandle_t xQueue;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vSenderTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        xQueueSend(xQueue, &amp;value, portMAX_DELAY); <span class="hljs-comment">// 发送数据</span><br>        vTaskDelay(pdMS_TO_TICKS(<span class="hljs-number">1000</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vReceiverTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-type">int</span> receivedValue;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (xQueueReceive(xQueue, &amp;receivedValue, portMAX_DELAY) == pdPASS) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received: %d\n&quot;</span>, receivedValue);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    xQueue = xQueueCreate(<span class="hljs-number">5</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    xTaskCreate(vSenderTask, <span class="hljs-string">&quot;Sender&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>);<br>    xTaskCreate(vReceiverTask, <span class="hljs-string">&quot;Receiver&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>);<br>    vTaskStartScheduler();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>示例: 中断与任务通信</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">QueueHandle_t xInterruptQueue;<br><br><span class="hljs-comment">// 中断服务程序(ISR)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">USART1_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">char</span> data = USART1-&gt;DR;<br>    BaseType_t xHigherPriorityTaskWoken = pdFALSE;<br>    <br>    xQueueSendFromISR(xInterruptQueue, &amp;data, &amp;xHigherPriorityTaskWoken);<br>    portYIELD_FROM_ISR(xHigherPriorityTaskWoken); <span class="hljs-comment">// 必要时触发任务切换</span><br>&#125;<br><br><span class="hljs-comment">// 任务处理中断数据</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vISRHandlerTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-type">char</span> receivedData;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (xQueueReceive(xInterruptQueue, &amp;receivedData, portMAX_DELAY)) &#123;<br>            process_data(receivedData); <span class="hljs-comment">// 处理数据</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4 信号量"></a>4 信号量</h2><h3 id="4-1-信号量概念"><a href="#4-1-信号量概念" class="headerlink" title="4.1 信号量概念"></a>4.1 信号量概念</h3><ol><li><p><strong>信号量(Semaphore): 轻量级的任务间同步与互斥机制.主要用于 资源管理 或 事件通知</strong></p><ul><li>核心特点: 不传递具体数据,仅通过计数值协调任务</li><li>信号量可以是二值的(0 &#x2F; 1)或计数型(正整数)</li></ul></li><li><p><strong>信号量的类型</strong></p><table><thead><tr><th align="left">类型</th><th align="left">特点</th><th align="left">典型应用场景</th></tr></thead><tbody><tr><td align="left">二进制信号量</td><td align="left">计数值仅 0 或 1,相当于互斥锁</td><td align="left">共享资源保护(如外设访问)</td></tr><tr><td align="left">计数信号</td><td align="left">计数值可 &gt;1,表示可用资源数量</td><td align="left">资源池管理(如内存块, 连接池)</td></tr><tr><td align="left">互斥量(Mutex)</td><td align="left">具有优先级继承机制,解决优先级反转问题</td><td align="left">临界区保护(高优先级任务需访问)</td></tr></tbody></table></li><li><p>共享资源管理</p><ul><li>管理对共享资源的访问,确保同一时刻只有一个任务可以访问共享资源</li><li>适用于对资源的互斥访问,控制任务的执行顺序.或限制同时访问某一资源的任务数量</li></ul></li></ol><h3 id="4-2-信号量-API"><a href="#4-2-信号量-API" class="headerlink" title="4.2 信号量 API"></a>4.2 信号量 API</h3><ol><li><p>创建信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建二进制信号量(初始值=0)</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateBinary</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-comment">// 创建计数型信号量</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateCounting</span><span class="hljs-params">(</span><br><span class="hljs-params">                      UBaseType_t uxMaxCount,       <span class="hljs-comment">// 最大信号量数</span></span><br><span class="hljs-params">                      UBaseType_t uxInitialCount)</span>;  <span class="hljs-comment">// 初始信号数</span><br><br><span class="hljs-comment">// 创建互斥量</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateMutex</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure></li><li><p>获取信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取信号量,成功返回 pdTRUE</span><br>BaseType_t <span class="hljs-title function_">xSemaPhoreTake</span><span class="hljs-params">(</span><br><span class="hljs-params">    SemaphoreHandle_t xSemaphore,  <span class="hljs-comment">// 信号量句柄</span></span><br><span class="hljs-params">    TickType_t xTicksToWait)</span>;      <span class="hljs-comment">// 阻塞超时时间(portMAX_DELAY 表示永久等待)</span><br></code></pre></td></tr></table></figure></li><li><p>释放信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 释放信号量.  中断安全版本为: xSemaphoreGiveFromISR()</span><br>BaseType_t <span class="hljs-title function_">xSemaPhoreGive</span><span class="hljs-params">(SemaphoreHandle_t xSemaphore)</span>;<br></code></pre></td></tr></table></figure></li><li><p>删除信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vSemaphoreDelete</span><span class="hljs-params">(SemaphoreHandle_t xSemaphore)</span>;<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-3-信号量使用"><a href="#4-3-信号量使用" class="headerlink" title="4.3 信号量使用"></a>4.3 信号量使用</h3><ol><li><p><strong>示例: 二进制信号量实现任务同步</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">SemaphoreHandle_t xBinarySem;<br><br><span class="hljs-comment">// 任务A: 释放信号量(触发任务B)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskA</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        xSemaphoreGive(xBinarySem); <span class="hljs-comment">// 发送信号</span><br>        vTaskDelay(pdMS_TO_TICKS(<span class="hljs-number">1000</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 任务B: 等待信号量</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskB</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (xSemaphoreTake(xBinarySem, portMAX_DELAY) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Signal received!\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> main() &#123;<br>    xBinarySem = xSemaphoreCreateBinary();<br>    xTaskCreate(vTaskA, <span class="hljs-string">&quot;TaskA&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>);<br>    xTaskCreate(vTaskB, <span class="hljs-string">&quot;TaskB&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">NULL</span>);<br>    vTaskStartScheduler();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>示例: 互斥量保护共享资源</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">SemaphoreHandle_t xMutex;<br><span class="hljs-type">int</span> sharedData = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vWriteTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (xSemaphoreTake(xMutex, portMAX_DELAY)) &#123;<br>            sharedData++; <span class="hljs-comment">// 安全修改数据</span><br>            xSemaphoreGive(xMutex);<br>        &#125;<br>        vTaskDelay(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vReadTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (xSemaphoreTake(xMutex, portMAX_DELAY)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Data: %d\n&quot;</span>, sharedData);<br>            xSemaphoreGive(xMutex);<br>        &#125;<br>        vTaskDelay(<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-事件标志组"><a href="#5-事件标志组" class="headerlink" title="5 事件标志组"></a>5 事件标志组</h2><h3 id="5-2-事件标志组概念"><a href="#5-2-事件标志组概念" class="headerlink" title="5.2 事件标志组概念"></a>5.2 事件标志组概念</h3><ol><li><p>**事件标志组(Event Group): **任务间事件通知机制</p><ul><li>允许任务 等待多个事件位的组合,并支持 同步多个任务的执行</li><li>适用于需要 复杂事件触发逻辑 的场景</li></ul></li><li><p><strong>事件位(Event Bits)</strong>: 每个事件标志组包含一个 32 位变量(<code>EventBits_t</code>),每位(bit)代表一个独立的事件</p><ul><li><strong>逻辑或(OR)</strong>: 任意一个事件位被置位即可唤醒任务</li><li><strong>逻辑与(AND)</strong>: 所有指定事件位被置位才唤醒任务</li></ul><ul><li><strong>跨任务同步</strong>: 多个任务可以等待同一组事件,实现协同操作</li><li><strong>高效性</strong>: 比信号量, 队列更节省内存,适用于高频事件通知</li></ul></li></ol><h3 id="5-2-事件标志组-API"><a href="#5-2-事件标志组-API" class="headerlink" title="5.2 事件标志组 API"></a>5.2 事件标志组 API</h3><ol><li><p>创建事件标志组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">EventGroupHandle_t <span class="hljs-title function_">xEventGroupCreate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure></li><li><p>设置事件位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">EventBits_t <span class="hljs-title function_">xEventGroupSetBits</span><span class="hljs-params">(</span><br><span class="hljs-params">    EventGroupHandle_t xEventGroup, <span class="hljs-comment">// 事件组句柄</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> EventBits_t uxBitsToSet   <span class="hljs-comment">// 要置位的事件位(按位或组合)</span></span><br><span class="hljs-params">)</span>;<br><br><span class="hljs-comment">// 置位 bit0 和 bit2</span><br>xEventGroupSetBits(xEventGroup, (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>));<br><span class="hljs-comment">// 中断安全版本: xEventGroupSetBitsFromISR</span><br></code></pre></td></tr></table></figure></li><li><p>清除事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">EventBits_t <span class="hljs-title function_">xEventGroupClearBits</span><span class="hljs-params">(</span><br><span class="hljs-params">    EventGroupHandle_t xEventGroup,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> EventBits_t uxBitsToClear</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure></li><li><p>等待事件位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">EventBits_t <span class="hljs-title function_">xEventGroupWaitBits</span><span class="hljs-params">(<span class="hljs-comment">// 等待事件组中的某些标志位</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> EventGroupHandle_t xEventGroup,    <span class="hljs-comment">// 事件组句柄</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> EventBits_t uxBitsToWaitFor,       <span class="hljs-comment">// 需要等待哪些位</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> BaseType_t xClearOnExit,           <span class="hljs-comment">// pdTRUE: 退出时清除这些位</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> BaseType_t xWaitForAllBits,        <span class="hljs-comment">// pdTRUE: 需所有位满足.pdFALSE: 任意位满足</span></span><br><span class="hljs-params">    TickType_t xTicksToWait)</span>;                <span class="hljs-comment">// 超时时间</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="5-3-事件标志组使用"><a href="#5-3-事件标志组使用" class="headerlink" title="5.3 事件标志组使用"></a>5.3 事件标志组使用</h3><ol><li><p><strong>示例: 等待单一事件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">EventGroupHandle_t xEventGroup;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSensor</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 模拟传感器数据就绪(置位 bit0)</span><br>        xEventGroupSetBits(xEventGroup, (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>));<br>        vTaskDelay(pdMS_TO_TICKS(<span class="hljs-number">1000</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskProcessor</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待 bit0 置位(不自动清除)</span><br>        xEventGroupWaitBits(xEventGroup, (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>), pdFALSE, pdFALSE, portMAX_DELAY);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sensor data ready!\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>示例: <strong>多事件组合触发</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vControlTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待 bit0 AND bit1 同时置位,或 bit2 单独置位</span><br>        EventBits_t uxBits = xEventGroupWaitBits(<br>            xEventGroup,<br>            (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>), <span class="hljs-comment">// 监听 bit0/1/2</span><br>            pdTRUE,  <span class="hljs-comment">// 退出时清除所有监听位</span><br>            pdFALSE, <span class="hljs-comment">// 任意条件满足即可(改为 pdTRUE 则需全部满足)</span><br>            portMAX_DELAY<br>        );<br><br>        <span class="hljs-keyword">if</span> (uxBits &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Event 0 triggered!\n&quot;</span>);<br>        <span class="hljs-keyword">if</span> (uxBits &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Event 1 triggered!\n&quot;</span>);<br>        <span class="hljs-keyword">if</span> (uxBits &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Event 2 triggered!\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-任务通知"><a href="#6-任务通知" class="headerlink" title="6 任务通知"></a>6 任务通知</h2><h3 id="6-1-任务通知概念"><a href="#6-1-任务通知概念" class="headerlink" title="6.1 任务通知概念"></a>6.1 任务通知概念</h3><ol><li><p><strong>任务通知(Task Notification)</strong> 是一种 <strong>轻量级, 高性能的任务间通信机制</strong></p><ul><li>允许一个任务或中断直接向另一个任务发送事件或数据,而无需使用队列, 信号量等传统通信对象</li><li>任务通知是 FreeRTOS 中最快的通信方式,适用于对实时性要求极高的场景</li></ul></li><li><p>任务通知的优点</p><ul><li><strong>极速通信</strong>: 比队列, 信号量快 <strong>45% ~ 500%</strong>(无需全局对象管理)</li><li><strong>低内存占用</strong>: 每个任务自带通知字段,无需额外内存</li><li><strong>多功能集成</strong>: 可模拟<ul><li><strong>二进制信号量</strong>(通知值作为标志)</li><li><strong>计数信号量</strong>(通知值作为计数器)</li><li><strong>事件标志组</strong>(通知值的每一位作为事件)</li><li><strong>轻量队列</strong>(传递 32 位数据或指针)</li></ul></li></ul></li><li><p>任务通知的限制</p><ul><li><strong>单接收者</strong>: 每个通知只能发送给一个特定任务</li><li><strong>无缓冲</strong>: 仅保存最新通知(覆盖旧值,除非使用计数模式)</li></ul></li><li><p>通信机制</p><table><thead><tr><th align="left"><strong>机制</strong></th><th align="left"><strong>特点</strong></th><th align="left"><strong>适用场景</strong></th></tr></thead><tbody><tr><td align="left"><strong>事件标志组</strong></td><td align="left">支持多事件组合触发,轻量高效</td><td align="left">复杂事件条件, 多任务同步</td></tr><tr><td align="left"><strong>信号量</strong></td><td align="left">仅单事件通知,无位操作</td><td align="left">简单资源管理或同步</td></tr><tr><td align="left"><strong>队列</strong></td><td align="left">可传递数据,但无法组合事件</td><td align="left">需要数据传输的场景</td></tr><tr><td align="left"><strong>任务通知</strong></td><td align="left">极快,但只能传递单值</td><td align="left">高性能一对一通信</td></tr></tbody></table></li></ol><h3 id="6-2-任务通知-API"><a href="#6-2-任务通知-API" class="headerlink" title="6.2 任务通知 API"></a>6.2 任务通知 API</h3><ol><li><p>发送任务通知</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskNotify</span><span class="hljs-params">(</span><br><span class="hljs-params">    TaskHandle_t xTaskToNotify, <span class="hljs-comment">// 目标任务句柄</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span> ulValue,           <span class="hljs-comment">// 传递的数据(32位)</span></span><br><span class="hljs-params">    eNotifyAction eAction       <span class="hljs-comment">// 通知方式(见下表)</span></span><br><span class="hljs-params">)</span>;<br><br><span class="hljs-comment">// 中断安全版本</span><br>BaseType_t <span class="hljs-title function_">xTaskNotifyFromISR</span><span class="hljs-params">(</span><br><span class="hljs-params">    TaskHandle_t xTaskToNotify,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span> ulValue,</span><br><span class="hljs-params">    eNotifyAction eAction,</span><br><span class="hljs-params">    BaseType_t *pxHigherPriorityTaskWoken</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left"><strong>动作</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left"><code>eNoAction</code></td><td align="left">仅触发任务,不更新通知值(类似二进制信号量)</td></tr><tr><td align="left"><code>eSetBits</code></td><td align="left">按位或(OR)操作通知值(类似事件标志组)</td></tr><tr><td align="left"><code>eIncrement</code></td><td align="left">通知值 +1(类似计数信号量)</td></tr><tr><td align="left"><code>eSetValueWithOverwrite</code></td><td align="left">直接覆盖通知值(默认行为)</td></tr><tr><td align="left"><code>eSetValueWithoutOverwrite</code></td><td align="left">仅当通知值未被读取时更新(避免覆盖)</td></tr></tbody></table></li><li><p>接受任务通知</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskNotifyWait</span><span class="hljs-params">(<span class="hljs-comment">// 等待接收任务通知</span></span><br><span class="hljs-params"><span class="hljs-type">uint32_t</span> ulBitsToClearOnEntry,  <span class="hljs-comment">// 进入函数清除的通知值位</span></span><br><span class="hljs-params"><span class="hljs-type">uint32_t</span> ulBitsToClearOnExit,   <span class="hljs-comment">// 退出函数清除的通知值位</span></span><br><span class="hljs-params"><span class="hljs-type">uint32_t</span> *pulNotificationValue, <span class="hljs-comment">// 存储接收到的值</span></span><br><span class="hljs-params">TickType_t xTicksToWait)</span>;       <span class="hljs-comment">// 等待时长</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="6-3-任务通知使用"><a href="#6-3-任务通知使用" class="headerlink" title="6.3 任务通知使用"></a>6.3 任务通知使用</h3><ol><li><p><strong>示例: 模拟二进制信号量(任务同步)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vSenderTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 发送通知(不传递数据,仅触发任务)</span><br>        xTaskNotify(xReceiverTask, <span class="hljs-number">0</span>, eNoAction);<br>        vTaskDelay(pdMS_TO_TICKS(<span class="hljs-number">1000</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vReceiverTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待通知(类似 xSemaphoreTake)</span><br>        xTaskNotifyWait(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, portMAX_DELAY);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Notification received!\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>示例: 传递 32 位数据</strong>**</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vDataProducerTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-type">uint32_t</span> data = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 发送数据并覆盖旧值</span><br>        xTaskNotify(xConsumerTask, data, eSetValueWithOverwrite);<br>        vTaskDelay(pdMS_TO_TICKS(<span class="hljs-number">500</span>));<br>        data++;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vDataConsumerTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-type">uint32_t</span> receivedData;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待并读取数据</span><br>        xTaskNotifyWait(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;receivedData, portMAX_DELAY);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Data: %lu\n&quot;</span>, receivedData);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>示例: <strong>模拟事件标志组(多事件触发)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_EVENT_DATA_READY  (1 &lt;&lt; 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_EVENT_ERROR       (1 &lt;&lt; 1)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vInterruptHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// 在中断中设置事件位(bit0)</span><br>    xTaskNotifyFromISR(xHandlerTask, TASK_EVENT_DATA_READY, eSetBits, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vEventHandlerTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-type">uint32_t</span> ulNotifiedValue;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待任意事件位触发</span><br>        xTaskNotifyWait(<span class="hljs-number">0</span>, <span class="hljs-number">0xFF</span>, &amp;ulNotifiedValue, portMAX_DELAY);<br>        <br>        <span class="hljs-keyword">if</span> (ulNotifiedValue &amp; TASK_EVENT_DATA_READY) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Data ready event!\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ulNotifiedValue &amp; TASK_EVENT_ERROR) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error event!\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>FreeRTOS</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32</title>
    <link href="/2024/04/01/Embedded/STM32/"/>
    <url>/2024/04/01/Embedded/STM32/</url>
    
    <content type="html"><![CDATA[<h1 id="STM32"><a href="#STM32" class="headerlink" title="STM32"></a>STM32</h1><h2 id="0-开发板介绍"><a href="#0-开发板介绍" class="headerlink" title="0 开发板介绍"></a>0 开发板介绍</h2><h3 id="0-1-STM32-开发板"><a href="#0-1-STM32-开发板" class="headerlink" title="0.1 STM32 开发板"></a>0.1 STM32 开发板</h3><p><img src="/2024/04/01/Embedded/STM32/0-STM32F103C8T6-Board-Features.jpg"></p><ol><li>使用右侧 SWD 接口下载程序及供电</li><li>32.768KHz 晶振: 连接到 LSE(low-speed external clock signal),给 RTC 提供时钟.<br>如果无需使用掉电不丢失时间的功能,可去掉.由内部 40KHz 的 RC 时钟源给 RTC 提供时钟</li><li>8MHz 晶振: 连接到 HSE(high-speed external clock signal),给 SYSCLK 提供时钟.<br>由于芯片内部的 HSI RC 时钟源不够精准,<strong>通常采用外部独立时钟源来为芯片提供系统时钟</strong></li></ol><h3 id="0-2-开发板引脚图"><a href="#0-2-开发板引脚图" class="headerlink" title="0.2 开发板引脚图"></a>0.2 开发板引脚图</h3><p><img src="/2024/04/01/Embedded/STM32/0-STM32F103C8T6-Blue-Pill-Pin-Layout.gif"></p><h3 id="0-3-最小系统电路"><a href="#0-3-最小系统电路" class="headerlink" title="0.3 最小系统电路"></a>0.3 最小系统电路</h3><p><img src="/2024/04/01/Embedded/STM32/0-minimal-system-circuit.png"></p><ol><li>3V3 与 GND 间的 100nF 滤波电容: 保证供电电压的稳定</li><li><strong>晶振</strong>: 8MHz 晶振的典型电路.20pF 作为起振电容.接到芯片的5,6号脚.3,4号引脚预留接 32.768KHz 晶振</li><li><strong>复位</strong>: NRST 接到7号引脚,低电平复位<ul><li>刚上电时,电容充电,相当于短路,NRST 下拉至 GND(上电复位).充满电后短路,上拉至 3V3</li><li>之后,K1 断开时,NRST 拉至 3V3.K1 闭合时,电容放电,NRST 接地(手动复位)</li></ul></li><li><strong>启动配置</strong>: H1 起到开关的作用.实际中采用跳线帽的方式选择模式</li><li><strong>下载端口</strong>: SWDIO, SWCLK 分别接到芯片的34,37号引脚(PA13,14).正负极间同样可以加滤波电容</li></ol><h2 id="1-STM32"><a href="#1-STM32" class="headerlink" title="1 STM32"></a>1 STM32</h2><h3 id="1-1-STM32-命名规则"><a href="#1-1-STM32-命名规则" class="headerlink" title="1.1 STM32 命名规则"></a>1.1 STM32 命名规则</h3><p><img src="/2024/04/01/Embedded/STM32/1-STM32-naming.png"></p><h3 id="1-2-存储器和总线构架"><a href="#1-2-存储器和总线构架" class="headerlink" title="1.2 存储器和总线构架"></a>1.2 存储器和总线构架</h3><p><img src="/2024/04/01/Embedded/STM32/1-system-architecture.png"></p><h3 id="1-3-F103C8T6-引脚定义"><a href="#1-3-F103C8T6-引脚定义" class="headerlink" title="1.3 F103C8T6 引脚定义"></a>1.3 F103C8T6 引脚定义</h3><p><img src="/2024/04/01/Embedded/STM32/1-STM32F103C8T6-pin-define.png"></p><h3 id="1-4-片上资源-外设"><a href="#1-4-片上资源-外设" class="headerlink" title="1.4 片上资源(外设)"></a>1.4 片上资源(外设)</h3><table><thead><tr><th>英文缩写</th><th>名称</th><th>英文缩写</th><th>名称</th></tr></thead><tbody><tr><td>NVIC</td><td>嵌套向量中断控制器</td><td>CAN</td><td>CAN 通信</td></tr><tr><td>SysTick</td><td>系统滴答定时器</td><td>USB</td><td>USB 通信</td></tr><tr><td>RCC</td><td>复位和时钟控制</td><td>RTC</td><td>实时时钟</td></tr><tr><td>GPIO</td><td>通用 IO 口</td><td>CRC</td><td>CRC 校验</td></tr><tr><td>AFIO</td><td>复用 IO 口</td><td>PWR</td><td>电源控制</td></tr><tr><td>EXTI</td><td>外部中断</td><td>BKP</td><td>备份寄存器</td></tr><tr><td>TIM</td><td>定时器</td><td>IWDG</td><td>独立看门狗</td></tr><tr><td>ADC</td><td>模数转换器</td><td>WWDG</td><td>窗口看门狗</td></tr><tr><td>DMA</td><td>直接内存访问</td><td>DAC</td><td>数模转换器</td></tr><tr><td>USART</td><td>同步 &#x2F; 异步串口通信</td><td>SDIO</td><td>SD 卡接口</td></tr><tr><td>I2C</td><td>I2C 通信</td><td>FSMC</td><td>可变静态存储控制器</td></tr><tr><td>SPI</td><td>SPI 通信</td><td>USB OTG</td><td>USB 主机接口</td></tr></tbody></table><h2 id="2-工程建立"><a href="#2-工程建立" class="headerlink" title="2 工程建立"></a>2 工程建立</h2><h3 id="2-1-开发环境"><a href="#2-1-开发环境" class="headerlink" title="2.1 开发环境"></a>2.1 开发环境</h3><ol><li><p><strong>Keil5 MDK: IDE, 集成开发环境</strong></p><ul><li><p>运行 <code>MDK542a.exe</code> 文件,更改安装路径后,一路点击 <code>next</code> 即可</p></li><li><p>软件注册: 以管理员身份运行 Keil5 -&gt; <code>File</code> -&gt; <code>License Management</code> -&gt; 复制 CID</p><p><img src="/2024/04/01/Embedded/STM32/2-register-Keil.png"></p></li><li><p>运行 <code>keygen_new2032.exe</code> 文件 -&gt; 粘贴 <code>CID</code> -&gt; <code>Target</code> 选 <code>ARM</code> -&gt; 点击 <code>Generate</code> 生成序列码</p></li><li><p>将序列码粘贴到 keil5 中的 <code>New License ID Code</code> 栏 -&gt; <code>ADD LIC</code></p></li></ul></li><li><p><strong>器件支持包: 对相应的 MCU 型号提供支持</strong></p><ul><li><p>离线安装: 下载后,运行相应的器件支持包文件即可(<code>Keil.STM32F1xx_DFP.2.2.0.pack</code>)</p></li><li><p>在线安装: 打开 Keil -&gt; <code>Pack Installer</code> -&gt; <code>Device</code> -&gt; <code>STMicroelectronics</code> -&gt; install 后缀 <code>DFP</code> 的文件</p></li></ul></li><li><p><strong>STLink 驱动</strong>: Keil5 安装目录中自带(<code>Keil5\ARM\STLink\USBDriver\dpinst_amd64.exe</code>)</p></li><li><p><strong>JLink 驱动</strong>: 同样位于 Keil5 安装目录中(<code>Keil5\ARM\Segger\JLink.exe</code>)</p></li><li><p><strong>USB 转串口驱动</strong>: 运行 <code>CH341SER.EXE</code></p></li><li><p>STM32 开发方式</p><ul><li>基于寄存器: STM32 结构复杂,寄存器数量太多,不推荐</li><li>基于库函数: 使用 ST 官方提供的函数,间接配置寄存器(官方停止维护)</li><li>基于 HAL 库: 图形化界面配置 STM32(官方主推)</li></ul></li><li><p>基于库函数需要 STM32 库函数的文件(固件库)</p></li></ol><h3 id="2-2-寄存器开发"><a href="#2-2-寄存器开发" class="headerlink" title="2.2 寄存器开发"></a>2.2 寄存器开发</h3><ol><li><p>在 Keil5 中 -&gt; <code>Project</code> -&gt; <code>New uVision Project</code> -&gt; 设置工程文件名(project) -&gt; 选择芯片型号</p><ul><li><p>此时工程目录下将会有一个 <code>project.uvprojx</code> 文件.该文件为 keil 工程文件</p></li><li><p>配合使用 git 管理代码版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init<br></code></pre></td></tr></table></figure></li><li><p>创建 <code>.gitignore</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">.vscode/<br>DebugConfig/<br>Listings/<br>Objects/<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>添加固件库文件: 在工程目录中创建 Start 目录存放下列启动文件(STM32程序从启动文件开始执行)</strong></p><p><img src="/2024/04/01/Embedded/STM32/2-Start-directory.png"></p></li><li><p><strong>将文件添加到工程</strong></p><ul><li><p>将左侧的 <code>Source Group 1</code> 改名为 <code>Start</code> -&gt; 右击后选择 <code>Add Existing Files to Group</code> 添加文件</p><p><img src="/2024/04/01/Embedded/STM32/2-add-start-file.png"></p></li><li><p>启动文件需要根据型号选择(这里选择仅 <code>startup_stm32f10x_md.s</code>)</p></li></ul></li><li><p><strong>添加文件夹的头文件路径</strong>: <code>Options</code> -&gt; <code>C/C++</code> -&gt; 在 <code>Include Paths</code> 栏添加路径</p></li><li><p><strong>编写测试函数</strong>: 首先创建 User 目录用于存放用户代码</p><ul><li><p>创建 <code>main.c</code> 文件并添加到工程</p><ul><li><p>右键 <code>Target</code> -&gt; <code>Add Group</code> 并将名称改为 <code>User</code> -&gt; 右键 <code>Add New item...</code></p></li><li><p>选择 <code>C File</code> -&gt; 名称设为 <code>main</code> -&gt; 修改文件存放路径为 <code>User</code> 目录</p></li></ul></li><li><p>测试配置: 打开 <code>main</code> 文件在空白处右击,选择 insert <code>#include file stm32f10x.h</code> -&gt; 编写任意代码 -&gt; <code>Build</code></p></li><li><p>若编译没有错误说明工程建立正常.到此可以进行<strong>基于寄存器的开发</strong>.如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;  <span class="hljs-comment">/* 点亮 PC13 的 LED */</span><br>RCC-&gt;APB2ENR |= <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<span class="hljs-comment">/* 开启 APB2 的 GPIOC 时钟 */</span><br>GPIOC-&gt;CRH |= <span class="hljs-number">3</span> &lt;&lt; (<span class="hljs-number">4</span> * (<span class="hljs-number">13</span> - <span class="hljs-number">8</span>));<span class="hljs-comment">/* 指定 GPIO_Pin_13 为推挽输出.50MHz */</span><br>GPIOC-&gt;ODR &amp;= !(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">13</span>);<span class="hljs-comment">/* 指定 GPIO_Pin_13 引脚的电压为低 */</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>连接最小系统板时需要选择对应的调试方式(这里使用 STLink)</p><ul><li><code>Options</code> -&gt; <code>Debug</code> -&gt; Use 栏选择 <code>ST-Link Debugger</code> -&gt; <code>Settings</code> -&gt; <code>Flash Download</code> -&gt; 勾选 <code>Reset and Run</code></li></ul></li></ol><h3 id="2-3-标准库开发"><a href="#2-3-标准库开发" class="headerlink" title="2.3 标准库开发"></a>2.3 标准库开发</h3><ol><li><p>在工程新建 <code>Library</code> 目录,添加 <code>Libraries\STM32F10x_StdPeriph_Driver\src, inc</code> 目录下的所有文件(各23个)</p></li><li><p>将 <code>Project\STM32F10x_StdPeriph_Template</code> 目录下的三个文件添加到工程的 <code>User</code> 目录</p><p><img src="/2024/04/01/Embedded/STM32/2-User-directory.png"></p></li><li><p>添加全局宏定义</p><ul><li><p>打开 <code>&quot;stm32f10x.h&quot;</code> 文件,在文件末尾有条件编译语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_STDPERIPH_DRIVER</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x_conf.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>因此需要宏定义 <code>USE_STDPERIPH_DRIVER</code>: <code>Options</code> -&gt; 在 <code>C/C++ Define</code> 栏填 <code>USE_STDPERIPH_DRIVER</code></p></li></ul></li><li><p>需要再次完成 <strong>将文件添加到工程,添加文件夹的头文件路径</strong> 步骤</p></li><li><p>至此可以进行<strong>基于库函数的开发</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-comment">/* 配置 GPIOC.并设置为: 推挽输出,引脚选中13, 速率50MHz */</span><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);<br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOC, &amp;GPIO_InitStructure);<br>GPIO_ResetBits(GPIOC, GPIO_Pin_13);  <span class="hljs-comment">// 将 PC13 置为低电平</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>库函数调用逻辑: 复位中断函数才是程序的入口(在复位后执行).其职责为调用 <code>SystemInit, main</code> 函数</p><p><img src="/2024/04/01/Embedded/STM32/2-Engineering-architecture.png"></p></li></ol><h3 id="2-4-Keil5-使用"><a href="#2-4-Keil5-使用" class="headerlink" title="2.4 Keil5 使用"></a>2.4 Keil5 使用</h3><ol><li><strong>界面设置(Configuration)</strong><ul><li><code>Configuration</code> -&gt; <code>Color &amp; Fonts</code> -&gt; <code>C/C++ Editor files</code> -&gt; 设置字体及其大小</li><li><code>Configuration</code> -&gt; <code>Editor</code> -&gt; <code>Encoding</code> 改为 <code>UTF-8</code> 编码, <code>Tab Size</code> 改为4</li><li><code>Manage Project Items</code> -&gt; 可以调整左侧文件显示的顺序</li></ul></li><li>Keil 中直接写入汉字报错的解决方式<ul><li><code>Options</code> -&gt; <code>C/C++</code> -&gt; <code>Misc Controls</code> 栏填入 <code>--no-multibyte-chars</code></li></ul></li></ol><h3 id="2-5-串口下载"><a href="#2-5-串口下载" class="headerlink" title="2.5 串口下载"></a>2.5 串口下载</h3><ol><li><p>启动模式</p><table><thead><tr><th>BOOT1</th><th>BOOT 0</th><th>启动模式</th><th>说明</th></tr></thead><tbody><tr><td>X</td><td>0</td><td>主闪存存储器</td><td><strong>主闪存存储器被选为启动区域(主要使用方式)</strong></td></tr><tr><td>0</td><td>1</td><td>系统存储器</td><td>系统存储器被选为启动区域.运行 BootLoader(串口下载)</td></tr><tr><td>1</td><td>1</td><td>内置 SRAM</td><td>内置 SRAM 被选为启动区域(程序调试)</td></tr></tbody></table></li><li><p>FlyMcu 串口下载程序</p><ul><li><p>需要连接 USB转串口模块的 RX(PA9), TX(PA10), GND</p></li><li><p>需要工程生成的 HEX 文件(在 Keil 中 <code>Options for target</code> -&gt; <code>output</code> 勾选 <code>Creact HEX File</code>)</p><p><img src="/2024/04/01/Embedded/STM32/2-CreateHEX.png"></p></li><li><p><code>搜索串口</code> -&gt; bps 默认115200 -&gt; 选择下载的程序文件(.hex)</p></li><li><p>单片机引脚配置: 让STM32执行 <code>BootLoader</code> 程序</p><ul><li>将 Boot0 配置为1(插在右边), Boot1 配置为0(插在左边)</li><li>按下复位键,此时 STM32 将不断接收 USART1 的数据.刷新到主闪存</li></ul></li><li><p>点击<code>开始编程</code>.写入完成后,将 Boot0 配置为0(插在左边).按下复位键.程序开始执行</p><p><img src="/2024/04/01/Embedded/STM32/2-FlyMcu.png"></p></li></ul></li><li><p><strong>STM32 一键下载</strong>(需要搭建另外的电路)</p><ul><li>但是仍可以勾选<code>编程后执行</code>,反勾选<code>编程到FLASH时写选项字节</code></li><li>然后 boot0 选为1 -&gt; 按下复位键 -&gt; 下载程序.完成下载后程序会直接运行</li><li>原理为指定运行程序从 0800 0000 开始运行.复位其本质后仍执行 <code>BootLoader</code> 程序</li></ul></li><li><p>ST-LINK Utility(需连接 ST Link 下载)</p><p><img src="/2024/04/01/Embedded/STM32/2-ST-LINK-Utility.png"></p><ul><li><strong><code>Target</code> -&gt; <code>Option Bytes</code>(快捷键 Ctrl + B): 打开选项字节的设置页面</strong></li></ul></li></ol><h3 id="2-6-HAL-库开发"><a href="#2-6-HAL-库开发" class="headerlink" title="2.6 HAL 库开发"></a>2.6 HAL 库开发</h3><ol><li><p>CubeMX <a href="https://www.st.com/en/development-tools/stm32cubemx.html">官网下载</a></p><ul><li><p>运行 <code>SetupSTM32CubeMX-6.12.1-Win.exe</code> 安装 CubeMX(<strong>注意第一次需要使用管理员权限打开</strong>)</p></li><li><p>安装支持包(在线安装): Help -&gt; Manage embedded software packages.选择对应版本下载</p><p><img src="/2024/04/01/Embedded/STM32/2-Cube-pack-manager.png"></p></li><li><p>创建项目: Access to MCU selector -&gt; 选择相应 MCU</p><p><img src="/2024/04/01/Embedded/STM32/2-Cube-pin.png"></p></li><li><p><strong>引脚和配置</strong></p><ul><li><strong>RCC 选择 Crystal&#x2F;Ceramic Resonator</strong></li><li><strong>SYS 中 Debug 选择 Serial Wire</strong></li><li><strong>PC13 选择 GPIO_Output</strong></li></ul></li><li><p><strong>时钟配置: HCLK 设为72MHz</strong></p><p><img src="/2024/04/01/Embedded/STM32/2-Cube-clock.png"></p></li><li><p>项目配置</p><ul><li><p>需要指定项目名称, IDE 选择 <code>MDK-ARM</code></p></li><li><p>在 <code>Code Generator</code> 中勾选 <code>Generate peripheral initialization as a pair of &quot;.c/.h&quot; files per peripheral</code></p><p><img src="/2024/04/01/Embedded/STM32/2-Cube-project-config.png"></p></li></ul></li></ul></li></ol><h3 id="2-7-VSCode-编码"><a href="#2-7-VSCode-编码" class="headerlink" title="2.7 VSCode 编码"></a>2.7 VSCode 编码</h3><ol><li><p>VSCode <a href="https://code.visualstudio.com/">官网下载</a></p><ul><li><p>安装插件: <code>C/C++, Keil Assistant</code></p><p><img src="/2024/04/01/Embedded/STM32/2-VSCode-plug.png"></p></li><li><p>关联 Keil: 设置中搜索 keil, 在 <code>Keil Assistant.MDK: Uv4 Path</code> 栏指定 UV4 路径</p><p><img src="/2024/04/01/Embedded/STM32/2-Keil4-path.png"></p></li><li><p>在资源管理器中将会新增 keil 栏.可以进行编译下载(其本质仍是调用 Keil 的配置)</p><p><img src="/2024/04/01/Embedded/STM32/2-Keil.png"></p></li></ul></li></ol><h2 id="3-GPIO-输入输出"><a href="#3-GPIO-输入输出" class="headerlink" title="3 GPIO 输入输出"></a>3 GPIO 输入输出</h2><h3 id="3-1-GPIO-结构"><a href="#3-1-GPIO-结构" class="headerlink" title="3.1 GPIO 结构"></a>3.1 GPIO 结构</h3><ol><li><p>GPIO 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/3-GPIO-struct.png"></p><ul><li>I&#x2F;O 引脚连接驱动器寄存器到 APB2</li><li>内核写入(读取)输出寄存器(输入寄存器),以此控制(读取) I&#x2F;O 引脚的高低电平</li></ul></li><li><p>IO 口的基本结构</p><p><img src="/2024/04/01/Embedded/STM32/3-IOpin-struct.png"></p></li><li><p>输入电路分析</p><ul><li><code>保护二极管</code>对输入电压进行限幅: 确保输入电压范围在 $V_{SS} \sim V_{DD}$</li><li><code>上拉电阻和下拉电阻</code>: 避免引脚悬空导致的输入数据不确定, 设定一个默认值<ul><li>上方闭合,下方断开: <strong>上拉输入模式,即默认高电平</strong></li><li>上方断开,下方闭合: <strong>下拉输入模式,即默认低电平</strong></li><li>开关均断开: <strong>浮空输入模式</strong></li></ul></li><li><code>施密特触发器</code>(图中翻译错误): 对输入电压整形,然后写入<code>输入数据寄存器</code><ul><li>输入电压大于某个上限,输出瞬间升为高电平;</li><li>输入电压小于某个下限,输出瞬间将为低电平;否则不变</li></ul></li><li>模拟输入, 复用功能输入<ul><li><strong>模拟输入</strong>需要连续量,因此在施密特触发器之前.连接到 ADC.此时 GPIO 失效</li><li><strong>复用功能输入</strong>(如串口的输入引脚)需要数字量,因此在施密特触发器之后</li></ul></li></ul></li><li><p>输出电路分析: 输出可由 <code>输出数据寄存器</code>(普通IO输出) 或 <code>片上外设</code>(<strong>复用功能输出</strong>) 控制</p><ul><li><code>位设置/清除寄存器</code>: 单独操作输出数据寄存器的某一位, 而不影响其他位<br>将需要置1的对应写1,其余写0,即可自动将相应位置置1,其他位不变</li><li><code>输出数据寄存器</code>: 输出整个寄存器的数据.只能整体写入,不能单独操作某一位</li><li><code>数据输出选择器</code>: 选择由输出数据寄存器或是复用功能输出</li><li><code>P-MOS, N-MOS</code>的作用: 输出控制<ul><li>当 P-MOS,N-MOS 均有效时为<strong>推挽输出</strong>, 高低电平均有驱动能力</li><li>当 P-MOS 无效, N-MOS 有效时为<strong>开漏输出</strong>,仅低电平具有驱动能力<ul><li>当数据寄存器为1时,N-MOS 断开,呈现出高阻态</li><li>当数据寄存器为0时,N-MOS 导通,输出低电平</li><li>开漏输出模式可以用于通信协议的驱动,如 I2C</li><li>开漏输出模式输出 5V 信号: 在 I&#x2F;O 口外接一个上拉电阻到 5V 电源正极</li></ul></li><li>当 P-MOS N-MOS 均无效时,输出关闭,端口电平由外部控制</li></ul></li></ul></li></ol><h3 id="3-2-标准库代码分析"><a href="#3-2-标准库代码分析" class="headerlink" title="3.2 标准库代码分析"></a>3.2 标准库代码分析</h3><ol><li><p>对 <code>stm32f10x_gpio.h, stm32f10x_gpio.c</code> 源码的分析</p></li><li><p><strong>头文件中的通用格式</strong>: 防止重复包含以及保证对 C++ 的兼容性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __STM32F10x_GPIO_H  <span class="hljs-comment">/* 防止头文件重复包含 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __STM32F10x_GPIO_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus  <span class="hljs-comment">/* 对 C++ 的兼容 */</span></span><br> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* 对 C++ 的兼容 */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __STM32F10x_GPIO_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>参数合理性判断</strong>: 对于后续编写的函数,需要判断传入参数是否为 GPIO.在调用函数前断言</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOB) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOC) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOD) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOE) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOF) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOG))</span><br><br><span class="hljs-comment">/* 分析: 断言参数 expr.若非零,则通过.否则断言失败,直接在编译时报错,并指出错误位置 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))</span><br></code></pre></td></tr></table></figure></li><li><p><strong>枚举定义</strong>: 初始化时,需要根据手册中的位组合确定模式时,提前对其定义.枚举非常多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 分析: 对于输出最大速率寄存器的组合,在这里直接定义为对应的值,方便使用 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>  GPIO_Speed_10MHz = <span class="hljs-number">1</span>,<span class="hljs-comment">/* MODE = 01 */</span><br>  GPIO_Speed_2MHz,<span class="hljs-comment">/* MODE = 10 */</span><br>  GPIO_Speed_50MHz<span class="hljs-comment">/* MODE = 11 */</span><br>&#125; GPIOSpeed_TypeDef;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-3-HAL-库"><a href="#3-3-HAL-库" class="headerlink" title="3.3 HAL 库"></a>3.3 HAL 库</h3><ol><li><p>使用 HAL 库使 led 闪烁</p><p><img src="/2024/04/01/Embedded/STM32/3-GPIO-HAL.png"></p></li></ol><h2 id="4-EXTI-外部中断"><a href="#4-EXTI-外部中断" class="headerlink" title="4 EXTI 外部中断"></a>4 EXTI 外部中断</h2><h3 id="4-1-中断"><a href="#4-1-中断" class="headerlink" title="4.1 中断"></a>4.1 中断</h3><ol><li><p>中断系统</p><ul><li>中断允许微控制器在执行主程序的同时,对发生的特定事件做出及时响应</li><li>在 STM32 中,中断用于处理外部事件,如按键输入,定时器溢出,串口数据接收等</li><li><strong>中断处理程序: 一段特殊的代码,用于处理中断事件</strong></li><li>当中断发生时,自动跳转到对应中断向量表项中存储的中断处理程序地址,并执行其中的代码</li></ul></li><li><p>中断向量表</p><ul><li><strong>中断处理程序的入口地址存储在中断向量表中</strong></li><li>中断向量表是一个存储中断处理程序地址的数组,每个中断都有一个对应的向量表项</li></ul></li><li><p><strong>中断优先级: 每个中断都有一个优先级,用于确定中断的相对重要性</strong></p><ul><li>较高优先级的中断将优先处理,而较低优先级的中断可能会被延迟处理</li><li><strong>中断嵌套: 即在一个中断处理程序中,可以允许更高优先级的中断打断当前正在执行的中断处理程序.以确保对于紧急事件的及时响应</strong></li></ul></li></ol><h3 id="4-2-NVIC"><a href="#4-2-NVIC" class="headerlink" title="4.2 NVIC"></a>4.2 NVIC</h3><ol><li><p><strong>NVIC(Nested Vectored Interrupt Controller, 嵌套向量中断控制器)是内核外设</strong></p><p><img src="/2024/04/01/Embedded/STM32/4-NVIC.png"></p><ul><li>中断通道可以将 EXTI, TIM, ADC, USART… 作为输入</li><li>只有一条输出通道,根据中断优先级分配先后顺序</li></ul></li><li><p>优先级分组: 由优先级寄存器的4位决定</p><ul><li>优先级寄存器分为高 n 位的抢占优先级和低 (4-n) 位的响应优先级</li><li><strong>抢占优先级可以中断嵌套,响应优先级则需要进行排队</strong></li></ul></li><li><p>优先级规则</p><ul><li>优先级数字越小,优先级越高.如果不设置优先级,默认为0</li><li>若抢占优先级和响应优先级都一样,则查找中断向量表,值小的先响应</li></ul></li></ol><h3 id="4-3-EXTI"><a href="#4-3-EXTI" class="headerlink" title="4.3 EXTI"></a>4.3 EXTI</h3><ol><li><p><strong>EXTI(Extern Interrupt, 外部中断)</strong></p><p><img src="/2024/04/01/Embedded/STM32/4-EXTI.png"></p><ul><li>EXTI 可以监测指定 GPIO 口的电平信号,当其指定的 GPIO 口产生电平变化时,EXTI 将立即向 NVIC 发出中断申请,经过 NVIC 裁决后即可中断 CPU 主程序,使 CPU 执行 EXTI 对应的中断程序</li><li>支持所有的 GPIO 口.但同 Pin 不能同时触发</li><li><strong>触发方式: 上升 &#x2F; 下降 &#x2F; 双边沿, 软件触发</strong></li><li>通道数: 16个 GPIO_Pin, PVD 输出, RTC 闹钟, USB 唤醒, 以太网唤醒</li></ul></li><li><p>响应方式</p><ul><li><strong>中断响应: 正常中断流程,申请中断</strong></li><li><strong>事件响应: 不申请中断,通向其他外设,触发其他外设的操作</strong></li></ul></li><li><p>判断代码是否成功进入中断的方法</p><ul><li>进入调试模式,在中断函数设置一个断点</li><li>选择全速运行代码,手动触发一个中断条件,使代码进入中断</li><li>如果代码运行到设置的断点处,说明进入了中断</li></ul></li></ol><h3 id="4-4-AFIO"><a href="#4-4-AFIO" class="headerlink" title="4.4 AFIO"></a>4.4 AFIO</h3><ol><li><p><strong>AFIO 功能: 引脚复用功能重映射, 中断引脚选择</strong></p></li><li><p>中断引脚选择: PA0~PG0 只能有一个通过 AFIO 的选择到达 EXTI</p><p><img src="/2024/04/01/Embedded/STM32/4-AFIO.png"></p></li><li><p>AFIO 引脚重映射(以 TIM2 的 CH1 为例)</p><ul><li><p>TIM2 的 CH1 原本位于 PA0.可以将其重映射到 PA15</p><p><img src="/2024/04/01/Embedded/STM32/4-AFIO-redefine.png"></p></li><li><p>因此,可以使用部分重映射1或完全重映射实现使用 PA15 作为 TIM2 的 CH1</p></li><li><p>需要注意的是,PA15 原本的功能是作为 JTAG 的调试功能,因此还需要将其关闭,作为普通 GPIO 引脚</p><p><img src="/2024/04/01/Embedded/STM32/4-JTAG-disable.png"></p></li></ul></li></ol><h3 id="4-5-HAL-库操作"><a href="#4-5-HAL-库操作" class="headerlink" title="4.5 HAL 库操作"></a>4.5 HAL 库操作</h3><ol><li><p>直接在引脚上选择 GPIO_EXTI</p><p><img src="/2024/04/01/Embedded/STM32/4-HAL-EXTI-pin.png"></p></li><li><p>在 GPIO 中选择其配置</p><p><img src="/2024/04/01/Embedded/STM32/4-HAL-EXTI-pin-config.png"></p></li><li><p>enable EXTI 中断线</p><p><img src="/2024/04/01/Embedded/STM32/4-NVIC-enable.png"></p></li><li><p>在 NVIC 中配置优先级(注意 hal_delay 的实现依赖于 SysTick 中断,因此若在中断使用 delay 需要 SysTick 优先级高于当前中断)</p><p><img src="/2024/04/01/Embedded/STM32/4-NVIC-priority.png"></p></li><li><p>生成的代码主要关注 <code>stm32f1xx_it.c</code> 文件,会增加一个中断处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* This function handles EXTI line1 interrupt. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">EXTI1_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  HAL_GPIO_EXTI_IRQHandler(key1_Pin);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>其底层会调用到一个弱实现的回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span> &#123;<br>  <span class="hljs-comment">/* EXTI line interrupt detected */</span><br>  <span class="hljs-keyword">if</span> (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != <span class="hljs-number">0x00u</span>) &#123;<br>    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);<br>    HAL_GPIO_EXTI_Callback(GPIO_Pin);<br>  &#125;<br>&#125;<br><br>__weak <span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_Callback</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span> &#123;<br>  UNUSED(GPIO_Pin);  <span class="hljs-comment">/* Prevent unused argument(s) compilation warning */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>因此可以通过重新实现回调函数来执行逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_Callback</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span> &#123;<br>  <span class="hljs-keyword">if</span> (GPIO_Pin == key1_Pin)<br>      <span class="hljs-comment">// 具体逻辑...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="5-TIM-定时器"><a href="#5-TIM-定时器" class="headerlink" title="5 TIM 定时器"></a>5 TIM 定时器</h2><h3 id="5-1-定时器"><a href="#5-1-定时器" class="headerlink" title="5.1 定时器"></a>5.1 定时器</h3><ol><li><p><strong>定时器: 对输入时钟计数,在计数值达到设定值时触发中断</strong></p><ul><li>基本定时功能: 每隔一段时间产生一个中断</li><li>定时器输出比较: 常用来产生 PWM 波形</li><li>定时器输入捕获: 测量方波频率</li><li>定时器编码器接口: 读取正交编码器的输出波形</li></ul></li><li><p>定时器类型</p><table><thead><tr><th><strong>类型</strong></th><th align="left"><strong>编号</strong></th><th><strong>总线</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>基本定时器</td><td align="left">TIM6 &amp; TIM7</td><td>APB1</td><td>定时中断, 主模式触发 DAC</td></tr><tr><td>通用定时器</td><td align="left">TIM2 ~ TIM5</td><td>APB1</td><td>拥有基本定时器全部功能. 额外具有: 内外时钟源选择,<br />输入捕获输出比较, 编码器接口, 主从触发模式等功能</td></tr><tr><td>高级定时器</td><td align="left">TIM1 &amp; TIM8</td><td>APB2</td><td>拥有通用定时器全部功能. 额外具有: 重复计数器,<br />死区生成, 互补输出, 刹车输入等功能</td></tr></tbody></table></li><li><p>基本定时器</p><p><img src="/2024/04/01/Embedded/STM32/5-basic-timer.png"></p><ul><li><strong>时基单元: 最基本的计数计时电路</strong><ul><li><code>PSC 预分频器</code>: 对 72MHz 的时钟进行预分频.实际分频系数 &#x3D; PSC + 1</li><li><code>CNT 计数器</code>: 对预分频后的时钟进行计数.每有一个上升沿,CNT ++</li><li><code>ARR 自动重装载寄存器</code>: 存储计数目标.<strong>当计数值 &#x3D;&#x3D; 重装值时,产生一个中断信号,并清零计数器</strong></li></ul></li><li><strong>主模式输出: 可以将定时器的更新事件映射到触发控制器(TRGO),TRGO 接到 DAC 的触发转换引脚</strong></li></ul></li><li><p>通用定时器</p><p><img src="/2024/04/01/Embedded/STM32/5-universal-timer.png"></p><ul><li><strong>通用计时器的时基单元: 通用定时器包含基本定时器的电路.时基单元是相似的</strong></li><li>内外时钟选择:<code>TIMx_ETR</code>引脚接一个外部方波时钟.经过<code>极性选择,边沿检测,预分频器,输入滤波</code>后分为两路<ul><li>向上进入<code>触发控制器</code>,作为时基单元的时钟</li><li>向下进入<code>TRGI</code>,用作触发输入.触发定时器的从模式</li></ul></li><li><code>ITR</code> 信号: 来自其他定时器从 <code>TRGO</code> 的输出</li><li><code>TIIF_ED</code>: 连接到输入捕获单元的 CH1 引脚</li><li><code>TI1FP1, TI2FP2</code>: 连接到输入滤波器和边沿检测器的后面</li><li><strong>主模式输出: TRGO 可将内部的事件映射到 TRGO 引脚</strong></li></ul></li><li><p>高级定时器</p><p><img src="/2024/04/01/Embedded/STM32/5-advanced-timer.png"></p><ul><li>高级定时器包含了通用定时器的电路.额外增加了下列内容<ul><li>申请中断的后面加入一个 <code>REP</code> 重复次数计数器,可以每个几个计数周期才发生一次更新事件&#x2F;中断</li><li><code>DTG</code> 寄存器: 死区生成电路.右侧输出引脚变为了两个,可以输出一对互补的 PWM 波</li><li><code>TIMxBKIN</code>: 若 <code>TIMxBKIN</code> 引脚产生刹车信号或内部时钟失效,将由控制电路自动切断电机输出</li></ul></li></ul></li></ol><h3 id="5-2-时基单元"><a href="#5-2-时基单元" class="headerlink" title="5.2 时基单元"></a>5.2 时基单元</h3><ol><li><p>预分频时序图</p><p><img src="/2024/04/01/Embedded/STM32/5-count-timing-sequence-1-2.png"></p><ul><li><p><code>预分频缓冲器(影子寄存器)</code>: 实际上起作用的寄存器.预分频控制寄存器修改后,为保证此计数周期内频率一致.<br>该修改并不立即生效,在本次计数结束后才生效.<code>自动加载寄存器, 捕获 / 比较寄存器</code>同样有影子寄存器</p></li><li><p>计数器计数频率公式<br>$$<br>\mathrm{CK_CNT} &#x3D; \frac{\mathrm{CK_PSC}}{\mathrm{(PSC +1)}}<br>$$</p></li></ul></li><li><p>计数器时序图</p><p><img src="/2024/04/01/Embedded/STM32/5-count-timing-sequence.png"></p><ul><li><strong>计数器溢出频率公式</strong><br>$$<br>\mathrm{freq} &#x3D; \frac{\mathrm{CK_CNT}}{\mathrm{(ARR + 1)}}<br>&#x3D; \frac{\mathrm{CK_PSC}}{\mathrm{(PSC +1)(ARR + 1)}}<br>$$</li></ul></li></ol><h3 id="5-3-RCC-时钟树"><a href="#5-3-RCC-时钟树" class="headerlink" title="5.3 RCC 时钟树"></a>5.3 RCC 时钟树</h3><ol><li><p>RCC 产生和配置时钟,然后发送给各个外设的系统</p><p><img src="/2024/04/01/Embedded/STM32/5-RCC-clock-tree.png"></p><ul><li><strong>时钟是所有外设运行的基础,需要最先配置</strong></li><li>左侧为时钟产生电路,右侧为时钟分配电路.中间的 <code>SYSCLK</code> 为系统时钟(72MHz)</li></ul></li><li><p><strong>程序在 <code>main</code> 函数之前会执行 <code>SystemInit</code> 函数,以配置时钟树</strong></p><ul><li>首先尝试以 线路1 按照 8MHz 频率运行,稳定后切换为 线路2</li><li>CSS 可以检测时钟运行是否正常.若出错会切换到内部时钟</li></ul></li></ol><h3 id="5-4-定时中断"><a href="#5-4-定时中断" class="headerlink" title="5.4 定时中断"></a>5.4 定时中断</h3><ol><li><p>定时中断基本结构</p><p><img src="/2024/04/01/Embedded/STM32/5-timer-interrupt-struct.png"></p></li><li><p>基本定时中断配置步骤</p><ul><li>开启 RCC 的 TIM 外设时钟</li><li>时基单元的时钟源选择(选择内部时钟模式). 配置时基单元</li><li>配置中断输出控制,允许更新中断输出到 NVIC. 配置 NVIC,打开定时器的中断通道</li></ul></li></ol><h3 id="5-5-输出比较"><a href="#5-5-输出比较" class="headerlink" title="5.5 输出比较"></a>5.5 输出比较</h3><ol><li><p><strong>OC(Output Compare, 输出比较)</strong></p><ul><li><strong>通过比较 CNT 和 CCR 寄存器值(CNT 计数自增,CCR 手动给定).</strong><br><strong>然后对输出电平 置1 &#x2F; 置0 &#x2F; 翻转,实现输出一定频率和占空比的 PWM 波形</strong></li><li>每个高级寄存器(前3个通道拥有死区生成和互补输出功能)和通用寄存器均拥有4个输出比较通道</li><li>CCR 被输入捕获和输出比较共用<ul><li>使用输入捕获时,CCR 作为捕获寄存器</li><li>使用输出比较时,CCR 作为比较寄存器</li></ul></li></ul></li><li><p><strong>PWM(Pulse Width Modulation 脉冲宽度调制)</strong></p><ul><li>在惯性系统中,可以通过对一系列脉冲的宽度进行调制,来等效地获得所需要的模拟参量</li><li>参数: 频率: $freq &#x3D; \frac{1}{T_S}$, 占空比: $duty &#x3D; \frac{T_{ON}}{T_S}$, 分辨率: 占空比变化步距(1%即可)<br>其中 $T_S$ 为周期(高低电平变化一次的时间), $T_{ON}$ 为周期中高电平的维持时间</li></ul></li><li><p>捕获 &#x2F; 比较通道</p><p><img src="/2024/04/01/Embedded/STM32/5-capture-channel.png"></p></li><li><p>输出比较模式(输出模式控制器)</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>冻结</td><td>CNT&#x3D;CCR 时,REF 保持为原状态.即维持为暂停时刻的状态不变</td></tr><tr><td>匹配时置有效电平</td><td>CNT&#x3D;CCR 时,REF 置有效电平</td></tr><tr><td>匹配时置无效电平</td><td>CNT&#x3D;CCR 时,REF 置无效电平</td></tr><tr><td>匹配时电平翻转</td><td>CNT&#x3D;CCR 时,REF 电平翻转</td></tr><tr><td>强制为无效电平</td><td>CNT 与 CCR 无效,REF 强制为无效电平</td></tr><tr><td>强制为有效电平</td><td>CNT 与 CCR 无效.REF 强制为有效电平</td></tr><tr><td><strong>PWM 模式1</strong></td><td><strong>向上计数: CNT &lt; CCR 时,REF 置有效电平;CNT ≥ CCR 时,REF 置无效电平</strong> <br />向下计数: CNT &gt; CCR 时,REF 置无效电平;CNT ≤ CCR 时,REF 置有效电平</td></tr><tr><td><strong>PWM 模式2</strong></td><td><strong>向上计数: CNT &lt; CCR 时,REF 置无效电平,CNT ≥ CCR 时,REF 置有效电平</strong> <br />向下计数: CNT &gt; CCR 时,REF 置有效电平,CNT ≤ CCR 时,REF 置无效电平</td></tr></tbody></table></li><li><p>高级定时器输出比较(相较于通用定时器可以输出互补电平信号和产生死区)</p><p><img src="/2024/04/01/Embedded/STM32/5-advanced-timer-output.png"></p><ul><li>输出 <code>OC1,OC1N</code> 分别接到外部推挽电路的控制极,2个推挽电路构成 H桥,3个推挽电路即可驱动三相无刷电机</li><li><code>死区生成器</code>: 在 MOS 管关闭时,进行一段延时,然后是另一个 MOS 管导通.防止因器件原因造成正负极短路</li></ul></li><li><p>PWM 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/5-PWM-struct.png"></p><ul><li>图示中蓝线为 CNT(不断自增); 红线为 CCR(手动设置); 黄线为 ARR(手动设置).PWM 模式1</li><li>输出 PWM 波形不需要进行中断申请</li></ul></li><li><p><strong>PWM 参数计算</strong></p><ul><li><p>已知 $\mathrm{CK_PSC}$, PSC, ARR, CCR.计算频率, 占空比, 分辨率</p><ul><li><p>频率:     $\mathrm{freq} &#x3D; \frac{\mathrm{CK_PSC}}{\mathrm{(PSC + 1)}\mathrm{(ARR + 1)}}$</p></li><li><p>占空比: $\mathrm{Duty} &#x3D; \frac{\mathrm{CCR}}{\mathrm{(ARR + 1)}}$</p></li><li><p>分辨率: $\mathrm{Reso} &#x3D; \frac{1}{(\mathrm{ARR} + 1)}$</p></li></ul></li><li><p>已知 时钟频率, PWM 频率, 占空比, 分辨率时.计算 PSC, ARR, CCR</p><ul><li>$\mathrm{ARR+1} &#x3D; \frac{1}{\mathrm{Reso}}$</li><li>$\mathrm{CCR} &#x3D; \frac{\mathrm{Duty}}{\mathrm{Reso}}$ </li><li>$\mathrm{PSC + 1} &#x3D; \frac{\mathrm{Reso\cdot CK_{PSC}}}{\mathrm{freq}}$</li></ul></li><li><p><strong>确定 PSC, ARR, CCR 的方式</strong></p><ul><li>首先根据分辨率决定 ARR.如要求分辨率为 1% 时, (ARR + 1) &#x3D; 100.此后固定 ARR 的值,方便计算</li><li>此时 CRR 值即为占空比的百分数.如 CCR &#x3D; 50 时,占空比 duty &#x3D; 50%.代码中改变 CRR,即可调节占空比</li><li>最后确定 PSC 的值.代码中改变 PSC,即可调节频率</li></ul></li></ul></li></ol><h3 id="5-6-输入捕获"><a href="#5-6-输入捕获" class="headerlink" title="5.6 输入捕获"></a>5.6 输入捕获</h3><ol><li><p><strong>IC(Input Capture 输入捕获)</strong></p><ul><li>输入捕获模式下<ul><li>当通道输入引脚出现指定电平跳变时,当前 CNT 的值将被锁存到 CCR 中</li><li>可用于测量 PWM 波形的频率, 占空比, 脉冲间隔, 电平持续时间等参数</li></ul></li><li>每个高级定时器和通用定时器都拥有4个输入捕获通道<ul><li>可配置为 PWMI 模式,同时测量频率和占空比</li><li>可配合主从触发模式,实现硬件全自动测量</li></ul></li></ul></li><li><p><strong>频率测量方法</strong></p><ul><li><strong>测频法</strong>: 在闸门时间 T 内对上升沿计次 N,则频率 $f_x &#x3D; \frac{N}{T}$</li><li><strong>测周法</strong>: 两个上升沿内以标准频率 $f_c$ 计次 N,则频率 $f_x &#x3D; \frac{f_c}{N}$</li><li><strong>中界频率</strong>: 测频法与测周法误差相等的频率 $f_m &#x3D; \sqrt{\frac{f_c}{T}}$</li></ul></li><li><p>捕获比较通道框图</p><p><img src="/2024/04/01/Embedded/STM32/5-capture-channel-block.png"></p></li><li><p>主从触发模式</p><p><img src="/2024/04/01/Embedded/STM32/5-%E4%B8%BB%E4%BB%8E%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F.png"></p><ul><li><strong>主模式: 可将定时器内部的信号映射到 TRGO 引脚,触发其他外设</strong></li><li><strong>从模式: 接收其他外设或使用自身外设的信号.用以控制自身控制器的运行</strong></li><li>触发源选择: 指定 从模式的触发信号 得到 TRGI,然后触发选定的从模式</li></ul></li><li><p>输入捕获基本结构</p><p><img src="/2024/04/01/Embedded/STM32/5-capture-struct.png"></p><ul><li>从GPIO口输入方波信号,经过<code>滤波器, 边沿检测, 极性选择</code>得到 <code>TI1FP1</code>,最后连接到 <code>CCR1</code></li><li>当<code>TI1FP1</code>出现上升沿,不断自增的 <code>CNT</code> 转运到 <code>CCR1</code> 中</li><li>同时,触发源选择为 <code>TI1FP1</code>,从模式配置为 <code>Reset</code>.当 <code>TI1FP1</code> 出现上升沿,<code>CNT</code> 自动清零,再次自增</li></ul></li><li><p>PWMI 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/5-PWMI-struct.png"></p><ul><li>PWMI 与 输入捕获的区别在于使用2个通道捕获同一 GPIO,可以同时测量周期和占空比</li><li>当上升沿来临,<code>TI1FP1</code> 触发,<code>CCR1</code> 捕获,清零 <code>CNT</code></li><li><code>TI1FP2</code>配置为下降沿触发.当下降沿来临,<code>TI1FP2</code> 触发,<code>CCR2</code> 捕获,不清零 <code>CNT</code></li><li>因而 <code>CCR2</code> 的值反映高电平维持时间,<code>CCR1</code> 的值反映周期的时间.占空比为 $\frac{CCR2}{CCR1}$</li></ul></li></ol><h3 id="5-7-编码器"><a href="#5-7-编码器" class="headerlink" title="5.7 编码器"></a>5.7 编码器</h3><ol><li><p>编码器接口(Encoder Interface)</p><ul><li>编码器接口可接收增量(正交)编码器的信号<ul><li>根据编码器旋转产生的正交信号脉冲</li><li>自动控制 CNT 自增或自减,从而指示 编码器的位置, 旋转方向, 旋转速度</li></ul></li><li>每个高级定时器和通用定时器都拥有1个编码器接口</li><li>编码器接口的两个输入引脚借用了输入捕获的通道1和通道2</li></ul></li><li><p>正交编码器</p><p><img src="/2024/04/01/Embedded/STM32/5-encoder.png"></p><ul><li>由于正转和反转输出的波形一致,故仅凭一项输出信号无法判断旋转方向.因此需要 A, B相</li><li>A相与B相 相位差90°.每当出现边沿变化时,判断另一相的状态,对照右侧表格,即可确定旋转方向</li></ul></li><li><p>编码器接口基本结构</p><p><img src="/2024/04/01/Embedded/STM32/5-encoder-struct.png"></p><ul><li><p>当编码器正转时,CNT++; 反转时,CNT–.结合固定的闸门时间,即可完成测速任务</p></li><li><p><code>TI1FP1, TI2FP2</code>来自 GPIO 端口输入.<strong>类似于一个外部时钟源,配置为编码器模式</strong></p><ul><li>因此此时 PSC 建议设为 0,不进行分频.ARR 设为 65535,最大</li></ul></li><li><p>配置 GPIO 为输入模式 -&gt; 配置时基单元 -&gt; 配置输入捕获单元 -&gt; 配置编码器接口(下行代码)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 编码器接口配置.并设置为: 定时器3, 选择编码器模式, TI1, TI2都计数, 不反相</span><br><span class="hljs-comment">** 注意此时参数的 Rising 和 Falling 不再代表上升沿和下降沿了,而是代表是否反相</span><br><span class="hljs-comment">** 此函数必须在输入捕获初始化之后进行,否则输入捕获的配置会覆盖此函数的部分配置 */</span><br>TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12,<br>                           TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="6-ADC"><a href="#6-ADC" class="headerlink" title="6 ADC"></a>6 ADC</h2><h3 id="6-1-ADC-功能"><a href="#6-1-ADC-功能" class="headerlink" title="6.1  ADC  功能"></a>6.1  ADC  功能</h3><ol><li><p><strong>ADC(Analog-Digital Converter, 模拟-数字转换器)</strong></p><ul><li>作用: 可将引脚上连续变化的模拟电压 转换为内存中存储的数字变量</li><li>18个输入通道: 可测量16个外部(GPIO)和2个内部信号源(温度传感器,内部参考电压)<ul><li>输入电压范围: 0 ~ 3.3V</li><li>分辨率为 12位: 即表示范围 $0 \sim 2^{12}-1$</li><li>1$\mu$s 转换时间: 即开始转换到产生结果耗时.对应频率为 1MHz</li></ul></li><li>STM32 增强功能: 规则组和注入组两个转换单元</li></ul></li><li><p>逐次逼近型 ADC 结构(<code>ADC0809</code> 内部结构图, 8位逐次逼近型)</p><p><img src="/2024/04/01/Embedded/STM32/6-approx-ADC.png"></p></li><li><p>ADC 框图</p><p><img src="/2024/04/01/Embedded/STM32/6-ADC-block.png"></p></li><li><p>ADC 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/6-ADC-struct.png"></p><ul><li>配置 GPIO 为模拟输入模式 -&gt; 配置数据选择器 -&gt; 配置 ADC 转换器 -&gt; 开启 ADC</li></ul></li></ol><h3 id="6-2-ADC-模式"><a href="#6-2-ADC-模式" class="headerlink" title="6.2 ADC 模式"></a>6.2 ADC 模式</h3><ol><li><p><strong>规则组的转换模式</strong></p><ul><li>单次转换: 在一次转换结束后,转换结果存放在数据寄存器中,置 EOC 标志位,结束转换</li><li>连续转换: 在一次转换结束后,置 EOC 标志位,立即开始下一轮的转换</li><li>非扫描模式: 规则组的序列只有一个通道有效.即只处理一个通道的信号</li><li>扫描模式: 规则组的序列有效,一次转换多个通道的信号</li></ul></li><li><p>ADC 转换触发控制</p><p><img src="/2024/04/01/Embedded/STM32/6-ADC-external-trigger.png"></p></li><li><p>数据对齐: 对于一个 12bit ADC,其转换结果为 12bit.而数据寄存器为16bit,需进行数据对齐</p><ul><li><strong>右对齐: 有效数据右对齐,左边补0</strong></li><li>左对齐: 有效数据左对齐,右边补0</li></ul></li><li><p>转换时间(采样, 保持, 量化, 编码)</p><ul><li>ADC 的总转换时间: <code>T = 采样时间 + 12.5 * ADC 周期</code></li><li>采样时间可在程序中配置.量化编码因是12位 ADC,需要 12.5 个周期</li><li>例: 采样时间配置为1.5, ADC 频率为14MHz,则总转换时间为14个 ADC 周期,即 1us</li></ul></li></ol><h2 id="7-DMA"><a href="#7-DMA" class="headerlink" title="7 DMA"></a>7 DMA</h2><h3 id="7-1-DMA-功能"><a href="#7-1-DMA-功能" class="headerlink" title="7.1 DMA 功能"></a>7.1 DMA 功能</h3><ol><li><p><strong>DMA(Direct Memory Access, 直接存储器存取)</strong></p><ul><li>DMA 可以提供外设和存储器或者存储器和存储器之间的高速数据传输</li><li>本质上是从某个地址取出数据,转运到另一地址</li><li>作用: DMA 数据传输无须 CPU 干预,节省 CPU 的资源</li><li>12个独立可配置的通道: DMA1(7个通道), DMA2(5个通道)</li><li>每个通道都支持软件触发和特定的硬件触发</li></ul></li><li><p><strong>存储器映像</strong></p><table><thead><tr><th>类型</th><th>起始地址</th><th>存储器</th><th>用途</th></tr></thead><tbody><tr><td>ROM</td><td>0x0800 0000</td><td>程序存储器 Flash</td><td>存储编译后的 C 语言程序代码</td></tr><tr><td></td><td>0x1FFF F000</td><td>系统存储器</td><td>存储 BootLoader,用于串口下载</td></tr><tr><td></td><td>0x1FFF F800</td><td>选项字节</td><td>存储一些独立于程序代码的配置参数</td></tr><tr><td>RAM</td><td>0x2000 0000</td><td>运行内存 SRAM</td><td>存储运行过程中的临时变量</td></tr><tr><td></td><td>0x4000 0000</td><td>外设寄存器</td><td>存储各个外设的配置参数</td></tr><tr><td></td><td>0xE000 0000</td><td>内核外设寄存器</td><td>存储内核各个外设的配置参数</td></tr></tbody></table></li><li><p>DMA 框图</p><p><img src="/2024/04/01/Embedded/STM32/7-DMA-block.png"></p><ul><li>DMA 通过 <code>DMA 总线</code>主动访问各种存储器.DMA 总线是被分时复用的<ul><li><code>仲裁器</code>根据通道的优先级处理 DMA 通道的冲突</li><li><code>总线矩阵</code>也有仲裁器,当 CPU 和 DMA 访问同一目标时.保障 CPU 正常工作</li></ul></li><li>DMA 作为外设,也有寄存器.连接在 <code>AHB 总线</code>上,因此 CPU 可以访问,配置 DMA<ul><li>硬件可通过 DMA 请求线路向 DMA 发出硬件触发信号</li></ul></li></ul></li></ol><h3 id="7-2-DMA-转运"><a href="#7-2-DMA-转运" class="headerlink" title="7.2 DMA 转运"></a>7.2 DMA 转运</h3><ol><li><p><strong>DMA 基本结构</strong></p><p><img src="/2024/04/01/Embedded/STM32/7-DMA-struct.png"></p><ul><li>DMA 数据转运<ul><li>条件: DMA 使能, <code>传输计数器</code> &gt; 0, 触发源有触发信号</li><li>方向: 外设 -&gt; 存储器, 存储器 -&gt; 外设, Flash -&gt; SRAM</li><li>参数: 源端和目标的 <code>起始地址, 数据宽度, 地址是否自增</code></li></ul></li><li><strong>传输计数器</strong>: 在完成一次转运后会进行自减,当其值为0时结束转运,起始地址参数复位<ul><li><code>自动重装器</code>: 可以在传输计数器自减到0后,恢复传输计数器的值,再次自减.使得可以循环转运</li><li>DMA 转运完成后,必须先关闭 DMA,然后再次开启,才能给 <code>传输计数器</code> 写值</li></ul></li><li>触发方式: 由 <code>M2M</code> 控制<ul><li>软件触发: DMA 不断运行,直到 <code>传输计数器</code> 清零.此时不应开启 <code>自动重装器</code>,一般用于存储器间数据转运</li><li>硬件触发: 达到某种条件(如 ADC 转换完成,串口接收到数据,达到定时时间),触发 DMA 运行</li></ul></li></ul></li><li><p>DMA1 请求映像 </p><p><img src="/2024/04/01/Embedded/STM32/7-DMA1-request-map.png"></p><ul><li><strong>每个通道的硬件触发源不同.而软件触发都一样.需要根据触发选择 ADC 通道</strong></li><li>对于外设请求信号的选择: 由外设的 DMA 控制决定,开启就可以发出请求信号</li><li>外设请求信号经过 或门到硬件请求.一般只开启一个外设请求</li></ul></li><li><p>DMA 传输数据宽度</p><ul><li>源端宽度 &#x3D; 目标宽度: 正常传输</li><li>源端宽度 &gt; 目标宽度: 高位舍弃</li><li>源端宽度 &lt; 目标宽度: 高位补0</li></ul></li></ol><h2 id="8-USART-串口"><a href="#8-USART-串口" class="headerlink" title="8 USART 串口"></a>8 USART 串口</h2><h3 id="8-1-通信接口"><a href="#8-1-通信接口" class="headerlink" title="8.1 通信接口"></a>8.1 通信接口</h3><ol><li><p><strong>通信协议</strong></p><table><thead><tr><th>名称</th><th>引脚</th><th>双工</th><th>时钟</th><th>电平</th><th>设备</th></tr></thead><tbody><tr><td>USART</td><td>TX, RX</td><td>全双工</td><td>异步</td><td>单端</td><td>点对点</td></tr><tr><td>I2C</td><td>SCL, SDA</td><td>半双工</td><td>同步</td><td>单端</td><td>多设备</td></tr><tr><td>SPI</td><td>SCLK, MOSI, MISO, CS</td><td>全双工</td><td>同步</td><td>单端</td><td>多设备</td></tr><tr><td>CAN</td><td>CAN_H, CAN_L</td><td>半双工</td><td>异步</td><td>差分</td><td>多设备</td></tr><tr><td>USB</td><td>DP, DM</td><td>半双工</td><td>异步</td><td>差分</td><td>点对点</td></tr></tbody></table><ul><li>全双工: 通信双方能够同时进行双向通信.一般需要2根通信线</li><li>半双工: 通信双方无法同时输入 &#x2F; 输出数据</li><li>单工: 数据传输方向为单向</li><li>时钟: 确定数据的采集时机</li></ul></li><li><p>电平标准: 数据1&#x2F;0的表达方式(当电平信号不一致时,需要加入电平转换芯片)</p><table><thead><tr><th>电平标准</th><th>data: 1</th><th>data: 0</th></tr></thead><tbody><tr><td><strong>TTL</strong></td><td><strong>+3.3V 或 +5V</strong></td><td><strong>0V</strong></td></tr><tr><td>RS232 电平</td><td>-3 ~ -15V</td><td>+3 ~ +15</td></tr><tr><td>RS485 电平(差分信号)</td><td>+2 ~ +6V</td><td>-2 ~ -6V</td></tr></tbody></table></li><li><p>串口时序</p><p><img src="/2024/04/01/Embedded/STM32/8-uart-timing-sequence.png"></p></li><li><p>串口参数</p><ul><li><strong>波特率: 串口通信的速率.每秒传输码元的个数</strong></li><li>比特率: 每秒传输的比特数(bit&#x2F;s).二进制情况下,码元即是 bit,波特率等于比特率</li><li>起始位: 标志一个数据帧的开始,固定为低电平(空闲时为高电平)</li><li><strong>数据位: 数据帧的有效载荷.1为高电平,0为低电平.低位先行</strong></li><li>校验位: 用于数据验证(如奇校验表示连同校验位共有奇数个1,还有 CRC 校验)</li><li>停止位: 用于数据帧间隔.固定为高电平</li></ul></li></ol><h3 id="8-2-USART-外设"><a href="#8-2-USART-外设" class="headerlink" title="8.2 USART 外设"></a>8.2 USART 外设</h3><ol><li><p><strong>USART(Universal Synchronous&#x2F;Asynchronous Receiver&#x2F;Transmitter, 通用同步&#x2F;异步收发器)</strong></p><ul><li>STM32 内部集成 USART 外设<ul><li>可根据数据寄存器的一个字节数据自动生成数据帧时序.由 TX 引脚发送</li><li>可自动接收 RX 引脚的数据帧时序,拼接为一个字节数据,存放于数据寄存器</li><li>自带波特率发生器.最高达4.5Mbits&#x2F;s(本质是一个预分频器)</li></ul></li><li>可配置参数<ul><li>数据位长度(<strong>8</strong> &#x2F; 9). 停止位长度(0.5 &#x2F; <strong>1</strong> &#x2F; 1.5 &#x2F; 2)</li><li>校验位: <strong>无校验,</strong> 奇校验, 偶校验</li><li>支持同步模式, 硬件流控制, DMA, 智能卡, IrDA, LIN</li></ul></li><li>stm32f103 的 usart1 的引脚: tx - PA9, rx - PA10</li></ul></li><li><p>USART 框图</p><p><img src="/2024/04/01/Embedded/STM32/8-USART-block.png"></p><ul><li><code>TX</code> 引脚连接 <code>发送移位寄存器</code>,在<code>发送器控制</code>的控制下,将数据按位移出<ul><li>当 <code>TDR</code>(只写) 被写入数据时,先检查<code>移位寄存器</code>是否有数据正在移位</li><li>若无,则数据发送到<code>移位寄存器</code>,同时,置 <code>TXE 标志位</code>,可以再次向 <code>TDR</code> 写入数据</li><li>若有,则等待移位完成后,立即转移数据</li></ul></li><li><code>RX</code> 连接通向 <code>接收移位寄存器</code>,在<code>接收器控制</code>的控制下,将数据按位移出<ul><li><code>接收移位寄存器</code>按位读取 <code>RX</code> 引脚的信号</li><li>读取满1byte 后,将数据转移到 <code>RDR</code>.同时,置 <code>RXNE 标志位</code>.此时可从 <code>RDR</code>(只读)读出数据</li></ul></li></ul></li><li><p>USART 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/8-USART-struct.png"></p><ul><li>APB的时钟信号到达波特率发生器进行分频</li><li>发送器 &#x2F; 接收器的波特率 &#x3D; $\mathrm{\frac{f_{PCLK}} { {16} \cdot {DIV} } }$. 由 <code>波特率寄存器 BRR</code> 中的 <code>DIV</code> 决定</li></ul></li></ol><h3 id="8-3-重定向-printf"><a href="#8-3-重定向-printf" class="headerlink" title="8.3 重定向 printf"></a>8.3 重定向 <code>printf</code></h3><ol><li><p>格式化打印: 对 <code>printf</code>函数的重定向</p></li><li><p>打开工程文件中的 <code>Options for target</code>,勾选 <code>Use MicroLIB</code>(Keil 为嵌入式平台准备的精简库)</p><p><img src="/2024/04/01/Embedded/STM32/8-UseMicroLib.png"></p></li><li><p><strong>由于<code>printf</code>函数底层调用<code>fput</code>函数不断打印,因此可以将 <code>printf</code> 函数重定向为向串口发送数据</strong></p></li><li><p>方法1: 重写的<code>fputc</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span> &#123;<br>serial_send_byte(ch);  <span class="hljs-comment">// 这是一个串口传输数据的函数,需要自行实现</span><br><span class="hljs-keyword">return</span> ch;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方法2: 对 <code>sprintf</code> 的封装(<code>sprintf</code> 函数: 将内容打印打印到字符串中)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">serial_printf</span><span class="hljs-params">(<span class="hljs-type">char</span> *format, ...)</span> &#123;<br><span class="hljs-type">char</span> <span class="hljs-built_in">string</span>[<span class="hljs-number">100</span>];               <span class="hljs-comment">// 定义字符数组</span><br>va_list arg;                    <span class="hljs-comment">// 定义可变参数列表数据类型的变量 arg</span><br>va_start(arg, format);          <span class="hljs-comment">// 从 format 开始,接收参数列表到 arg 变量</span><br><span class="hljs-built_in">vsprintf</span>(<span class="hljs-built_in">string</span>, format, arg);  <span class="hljs-comment">// 使用 vsprintf 打印格式化字符串和参数列表到字符数组中</span><br>va_end(arg);                    <span class="hljs-comment">// 结束变量 arg</span><br>serial_send_string(<span class="hljs-built_in">string</span>);     <span class="hljs-comment">// 串口发送字符数组的函数,需要自行实现</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="8-4-HAL-库"><a href="#8-4-HAL-库" class="headerlink" title="8.4 HAL 库"></a>8.4 HAL 库</h3><ol><li>配置 UART1</li></ol><p>   <img src="/2024/04/01/Embedded/STM32/8-USART-HAL.png"></p><ol start="2"><li><p>在 <code>stm32f1xx_hal_uart.h</code> 中有很多中断回调函数,以及功能实现函数</p><ul><li><p>收发函数(还有中断和 dma 版本)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_StatusTypeDef <span class="hljs-title function_">HAL_UART_Transmit</span><span class="hljs-params">(UART_HandleTypeDef *huart, </span><br><span class="hljs-params">                                    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *pData, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_UART_Receive</span><span class="hljs-params">(UART_HandleTypeDef *huart, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint8_t</span> *pData, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint32_t</span> Timeout)</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="9-I2C-通信"><a href="#9-I2C-通信" class="headerlink" title="9 I2C 通信"></a>9 I2C 通信</h2><h3 id="9-1-I2C-协议"><a href="#9-1-I2C-协议" class="headerlink" title="9.1 I2C 协议"></a>9.1 I2C 协议</h3><ol><li><p><strong>I2C(Inter IC BUS).由 Philips 公司开发的一种通用数据总线</strong></p><ul><li><strong>通信线: SCL(Serial Clock), SDA(Serial Data)</strong></li><li>属于同步通信,半双工通信.可以数据应答,支持总线挂载多设备</li><li>I2C 外设出厂会有一个地址(7位或10位)</li></ul></li><li><p>硬件电路</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-bus.png"></p><ul><li>SDA 和 SCL 的控制<ul><li>主机拥有对 SCL 线的完全控制权.也可控制空闲状态下的 SDA 线</li><li>从机只能读取 SCL 线,也不允许主动控制 SDA 线</li><li>仅在应答或主机要读取从机时才能获取 SDA 的控制权</li></ul></li><li>接线方式<ul><li>所有 I2C 设备的 SCL 连在一起,SDA 连在一起.均默认为高电平</li><li><strong>设备的 SCL 和 SDA 均要配置成开漏输出模式,禁止输出高电平</strong></li><li>SCL 和 SDA 各添加一个上拉电阻,阻值一般为4.7KΩ</li></ul></li></ul></li><li><p><strong>I2C 时序基本单元</strong></p><ul><li><p><strong>起始与终止</strong>: 始终由主机控制,从机无权发送该指令</p><ul><li><p>起始条件: 主机拉低 SDA 电平(下降沿,此时从机复位).然后拉低 SCL,占用 SCL</p></li><li><p>终止条件: 主机先放开 SCL,然后放开 SDA (上升沿).回到初始态</p></li><li><p><strong>除了起始和终止条件,每个时序单元的 SCL 以低电平开始,也以低电平结束</strong></p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-start-end.png"></p></li></ul></li><li><p><strong>发送数据</strong></p><ul><li><p>起始状态后.SCL,SDA均为低电平.主机将数据置于 SDA 线(高位先行)</p></li><li><p>然后释放 SCL.从机在 SCL 高电平期间读取数据位,需要尽快读取,最好在上升沿时就立即读取</p></li><li><p>当 SCL 高电平时, SDA 不应发生变化,维持一段时间后,主机再次拉低 SCL.完成一位数据的传输</p></li><li><p>循环上述过程8次,即可传输一个字节的数据</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-send-byte.png"></p></li></ul></li><li><p><strong>接收数据</strong></p><ul><li><p>主机需要先释放 SDA.在 SCL 低电平期间,从机将数据置于 SDA 线(高位先行)</p></li><li><p>然后主机释放 SCL.由主机读取数据位</p></li><li><p><strong>SDA 总是在 SCL 低电平(下降沿)时被放置数据,在 SCL 高点平(上升沿)时被读取</strong></p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-receive-byte.png"></p></li></ul></li><li><p><strong>主机发送应答</strong>: 主机接收完一个字节后,在下一个时钟发送一位数据.<strong>0为应答,1为非应答</strong></p></li><li><p><strong>接收从机应答</strong>: 主机发送完一个字节后,在下一个时钟接收一位数据.<strong>0为应答,1为非应答</strong></p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-ack.png"></p></li></ul></li><li><p>指定地址写: 给指定设备(slave addr)的指定地址(reg addr)写入指定数据(data)</p><ul><li><p>起始条件 -&gt; 发送 1byte(前 7bit 为 slave addr, 后 1bit 表示读(1) &#x2F; <strong>写(0)</strong> ) -&gt; 从机应答0 -&gt; </p></li><li><p>发送 1byte 数据(reg addr) -&gt; 从机应答0 -&gt; </p></li><li><p>发送 1byte 数据(data) -&gt; 从机应答0 -&gt; 终止条件</p></li><li><p>后续字节: 传输真正的数据(寄存器的地址将会自增).当完成传输时,主机需要产生一个终止条件</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-write-reg.png"></p></li></ul></li><li><p>当前地址读: 对于指定设备(slave addr),读取从机当前地址指针的数据(data)</p><ul><li><p>起始条件 -&gt; 发送 1byte(前 7bit 为 slave addr, 后 1bit 表示<strong>读(1)</strong> &#x2F; 写(0) ) -&gt; 从机应答0 -&gt;</p></li><li><p>接收 1byte data(此时从机在 scl 低电平写入 sda,主机在 scl 高电平读取 sda) -&gt; 主机应答1 -&gt; 终止条件</p></li><li><p>当主机不想再接收数据时,需要在发送应答时给出非应答,此时从机将不再发送数据</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-read-reg.png"></p></li></ul></li><li><p>指定地址读: 给指定设备(slave addr)的指定地址(reg addr)读取数据(data)</p><ul><li><p>起始条件 -&gt; 发送 1byte(前 7bit 为 slave addr, 后 1bit 表示读(1) &#x2F; <strong>写(0)</strong> ) -&gt; 从机应答0 -&gt; </p></li><li><p>发送 1byte 数据(reg addr) -&gt; 从机应答0 -&gt; </p></li><li><p>重复起始条件 -&gt; 发送 1byte(前 7bit 为 slave addr, 后 1bit 表示<strong>读(1)</strong> &#x2F; 写(0) ) -&gt; 从机应答0 -&gt;</p></li><li><p>接收 1byte data(此时从机在 scl 低电平写入 sda,主机在 scl 高电平读取 sda) -&gt; 主机应答1 -&gt; 终止条件  </p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-set-addr-read-reg.png"></p></li></ul></li></ol><h3 id="9-2-I2C-外设"><a href="#9-2-I2C-外设" class="headerlink" title="9.2 I2C 外设"></a>9.2 I2C 外设</h3><ol><li><p>STM32 内部集成了硬件 I2C 收发电路</p><ul><li>可以由硬件自动执行时钟生成,起始终止条件生成,应答位收发,数据收发等功能.减轻CPU的负担</li><li>支持 7bit &#x2F; 10bit 地址模式(若第一字节的前5位为11110,则表示10位地址)</li><li>支持不同的通讯速度,标准速度(高达100 kHz), 快速(高达400 kHz)</li><li>支持 DMA, 多主机模型, 兼容 SMBus(System Management Bus)协议</li></ul></li><li><p>I2C 基本结构图</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-struct.png"></p></li><li><p>硬件 I2C 波形</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-hardware-wave.png"></p></li></ol><h3 id="9-3-HAL-库"><a href="#9-3-HAL-库" class="headerlink" title="9.3 HAL 库"></a>9.3 HAL 库</h3><ol><li><p>I2C2 配置</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-hal.png"></p></li><li><p>在 <code>stm32f1xx_hal_i2c.h</code> 中有很多中断回调函数,以及功能实现函数.下面是收发函数的声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Write</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> DevAddress,  <span class="hljs-comment">// 注意是 7bit地址 &lt;&lt; 1</span></span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> MemAddress,</span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> MemAddSize, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint8_t</span> *pData, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Read</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> DevAddress, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> MemAddress, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> MemAddSize, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint8_t</span> *pData, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint32_t</span> Timeout)</span>;<br></code></pre></td></tr></table></figure></li></ol><h2 id="10-SPI-通信"><a href="#10-SPI-通信" class="headerlink" title="10 SPI 通信"></a>10 SPI 通信</h2><h3 id="10-1-SPI-协议"><a href="#10-1-SPI-协议" class="headerlink" title="10.1 SPI 协议"></a>10.1 SPI 协议</h3><ol><li><p><strong>SPI(Serial Peripheral Interface): 由Motorola公司开发的一种通用数据总线</strong></p><ul><li>通信线: SCK(Serial Clock), SS(Slave Select),<br>MOSI(Master Output Slave Input), MISO(Master Input Slave Output)</li><li>同步, 全双工.支持总线挂载多设备(一主多从)</li></ul></li><li><p>硬件电路</p><p><img src="/2024/04/01/Embedded/STM32/10-SPI-bus.jpg"></p><ul><li>所有 SPI 设备的 SCK, MOSI, MISO 分别连在一起<ul><li><strong>SCK: 时钟线</strong>.完全由主机掌控.由主机进行输出,从机得到输入</li><li><strong>MOSI: 主机输出从机输入</strong>.在主机上,表现为数据输出.在从机上,表现为数据输入</li><li><strong>MISO: 主机输入从机输出</strong>.在主机上,表现为数据输入.在从机上,表现为数据输出</li></ul></li><li><strong>主机另外引出多条 SS 控制线,分别接到各从机的 SS 引脚</strong><ul><li>当从机的 SS 高电平时,MISO 必须为高阻态,不允许从机输出,防止 MISO 数据冲突</li><li>SS 低电平有效,且只能同时选中一个从机.如需指定从机输入输出数据.则将对应的 SS 拉至低电平</li><li>输出的引脚需配置为推挽输出,保证高低电平均有强驱动能力.输入的引脚需配置为浮空或上拉输入</li></ul></li></ul></li><li><p>SPI 数据交换</p><p><img src="/2024/04/01/Embedded/STM32/10-SPI-swap-byte.png"></p><ul><li><code>波特率发生器</code>时钟上升沿时,所有移位寄存器向左移位,置于引脚</li><li><code>波特率发生器</code>时钟下降沿时,对引脚电平采样,置于移位寄存器的最低位</li><li>主机与从机的数据交换<ul><li>在一个周期内,从机由高位移出的数据传输到主机的低位,主机由高位移出的数据传输到从机的低位</li><li>循环8次后,从机的数据完整到达主机,主机的数据也完整达到从机,完成一次数据交换</li></ul></li><li>如果仅需主机发送数据,仍然需要执行数据交换,忽略接收到的数据即可</li><li>如果仅需接收从机数据,仍然需要执行数据交换,此时主机可使用任意数据交换(一般0x00或0xFF)</li></ul></li><li><p>SPI 基本时序</p><ul><li><p>起始条件: SS 从高电平切换到低电平</p></li><li><p>终止条件: SS 从低电平切换到高电平</p></li><li><p>可选择 上升&#x2F;下降沿 移位.可配置时钟相位提前半个时钟</p><ul><li><code>CPOL(Clock Polarity)</code><ul><li>CPOL&#x3D;0: SCK 空闲时为低电平</li><li>CPOL&#x3D;1: SCK 空闲时为高电平</li></ul></li><li><code>CPHA(Clock phase)</code><ul><li>CPHA&#x3D;0: SCK 奇数边沿时移入数据.偶数边沿移出数据(提前)</li><li>CPHA&#x3D;1: SCK 奇数边沿时移出数据.偶数边沿移入数据(正常)</li></ul></li></ul></li><li><p><strong>模式0 使用最多(CPOL&#x3D;0,CPHA&#x3D;0): 空闲时,SCK为低电平,上升沿采集数据</strong></p><p><img src="/2024/04/01/Embedded/STM32/10-SPI-mode0.jpg"></p></li></ul></li><li><p>SPI 通常使用指令码和读写数据的方式操作从机: 从机选择 -&gt; 发送指令 -&gt; 发送数据<br>向指定设备发送指令 0x02,然后写入数据</p><p><img src="/2024/04/01/Embedded/STM32/10-SPI-timing-sequence.jpg"></p></li></ol><h3 id="10-2-SPI-外设"><a href="#10-2-SPI-外设" class="headerlink" title="10.2 SPI 外设"></a>10.2 SPI 外设</h3><ol><li><p>STM32 内部集成了硬件 SPI 收发电路</p><ul><li>可配置 8 &#x2F; 16位数据帧, 高 &#x2F; 低位先行</li><li>时钟频率: PCLK &#x2F; (2, 4, 8, 16, 32, 64, 128, 256)</li><li>支持多主机模型(主&#x2F;从操作), 可精简为半双工&#x2F;单工通信, 支持 DMA, 兼容 I2S 协议</li></ul></li><li><p>SPI 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/10-SPI-struct.png"></p></li></ol><h3 id="10-3-HAL-库"><a href="#10-3-HAL-库" class="headerlink" title="10.3 HAL 库"></a>10.3 HAL 库</h3><ol><li><p>SPI1 配置</p><p><img src="/2024/04/01/Embedded/STM32/10-SPI-hal.png"></p></li><li><p>spi 基础函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_StatusTypeDef <span class="hljs-title function_">HAL_SPI_TransmitReceive</span><span class="hljs-params">(SPI_HandleTypeDef *hspi, </span><br><span class="hljs-params">                                          <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *pTxData, </span><br><span class="hljs-params">                                          <span class="hljs-type">uint8_t</span> *pRxData,</span><br><span class="hljs-params">                                          <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                          <span class="hljs-type">uint32_t</span> Timeout)</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="11-RTC-实时时钟"><a href="#11-RTC-实时时钟" class="headerlink" title="11 RTC 实时时钟"></a>11 RTC 实时时钟</h2><h3 id="11-1-Unix-时间戳"><a href="#11-1-Unix-时间戳" class="headerlink" title="11.1 Unix 时间戳"></a>11.1 Unix 时间戳</h3><ol><li><p><strong>Unix 时间戳(Timestamp): 从 UTC &#x2F; GMT 的 <code>1970年1月1日00:00:00</code> 开始经过的秒数</strong></p><ul><li>秒计数器为 32 &#x2F; 64bit 的整型变量</li><li>各时区的秒计数器相同,但不同时区通过偏移得到当地时间</li></ul></li><li><p>GMT(Greenwich Mean Time): 格林尼治标准时间,将地球自转一周的时间等分为24小时</p></li><li><p>UTC(Universal Time Coordinated): 协调世界时,以原子钟为基础的时间计量系统</p></li><li><p>时间戳与时间的转换: C语言的 <code>&lt;time.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> tm* <span class="hljs-title function_">gmtime</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">time_t</span>*)</span>;     <span class="hljs-comment">// 秒计数器转换为日期时间</span><br><span class="hljs-keyword">struct</span> tm* <span class="hljs-title function_">localtime</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">time_t</span>*)</span>;  <span class="hljs-comment">// 秒计数器转换为当地时间</span><br><span class="hljs-type">time_t</span> <span class="hljs-title function_">mktime</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tm*)</span>;            <span class="hljs-comment">// 日期时间转换为秒计数器</span><br></code></pre></td></tr></table></figure><p><img src="/2024/04/01/Embedded/STM32/11-timestamp-convert.png"></p></li></ol><h3 id="11-2-BKP-备份寄存器"><a href="#11-2-BKP-备份寄存器" class="headerlink" title="11.2 BKP 备份寄存器"></a>11.2 BKP 备份寄存器</h3><ol><li><p>BKP 可用于存储用户应用程序数据</p><ul><li>当 VDD(2.0 ~ 3.6V)电源被切断时,仍由 VBAT(1.8 ~ 3.6V)维持供电</li><li>就算系统复位,电源复位,BKP 也不会复位</li><li>用户数据存储容量: 20字节(中&#x2F;小容量), 84字节(大容量&#x2F;互联型)</li></ul></li><li><p><strong>TAMPER 引脚产生的侵入事件会将所有备份寄存器内容清除</strong></p></li><li><p>RTC 引脚可以输出: RTC 校准时钟, RTC 闹钟脉冲, 秒脉冲</p></li><li><p>BPK 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/11-BPK-struct.png"></p></li></ol><h3 id="11-3-RTC-实时时钟"><a href="#11-3-RTC-实时时钟" class="headerlink" title="11.3 RTC 实时时钟"></a>11.3 RTC 实时时钟</h3><ol><li><p><strong>RTC(Real Time Clock): 实时时钟,RTC是一个独立的定时器,可为系统提供时钟 &#x2F; 日历功能</strong></p><ul><li>RTC 和 时钟配置系统处于后备区域,系统复位时数据不清零</li><li>拥有32位可编程计数器,对应 Unix 时间戳的秒计数器</li><li>拥有20位可编程预分频器,适配不同频率的输入时钟.可选时钟源有<ul><li>HSE 时钟除以128(8MHz&#x2F;128)</li><li><strong>LSE 振荡器时钟(32.768KHZ)</strong></li><li>LSI 振荡器时钟(40KHz)</li></ul></li></ul></li><li><p>RTC 框图</p><p><img src="/2024/04/01/Embedded/STM32/11-RTC-block.png"></p></li><li><p>RTC 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/11-RTC-struct.png"></p></li></ol><h2 id="12-PWR-电源控制"><a href="#12-PWR-电源控制" class="headerlink" title="12 PWR 电源控制"></a>12 PWR 电源控制</h2><h3 id="12-1-PWR"><a href="#12-1-PWR" class="headerlink" title="12.1 PWR"></a>12.1 PWR</h3><ol><li><p><strong>PWR(Power Control, 电源控制): 负责 STM32 内部的电源供电部分,可实现可编程电压检测器和低功耗模式</strong></p></li><li><p>电源框图</p><p><img src="/2024/04/01/Embedded/STM32/12-power-block.png"></p></li><li><p>上电复位和掉电复位</p><p><img src="/2024/04/01/Embedded/STM32/12-reset.png"></p></li><li><p><strong>可编程电压检测器(PVD): 监控 VDD 电源电压,当 VDD 上升&#x2F;下降到 PVD 阈值时,触发中断,执行紧急关闭任务</strong></p><p><img src="/2024/04/01/Embedded/STM32/12-PVD-threshold.png"></p></li></ol><h3 id="12-2-低功耗模式"><a href="#12-2-低功耗模式" class="headerlink" title="12.2 低功耗模式"></a>12.2 低功耗模式</h3><ol><li><p><strong>低功耗模式: 在系统空闲时,降低 STM32 的功耗,延长设备的使用时间</strong></p><p><img src="/2024/04/01/Embedded/STM32/12-low-power-mode.png"></p></li><li><p><strong>芯片在低功耗模式下无法直接下载程序: 下载程序步骤:按住复位键,点击下载程序,然后及时松开复位键</strong></p></li><li><p>修改芯片主频(修改文件 <code>Start/system_stm32f10x.c</code>)</p><ul><li>外部可见变量 <code>SystemCoreClock</code>: 系统主频的值</li><li>搜索 <code>SYSCLK_FREQ_xxMHz</code>,在此处进行的宏定义将会决定运行哪个设置系统时钟的函数</li></ul></li><li><p>进入睡眠模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">__WFI();  <span class="hljs-comment">// 进入睡眠模式,等待中断唤醒.一般置于主循环的最后一行</span><br>__WFE();  <span class="hljs-comment">// 进入睡眠模式,等待唤醒事件</span><br></code></pre></td></tr></table></figure></li><li><p>进入停机 &#x2F; 待机模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);      <span class="hljs-comment">// 停机和待机模式需开启 PWR 的时钟</span><br><br>PWR_EnterSTOPMode(PWR_Regulator_ON, PWR_STOPEntry_WFI);  <span class="hljs-comment">// 进入停止模式,并等待外部中断唤醒</span><br>PWR_EnterSTANDBYMode();  <span class="hljs-comment">// 进入待机模式,并等待指定的唤醒事件.唤醒后程序从头执行</span><br><br>SystemInit();  <span class="hljs-comment">// 从停止模式唤醒后,需重新配置时钟为 HSE(72MHz).而待机模式不需要</span><br></code></pre></td></tr></table></figure></li><li><p>设置闹钟或 PA0 上升沿唤醒待机模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">PWR_WakeUpPinCmd(ENABLE);  <span class="hljs-comment">// 使能 WakeUp 引脚(PA0)唤醒待机的功能(默认下拉低电平,高电平有效)</span><br>RTC_SetAlarm(RTC_GetCounter() + <span class="hljs-number">10</span>);  <span class="hljs-comment">// 设置 RTC 闹钟的值.为 10s 后</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="13-WDG-看门狗"><a href="#13-WDG-看门狗" class="headerlink" title="13 WDG 看门狗"></a>13 WDG 看门狗</h2><h3 id="13-1-看门狗功能"><a href="#13-1-看门狗功能" class="headerlink" title="13.1 看门狗功能"></a>13.1 看门狗功能</h3><ol><li><p><strong>看门狗(WDG, Watchdog)</strong></p><ul><li>监测程序的运行状态,当程序卡死时复位程序.保证安全性和可靠性</li><li><strong>看门狗本质是定时器,在指定的时间范围内,若未重置计数器,则硬件电路将产生复位信号</strong></li></ul></li><li><p><strong>独立看门狗(Independent WDG)</strong></p><p><img src="/2024/04/01/Embedded/STM32/13-independent-wdg.png"></p><ul><li><p>键寄存器 IWDG_KR: 控制寄存器,用于控制硬件电路的工作,避免干扰发生</p><table><thead><tr><th>写入键寄存器的值</th><th>作用</th></tr></thead><tbody><tr><td>0xCCCC</td><td>启用独立看门狗</td></tr><tr><td>0xAAAA</td><td>IWDG_RLR 中的值重新加载到计数器(喂狗)</td></tr><tr><td>0x5555</td><td>解除 IWDG_PR, IWDG_RLR 的写保护</td></tr><tr><td>0x5555之外的值</td><td>启用 IWDG_PR, IWDG_RLR 的写保护</td></tr></tbody></table></li><li><p>超时时间</p><p><img src="/2024/04/01/Embedded/STM32/13-wdg-timeout.png"></p><ul><li>超时时间: $T_{IWDG}$ &#x3D; 时钟周期 * PR 预分频系数 * (重装计数值 + 1)</li><li>其中,时钟周期&#x3D;1&#x2F;40KHz, PR 预分频系数只能取表中限定的值, 重装计数值12位(0~4095)</li></ul></li></ul></li><li><p><strong>窗口看门狗(Window WDG): 要求看门狗在精确计时窗口时作用(过早过晚均不行)</strong></p><p><img src="/2024/04/01/Embedded/STM32/13-wdg-block.png"></p></li><li><p>对比独立看门狗与窗口看门狗</p><table><thead><tr><th></th><th>独立看门狗</th><th>窗口看门狗</th></tr></thead><tbody><tr><td>复位时机</td><td>计数器减到0</td><td>计数器T[5:0] 减到0 &#x2F; 过早重装计数器</td></tr><tr><td>中断</td><td>&#x2F;</td><td>早期唤醒中断</td></tr><tr><td>时钟源</td><td>LSI(40KHz)</td><td>PCLK1(36MHz)</td></tr><tr><td>预分频系数</td><td>4, 8, 32, 64, 128, 256</td><td>1, 2, 4, 8</td></tr><tr><td>计数器</td><td>12位</td><td>6位</td></tr><tr><td>超时时间</td><td>0.1ms ~ 26214.4ms</td><td>113us ~ 58.25ms</td></tr><tr><td>喂狗方式</td><td>写入键寄存器,重装固定值 RLR</td><td>直接写入计数器</td></tr><tr><td>防误操作</td><td>键寄存器和写保护</td><td>&#x2F;</td></tr><tr><td>用途</td><td>独立工作,对时间精度要求较低</td><td>要求看门狗在精确计时窗口起作用</td></tr></tbody></table></li></ol><h3 id="13-2-看门狗代码"><a href="#13-2-看门狗代码" class="headerlink" title="13.2 看门狗代码"></a>13.2 看门狗代码</h3><ol><li><p>判断复位信号来源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) == SET) &#123;  <span class="hljs-comment">// 成立说明是独立看门狗复位</span><br><span class="hljs-comment">//if (RCC_GetFlagStatus(RCC_FLAG_WWDGRST) == SET) &#123;  // 成立说明是窗口看门狗复位</span><br>RCC_ClearFlag();  <span class="hljs-comment">// 标志位不会自动清除,进入后需要手动清除</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>操作独立看门狗</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* IWDG 初始化.LSI 会在设置看门狗后自动配置,无需手动开启 */</span><br>IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);  <span class="hljs-comment">// 独立看门狗写使能</span><br>IWDG_SetPrescaler(IWDG_Prescaler_16);  <span class="hljs-comment">// 设置预分频为16</span><br>IWDG_SetReload(<span class="hljs-number">2499</span>);  <span class="hljs-comment">// 设置重装值为2499,独立看门狗的超时时间为 1/40000 * 16 * 2500=1s</span><br>IWDG_ReloadCounter();  <span class="hljs-comment">// 重装计数器,初始化喂狗. 主循环中每1秒都需要喂狗,否则复位</span><br>IWDG_Enable();  <span class="hljs-comment">// 独立看门狗使能</span><br><span class="hljs-comment">/* 主循环中喂狗 */</span><br>IWDG_ReloadCounter();  <span class="hljs-comment">//重装计数器</span><br></code></pre></td></tr></table></figure></li><li><p>操作窗口看门狗</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* WWDG 初始化.以窗口时长 30~50ms 为例 */</span><br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);  <span class="hljs-comment">// 开启 WWDG 的时钟</span><br>WWDG_SetPrescaler(WWDG_Prescaler_8);  <span class="hljs-comment">// 设置预分频为8</span><br>WWDG_SetWindowValue(<span class="hljs-number">0x40</span> | <span class="hljs-number">21</span>);  <span class="hljs-comment">// 设置窗口时长 1/36,000,000 * 4096 * 8 * (54-21) = 30ms</span><br>WWDG_Enable(<span class="hljs-number">0x40</span> | <span class="hljs-number">54</span>);  <span class="hljs-comment">// 使能并第一次喂狗,超时时间为 1/36,000,000 * 4096 * 8 * (54+1) = 50ms</span><br><span class="hljs-comment">/* 主循环中喂狗 */</span><br>WWDG_SetCounter(<span class="hljs-number">0x40</span> | <span class="hljs-number">54</span>);  <span class="hljs-comment">//重装计数器</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="14-Flash-闪存"><a href="#14-Flash-闪存" class="headerlink" title="14 Flash 闪存"></a>14 Flash 闪存</h2><h3 id="14-1-Flash-功能"><a href="#14-1-Flash-功能" class="headerlink" title="14.1 Flash 功能"></a>14.1 Flash 功能</h3><ol><li><p>STM32F1 系列中容量产品 Flash 闪存模块组织</p><p><img src="/2024/04/01/Embedded/STM32/14-flash.png"></p></li><li><p><strong>读写 Flash 的用途</strong></p><ul><li><strong>利用程序存储器的剩余空间,保存用户数据(掉电不丢失)</strong></li><li><strong>通过在程序中编程(In-Application Programming),实现程序自我更新</strong></li></ul></li><li><p>下载程序方式</p><ul><li><strong>在线编程(In-Circuit Programming)</strong>: 更新程序存储器的全部内容<ul><li>通过 JTAG, SWD 协议(ST Link)或系统加载程序(Bootloader)下载程序</li></ul></li><li><strong>在程序中编程(In-Application Programming)</strong>: 使用微控制器支持的任意通信接口下载程序<ul><li>需要自己编写 Bootloader 程序(存储于程序更新时不覆盖的地方)</li><li>需要更新程序时,控制程序跳转到 Bootloader,接收通信数据(程序信息)</li><li>然后通过控制 Flash 读写,将程序信息存储于程序正常运行的地方</li></ul></li></ul></li><li><p>Flash 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/14-Flash-struct.png"></p></li><li><p><strong>指针访问存储器</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// #define __IO volatile  // STM32对__IO的宏定义</span><br><span class="hljs-type">uint16_t</span> Data = *((__IO <span class="hljs-type">uint16_t</span> *)(<span class="hljs-number">0x08000000</span>));  <span class="hljs-comment">// 读取0x8000 0000地址的数据</span><br>* ((__IO <span class="hljs-type">uint16_t</span> *)(<span class="hljs-number">0x80000000</span>)) = <span class="hljs-number">0x1234</span>;  <span class="hljs-comment">// 给0x8000 0000地址写入数据.需要先解锁,执行相应流程</span><br></code></pre></td></tr></table></figure></li><li><p><strong>器件电子签名: 存放于闪存的系统存储区域,不可更改</strong></p><ul><li>读取方式: 使用指针直接读取指定地址下的存储器获得</li><li>闪存容量(单位kb)寄存器(16位)基地址: <code>0x1FFF F7E0</code></li><li>产品唯一身份标识寄存器(96位)基地址: <code>0x1FFF F7E8</code></li></ul></li></ol><h3 id="14-2-Flash-烧录"><a href="#14-2-Flash-烧录" class="headerlink" title="14.2 Flash 烧录"></a>14.2 Flash 烧录</h3><ol><li><p>读取芯片 ID</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">*((__IO <span class="hljs-type">uint16_t</span> *)(<span class="hljs-number">0x1FFFF7E0</span>));  <span class="hljs-comment">// 闪存容量寄存器的值</span><br>*((__IO <span class="hljs-type">uint32_t</span> *)(<span class="hljs-number">0x1FFFF7E8</span>));  <span class="hljs-comment">// 产品唯一身份标识寄存器的值,共96位</span><br>*((__IO <span class="hljs-type">uint32_t</span> *)(<span class="hljs-number">0x1FFFF7E8</span> + <span class="hljs-number">0x04</span>));<br>*((__IO <span class="hljs-type">uint32_t</span> *)(<span class="hljs-number">0x1FFFF7E8</span> + <span class="hljs-number">0x08</span>));<br></code></pre></td></tr></table></figure></li><li><p><strong>指定烧录程序是的起始地址</strong>: 打开工程选项 -&gt; Target</p><p><img src="/2024/04/01/Embedded/STM32/14-start-addr.png"></p></li><li><p><strong>程序占用空间大小查看</strong></p><ul><li><p>编译完成后会出现提示信息: <code>Program Size: Code=2784 RO-data=1788 RW-data=4 ZI-data=2660</code></p><ul><li><code>Code + RO=-data + Rw-data = 4576</code>: ROM 使用空间</li><li><code>Rw-data + ZI-data = 2664</code>:  RAM 使用空间</li></ul><table><thead><tr><th>数据类型</th><th>存储位置</th><th>说明</th></tr></thead><tbody><tr><td>Code</td><td>Flash</td><td>代码</td></tr><tr><td>RO-Data</td><td>Flash</td><td>只读数据.如 const 修饰</td></tr><tr><td>RW-Data</td><td>Flash &amp; SRAM</td><td>初值非0 可读可写的数据</td></tr><tr><td>ZI-Data</td><td>SRAM</td><td>初值为0 可读可写数据</td></tr></tbody></table></li><li><p>双击 <code>Target 1</code> 出现 <code>Project.map</code> 文件,拉到文件底部,可以直接查看程序占用空间情况</p><p><img src="/2024/04/01/Embedded/STM32/14-total-process-size.png"></p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Basic</title>
    <link href="/2024/01/19/Computer/C++-Basic/"/>
    <url>/2024/01/19/Computer/C++-Basic/</url>
    
    <content type="html"><![CDATA[<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++ 基础"></a>C++ 基础</h1><h2 id="0-基本概念"><a href="#0-基本概念" class="headerlink" title="0 基本概念"></a>0 基本概念</h2><h3 id="0-1-设计理念"><a href="#0-1-设计理念" class="headerlink" title="0.1 设计理念"></a>0.1 设计理念</h3><ol><li>程序设计语言的目的是帮助我们使用代码来表达思想.因此程序设计语言需要完成<ul><li>为程序员提供一个工具,指明需要由机器执行什么动作</li><li>为程序员提供一组概念,用于思考能做什么</li></ul></li><li>C++ 的设计理念提供<ul><li>将内置操作和内置类型直接映射到硬件</li><li>灵活且低开销的抽象机制</li></ul></li><li>C++ 设计基本原则<ul><li>不给比 C++ 更底层的语言留任何余地</li><li><strong>零开销原则(zero-overhead principle): 你不使用它,就不要为它付出代价</strong></li></ul></li><li>C++ 语言特性直接支持4种程序设计风格<ul><li><strong>过程式程序设计</strong>: 专注于处理和设计恰当的数据结构(如 C 语言)</li><li><strong>数据抽象</strong>: 专注于接口的设计, 一般实现细节的隐藏和特殊的表示方式(具体类, 抽象类)</li><li><strong>面向对象程序设计</strong>: 专注于类层次的设计, 实现, 使用(通过封装, 继承, 多态)</li><li><strong>泛型程序设计</strong>: 专注于通用算法的设计, 实现, 使用(通过模板)</li></ul></li></ol><h3 id="0-2-关键字"><a href="#0-2-关键字" class="headerlink" title="0.2 关键字"></a>0.2 关键字</h3><ol><li><p>ANSI C 有32个关键字</p><table><thead><tr><th>auto</th><th>break</th><th>case</th><th>char</th><th>const</th><th>continue</th><th>default</th><th>do</th></tr></thead><tbody><tr><td>double</td><td>else</td><td>enum</td><td>extern</td><td>float</td><td>for</td><td>goto</td><td>if</td></tr><tr><td>int</td><td>long</td><td>register</td><td>return</td><td>short</td><td>signed</td><td>sizeof</td><td>static</td></tr><tr><td>struct</td><td>switch</td><td>typedef</td><td>union</td><td>unsigned</td><td>void</td><td>volatile</td><td>while</td></tr></tbody></table></li><li><p>C99 标准新增5个关键字: <code>inline, restrict, _Bool, _Complex, _Imaginary</code></p></li><li><p>C11 标准新增7个关键字: <code>_Alignas, _Alignof, _Atomic, _Static_assert, _Noreturn, _Thread_local, _Generic</code></p></li><li><p><strong>C++98&#x2F;03 相较 ANSI C 增加的31个关键字(共63个)</strong></p><table><thead><tr><th>asm</th><th>bool</th><th>catch</th><th>class</th><th>const_cast</th></tr></thead><tbody><tr><td>delete</td><td>dynamic_cast</td><td>explicit</td><td>export</td><td>false</td></tr><tr><td>friend</td><td>inline</td><td>mutable</td><td>namespace</td><td>new</td></tr><tr><td>operate</td><td>private</td><td>protected</td><td>public</td><td>reinterpret_cast</td></tr><tr><td>static_cast</td><td>template</td><td>this</td><td>throw</td><td>true</td></tr><tr><td>try</td><td>typeid</td><td>typename</td><td>using</td><td>virtual</td></tr><tr><td>wchar_t</td><td></td><td></td><td></td><td></td></tr></tbody></table></li><li><p><strong>C++11 相较于 C++98 新增的10个关键字(共73个)</strong></p><table><thead><tr><th>alignas</th><th>alignof</th><th>char16_t</th><th>char32_t</th><th>constexpr</th></tr></thead><tbody><tr><td>decltype</td><td>noexcept</td><td>nullptr</td><td>static_assert</td><td>thread_local</td></tr></tbody></table></li><li><p>逻辑运算符: <code>and, or, not, and_eq, or_eq, not_eq, bitand, bitor, compl, xor, xor_eq</code></p></li></ol><h3 id="0-3-示例程序"><a href="#0-3-示例程序" class="headerlink" title="0.3 示例程序"></a>0.3 示例程序</h3><ol><li><p>输出 <code>Hello, World!</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>using</code> 的使用(以 <code>std::cout</code> 对象为例.注意不要在全局作用域的头文件中使用 <code>using</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;         <span class="hljs-comment">// 使得 std 命名空间中的所有名称都可直接使用.方便但不推荐</span><br><span class="hljs-keyword">using</span> std::cout;             <span class="hljs-comment">// 仅引入需要使用的 std::cout, 并简化为 cout. 推荐的使用方式</span><br>std::coot &lt;&lt; <span class="hljs-string">&quot;Hello,world!&quot;</span>; <span class="hljs-comment">// 不使用 using 编译指令.而是都每次都加上 std:: 前缀.比较麻烦</span><br></code></pre></td></tr></table></figure></li><li><p><code>namespace</code> 的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> 名称 &#123;<br>    <span class="hljs-comment">/* 在此处声明变量, 函数, 类型, 对象... 其他位置进行实现 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>namespace</code> 注意事项</p><ul><li><p>访问方式(与访问类成员类似,但运算符为 <code>::</code>)</p><ul><li>内部访问: 直接访问即可,无需任何条件</li><li><strong>外部访问: 通过 <code>::</code> 作用域解析运算符访问命名空间成员</strong></li></ul></li><li><p>只能在全局范围定义(如函数内不允许定义命名空间)</p></li><li><p>可以嵌套定义.访问时使用多次 <code>::</code> 即可访问</p></li><li><p>实现与声明通常分离(声明于 <code>.h</code> 文件,实现于 <code>.cpp</code> 文件)</p></li><li><p>命名空间可以起别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> alias = std;  <span class="hljs-comment">// 直接赋值.后续即可使用别名</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-4-C-兼容性"><a href="#0-4-C-兼容性" class="headerlink" title="0.4 C 兼容性"></a>0.4 C 兼容性</h3><ol><li>C 与 C++ 的兼容性<ul><li><strong>C++ 几乎是 C 的超集.C 语言的语法在 C++ 中可以通用(如预处理器, 变量声明, 函数声明)</strong></li><li><strong>C++ 增加了面向对象(通过类)与泛型编程(通过模板)</strong></li></ul></li><li>对 C 程序员的建议<ul><li><strong>C++ 几乎不需要宏替换</strong><ul><li>使用 <code>const, constexpr, enum, enum class</code> 定义显式常量</li><li>使用 <code>inline</code> 避免函数调用的开销</li><li>使用 <code>template</code> 指明函数族和类型族</li><li>使用 <code>namespace</code> 避免命名冲突</li></ul></li><li><strong>在需要使用一个变量时才声明,且声明后立即进行初始化</strong></li><li>不要使用 <code>malloc</code>, 而是使用 <code>new</code></li><li>避免使用 <code>void *, 类型转换</code></li><li><strong>减少 C 风格字符串的使用.而是使用 <code>string</code></strong></li></ul></li><li>文件格式<ul><li>C 语言的源代码使用 <code>.c</code>,而 C++ 源代码的拓展名常用 <code>.cpp</code></li><li>C 语言的头文件使用 <code>.h</code>,而 <strong>C++ 头文件没有拓展名(如 C 中的 <code>math.h</code> 改为 <code>cmath</code>)</strong></li></ul></li></ol><h3 id="0-5-数据使用"><a href="#0-5-数据使用" class="headerlink" title="0.5 数据使用"></a>0.5 数据使用</h3><ol><li>数值字面量<ul><li>整数: <strong>二进制(前缀 0b)</strong>, 八进制(前缀 0), 十进制(默认形式), 十六进制(前缀 0x)</li><li>浮点数: <code>float</code> 类型(f 后缀), <code>double</code> 类型(默认形式): 3.14</li><li><strong>分隔符 <code>&#39;</code></strong>: 如 <code>100&#39;000, 0.123&#39;456f, 0b1000&#39;000</code></li></ul></li><li><strong>初始化列表</strong><ul><li><p>初始化列表对不同对象的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> l &#123;<span class="hljs-number">5400UL</span>&#125;;  <span class="hljs-comment">// 相当于 unsigned long l = 5400UL;</span><br><span class="hljs-type">int</span> array[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;     <span class="hljs-comment">// 省略了赋值号,并由编译器推断数组长度</span><br></code></pre></td></tr></table></figure></li><li><p>零初始化: <code>&#123;&#125;</code></p><ul><li>数值类型初始化为 0</li><li>指针类型初始化为 <code>nullptr</code></li><li>类对象调用默认构造函数</li></ul></li></ul></li><li>变量类型转换(<code>static_cast</code> 关键字)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> f = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> a &#123; (<span class="hljs-type">int</span>)f &#125;;  <span class="hljs-comment">// C 风格强制类型转换</span><br><span class="hljs-type">int</span> b &#123; <span class="hljs-built_in">int</span>(f) &#125;;  <span class="hljs-comment">// 使用较少</span><br><span class="hljs-type">int</span> c &#123; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(f) &#125;;  <span class="hljs-comment">// 推荐使用</span><br></code></pre></td></tr></table></figure></li><li><strong>枚举类</strong><ul><li>定义方式与 C 语言类似,区别在于多一个 <code>class</code> 关键字(不同点在于枚举类不能与整数混用)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">piece_type</span> &#123;King, Queen, Rook, Pawn&#125;;<br></code></pre></td></tr></table></figure></li><li><strong>访问方式: 与访问类常量相似(因为不同枚举类被当作不同的作用域.这区别于 C 语言的枚举)</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">piece_type piece&#123; PieceType::King &#125;;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">piece_type</span>;  <span class="hljs-comment">// C++20 语法</span><br>piece = Queen;          <span class="hljs-comment">// 无需使用全名访问</span><br></code></pre></td></tr></table></figure></li></ul></li><li>控制流<ul><li><p><code>if, switch</code> 语句的初始化器: 初始化引入的变量作用域局限于条件语句内部</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>( &lt;初始化&gt;; &lt;条件语句&gt; ) &#123; <span class="hljs-comment">/* code */</span> &#125;<br><span class="hljs-keyword">switch</span>( &lt;初始化&gt;; &lt;表达式&gt; ) &#123; <span class="hljs-comment">/* code */</span> &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>基于范围的 <code>for</code> 循环</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>( &lt;初始化&gt;; &lt;范围声明&gt;) &#123; <span class="hljs-comment">/* code */</span> &#125;  <span class="hljs-comment">// C++20 基于范围的 for 循环的初始化器</span><br><br><span class="hljs-keyword">for</span>( array arr&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;; <span class="hljs-type">int</span> i : arr )<br>    cout &lt;&lt; i &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li></ul></li><li>数组<ul><li><strong>C++ 不推荐使用 C 风格的数组,而是采用 <code>std::array, std::vector</code> 容器</strong></li><li><code>std::array</code> 是对 C 风格数组的封装.拥有固定大小<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">array&lt;<span class="hljs-type">int</span>, 3&gt; arr &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>&#125;;<br></code></pre></td></tr></table></figure></li><li><code>std::array</code> 的优点: 知道自身大小; 不会自动转为指针; 具有迭代器</li></ul></li></ol><h2 id="1-语言特性"><a href="#1-语言特性" class="headerlink" title="1 语言特性"></a>1 语言特性</h2><h3 id="1-1-new"><a href="#1-1-new" class="headerlink" title="1.1 new"></a>1.1 <code>new</code></h3><ol><li><p>C++ 中利用 <code>new</code> 操作符在堆区申请内存,利用操作符 <code>delete</code> 释放空间</p></li><li><p><code>new</code> 申请单个数据的内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">new_int</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-type">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 申请一个 int 类型的空间,且初始化为 10</span><br><span class="hljs-keyword">return</span> a;             <span class="hljs-comment">// a 是一个局部变量指针.但指向的数据存储于堆中</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-type">int</span> *p = <span class="hljs-built_in">new_int</span>();  <span class="hljs-comment">// p 是一个指针,指向的空间是由 new 申请</span><br>cout &lt;&lt; *p &lt;&lt; endl;  <span class="hljs-comment">// 验证其值是否初始化为 10</span><br><span class="hljs-keyword">delete</span> p;            <span class="hljs-comment">// 释放申请的空间</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>new</code> 申请数组内存(注意释放内存时 <code>delete</code> 的格式应与 <code>new</code> 对应)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">// 申请的是 int[],长度为10</span><br><br><span class="hljs-keyword">if</span> (arr) &#123;         <span class="hljs-comment">// 释放前先判断是否为空</span><br>    <span class="hljs-keyword">delete</span>[] arr;  <span class="hljs-comment">// 对应地,释放时要表明是数组 delete[]</span><br>    arr = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 释放空间后将指针置空.防止再次使用</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>new, delete</code> 与 <code>malloc, free</code> 对比</p><ul><li><code>new, delete</code> 是 C++ 的操作符(可重载).而 <code>malloc, free</code> 是标准库函数</li><li><code>new</code> 免去了计算内存空间的操作.而 <code>malloc</code> 需要手动计算字节数</li><li><code>new</code> 直接返回具体类型的指针.而 <code>malloc</code> 返回 <code>void *</code>,需要强转</li><li><code>new, delete</code> 会调用 构造 &#x2F; 析构函数</li></ul></li></ol><h3 id="1-2-引用"><a href="#1-2-引用" class="headerlink" title="1.2 引用"></a>1.2 引用</h3><ol><li><p>引用: 给变量起别名</p><ul><li><p><strong>引用必须初始化.且初始化后不可修改其指向对象,而只能修改其值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;b = a;  <span class="hljs-comment">// &amp; 表示引用.这里 b 是对 a 的引用.即修改 b 将会直接影响 a</span><br>b = <span class="hljs-number">100</span>;     <span class="hljs-comment">// 此时 a 也会被修改 100</span><br></code></pre></td></tr></table></figure></li><li><p>引用的本质: 指针常量(指向不可修改)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 相当于下面写法的语法糖.简化了代码的编写</span><br><span class="hljs-type">int</span> &amp;b = a;  <span class="hljs-comment">// &lt;==&gt; int* const p = &amp;a;</span><br>b = <span class="hljs-number">100</span>;     <span class="hljs-comment">// &lt;==&gt; *p = 100;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>引用作为函数参数: 可以简化指针修改实参的语法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 1. 值传递: 这无法完成 &quot;值交换功能&quot; */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_swap1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> temp = a; a = b; b = temp;&#125;<br><br><span class="hljs-comment">/* 2. 地址传递: 完成了 &quot;值交换功能&quot;,但需要进行取址/取值操作 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_swap2</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> </span>&#123;<span class="hljs-type">int</span> temp = *a; *a = *b; *b = temp;&#125;<br><br><span class="hljs-comment">/* 3. 引用传递: 完成了 &quot;值交换功能&quot;,且代码中并未直接出现指针 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_swap3</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span> </span>&#123;<span class="hljs-type">int</span> temp = a; a = b; b = temp;&#125;<br></code></pre></td></tr></table></figure></li><li><p>引用作为返回值</p><ul><li>引用可以作为函数的返回值(注意不要返回局部变量引用)</li><li><strong>函数调用可作为左值(因为函数调用后返回的是变量引用).实现链式调用</strong></li></ul></li><li><p><strong>常量引用: 主要用来修饰形参,防止误操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 在函数形参列表中,可以加 const 修饰形参,防止形参改变实参 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;v)</span> </span>&#123;<br><span class="hljs-comment">// v += 10;  // 对常量进行修改, 将会导致编译报错</span><br>cout &lt;&lt; v &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-3-函数"><a href="#1-3-函数" class="headerlink" title="1.3 函数"></a>1.3 函数</h3><ol><li><p><strong>默认参数</strong></p><ul><li>C++ 中,函数的形参列表中的形参可以有默认值(在形参列表中赋值)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>)</span> </span>&#123;<br>    <span class="hljs-comment">/* code */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>如果某个位置参数有默认值,那么从这个位置 往后的参数都必须有默认值</strong></li><li><strong>如果函数声明有默认值,函数实现就不能有默认参数(因为导致语义二义性)</strong></li></ul></li><li><p><strong>占位参数</strong></p><ul><li><strong>C++ 中函数的形参列表里可以有占位参数,用来做占位,调用函数时必须填补该位置</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 函数占位参数也可以有默认参数 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> = <span class="hljs-number">10</span>)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;this is func&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>函数重载</strong>: 函数名可以相同,提高复用性</p><ul><li>函数重载条件<ul><li>函数名相同,且位于同一个作用域</li><li>函数的参数不同(类型 &#x2F; 个数 &#x2F; 顺序的任意一种)</li></ul></li><li>注意事项<ul><li>返回值不作为函数重载的条件</li><li>引用可作为重载条件(是否被 <code>const</code> 修饰的引用形参)</li><li><strong>函数重载碰到函数默认参数时.会产生歧义,应避免</strong></li></ul></li><li>函数被调用时,会根据传入参数不同匹配需要调用的函数</li></ul></li></ol><h3 id="1-4-auto-待补充"><a href="#1-4-auto-待补充" class="headerlink" title="1.4 auto&#x3D;&#x3D;待补充&#x3D;&#x3D;"></a>1.4 <code>auto</code>&#x3D;&#x3D;待补充&#x3D;&#x3D;</h3><ol><li><p><code>auto</code>: 类型推断关键字</p><ul><li>推断函数返回类型<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;  <span class="hljs-comment">// 自动推断函数返回值类型</span><br></code></pre></td></tr></table></figure></li><li>结构化绑定: 声明多个变量<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">array&lt;<span class="hljs-type">int</span>, 3&gt; arr&#123; <span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span> &#125;;<br><span class="hljs-keyword">auto</span> [x, y, z] &#123;arr&#125;;  <span class="hljs-comment">// 还可使用 auto&amp;, const auto&amp;</span><br></code></pre></td></tr></table></figure></li><li>推断表达式类型<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a &#123; <span class="hljs-built_in">func</span>() &#125;;  <span class="hljs-comment">// 将变量 a 初始化为 func() 的返回值</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>推断非类型模板参数的类型</p></li><li><p>简写函数模板的语法</p></li><li><p><code>decltype(auto)</code></p><ul><li><code>decltype(表达式)</code>: 计算表达式的类型.与 <code>auto</code> 的区别在于不会去除 <code>const, &amp;</code> 限定符</li></ul></li><li><p>其他函数语法</p></li><li><p>泛型 <code>lambda</code> 表达式</p></li></ol><h2 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2 面向对象"></a>2 面向对象</h2><h3 id="2-1-封装"><a href="#2-1-封装" class="headerlink" title="2.1 封装"></a>2.1 封装</h3><ol><li><p><strong>面向对象的三大特性: 封装, 继承, 多态</strong></p></li><li><p>封装的意义</p><ul><li>将属性和行为作为一个整体</li><li>对属性和行为进行权限控制</li></ul></li><li><p>C++ 提供三种类的支持</p><ul><li>具体类(与内置类型一样自然); 抽象类(具有虚函数); 类层次中的类(继承)</li><li>其他类可以看作这些类的变形或组合</li></ul></li><li><p>在设计类的时候,属性和行为写在一起,表现事物</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> radius &#123;<span class="hljs-number">0</span>&#125; ;  <span class="hljs-comment">// 类内成员初始化器</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">get_perimeter</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span>  <span class="hljs-number">2</span> * PI * radius;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    Circle c&#123;&#125;;     <span class="hljs-comment">// 实例化对象</span><br>    c.radius = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 类实例访问方式与结构体类似.使用 . 或 -&gt;</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Circle perimeter: &quot;</span> &lt;&lt; c.<span class="hljs-built_in">get_perimeter</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>类在设计时,可以把属性和行为放在不同的权限下,加以控制</strong></p><table><thead><tr><th>关键字</th><th>权限类别</th><th>说明</th></tr></thead><tbody><tr><td><code>public</code></td><td>公共权限</td><td>类内 &#x2F; 类外均可访问.用于提供接口</td></tr><tr><td><code>protected</code></td><td>保护权限</td><td>类内可以访问,子类可以访问.但类外不可以访问</td></tr><tr><td><code>private</code></td><td>私有权限</td><td>类内可访问,类外不可访问.用于提供实现细节</td></tr></tbody></table></li><li><p>C++中 <code>struct</code> 和 <code>class</code> 默认的访问权限不同.<code>struct</code> 默认公共; <code>class</code> 默认私有</p></li><li><p>成员属性设为 <code>private</code> 的优点: 控制读写权限</p><ul><li>对于读权限,通过 <code>get</code> 方法(控制访问权限)</li><li>对于写权限,通过 <code>set</code> 方法(检测数据的合法性)</li></ul></li><li><p><strong>分离编译</strong></p><ul><li>将描述模块接口的内容放置于 <code>.h</code> 头文件中</li><li>将负责实现的内容放置于 <code>.cpp</code> 源文件中</li></ul></li></ol><h3 id="2-2-类成员"><a href="#2-2-类成员" class="headerlink" title="2.2 类成员"></a>2.2 类成员</h3><ol><li><p><strong>构造函数: 用于创建对象时为对象的成员属性赋值,将由编译器自动调用(只会调用一次)</strong></p><ul><li>函数名称与类名相同: <code>类名() &#123;&#125;</code></li><li>没有返回值,但不用写 <code>void</code></li><li><strong>可以有参数,因此构造函数可以重载</strong></li></ul></li><li><p><strong>析构函数: 用于对象销毁前的清理工作,将由编译器自动调用(只会调用一次)</strong></p><ul><li>函数名称与类名相同,但需在名称前加上 <code>~</code> 符号: <code>~类名() &#123;&#125;</code></li><li>没有返回值,但不用写 <code>void</code></li><li>不可以有参数,因此析构函数不可重载<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>()  &#123;cout &lt;&lt; <span class="hljs-string">&quot;Person 的构造函数调用&quot;</span> &lt;&lt; endl;&#125;<br>    ~<span class="hljs-built_in">Person</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;Person 的析构函数调用&quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>类实例的初始化和清理</p><ul><li>编译器强制要求完成对象的初始化和清理工作</li><li><strong>如果不提供构造和析构,编译器会将其设为空实现</strong></li></ul></li><li><p>类内默认函数</p><ul><li><strong>默认情况下,C++ 编译器至少给一个类添加4个函数</strong><ul><li>默认构造函数(无参,函数体为空)</li><li>默认析构函数(无参,函数体为空)</li><li>默认拷贝构造函数, 对属性进行值拷贝</li><li>赋值运算符 <code>operator=</code>: 对属性进行值拷贝.非构造情况下调用</li></ul></li><li>若用户定义有参构造函数,C++ 不再提供默认无参构造,但是仍提供默认拷贝构造</li><li>若用户定义拷贝构造函数,C++ 不再提供其他构造函数</li></ul></li><li><p>深拷贝与浅拷贝</p><ul><li>浅拷贝: 简单的赋值拷贝操作</li><li>深拷贝: 在堆区重新申请空间,进行拷贝操作<ul><li><strong>如果属性有在堆区开辟空间的操作,此时配套的析构函数应包含释放内存操作</strong></li><li>若使用浅拷贝,多个对象的析构将会导致重复释放内存</li><li>需要自己提供拷贝构造函数避免该问题</li></ul></li></ul></li></ol><h3 id="2-3-类初始化"><a href="#2-3-类初始化" class="headerlink" title="2.3 类初始化"></a>2.3 类初始化</h3><ol><li><p>简单的类定义示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/* 无参构造函数.若没有任何构造函数,则编译器默认提供一个空实现.但建议手动添加 */</span><br>    <span class="hljs-built_in">Person</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;&#125;<br>    <span class="hljs-comment">/* 有参构造函数.可以重载,可以有默认参数,但建议不要同时出现 */</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a) &#123;<br>         age = a;<br>         cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">/* 拷贝构造函数.编译器默认实现为对属性的简单赋值 */</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person &amp;p) &#123;  <span class="hljs-comment">// p 引用的是右值(将要被拷贝的对象)</span><br>         age = p.age;           <span class="hljs-comment">// 当属性为指针且指向堆空间时.要按需实现拷贝逻辑</span><br>         cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">/* 析构函数 */</span><br>    ~<span class="hljs-built_in">Person</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;&#125;<br><span class="hljs-keyword">public</span>: <span class="hljs-type">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>构造函数的调用方式</strong>: 括号法, 显示法, 隐式转换法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 调用无参构造函数 */</span><br>Person p;    <span class="hljs-comment">// 正确.注意不需要括号</span><br><span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 错误.编译器理解为函数声明</span><br><br><span class="hljs-comment">/* 调用有参的构造函数 */</span><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">// 括号法,常用</span><br><br><span class="hljs-comment">/* 显式调用 */</span><br>Person p2 = <span class="hljs-built_in">Person</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// Person(10) 是匿名对象.当前行结束之后,会立即析构</span><br>Person p3 = <span class="hljs-built_in">Person</span>(p2);  <span class="hljs-comment">// 触发拷贝构造</span><br><br><span class="hljs-comment">/* 隐式转换 */</span><br>Person p4 = <span class="hljs-number">10</span>;  <span class="hljs-comment">// Person p4 = Person(10); </span><br>Person p5 = p4;  <span class="hljs-comment">// Person p5 = Person(p4); 触发拷贝构造</span><br><br><span class="hljs-comment">/* 不能利用拷贝构造函数来初始化匿名对象.因为编译器会理解为对象声明 */</span><br><span class="hljs-built_in">Person</span>(p5);  <span class="hljs-comment">// 错误.编译器理解为 Person p5; 对 p5 重定义</span><br></code></pre></td></tr></table></figure></li><li><p><strong>拷贝构造函数</strong>调用时机: 通常有三种情况(用已有的对象创建其他对象)</p><ul><li>用已创建的对象来初始化一个新对象<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;  <span class="hljs-comment">// 使用 p1 创建对象 p2.即拷贝构造</span><br></code></pre></td></tr></table></figure></li><li>以值传递的方式给函数参数传值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Person p)</span></span>;  <span class="hljs-comment">// func 函数以值传递形式接收对象</span><br><span class="hljs-built_in">func</span>(p);              <span class="hljs-comment">// func 调用时,实参传递给形参,触发拷贝构造</span><br></code></pre></td></tr></table></figure></li><li>以值方式返回局部对象<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Person <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    Person p;<br>    <span class="hljs-keyword">return</span> p;  <span class="hljs-comment">// func 函数以值的形式返回局部对象</span><br>&#125;<br>Person p = <span class="hljs-built_in">func</span>();  <span class="hljs-comment">// 接收 func 函数的返回值时,触发拷贝构造</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>初始化成员列表</strong>使用时机</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">ClassName</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b): <span class="hljs-built_in">property1</span>(a), <span class="hljs-built_in">property2</span>(b) &#123;&#125;<br><span class="hljs-function">ClassName <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">8</span>)</span></span>;<span class="hljs-comment">// 创建对象时,属性1初始化为2,属性2初始化为8</span><br></code></pre></td></tr></table></figure><ul><li>某个属性为引用(为其赋初值)</li><li>某个属性被 <code>const</code> 修饰(为其赋初值)</li><li>某个属性是其他类的对象(为了构造对象)</li></ul></li></ol><h3 id="2-3-this"><a href="#2-3-this" class="headerlink" title="2.3 this"></a>2.3 <code>this</code></h3><ol><li><strong>静态成员: 在成员变量和成员函数前加上关键字 <code>static</code></strong><ul><li>静态成员变量<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明,类外初始化</li></ul></li><li>静态成员函数<ul><li>所有对象共享同一个函数</li><li><strong>静态成员函数只能访问静态成员变量</strong></li></ul></li><li>静态成员可以通过类名直接访问: <code>对象.成员</code> 或 <code>类名::成员</code></li></ul></li><li>成员变量和成员函数分开存储<ul><li>C++ 中,类内的成员变量(栈区)和成员函数(代码区)分开存储</li><li><strong>只有非静态成员变量属于类的对象之中</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123;mA = <span class="hljs-number">0</span>;&#125;<br><span class="hljs-type">int</span> mA;           <span class="hljs-comment">// 非静态成员变量占对象空间</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> mB;    <span class="hljs-comment">// 静态成员变量不占对象空间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 函数也不占对象空间,所有函数共享一个函数实例</span><br>cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mA &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">sfunc</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// 静态成员函数也不占对象空间</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><code>this</code><ul><li>每个非静态成员函数只会产生一份函数实例,即同类型的多个对象会共用一块代码</li><li><strong>C++ 通过特殊的对象指针 <code>this</code> 指针,指向调用方法的对象.是一个指针常量</strong><ul><li><code>this</code> 指针隐含于每一个非静态成员函数内</li><li><code>this</code> 指针不需要定义,可直接使用</li></ul></li><li><code>this</code> 指针的用途<ul><li>形参和成员变量同名时,可用 <code>this</code> 指针来区分</li><li>在类的非静态成员函数中返回对象本身,可使用 <code>return *this</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age)&#123;<br><span class="hljs-keyword">this</span>-&gt;age = age;  <span class="hljs-comment">// 当形参和成员变量同名时,可用 this 指针区分</span><br>&#125;<br><span class="hljs-function">Person&amp; <span class="hljs-title">addAge</span><span class="hljs-params">(Person&amp; p)</span></span>&#123;<br><span class="hljs-keyword">this</span>-&gt;age += p.age;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 返回对象本身</span><br>&#125;<br><span class="hljs-type">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li>空指针访问成员函数<ul><li>C++ 中空指针也是可以调用方法</li><li>但非静态属性前面默认有 <code>this</code> 指针,不可通过空指针调用</li><li>如果用到 <code>this</code> 指针,需要加以判断保证代码的健壮性</li></ul></li><li><code>const</code> 修饰成员函数<ul><li>常函数: 成员函数最后加 <code>const</code> 后称为常函数<ul><li><strong>常函数内不可以修改成员属性</strong></li><li>成员属性声明时加关键字 <code>mutable</code> 后,在常函数中依然可以修改</li></ul></li><li>常对象: 声明对象前加 <code>const</code> 称该对象为常对象<ul><li><strong>常对象不能修改成员变量,只能访问.因此只能调用常函数</strong></li><li>常对象可以修改 <code>mutable</code> 修饰成员变量.可访问 <code>public</code> 属性<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123; property1 = <span class="hljs-number">0</span>; property2 = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-comment">/* this 指针的类型为 Type* const this;</span><br><span class="hljs-comment">** this 指针的本质是一个指针常量,指针的指向不可修改</span><br><span class="hljs-comment">** 如果想让指针指向的值也不可以修改,需要声明常函数  */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>     <span class="hljs-comment">/* 成员函数加上 const,本质是在修饰 this 指针指向数据的类型</span><br><span class="hljs-comment">     ** 此时 this 指针类型为 const Type* const pointer</span><br><span class="hljs-comment">     ** 则 this 指向的数据不能修改,除使用 mutable 修饰的变量 */</span><br><span class="hljs-keyword">this</span>-&gt;property2 = <span class="hljs-number">100</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> property1;<br><span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> property2;  <span class="hljs-comment">// mutable: 可修改,可变的</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="2-4-友元"><a href="#2-4-友元" class="headerlink" title="2.4 友元"></a>2.4 友元</h3><ol><li>友元作用: 让函数或者类可以访问另一个类中的私有成员<ul><li>实现: 将类 &#x2F; 函数声明语句置于需要被访问私有成员的类中(无需权限修饰符)</li><li><strong>友元理论上提高程序的运行效率(因为无需进行类型检查,安全检查).但破坏了封装性</strong></li><li>示例: 全局函数做友元<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span> &#123;<br><span class="hljs-comment">/* 声明全局函数 goodGay 是 Building 类的友元 */</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building * building)</span></span>;<br><span class="hljs-keyword">public</span>:<span class="hljs-built_in">Building</span>()&#123;<span class="hljs-keyword">this</span>-&gt;m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;&#125;<br><span class="hljs-keyword">private</span>: string m_BedRoom; <span class="hljs-comment">// 卧室</span><br>&#125;;<br><br><span class="hljs-comment">/* 全局函数 goodGay 可以访问 Building 类的私有成员 m_BedRoom */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building * building)</span> </span>&#123;<br>cout &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>友元类: 友元类的所有方法均可访问其私有成员<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>;<br></code></pre></td></tr></table></figure><ul><li>友元关系不能继承.即友元类的子类不是友元类<ul><li>友元关系是单向的.即反向的友元关系需要在另一类中手动声明</li><li>友元关系不具有传递性.即友元的友元不是友元</li></ul></li></ul></li><li>友元函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">ClassName::func</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><ul><li>友元函数没有 <code>this</code> 指针</li><li>两个类需要共享数据时,可以将一个类的方法作为另一个类的友元函数</li></ul></li></ol><h3 id="2-5-运算符重载"><a href="#2-5-运算符重载" class="headerlink" title="2.5 运算符重载"></a>2.5 运算符重载</h3><ol><li>运算符重载<ul><li>对已有的运算符重定义,赋予其另一种功能 以适应不同的数据类型</li><li><strong>对于内置的数据类型的表达式,运算符含义不可改变,不要滥用运算符重载</strong></li><li>可以重载的运算符<table><thead><tr><th>类别</th><th>符号</th></tr></thead><tbody><tr><td>单目运算符</td><td>+(正), -(负), *(取值), &amp;(取址), ++, –</td></tr><tr><td>算术运算符</td><td><code>+, -, *, /, %</code></td></tr><tr><td>关系运算符</td><td><code>==, !=, &lt;, &gt;, &lt;=, &gt;=</code></td></tr><tr><td>逻辑运算符</td><td>&#96;</td></tr><tr><td>位运算符</td><td>&#96;</td></tr><tr><td>赋值运算符</td><td>&#96;&#x3D;, +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D;, %&#x3D;,</td></tr><tr><td>空间申请释放</td><td><code>new, delete, new[], delete[]</code></td></tr><tr><td>其他</td><td><code>()</code>(函数调用)  <code>,</code>(逗号)  <code>[]</code>(下标)</td></tr></tbody></table></li><li>不可重载的运算符<ul><li><code>.</code>(成员访问)  <code>-&gt;</code>(成员访问)  <code>::</code>(域访问)</li><li><code>sizeof</code>(长度计算)  <code>:?</code>(条件运算)  <code>#</code>(预处理)</li></ul></li></ul></li><li><code>+</code> 运算符重载<ul><li>示例: 对自定义的数据类型相加运算</li><li>实现方式: <strong>将成员 &#x2F; 全局函数名改为 <code>operator+</code> 即可重载 <code>+</code> 运算符</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">ClassName <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> ClassName&amp; p) &#123;<br>    ClassName temp;<br>    temp.property1 = <span class="hljs-keyword">this</span>-&gt;property1 + p.property1;<br>    temp.property2 = <span class="hljs-keyword">this</span>-&gt;property2 + p.property2;<br>    <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回加法运行后的结果(对象)</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><code>&lt;&lt;</code> 运算符重载<ul><li>示例: 输出自定义的数据类型</li><li>只能用全局函数重载 <code>&lt;&lt;</code>(可在类中加上 <code>friend</code> 通过友元函数实现访问私有成员)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// &lt;&lt; 运算符的参数为: out 以及 p 对象的引用</span><br><span class="hljs-comment">// 返回: ostream 类的引用,便于链式编程</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, ClassName&amp; p) &#123;<br>out &lt;&lt; p.property1 &lt;&lt; p.property2; <span class="hljs-comment">// 输出对象的属性</span><br><span class="hljs-keyword">return</span> out;<span class="hljs-comment">// out 是 ostream 对象</span><br>&#125;<br><span class="hljs-comment">// 本质上调用方式为 operator&lt;&lt;(cout, p) 被编译器简化为 cout &lt;&lt; p</span><br></code></pre></td></tr></table></figure></li></ul></li><li><code>++</code> 运算符重载<ul><li>示例: 通过重载递增运算符,实现自己的整型数据</li><li>前置递增返回引用,后置递增返回值</li><li>前置 <code>++</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">ClassName&amp; <span class="hljs-keyword">operator</span>++() &#123; <span class="hljs-comment">// 前置++ 返回计算后的引用</span><br>property++;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">// 操作后返回自身.可链式调用</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>后置 <code>++</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 参数列表的 int 为占位符(且只能为 int),表示这是后置++</span><br>ClassName <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>ClassName temp = *<span class="hljs-keyword">this</span>;<span class="hljs-comment">// 用临时对象存储初始对象</span><br>property++;<br><span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回操作后记录的对象.该实现不可链式调用</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><code>=</code> 运算符重载<ul><li>如果类中有属性指向堆区,做赋值操作时也会(拷贝构造也会)出现深浅拷贝问题</li><li>编译器在进行对象之间的赋值时,会进行浅拷贝.即单纯的值拷贝<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">ClassName&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ClassName &amp;p) &#123;  <span class="hljs-comment">// 编译器默认提供浅拷贝实现</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;p)  <span class="hljs-comment">// 处理自赋值</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">if</span> (ptr != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">delete</span> ptr;  <span class="hljs-comment">// 释放自身原本就有的指针成员变量</span><br>        ptr = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 释放后指向空指针</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (p.ptr != <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 解引用指针前保证不为空</span><br>        ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.ptr);  <span class="hljs-comment">// 深拷贝逻辑</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回自身.可链式调用</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>关系运算符重载: 让两个自定义类型对象进行对比操作  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> ClassName&amp; p) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;property == p.property) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br>    <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> ClassName&amp; p) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;property == p.property) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>    <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br>&#125;<br><span class="hljs-comment">// 类似的可以重载不等号 &lt;, &gt;, &lt;=, &gt;=</span><br></code></pre></td></tr></table></figure></li><li>函数调用运算符重载<ul><li><strong><code>()</code> 重载后使用的方式非常像函数的调用,因此称为仿函数</strong></li><li>仿函数没有固定写法,非常灵活</li></ul></li></ol><h3 id="2-6-继承"><a href="#2-6-继承" class="headerlink" title="2.6 继承"></a>2.6 继承</h3><ol><li>继承的优点: 减少重复的代码<ul><li>继承的的语法: <code>class 子类名: 继承方式 父类名 &#123;&#125;</code></li><li>继承方式(注意三种方式中,子类均无法访问父类 private 成员)<table><thead><tr><th>继承方式</th><th>关键字</th><th>特点</th></tr></thead><tbody><tr><td>公共继承</td><td><code>public</code></td><td>除私有成员,其他原封不动地继承</td></tr><tr><td>保护继承</td><td><code>protected</code></td><td>父类 <code>public, protected</code> 成员均继承为 <code>protected</code> 成员</td></tr><tr><td>私有继承</td><td><code>private</code></td><td>父类 <code>public, protected</code> 成员均继承为 <code>private</code> 成员</td></tr></tbody></table></li><li><strong>父类中所有非静态成员变量(静态成员仍会共享)都会被继承,包括私有成员</strong></li><li><strong>编译器隐藏了父类的私有成员,子类不可访问)</strong></li></ul></li><li>父类和子类的构造,析构顺序<ul><li><strong>先调用父类构造函数,再调用子类构造函数</strong></li><li>析构顺序与构造顺序相反.先析构子类对象,再析构父类对象</li></ul></li><li>继承时子类与父类同名成员处理<ul><li>访问子类同名成员: 直接访问.即对象优先访问本类的成员</li><li>访问父类同名成员: 需要加作用域 <code>p.FatherClass::property</code></li><li><strong>当子类与父类拥有同名的成员函数,子类会隐藏父类中所有同名成员函数(包括重载)</strong></li><li><strong>当发生函数隐藏时,子类对象需要加上作用域则可以访问到父类中同名函数</strong></li></ul></li><li>多继承: C++ 允许一个类继承多个类<ul><li>语法:<code> class 子类名: 继承方式 父类1 ,继承方式 父类2... &#123;&#125;</code></li><li>若父类间出现了同名情况,子类访问其成员时要加作用域</li></ul></li><li>菱形继承: 两个派生类继承同一个基类,而后某个类同时继承这两个派生类<ul><li>子类继承两份相同的数据,导致资源浪费以及毫无意义</li><li>利用虚继承(在继承方式前加上  <code>virtual</code> 关键字)可以解决菱形继承浪费资源问题</li></ul></li></ol><h3 id="2-7-虚函数"><a href="#2-7-虚函数" class="headerlink" title="2.7 虚函数"></a>2.7 虚函数</h3><ol><li><strong>虚函数目的: 通过父类对象指针(指向子类)访问子类定义的函数</strong><ul><li>函数最前面加上 <code>virtual</code> 关键字即成为虚函数</li><li>函数重写: 子类对父类(允许访问的)虚函数的实现过程进行重新编写(形参必须完全一致)</li><li>父类对象指针(指向子类)调用虚函数时,会优先寻找子类是否重写了该方法并调用</li><li><code>override</code> 关键字可以显式的声明该方法是对父类方法的重写</li></ul></li><li>纯虚函数<ul><li>在动态多态中,通常父类中虚函数的实现是毫无意义的</li><li><strong>调用的都是子类重写的内容.因此可以直接将父类的虚函数改为纯虚函数</strong></li><li>纯虚函数语法: <code>virtual 返回值类型 函数名(参数列表) = 0 ;</code></li></ul></li><li><strong>抽象类: 有纯虚函数的类</strong><ul><li>抽象类无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数,否则也属于抽象类</li></ul></li><li>虚析构<ul><li><strong>使用多态时,若父类没有将析构声明为虚析构,将导致析构时仅调用父类析构函数</strong></li><li>若此时子类中有属性开辟到堆区时,没有进行释放,从而导致内存泄露</li><li>解决方式: 将父类中的析构函数改为虚析构或者纯虚析构</li><li>注意: 若子类没有堆区数据待释放,则不需要虚析构函数</li></ul></li><li>虚析构和纯虚析构<ul><li>均可以通过父类指针释放子类对象</li><li>纯虚析构不仅要声明,还必须有具体的函数实现.否则编译报错</li></ul></li><li>虚函数表: 记录虚函数地址<ul><li>虚函数指针(vfptr, virtual function pointer): 指向虚函数表</li><li>当子类重写父类的虚函数时,子类的虚函数表存储的函数指针被替换重写函数的地址</li><li><strong>当父类引用子类对象时,调用虚函数会在子类的虚函数表中查找.实现多态</strong></li></ul></li></ol><h3 id="2-8-多态"><a href="#2-8-多态" class="headerlink" title="2.8 多态"></a>2.8 多态</h3><ol><li>多态分为: 静态 &#x2F; 动态<ul><li><strong>静态多态: 父类成员隐藏, 函数重载, 运算符重载, 泛型编程</strong></li><li><strong>动态多态: 子类重写方法和虚函数实现运行时多态</strong></li><li>静态多态的函数地址早绑定: 编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定: 运行阶段确定函数地址</li></ul></li><li>动态多态需满足条件<ul><li>存在继承关系</li><li>子类重写父类中的虚函数</li><li>父类指针(或引用)指向子类的对象</li></ul></li><li>多态案例: 分别利用普通方式和多态方式,实现对两个操作数进行运算的计算器类<ul><li><p>普通方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">(string oper)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;+&quot;</span>) &#123;<span class="hljs-keyword">return</span> num1 + num2;&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;-&quot;</span>) &#123;<span class="hljs-keyword">return</span> num1 - num2;&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;*&quot;</span>) &#123;<span class="hljs-keyword">return</span> num1 * num2;&#125;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> num1;<br><span class="hljs-type">int</span> num2;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>多态方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCalculator</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> num1;<br><span class="hljs-type">int</span> num2;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddCalculator</span>: <span class="hljs-keyword">public</span> AbstractCalculator<br>&#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> num1 + num2;&#125; &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubCalculator</span>: <span class="hljs-keyword">public</span> AbstractCalculator<br>&#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> num1 - num2;&#125; &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulCalculator</span>: <span class="hljs-keyword">public</span> AbstractCalculator<br>&#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> num1 * num2;&#125; &#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="3-异常"><a href="#3-异常" class="headerlink" title="3 异常"></a>3 异常</h2><h3 id="3-1-概念-待完成"><a href="#3-1-概念-待完成" class="headerlink" title="3.1 概念&#x3D;&#x3D;待完成&#x3D;&#x3D;"></a>3.1 概念&#x3D;&#x3D;待完成&#x3D;&#x3D;</h3><h2 id="4-文件-IO"><a href="#4-文件-IO" class="headerlink" title="4 文件 IO"></a>4 文件 IO</h2><ol><li>程序运行时产生的数据都属于临时数据,程序一旦运行结束都会被释放<ul><li>通过文件可以将数据持久化.C++ 中对文件操作需要包含头文件 <code>#include &lt;fstream&gt;</code></li></ul></li><li>文件类型分为<ul><li>文本文件: 文件以文本的 ASCII 码形式存储在计算机中</li><li>二进制文件: 文件以文本的二进制形式存储在计算机中,用户一般不能直接读懂它们</li></ul></li><li>操作文件的三大类:<ol><li><code>ofstream</code>: 写操作</li><li><code>ifstream</code>: 读操作</li><li><code>fstream</code>: 读写操作</li></ol></li></ol><h3 id="4-1-文本文件"><a href="#4-1-文本文件" class="headerlink" title="4.1 文本文件"></a>4.1 文本文件</h3><ol><li>写文件步骤<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>  <span class="hljs-comment">// 包含头文件</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>ofstream ofs;  <span class="hljs-comment">// 创建流对象</span><br>ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::out);  <span class="hljs-comment">// 打开文件</span><br>ofs &lt;&lt; <span class="hljs-string">&quot;姓名:张三&quot;</span> &lt;&lt; endl;  <span class="hljs-comment">// 写入数据</span><br>ofs &lt;&lt; <span class="hljs-string">&quot;性别:男&quot;</span> &lt;&lt; endl;<br>ofs.<span class="hljs-built_in">close</span>();  <span class="hljs-comment">// 关闭文件</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>文件打开方式<table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>读文件</td></tr><tr><td>ios::out</td><td>写文件</td></tr><tr><td>ios::ate</td><td>将文件指针置于文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在,先删除,再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><ul><li>注意: 文件打开方式可以配合使用,利用 <code>|</code> 操作符</li><li>例如: 用二进制方式写文件 <code>ios::binary |  ios:: out</code></li></ul></li><li>读文件与写文件步骤相似,但是读取方式相对于比较多<ul><li>读文件步骤<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>  <span class="hljs-comment">// 包含头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>ifstream ifs;  <span class="hljs-comment">// 创建流对象</span><br>ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::in);  <span class="hljs-comment">// 打开文件</span><br><br><span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>()) &#123;  <span class="hljs-comment">// 使用 is_open 方法判断是否打开成功</span><br>cout &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>    <span class="hljs-comment">// 在此处读取文件</span><br>    ifs.<span class="hljs-built_in">close</span>();  <span class="hljs-comment">// 关闭文件</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>4种读取方式<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1. 右移运算符将 ifs 中数据读入 buf.完毕后返回 false</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123; <span class="hljs-number">0</span> &#125;; <span class="hljs-comment">// 将 buf 全初始化为0</span><br><span class="hljs-keyword">while</span> (ifs &gt;&gt; buf) &#123; cout &lt;&lt; buf &lt;&lt; endl;&#125;<br><br><span class="hljs-comment">// 2. getline 方法读入一行.参数 str 为存放数据的地址,count 为最大读入数量</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123; <span class="hljs-number">0</span> &#125;; <span class="hljs-comment">// 将 buf 全初始化为0</span><br><span class="hljs-keyword">while</span> (ifs.<span class="hljs-built_in">getline</span>(buf,<span class="hljs-built_in">sizeof</span>(buf))) &#123; cout &lt;&lt; buf &lt;&lt; endl;&#125;<br><br><span class="hljs-comment">// 3. 全局函数 getline 读入一行</span><br>string buf;  <span class="hljs-comment">// 使用 string 对象进行维护</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(ifs, buf)) &#123; cout &lt;&lt; buf &lt;&lt; endl;&#125;<br><br><span class="hljs-comment">// 4. get 方法每次只读一个字符</span><br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span> ((c = ifs.<span class="hljs-built_in">get</span>()) != EOF) &#123;cout &lt;&lt; c;&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="4-2-二进制文件"><a href="#4-2-二进制文件" class="headerlink" title="4.2 二进制文件"></a>4.2 二进制文件</h3><ol><li>以二进制的方式对文件进行读写操作.打开方式要指定为 <code>ios::binary</code></li><li>写文件<ul><li>二进制方式写文件主要利用流对象调用成员函数 <code>write</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ostream&amp; <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buffer,<span class="hljs-type">int</span> len)</span></span>;<br><span class="hljs-comment">// buffer: 指向内存中一段存储空间</span><br><span class="hljs-comment">// len: 读写的字节数</span><br></code></pre></td></tr></table></figure></li><li>示例<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br><span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">// 二进制文件: 写数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">ofstream <span class="hljs-title">ofs</span><span class="hljs-params">(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;<br>Person p = &#123;<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>&#125;;<br>ofs.<span class="hljs-built_in">write</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)&amp;p, <span class="hljs-built_in">sizeof</span>(p));<br>ofs.<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>读文件<ul><li>二进制方式读文件主要利用流对象调用成员函数 <code>read</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">istream&amp; <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">char</span> *buffer,<span class="hljs-type">int</span> len)</span></span>;<br><span class="hljs-comment">// buffer: 指向内存中一段存储空间</span><br><span class="hljs-comment">// len: 读写的字节数</span><br></code></pre></td></tr></table></figure></li><li>示例<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br><span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;<br><span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>Person p;<br>ifs.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span> *)&amp;p, <span class="hljs-built_in">sizeof</span>(p));<br><br>cout &lt;&lt; <span class="hljs-string">&quot;姓名: &quot;</span> &lt;&lt; p.name &lt;&lt; <span class="hljs-string">&quot; 年龄: &quot;</span> &lt;&lt; p.age &lt;&lt; endl;<br>    ifs.<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="5-模板"><a href="#5-模板" class="headerlink" title="5 模板"></a>5 模板</h2><h3 id="5-1-函数模板"><a href="#5-1-函数模板" class="headerlink" title="5.1 函数模板"></a>5.1 函数模板</h3><ol><li><p>泛型编程是一种编程思想,主要利用的技术就是模板</p></li><li><p><strong>函数模板作用: 对类型进行参数化</strong></p></li></ol><ul><li>建立通用函数,其返回值类型和形参类型可以不具体指定,用虚拟类型来代表</li></ul><ol start="3"><li><p>函数模板语法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 后面接函数声明或定义</span><br></code></pre></td></tr></table></figure><ul><li><p><code>template</code> 关键字.用于声明创建模板</p></li><li><p><code>typename</code> 表明其后面的符号是一种数据类型,可以用 <code>class</code> 代替</p></li><li><p><code>T</code>: 通用的数据类型.名称可以替换,通常大写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> </span>&#123;<br>T temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">mySwap</span>(a, b);       <span class="hljs-comment">// 自动进行类型推导</span><br><span class="hljs-built_in">mySwap</span>&lt;<span class="hljs-type">int</span>&gt;(a, b);<span class="hljs-comment">// 显式地指定类型</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自动类型推导,必须推导出一致的数据类型 <code>T</code>,才可使用</p></li><li><p>模板必须要确定出 <code>T</code> 的数据类型,才可使用</p></li></ul></li><li><p>普通函数与函数模板的区别</p><ul><li>类型转换<ul><li>普通函数调用时,可以发生自动类型转换(隐式类型转换)</li><li>函数模板进行自动类型推导时,不会发生隐式类型转换</li><li>函数模板显式指定类型时,可以发生隐式类型转换</li></ul></li><li>调用规则<ul><li><strong>若函数模板和普通函数都可以调用,则优先调用普通函数</strong></li><li>可以通过空模板参数列表来强制调用函数模板.即 <code>&lt;&gt;</code> 里为空</li><li>如果函数模板可以产生更好的匹配,则优先调用函数模板</li></ul></li></ul></li><li><p>模板的重载</p><ul><li>为这些特定的类型提供具体化的模板<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-type">bool</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(T&amp; a, T&amp; b)</span>      <span class="hljs-comment">// 模板</span></span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-type">bool</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(Person &amp;p1, Person &amp;p2)</span> <span class="hljs-comment">// 重载的,更为具体的模板</span></span><br><span class="hljs-function"><span class="hljs-comment">// Person 是用户自定义的一个数据类型</span></span><br></code></pre></td></tr></table></figure><ul><li>显式具体化的参数类型.且以 <code>template&lt;&gt;</code> 开头</li><li><strong>调用时,具体化参数的函数模板优先于更广泛的模板</strong></li></ul></li><li>利用具体化的模板,可以解决自定义类型的通用化</li><li><strong>学习模板并不是为了写模板,而是在 STL 能够运用系统提供的模板</strong></li></ul></li></ol><h3 id="5-2-类模板"><a href="#5-2-类模板" class="headerlink" title="5.2 类模板"></a>5.2 类模板</h3><ol><li><strong>类模板作用: 建立通用类.类中成员的数据类型可不具体指定,用虚拟的类型来代表</strong></li><li>类模板和函数模板语法相似<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;  <span class="hljs-comment">// 类模板声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(T1 name, T2 age) &#123;<br><span class="hljs-keyword">this</span>-&gt;name = name;<br><span class="hljs-keyword">this</span>-&gt;age = age;<br>&#125;<br><br>T1 name;<br>T2 age;<br>&#125;;<br><br><span class="hljs-comment">// 创建对象.string 类型传递给 T1, int 类型传递给 T2</span><br>Person&lt;string, <span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure></li><li>类模板和函数模板的区别<ul><li><strong>类模板不能自动类型推导,必须显式指定</strong></li><li>类模板在模板参数列表中可以有默认参数(写在声明的地方)</li></ul></li><li><strong>类模板中的方法在调用时才创建(区别于普通方法在编译时即可创建)</strong></li><li>类模板对象做函数参数<ul><li><p><strong>指定传入的类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Person&lt;string, <span class="hljs-type">int</span>&gt;&amp; p)</span></span>;  <span class="hljs-comment">// 显式指定模板对象的数据类型</span><br></code></pre></td></tr></table></figure></li><li><p>参数模板化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;   <span class="hljs-comment">// 将函数改为函数模板</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Person&lt;T1, T2&gt;&amp; p)</span></span>;  <span class="hljs-comment">// 模板对象中的参数以虚拟类型进行传递</span><br></code></pre></td></tr></table></figure></li><li><p>整个类模板化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T&amp; p)</span></span>;  <span class="hljs-comment">// 将对象类型模板化进行传递</span><br></code></pre></td></tr></table></figure></li></ul></li><li>类模板与继承<ul><li>当子类继承类模板时.声明时要指定出父类中 <code>T</code> 的类型(若不指定,编译器无法给子类分配内存)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>: <span class="hljs-keyword">public</span> Person&lt;string, <span class="hljs-type">int</span>&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure></li><li>如果想灵活指定出父类中 <code>T</code> 的类型,子类也需变为类模板<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>: <span class="hljs-keyword">public</span> Person&lt;T1, T2&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li>类模板成员函数的类外实现,需要加上模板参数列表<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Person</span>(T1 name, T2 age);      <span class="hljs-comment">// 类内声明</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>&gt;  <span class="hljs-comment">// 类外实现</span><br>Person&lt;T1, T2&gt;::<span class="hljs-built_in">Person</span>(T1 name, T2 age) &#123;&#125;<br></code></pre></td></tr></table></figure></li><li>类模板分文件编写(类模板中成员函数创建于调用阶段,会导致分文件编写时链接不到)<ul><li>直接包含 <code>.cpp</code> 源文件</li><li><strong>将声明和实现写到同一个文件中,并更改后缀名为 <code>.hpp</code></strong></li></ul></li><li>类模板与友元<ul><li>全局函数类内实现: 直接在类内声明友元</li><li>全局函数类外实现: 需要提前让编译器知道全局函数的存在(复杂)</li></ul></li></ol><h2 id="6-STL"><a href="#6-STL" class="headerlink" title="6 STL"></a>6 STL</h2><h3 id="6-1-STL-简介"><a href="#6-1-STL-简介" class="headerlink" title="6.1 STL 简介"></a>6.1 STL 简介</h3><ol><li>STL 诞生<ul><li>C++ 的面向对象和泛型编程思想,目的是提高代码复用性</li><li>而数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</li><li>为建立数据结构和算法的一套标准,诞生了 STL</li></ul></li><li>STL 概念<ul><li>STL(Standard Template Library,标准模板库)</li><li><strong>STL 从广义上分为: 容器(container), 算法(algorithm), 迭代器(iterator)</strong></li><li>容器和算法之间通过迭代器进行无缝连接</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul></li><li>STL 六大组件<ul><li><strong>容器</strong>: 各种数据结构,如 <code>vector,list,deque,set,map...</code></li><li><strong>算法</strong>: 各种常用的算法,如 <code>sort,find,copy,for_each...</code></li><li><strong>迭代器</strong>: 容器与算法之间的胶合剂</li><li><strong>仿函数</strong>: 行为类似函数,可作为算法的某种策略</li><li><strong>适配器</strong>: 修饰容器, 仿函数, 迭代器接口</li><li><strong>空间配置器</strong>: 负责空间的配置与管理</li></ul></li></ol><h3 id="6-2-组件"><a href="#6-2-组件" class="headerlink" title="6.2  组件"></a>6.2  组件</h3><ol><li><p>容器: 存放数据的地方</p><ul><li>STL 容器: 实现运用最广泛的一些数据结构</li><li>常用数据结构: 数组, 链表, 树, 栈, 队列, 集合, 映射表…</li><li><strong>序列式容器</strong>: 强调排序.每个元素有固定的位置</li><li><strong>关联式容器</strong>: 二叉树结构.各元素之间没有严格的物理上的顺序关系</li></ul></li><li><p>算法: 解决问题的步骤</p><ul><li>用有限的步骤,解决逻辑或数学上的问题,称为算法(Algorithms)</li><li><strong>质变算法</strong>: 运算过程中会更改区间内的元素的内容. 如拷贝, 替换, 删除…</li><li><strong>非质变算法</strong>: 运算过程中不会更改区间内的元素内容. 如查找, 计数, 遍历, 寻找极值…</li></ul></li><li><p>迭代器: 容器和算法之间粘合剂</p><ul><li><p>能够依序寻访某个容器的元素,又无需暴露该容器的内部表示方式</p></li><li><p>每个容器都有自己专属的迭代器.算法通过迭代器访问容器的元素</p></li><li><p>迭代器使用非常类似于指针,初学阶段可以先理解迭代器为指针</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读. 支持 ++, &#x3D;&#x3D;, !&#x3D;</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写. 支持 ++</td></tr><tr><td>前向迭代器</td><td>读写操作,并能向前推进迭代器</td><td>读写. 支持 ++, &#x3D;&#x3D;, !&#x3D;</td></tr><tr><td>双向迭代器</td><td>读写操作,并能向前和向后操作</td><td>读写. 支持 ++, –</td></tr><tr><td>随机访问迭代器</td><td>读写操作,可以以跳跃的方式访问任意数据</td><td>读写. 支持 ++, –, [n], -n, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;</td></tr></tbody></table></li><li><p><strong>常用的容器中迭代器种类为双向迭代器, 随机访问迭代器</strong></p></li></ul></li></ol><h3 id="6-3-STL-使用示例"><a href="#6-3-STL-使用示例" class="headerlink" title="6.3 STL 使用示例"></a>6.3 STL 使用示例</h3><ol><li><p><code>vector</code> 存放内置数据类型</p><ul><li><p>STL中最常用的容器为 <code>vector</code>.可理解为数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v; <span class="hljs-comment">// 创建 vector 容器对象 v,并且指定容器中存放的数据的类型为 int</span><br></code></pre></td></tr></table></figure></li><li><p>算法: <code>for_each</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  <span class="hljs-comment">// 算法头文件</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 一个任意的函数声明</span><br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), func);  <span class="hljs-comment">// 对容器中的每个元素,调用 func 函数</span><br></code></pre></td></tr></table></figure></li><li><p>迭代器: <code>vector&lt;int&gt;::iterator</code></p><ul><li>每一个容器都有自己的迭代器.用来遍历容器中的元素</li><li><code>vector&lt;int&gt;::iterator</code> 获取 <code>vector&lt;int&gt;</code> 容器的迭代器类型</li></ul></li><li><p>遍历容器的方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt;::iterator pBegin = v.<span class="hljs-built_in">begin</span>();  <span class="hljs-comment">// 迭代器.指向容器中首元素</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator pEnd = v.<span class="hljs-built_in">end</span>();  <span class="hljs-comment">// 迭代器.指向容器尾元素的下一个位置</span><br><span class="hljs-keyword">while</span> (pBegin != pEnd) &#123;<br>    cout &lt;&lt; *pBegin &lt;&lt; endl;<br>    pBegin++;<br>&#125;<br><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>存放自定义数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;ClassName&gt; v;  <span class="hljs-comment">// 创建容器 v.元素为 ClassName 类型,可为自定义数据类名称</span><br>ClassName p;<br>v.<span class="hljs-built_in">push_back</span>(p); <span class="hljs-comment">// 对容器 v 进行尾插</span><br></code></pre></td></tr></table></figure></li><li><p><code>vector</code> 容器嵌套容器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt; vector&lt;<span class="hljs-type">int</span>&gt; &gt;  v;  <span class="hljs-comment">// 创建容器 v.元素为 vector&lt;int&gt;</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>v.<span class="hljs-built_in">push_back</span>(v1);<br><span class="hljs-comment">// 嵌套循环遍历输出容器 v</span><br><span class="hljs-keyword">for</span> (vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator vit = (*it).<span class="hljs-built_in">begin</span>(); vit != (*it).<span class="hljs-built_in">end</span>(); vit++) &#123;<br>        cout &lt;&lt; *vit &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="7-STL-常用容器"><a href="#7-STL-常用容器" class="headerlink" title="7 STL 常用容器"></a>7 STL 常用容器</h2><h3 id="7-1-string"><a href="#7-1-string" class="headerlink" title="7.1 string"></a>7.1 <code>string</code></h3><ol><li><p><code>string</code> 本质: C++ 风格的字符串,是一个类</p><ul><li><p>使用 <code>string</code> 需要包含头文件(也可以是在 <code>std</code> 名称空间的 <code>&lt;string&gt;</code> 中定义)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>string</code> 和 <code>char*</code> 区别</p><ul><li><p><code>char*</code> 是一个指针,字符数组使用 <code>&#39;\0&#39;</code> 标识结尾</p></li><li><p><code>string</code> 是一个类.内部封装 <code>char*</code>,管理这个字符串.是 <code>char*</code> 型的容器</p></li><li><p><code>string</code> 管理 <code>char*</code> 所分配的内存,不用担心复制越界和取值越界等</p></li></ul></li><li><p>原始字符串(R 前缀.中间不能含有 <code>)&quot;</code>.因为要以其作为结尾)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* c = <span class="hljs-string">R&quot;(E:\notes)&quot;</span>;  <span class="hljs-comment">// 括号中的内容不会被转义 E:\notes</span><br></code></pre></td></tr></table></figure></li><li><p><code>string</code> 字面量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> s1 &#123;<span class="hljs-string">&quot;hello&quot;</span>&#125;;  <span class="hljs-comment">// s1 类型为 const char*</span><br><span class="hljs-keyword">auto</span> s2 &#123;<span class="hljs-string">&quot;world&quot;</span>s&#125;; <span class="hljs-comment">// s2 类型为 std::string</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>运算符重载</p><ul><li><p><code>string</code> 字符串比较(可以使用 <code>&lt;, &lt;=, &gt;, &gt;=, ==</code> 关系运算符直接比较)</p></li><li><p><code>string</code> 字符索引</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> n);  <span class="hljs-comment">// 直接用 [] 运算符索引</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>获取长度</strong>: <code>size(), length()</code> 方法</p></li><li><p>构造与赋值</p><ul><li><p><code>string</code> 对象可用 <code>const char*, string, char</code> 构造 <code>string</code> 对象</p></li><li><p><code>string</code> 对象赋值: 可用赋值符 <code>=</code> 或 <code>assign</code> 方法进行赋值</p></li><li><p><strong><code>string</code> 对象拼接: 可用复合赋值符 <code>+=</code> 或 <code>append</code> 方法</strong></p></li></ul></li><li><p>查找和替换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">int</span> pos = npos)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-comment">// find 从左往后查找,rfind 从右往左查找</span><br><span class="hljs-comment">// find 找到字符串后返回查找的第一个字符的索引,找不到返回-1</span><br><span class="hljs-function">string&amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> n, <span class="hljs-type">const</span> string&amp; str)</span></span>;<br><span class="hljs-comment">// replace 需指定: 起始索引位置, 字符数量, 待替换为的字符串</span><br></code></pre></td></tr></table></figure></li><li><p>插入和删除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> string&amp; str)</span></span>;  <span class="hljs-comment">// 在指定的索引处插入</span><br><span class="hljs-function">string&amp; <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> n = npos)</span></span>;  <span class="hljs-comment">// 删除 pos 索引开始的 n 个字符</span><br></code></pre></td></tr></table></figure></li><li><p><code>string</code> 子串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">substr</span><span class="hljs-params">(<span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> n = npos)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-comment">// 返回由 pos 位置开始的 n个字符组成的字符串</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="7-2-vector"><a href="#7-2-vector" class="headerlink" title="7.2 vector"></a>7.2 <code>vector</code></h3><ol><li><p><code>vector</code> 数据结构和数组非常相似,也称单端数组</p><ul><li><p><strong>数组是静态空间,而 <code>vector</code> 可以动态扩展</strong></p></li><li><p><code>vector</code> 容器的迭代器支持随机访问</p></li><li><p>使用 <code>vector</code> 容器需要包含头文件(后面的容器同理)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>vector</code> 构造与赋值</p><ul><li><code>vector</code> 可用 指定迭代器的区间, 或指定大小 n 和元素 elem 的方式进行构造</li><li><code>vector</code> 赋值: 可用赋值符 <code>=</code> 或 <code>assign</code> 方法</li></ul></li><li><p><code>vector</code> 容量与大小</p><ul><li>判断为空: <code>empty()</code></li><li>获取容量: <code>capacity()</code></li><li><strong>获取大小: <code>size()</code></strong></li><li>重分配大小: <code>resize(int num, elem)</code></li></ul></li><li><p><code>vector</code> 插入和删除</p><ul><li><strong>尾插: <code>push_back(ele)</code></strong></li><li><strong>尾删: <code>pop_back()</code></strong></li><li>插入: <code>insert(const_iterator pos, ele)</code></li><li>删除: <code>erase(const_iterator pos)</code></li><li>清空: <code>clear()</code></li></ul></li><li><p><code>vector</code> 数据存取</p><ul><li>获取第一个元素: <code>front()</code></li><li>获取最后一个元素: <code>back()</code></li><li><strong>访问 <code>vector</code> 中元素可直接用<code>[]</code>访问.或用 <code>at</code> 方法</strong></li></ul></li><li><p><code>vector</code> 互换容器来收缩容量(使得容量 &#x3D;&#x3D; 大小)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-comment">// 对 v 的元素进行一系列操作改变 v 的容量后...</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v).<span class="hljs-built_in">swap</span>(v);  <span class="hljs-comment">// 收缩 v 的容量.使得容量 == 大小</span><br><span class="hljs-comment">/* 解释: vector&lt;int&gt;(v) 是一个根据 v 创建的匿名对象.</span><br><span class="hljs-comment">该匿名对象与 v 进行互换,然后本行结束后被自动回收 */</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="7-3-deque"><a href="#7-3-deque" class="headerlink" title="7.3 deque"></a>7.3 <code>deque</code></h3><ol><li><strong><code>deque</code>: 双端数组,可以对头端进行插入删除操作</strong><ul><li><code>deque</code>与 <code>vector</code> 区别<ul><li><code>vector</code> 对于头部的插入 &#x2F; 删除效率低,但访问元素时的速度</li><li><code>deque</code>  对头部的插入 &#x2F; 删除速度比 <code>vector</code> 快</li><li><code>deque</code> 没有容量的概念</li></ul></li><li><code>deque</code> 内部工作原理<ul><li><code>deque</code> 内部有个中控器,维护每段缓冲区中存放的真实数据</li><li>中控器维护的是每个缓冲区的地址,本质上内存空间并不连续</li></ul></li></ul></li><li><strong><code>deque</code> 构造方法, 赋值, 获取大小, 数据存取 均与 <code>vector</code> 容器类似</strong></li><li><code>deque</code> 插入和删除<ul><li>尾插: <code>push_back(elem)</code></li><li>尾删: <code>pop_back()</code></li><li><strong>头插: <code>push_front(elem)</code></strong></li><li><strong>头删: <code>pop_front()</code></strong></li><li>插入: <code>insert(const_iterator pos, ele)</code></li><li>删除: <code>erase(const_iterator pos)</code></li><li>清空: <code>clear()</code></li></ul></li></ol><h3 id="7-4-list"><a href="#7-4-list" class="headerlink" title="7.4 list"></a>7.4 <code>list</code></h3><ol><li><p><code>list</code> 基本概念</p><ul><li>链表(list)是一种物理存储单元上非连续的存储结构</li><li>数据元素的逻辑顺序是通过链表中的指针链接实现的<ul><li>链表的组成: 链表由一系列<strong>结点</strong>组成</li><li>结点的组成: 存储数据元素的<strong>数据域</strong>,及存储下一个结点地址的<strong>指针域</strong></li></ul></li></ul></li><li><p>STL 中的链表是一个双向循环链表</p><ul><li><p><strong>STL 中 <code>list</code> 和 <code>vector</code> 是两个最常被使用的容器,各有优缺点</strong></p></li><li><p><code>list</code> 的优点</p><ul><li><p>采用动态存储分配,不会造成内存浪费和溢出</p></li><li><p>链表的插入和删除非常方便(修改指针即可).不需要移动大量元素</p></li><li><p><code>list</code> 的插入操作和删除不会造成原有 <code>list</code> 迭代器失效(<code>vector</code>会)</p></li></ul></li><li><p><code>list</code> 的缺点</p><ul><li>空间(存储指针域)与时间(沿着指针遍历)额外耗费较大</li><li><code>list</code> 中的迭代器只支持前移和后移.属于双向迭代器(不能随机访问)</li></ul></li></ul></li><li><p><strong><code>list</code> 构造, 赋值, 获取大小, 插入, 删除, 获取头尾元素的 API 与 <code>deque </code> 基本一致</strong></p></li><li><p><code>list</code> 容器不可以通过 <code>[]</code> 或者 <code>at()</code> 方法 访问数据</p></li><li><p><code> list</code> 反转链表: <code>reverse()</code></p></li></ol><h3 id="7-5-stack"><a href="#7-5-stack" class="headerlink" title="7.5 stack"></a>7.5 <code>stack</code></h3><ol><li><code>stack</code> 基本概念<ul><li><code>stack</code> 特点为: 先进后出(First In Last Out, FILO)</li><li>栈中只有顶端的元素才可以被外界使用.因此栈不允许遍历</li></ul></li><li>构造与赋值<ul><li>创建空栈: <code>stack&lt;T&gt; stk</code></li><li>赋值可以通过 <code>=</code> 赋值</li></ul></li><li>数据存取<ul><li><strong>入栈: <code>push(elem)</code></strong></li><li><strong>出栈: <code>pop()</code></strong></li><li><strong>获取栈顶元素: <code>top()</code></strong></li></ul></li><li>获取大小<ul><li>判断为空: <code>empty()</code></li><li>获取大小: <code>size() </code></li></ul></li></ol><h3 id="7-6-queue"><a href="#7-6-queue" class="headerlink" title="7.6 queue"></a>7.6 <code>queue</code></h3><ol><li><code>queue</code> 基本概念<ul><li><code>queue</code> 特点为: 先进先出(First In First Out,FIFO)</li><li>队列中只有队头和队尾才可以被外界使用.因此队列不允许遍历</li><li><strong><code>queue</code> 容器的 API 与 <code>stack</code> 容器基本一致</strong></li></ul></li><li>构造与赋值<ul><li>创建空队列: <code>queue&lt;T&gt; que</code></li><li>赋值可以通过 <code>=</code> 赋值</li></ul></li><li>数据存取：<ul><li><strong>入队: <code>push(elem)</code></strong></li><li><strong>出队: <code>pop()</code></strong></li><li><strong>获取队尾元素: <code>back()</code></strong></li><li><strong>获取队头元素: <code>front()</code></strong></li></ul></li><li>获取大小<ul><li>判断为空: <code>empty()</code></li><li>获取大小: <code>size() </code></li></ul></li></ol><h3 id="7-7-set"><a href="#7-7-set" class="headerlink" title="7.7 set"></a>7.7 <code>set</code></h3><ol><li><code>set</code>: 所有元素都会在插入时自动被排序<ul><li><strong><code>set/multiset</code> 属于关联式容器,底层结构用二叉树实现</strong></li><li><code>set</code> 和 <code>multiset</code> 区别<ul><li><code>set</code> 插入元素会返回插入结果,表示插入是否成功.且不允许容器中有重复的元素</li><li><code>multiset</code> 不会检测数据,因此可以插入重复元素</li></ul></li></ul></li><li><code>set</code> 构造: 使用 <code>set&lt;T&gt; st;</code> 创建空容器</li><li><code>set</code> 大小和交换<ul><li>获取大小: <code>size()</code></li><li>判断为空: <code>empty()</code></li><li>交换容器: <code>swap(st)</code></li></ul></li><li><code>set</code> 插入和删除<ul><li>插入: <code>insert(elem)</code></li><li>删除: <code>erase(elem)</code></li><li>清空: <code>clear()</code></li></ul></li><li><code>set</code> 查找和统计<ul><li><strong>查找: <code>find(key)</code></strong></li><li><strong>统计: <code>count(key)</code></strong></li></ul></li></ol><h3 id="7-8-map"><a href="#7-8-map" class="headerlink" title="7.8 map"></a>7.8 <code>map</code></h3><ol><li><p><code>pair</code> 对组: 成对出现的数据.利用对组可以返回两个数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">pair&lt;type1, type2&gt; <span class="hljs-title">p</span><span class="hljs-params">(key, value)</span></span>;<br>pair&lt;type1, type2&gt; p = <span class="hljs-built_in">make_pair</span>(key, value);<br><span class="hljs-comment">// 第一个元素为键值,起到索引作用</span><br><span class="hljs-comment">// 第二个元素为实值</span><br></code></pre></td></tr></table></figure></li><li><p><code>map</code> 中元素为 <code>pair</code>.且根据元素的 <code>key</code> 自动排序</p><ul><li><strong><code>map/multimap</code> 属于关联式容器,底层结构是用二叉树实现</strong></li><li>优点: 可以根据 <code>key</code> 快速找到 <code>value</code></li></ul></li><li><p><code>map</code> 和 <code>multimap</code>区别</p><ul><li><code>map</code> 不允许重复 <code>key</code> 值元素</li><li><code>multimap</code> 允许重复 <code>key</code> 值元素</li></ul></li><li><p><code>map</code> 构造: 使用 <code>map&lt;T1, T2&gt; mp;</code> 创建空容器</p></li><li><p><code>map</code> 获取大小, 插入, 删除, 查找, 统计的 API 与 <code>set</code> 基本一致</p><ul><li><code>mp[key]</code>: 访问 <code>key</code> 对应的 <code>value</code></li></ul></li></ol><h2 id="8-STL-常用算法"><a href="#8-STL-常用算法" class="headerlink" title="8 STL 常用算法"></a>8 STL 常用算法</h2><p>STL 算法主要包含于头文件 <code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code></p><ul><li><code>&lt;algorithm&gt;</code> 是 STL 中最大的一个.涉及比较, 交换, 查找, 遍历操作, 复制, 修改…</li><li><code>&lt;numeric&gt;</code> 体积很小,只包括几个在序列上面进行的简单数学运算的模板函数</li><li><code>&lt;functional&gt;</code> 定义了一些模板类,用于声明函数对象</li></ul><h3 id="8-1-函数对象"><a href="#8-1-函数对象" class="headerlink" title="8.1 函数对象"></a>8.1 函数对象</h3><ol><li><p><strong>函数对象</strong>: 重载了函数调用操作符 <code>()</code>的类对象.也称仿函数</p><ul><li>函数对象在使用时.可像普通函数那样调用: 有参数,有返回值</li><li>函数对象超出普通函数的概念: 可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul></li><li><p><strong>谓词</strong>: 返回 <code>bool</code> 类型的仿函数</p><ul><li>如果 <code>operator()</code> 接受一个参数,称为一元谓词</li><li>如果 <code>operator()</code> 接受两个参数,称为二元谓词</li></ul></li><li><p><strong>STL 内建的函数对象: 算术仿函数, 关系仿函数, 逻辑仿函数</strong></p><ul><li><p>需要内建函数对象需要包含头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>这些仿函数所产生的对象,用法和普通函数完全相同</p></li><li><p>函数原型形如: <code>template&lt;class T&gt; T plus&lt;T&gt;</code></p></li></ul></li><li><p>算术仿函数实现四则运算(<code>+ - * / %</code>)</p><ul><li><p>对应的仿函数名称为: <code>plus, minus, multiplies, divides, modulus</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">plus&lt;<span class="hljs-type">int</span>&gt; p;  <span class="hljs-comment">// 加法仿函数.虽然是二元运算,但要求两者类型相同,仍只需一个类型标识</span><br><span class="hljs-built_in">p</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">// 结果为 30</span><br></code></pre></td></tr></table></figure></li><li><p>另外,还有 <code>negate</code> 是一元运算,表示取负</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">negate&lt;<span class="hljs-type">int</span>&gt; neg;  <span class="hljs-comment">// 取负仿函数</span><br><span class="hljs-built_in">neg</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 结果为 -10</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>关系仿函数实现比较运算(<code>= != &gt; &gt;= &lt; &lt;=</code>)</p><ul><li><p>对应的仿函数名称为: <code>equal_to, not_equal_to, greater, greater_equal, less, less_equal</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-comment">// sort 算法可以使用仿函数指定排序规则.默认升序排列 less&lt;&gt;()</span><br><span class="hljs-comment">// greater&lt;int&gt;() 是匿名对象,实现降序排列</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>逻辑仿函数实现逻辑运算(<code>&amp;&amp; || !</code>)</p><ul><li>对应的仿函数名称为: <code>logical_and, logical_or, logical_not</code></li></ul></li></ol><h3 id="8-2-遍历"><a href="#8-2-遍历" class="headerlink" title="8.2 遍历"></a>8.2 遍历</h3><ol><li><p><strong><code>for_each</code>: 遍历容器</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">for_each(iterator beg, iterator end, _func);<br><span class="hljs-comment">// beg: 开始迭代器</span><br><span class="hljs-comment">// end: 结束迭代器</span><br><span class="hljs-comment">// _func: 函数名 或 函数对象</span><br></code></pre></td></tr></table></figure></li><li><p><code>transform</code>: 将容器中的元素转移到目标容器(目标容器必须要提前申请空间)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">transform</span>(iterator beg1, iterator end1, iterator beg2, _func);<br><span class="hljs-comment">// beg1: 源容器开始迭代器</span><br><span class="hljs-comment">// end1: 源容器结束迭代器</span><br><span class="hljs-comment">// beg2: 目标容器开始迭代器</span><br><span class="hljs-comment">// _func: 函数名 或 函数对象</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="8-3-查找"><a href="#8-3-查找" class="headerlink" title="8.3 查找"></a>8.3 查找</h3><ul><li>查找: <code>find</code></li><li>按条件查找: <code>find_if</code></li><li>查找相邻重复元素: <code>adjacent_find</code></li><li>二分查找: <code>binary_search</code></li><li>统计: <code>count</code></li><li>按条件统计: <code>count_if</code></li></ul><h3 id="8-4-排序"><a href="#8-4-排序" class="headerlink" title="8.4 排序"></a>8.4 排序</h3><ul><li>排序: <code>sort</code></li><li>洗牌: <code>random_shuffle</code></li><li>合并: <code>merge </code></li><li>翻转: <code>reverse</code></li></ul><h3 id="8-5-拷贝和替换"><a href="#8-5-拷贝和替换" class="headerlink" title="8.5 拷贝和替换"></a>8.5 拷贝和替换</h3><ul><li>拷贝: <code>copy</code></li><li>替换: <code>replace</code></li><li>按条件替换: <code>replace_if </code></li><li>交换元素: <code>swap</code></li></ul><h3 id="8-6-常用算术生成算法"><a href="#8-6-常用算术生成算法" class="headerlink" title="8.6 常用算术生成算法"></a>8.6 常用算术生成算法</h3><ul><li>算术生成算法属于小型算法,需包含的头文件为 <code>#include &lt;numeric&gt;</code></li><li>计算元素总和: <code>accumulate</code></li><li>添加元素: <code>fill</code></li></ul><h3 id="8-7-并-交-差"><a href="#8-7-并-交-差" class="headerlink" title="8.7 并,交,差"></a>8.7 并,交,差</h3><ul><li>交集: <code>set_intersection</code></li><li>并集: <code>set_union</code></li><li>差集: <code>set_difference </code></li></ul><h2 id="9-附录"><a href="#9-附录" class="headerlink" title="9 附录"></a>9 附录</h2><h3 id="9-1-C-源文件中包含-C-文件"><a href="#9-1-C-源文件中包含-C-文件" class="headerlink" title="9.1 C++ 源文件中包含 C 文件"></a>9.1 C++ 源文件中包含 C 文件</h3><ol><li><p>假设一个头文件声明了 C 语言的函数和全局变量,但却可能会被 C++ 代码包含,则需要特殊处理</p><ul><li><p>因为 C++ 编译器对符号修饰的处理与 C 不同,因而导致链接出错</p></li><li><p>C++ 具有 <code>extern &quot;C&quot;</code> 关键字,用于处理与 C 的兼容性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>    <span class="hljs-type">int</span> var;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>处理方式: 正常编写 C 程序.而使用预编译指令处理头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// C function declarations here</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li><p>对于 C 程序对该文件被展开为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C function declarations here</span><br></code></pre></td></tr></table></figure></li><li><p>对于 C++, 则展开为(因为 C++ 编译时会默认定义 <code>__cplusplus</code> 宏)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-comment">// C function declarations here</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="9-2-编译过程"><a href="#9-2-编译过程" class="headerlink" title="9.2 编译过程"></a>9.2 编译过程</h3><ol><li><p>将某个 C 源文件编译为 windows 动态库文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc filename.c -fPIC -shared -o filename.dll<br></code></pre></td></tr></table></figure></li><li><p>编译 <code>main.cpp</code> 并链接 <code>filename.dll</code> 库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ main.cpp -L.-lfilename -o main<br></code></pre></td></tr></table></figure><ul><li><code>-L</code>: 库文件位于当前目录</li><li><code>.</code>: 当前目录</li><li><code>-l</code>: 链接(link) dll 库</li></ul></li><li><p>直接运行 <code>main.exe</code> 即可</p></li></ol><h3 id="9-3-nullptr"><a href="#9-3-nullptr" class="headerlink" title="9.3 nullptr"></a>9.3 <code>nullptr</code></h3><ol><li><p>NULL 在 C++ 的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NULL</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _WIN64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL 0LL</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* W64 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL ((void *)0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li>C++ 定义 NULL 为 0</li><li>C 定义 NULL 为 <code>((void *) 0)</code></li></ul></li><li><p>由于 C++ 允许函数重载,若出现重载的函数形如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> *)</span></span>;<br><span class="hljs-comment">// 若函数调用 func(NULL),将导致语义模糊</span><br><span class="hljs-built_in">func</span>(<span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// C++ 的正确调用方式</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="现代-C"><a href="#现代-C" class="headerlink" title="现代 C++"></a>现代 C++</h1><h2 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1 内存管理"></a>1 内存管理</h2><h3 id="1-1-智能指针"><a href="#1-1-智能指针" class="headerlink" title="1.1 智能指针"></a>1.1 智能指针</h3><ol><li><p>内存管理</p><ul><li>C++ 程序使用的内存有堆和栈,需要手动维护的是堆空间</li><li>当 new 和 delete 不匹配时,会出现内存泄漏</li></ul></li><li><p><strong>RAII(Resource Acquisition Is Initialization): 资源请求即初始化</strong></p><ul><li><p>C++ 特有的资源管理方式.依托于栈和析构函数,对资源进行管理.且是异常安全的管理方式</p></li><li><p>资源在对象初始化时申请,当弹栈时会调用析构函数释放资源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;  <span class="hljs-comment">// 测试类.显式地进行构造函数与析构函数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>()   &#123;std::cout &lt;&lt; <span class="hljs-string">&quot;test()&quot;</span> &lt;&lt; std::endl;&#125;<br>    ~<span class="hljs-built_in">Test</span>() &#123;std::cout &lt;&lt; <span class="hljs-string">&quot;~test()&quot;</span> &lt;&lt; std::endl;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Raii</span>&#123;  <span class="hljs-comment">// 内存管理类.将指针传入该类,该类对象进行析构时</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Raii</span><span class="hljs-params">(Test *p)</span> </span>&#123;m_ptr = p;&#125;<br>    ~<span class="hljs-built_in">Raii</span>() &#123; <span class="hljs-keyword">delete</span> m_ptr; m_ptr = <span class="hljs-literal">nullptr</span>; &#125;<br><span class="hljs-keyword">private</span>: Test *m_ptr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;  <span class="hljs-comment">// 模拟局部作用域.管理类对象 r 在局部作用域结束时被销毁.自动调用其析构函数</span><br>        Test *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>();<br>      <span class="hljs-function">Raii <span class="hljs-title">r</span><span class="hljs-params">(p)</span></span>;  <span class="hljs-comment">// 在 r 析构时,会管理内部的指针,将申请的空间释放</span><br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);  <span class="hljs-comment">// 暂停程序.在此处即可观察到 test 析构函数已被调用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>智能指针基本原理即通过 RAII 实现对内存进行管理</p><ul><li>智能指针会对被引用对象进行计数.新增引用+1,释放时-1.为零时将其释放</li><li>智能指针支持裸指针的所有操作.如 <code>*, ++, --, +=, &lt;, &gt;</code></li><li>C++11 引入 <code>shared_ptr, uniptr_ptr, weak_ptr</code> 三种智能指针,应对不同场景</li><li>智能指针重载了 <code>*  -&gt;  []</code> 运算符,使得它们的使用与裸指针类似</li></ul></li></ol><h3 id="1-2-shared-ptr"><a href="#1-2-shared-ptr" class="headerlink" title="1.2 shared_ptr"></a>1.2 <code>shared_ptr</code></h3><ol><li><p><strong><code>shared_ptr</code>: 共享所有权.具有复制语义</strong></p><ul><li><p><strong>当多个 <code>shared_ptr</code> 指向同一对象时,每个 <code>shared_ptr</code> 的引用计数都记录数量</strong></p></li><li><p><strong>当最后一个指向对象的 <code>shared_ptr</code> 析构时,删除对象和共享计数</strong></p></li><li><p><code>use_count</code> 方法: 获取 <code>shared_ptr</code> 对象的共享计数值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>  <span class="hljs-comment">// 内存管理需要的头文件</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;  <span class="hljs-comment">// Test 类与上面的定义相同</span><br>        Test *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>();<br>        <span class="hljs-function">std::shared_ptr&lt;Test&gt; <span class="hljs-title">sp</span><span class="hljs-params">(p)</span></span>;    <span class="hljs-comment">// 裸指针构造</span><br>        <span class="hljs-function">std::shared_ptr&lt;Test&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(sp)</span></span>;  <span class="hljs-comment">// 拷贝构造</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; sp.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>注意事项</p><ul><li>避免通过同一裸指针创建多个 <code>shared_ptr</code> 对象(会导致每个对象独立计数)</li><li>避免通过 <code>this</code> 指针创建 <code>shared_ptr</code> 对象(与上一条原因相同)</li></ul></li><li><p><code>shared_ptr</code> 细节</p><ul><li><code>shared_ptr</code> 尺寸一般是裸指针的2倍<ul><li>包含一个指向资源的裸指针</li><li>包含一个指向资源的引用计数的裸指针</li></ul></li><li>引用计数的内存是动态分配的</li><li>引用计数的递增递减操作是原子的(线程安全)</li></ul></li><li><p><code>make_shared</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::shared_ptr&lt;Test&gt; sp = std::<span class="hljs-built_in">make_shared</span>&lt;Test&gt;();<br></code></pre></td></tr></table></figure><ul><li><code>make_shared</code> 方法会通过对象的构造函数直接创建 <code>shared_ptr</code> 对象</li><li><strong>优先使用 <code>make_shared</code> 方法构建 <code>shared_ptr</code> 对象</strong><ul><li>效率更高: 只会产生一次内存分配,对象与计数对象共用一块区域</li><li>可以异常安全的构造 <code>shared_ptr</code> 对象</li></ul></li></ul></li></ol><h3 id="1-3-weak-ptr"><a href="#1-3-weak-ptr" class="headerlink" title="1.3 weak_ptr"></a>1.3 <code>weak_ptr</code></h3><ol><li><p><strong><code>weak_ptr</code> 表示临时所有权(弱引用,不增加引用计数)</strong></p><ul><li><p>配合 <code>shared_ptr</code> 使用.追踪其管理的对象是否有效</p></li><li><p>当需要临时所有权时,转换为 <code>shared_ptr</code>,此时计数+1,保证正访问对象的有效性</p></li><li><p><code>weak_ptr</code> 具有复制语义.即可从 <code>weak_ptr, shared_ptr</code> 对象构造</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">18</span>);  <span class="hljs-comment">// 指向 int 类型</span><br><span class="hljs-function">std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">wp</span><span class="hljs-params">(sp)</span></span>;  <span class="hljs-comment">// 构造 weak_ptr 对象</span><br>std::cout &lt;&lt; *wp.<span class="hljs-built_in">lock</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 将 wp 转为 shared_ptr 并解引用 </span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>weak_ptr</code> 的核心方法</p><ul><li><code>use_count</code>: 获取引用计数</li><li><code>expired</code>: 检测指向的对象是否有效</li><li><code>lock</code>: 先判断指针有效性,然后转换为 <code>shared_ptr</code> 对象</li></ul></li><li><p>多线程管理共享对象</p><ul><li>多线程中裸指针管理对象很难保证共享对象的有效性</li><li>通过 <code>weak_ptr</code> 和 <code>shared_ptr</code> 结合可以方便的管理共享对象(使用 <code>lock</code> 方法)</li></ul></li><li><p>避免 <code>shared_ptr</code> 的循环引用</p></li></ol><h3 id="1-4-unique-ptr"><a href="#1-4-unique-ptr" class="headerlink" title="1.4 unique_ptr"></a>1.4 <code>unique_ptr</code></h3><ol><li><p><strong><code>unique_ptr</code> 表示独占所有权,没有拷贝语义(拷贝构造函数和赋值函数)</strong></p><ul><li><p><strong>将 <code>unique_ptr</code> 指针用作默认智能指针.仅在需要共享资源时,才使用 <code>shared_ptr</code></strong></p></li><li><p><code>unique_ptr</code> 管理的内存和资源总会被释放.即使在执行 <code>return</code> 或抛出异常</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">couldLeaky</span><span class="hljs-params">()</span></span>&#123;<br>    ClassName* ptr &#123; <span class="hljs-keyword">new</span> <span class="hljs-built_in">ClassName</span>() &#125;;<br>    ptr-&gt;<span class="hljs-built_in">method</span>();  <span class="hljs-comment">// 若 method() 方法抛出异常,delete 语句便不会执行</span><br>    <span class="hljs-keyword">delete</span> ptr;  <span class="hljs-comment">// 尽管 new 与 delete 配对使用,也可能内存泄露</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>当 <code>unique_ptr</code> 指针离开作用域或被重置时,将会自动释放所指向的内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">noLeaky</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> ptr &#123; <span class="hljs-built_in">make_unique</span>&lt;ClassName&gt;() &#125;;  <span class="hljs-comment">// 推荐使用 make_unique 函数</span><br>    <span class="hljs-comment">// 等价于 unique_ptr&lt;ClassName&gt; ptr &#123;new ClassName&#125;;</span><br>    ptr-&gt;<span class="hljs-built_in">method</span>();  <span class="hljs-comment">// 就算抛出异常,unique_ptr 会离开作用域,在析构中释放管理的对象</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>unique_ptr</code> 只可以通过移动操纵转移所有权(移动语义).核心方法</p><ul><li><code>release</code>: 返回被管理对象的裸指针,智能指针置空.注意对象并不会被释放,而是需要自己管理</li><li><code>reset</code>: 释放被管理的对象,并将智能指针指向传入参数</li><li><code>swap</code>: 交换被管理的对象</li></ul></li><li><p>配合 <code>shared_ptr</code> 实现工厂模式</p></li></ol><h3 id="1-5-线程安全"><a href="#1-5-线程安全" class="headerlink" title="1.5 线程安全"></a>1.5 线程安全</h3><ol><li><code>shared_ptr</code> 的线程安全<ul><li>多个线程可在 <code>shared_ptr</code> 的不同实例上调用所有的成员函数而不加同步</li><li>若多个线程访问同一 <code>shared_ptr</code> 而不同步,且任一线程使用非 const 成员函数,则出现数据竞争<ul><li>一个  <code>shared_ptr</code> 对象可被多个线程同时读</li><li>两个指向同一对象的  <code>shared_ptr</code> 对象可被两个线程同时读写</li><li><strong>多个线程读写同一  <code>shared_ptr</code> 对象时,需要加锁</strong></li></ul></li></ul></li><li>实现写时复制(copy-on-write): 只有在真正需要资源时才分配资源<ul><li>若系统中读操作频率远大于写操作,而读写互斥导致线程间需要加锁互斥.降低了效率</li><li>实际上只有写线程操作时,才需要读写进程加锁互斥.而在读线程间无需加锁</li><li>在写线程时判断: 如果有读线程在操作,则拷贝一份数据进行更新.缩小锁的范围</li></ul></li></ol><h3 id="2-labmda-函数"><a href="#2-labmda-函数" class="headerlink" title="2 labmda 函数"></a>2 labmda 函数</h3><ol><li><p>labmda: 匿名函数.属于可调用对象,特点为就地定义,就地使用</p></li><li><p>C++ 中 lambda 是函数对象的语法糖</p><ul><li><p>语法: <code>[捕获列表](形参) -&gt; 返回值类型 &#123;函数体&#125;</code></p></li><li><p>在任何需要可调用对象的接口,都可传入 lambda 匿名函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 示例</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>捕获列表: lambda 所在父作用域定义的变量列表</p><ul><li>父作用域: 包含 lambda 函数的语句块</li><li>空捕获列表: 不使用父作用域的任何局部变量</li><li>隐式捕获: 不在捕获列表中指定局部变量,而是靠编译器推导<ul><li><code>[=]</code>: 值传递的方式捕获父作用域的所有变量</li><li><code>[&amp;]</code>: 引用传递的方式捕获父作用域的所有变量</li></ul></li><li>捕获 <code>this</code> 指针: 使得 lambda 表达式拥有与当前类成员相同的访问权限</li></ul></li></ol><h2 id="2-移动语义"><a href="#2-移动语义" class="headerlink" title="2 移动语义"></a>2 移动语义</h2><ol><li><p>如何将一个冰箱里的大象放入另一个冰箱</p><ul><li>拷贝复制: 将冰箱1的大象复制,然后放入冰箱2,最后让冰箱1原本的大象消失</li><li>移动: 打开冰箱,移动大象,关上冰箱</li></ul></li><li><p>C++11 之前只有复制语义(通过析构函数, 拷贝构造函数, 赋值函数)</p><ul><li>对于对象的非指针,非引用的行为都会使用复制语义</li><li>在拥有内存对象的资源中,需要定义这三个函数,并实现深拷贝</li><li>在一些场景中,对象拷贝后就立即被销毁.此时使用移动而非拷贝对象可提高性能</li></ul></li><li><p>左值与右值</p><ul><li>左值: 可以对其取址</li><li>右值: 不能取址,只能取值.通常位于赋值号右侧</li><li>将亡值: 如函数返回时的临时对象, 非引用的形参, 将被移动的对象</li></ul></li><li><p>右值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> &amp;&amp;r = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 右值引用.使用 &amp;&amp; 可以引用字面量</span><br></code></pre></td></tr></table></figure><ul><li>返回左值的对象: 返回左值引用的函数, 赋值, 下标, 解引用, 前置递增&#x2F;递减</li><li>返回右值的对象(会产生临时变量): 返回非引用类型的函数, 算术, 关系, 位, 后置递增&#x2F;递减</li><li>左值引用不能引用右值(因为右值不能改变.但 const 左值引用可以指向右值)</li></ul></li><li><p>移动语义: 从源对象窃取资源,而非拷贝资源.源对象不再拥有资源</p></li><li><p><strong>支持移动语义的对象需要定义移动构造函数和移动赋值函数(形参为右值引用)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 相较于 const 左值引用.右值可直接修改对象成员</span><br><span class="hljs-built_in">ClassName</span>(ClassName&amp;&amp; t) <span class="hljs-keyword">noexcept</span> &#123;&#125;  <span class="hljs-comment">// 移动构造函数</span><br>ClassName&amp; <span class="hljs-keyword">operator</span>=(ClassName&amp;&amp; t) <span class="hljs-keyword">noexcept</span> &#123;&#125;  <span class="hljs-comment">// 移动赋值函数</span><br></code></pre></td></tr></table></figure><ul><li>将对象中的资源移走,而非赋值.因此不分配内存</li><li>移动后的源对象因为是右值引用会被销毁.因此内部资源被置为无效</li><li>必须声明为 <code>noexcept</code>.因为若移动时抛出异常会导致源对象资源被破坏</li></ul></li><li><p>编译器有条件的提供默认移动操作(不要依赖编译器,最好自己实现)</p><ul><li>类中没有自定义拷贝控制成员(析构函数, 拷贝构造函数, 赋值函数)</li><li>所有的数据成员都能移动构造或移动赋值</li></ul></li><li><p><code>std::move</code>: 将左值转换为右值引用,其本身不产生移动操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string s = <span class="hljs-string">&quot;abc&quot;</span>;<br>std::string &amp;&amp;s1 = std::<span class="hljs-built_in">move</span>(s);  <span class="hljs-comment">// s1 是对 s 的右值引用</span><br>std::cout &lt;&lt; s.<span class="hljs-built_in">c_str</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 abc.说明并未发生移动语义</span><br><span class="hljs-function">std::string <span class="hljs-title">ss</span><span class="hljs-params">(std::move(s))</span></span>;  <span class="hljs-comment">// 将右值引用传入构造函数,触发移动构造函数</span><br><span class="hljs-comment">// 在移动语义发生后,不应再使用源对象</span><br></code></pre></td></tr></table></figure></li><li><p>STL 全面引入移动语义</p><ul><li><p>旧标准返回容器通常返回容器的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getDatas</span><span class="hljs-params">(std::vector&lt;Data&gt;&amp; datas)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>C++11 的 STL 容器支持移动语义,所以可以直接返回容器对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;Data&gt; <span class="hljs-title">getDatas</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> datas;&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="3-chrono-库"><a href="#3-chrono-库" class="headerlink" title="3 chrono 库"></a>3 chrono 库</h2><ol><li><p>时间处理的需求</p><ul><li>获取当前时间.如记录日志,精确到毫秒</li><li>计算时间间隔.如计算代码块的运行时长</li><li>获取日期,进行换算</li><li>定时器(chrono 不支持)</li></ul></li><li><p>chrono: C++11 提供的跨平台,强类型的时间日期处理库.使用前需要包含头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>clock</code>: 时钟.使用时间点(time point)与间隔(duration)的方式确定当前时间</p><ul><li><p><code>system_clock</code>: 系统时间.原点时间为 UNIX 1970-01-01 00:00::00 UTC</p><ul><li><p>拥有三个静态方法: <code>now, to_time, from_time_c</code></p></li><li><p>不稳定性: 如果修改了系统时间,将会导致 <code>system_clock</code> 变化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> timePoint = std::chrono::system_clock::<span class="hljs-built_in">now</span>();  <span class="hljs-comment">// 先获取当前时间</span><br><span class="hljs-keyword">auto</span> duration = timePoint.<span class="hljs-built_in">time_since_epoch</span>();  <span class="hljs-comment">// 转为时间间隔</span><br>std::cout &lt;&lt; duration.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 17370304141602793</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>steady_clock</code>: 处理器 tick 时间.原点时间为机器启动的时刻</p><ul><li>拥有 <code>now</code> 静态方法.一般用于度量时间间隔</li><li>稳定性: <code>now</code> 方法确保返回值不小于上次调用的返回值(就算修改系统时间也是)</li></ul></li><li><p><code>high_resolution_clock</code>: 当前系统支持的最高精度.使用场景和用法与 <code>steady_clock</code> 一致</p></li></ul></li><li><p><code>duration</code>: 时间间隔</p><ul><li><p>比率(<code>std::ratio</code>)模板类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">intmax_t</span> Num, std::<span class="hljs-type">intmax_t</span> Denom = <span class="hljs-number">1</span>&gt; <span class="hljs-keyword">class</span> ratio &#123;&#125;<br><span class="hljs-comment">// Num: 分子</span><br><span class="hljs-comment">// Denom: 分母.不可为零,不可为最小的负数.且已经约分到最简</span><br></code></pre></td></tr></table></figure></li><li><p>Duration 模板类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Rep</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Period</span> = ratio&lt;<span class="hljs-number">1</span>&gt; &gt; <span class="hljs-keyword">class</span> duration &#123;&#125;<br><span class="hljs-comment">// Period: 精度.如 ratio&lt;1&gt; 为秒, ratio&lt;1, 1000&gt; 为毫秒</span><br><span class="hljs-comment">// duration 支持算术运算符和比较运算符</span><br></code></pre></td></tr></table></figure></li><li><p><code>system_clock, steady_clock, high_resolution_clock</code> 各自拥有精度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::chrono::system_clock::period::num;  <span class="hljs-comment">// 分子默认为 1</span><br>std::chrono::system_clock::period::den;  <span class="hljs-comment">// 分母代表精度. 10e7</span><br></code></pre></td></tr></table></figure></li><li><p>预定义的基本时间单元</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> nanoseconds  = duration&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, nano&gt;;   <span class="hljs-comment">// 纳秒</span><br><span class="hljs-keyword">using</span> microseconds = duration&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, micro&gt;;  <span class="hljs-comment">// 微秒</span><br><span class="hljs-keyword">using</span> milliseconds = duration&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, milli&gt;;  <span class="hljs-comment">// 毫秒</span><br><span class="hljs-keyword">using</span> seconds      = duration&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;;<br><span class="hljs-keyword">using</span> minutes      = duration&lt;<span class="hljs-type">int</span>, ratio&lt;<span class="hljs-number">60</span>&gt;&gt;;<br><span class="hljs-keyword">using</span> hours        = duration&lt;<span class="hljs-type">int</span>, ratio&lt;<span class="hljs-number">3600</span>&gt;&gt;;<br></code></pre></td></tr></table></figure></li><li><p>自定义时间单元</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> std::chrono::duration&lt;<span class="hljs-type">long</span>, std::ratio&lt;<span class="hljs-number">1</span>, <span class="hljs-number">25</span>&gt;&gt; FrameRate;  <span class="hljs-comment">// 25帧率</span><br><span class="hljs-built_in">Frame</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 3帧的时间间隔 1/25*3 = 120ms</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>time point</code>: 时间点模板类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Duration</span>=<span class="hljs-keyword">typename</span> Clock::duration&gt; <span class="hljs-keyword">class</span> time_point &#123;&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-模块"><a href="#4-模块" class="headerlink" title="4 模块"></a>4 模块</h2><ol><li><p>头文件的问题</p><ul><li>需要避免多次包含同一个头文件</li><li>需要确保头文件的包含顺序</li><li><code>#include</code> 会导致新增大量需要编译器需要处理的代码</li></ul></li><li><p>模块(C++20)的优点</p><ul><li>只会编译一次</li><li>导入的顺序可以任意</li><li>模块不受外部定义的宏的影响,且模块内部定义的宏对外部不可见</li></ul></li><li><p>接口与实现分离</p><ul><li><p><strong>使用头文件时,一般只将声明放在头文件,所有实现放在源文件</strong></p></li><li><p>如果头文件包含了实现,哪怕只是修改注释,将导致所有包含了该头文件的源文件需要重新编译</p></li><li><p>模块接口的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Person.cppm 文件名</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> person;     <span class="hljs-comment">// 模块声明</span><br><span class="hljs-keyword">import</span> &lt;string&gt;;          <span class="hljs-comment">// 导入其他模块</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Persion</span>&#123;&#125;;   <span class="hljs-comment">// 导出声明</span><br></code></pre></td></tr></table></figure></li><li><p>模块接口的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Person.cpp 文件名</span><br><span class="hljs-keyword">module</span> person;  <span class="hljs-comment">// 模块声明.注意没有 export.这里会隐式的 import person;</span><br><span class="hljs-comment">/* person 类中定义方法的具体实现代码... */</span><br></code></pre></td></tr></table></figure></li><li><p>导入模块的方式(C++ 头文件都可以通过 <code>import</code> 导入.如 <code>&lt;iostream&gt;, &lt;vector&gt;</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">import</span> person;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>Code</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Crash Couser</title>
    <link href="/2023/07/01/Computer/Python-Crash-Course/"/>
    <url>/2023/07/01/Computer/Python-Crash-Course/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-Crash-Course"><a href="#Python-Crash-Course" class="headerlink" title="Python Crash Course"></a>Python Crash Course</h1><h2 id="0-Python-基础"><a href="#0-Python-基础" class="headerlink" title="0 Python 基础"></a>0 Python 基础</h2><h3 id="0-1-关键字"><a href="#0-1-关键字" class="headerlink" title="0.1 关键字"></a>0.1 关键字</h3><ol><li><p><strong>利用Python标准库提供的 <code>keyword</code>模块.输出当前版本的所有关键字</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> keyword<br><span class="hljs-built_in">print</span>(keyword.kwlist)<br></code></pre></td></tr></table></figure></li><li><p>Python 关键字</p><ul><li>基本类型: <code>False, True, None</code></li><li>控制流: <ul><li>分支结构: <code>if, elif, else[, match, case]</code></li><li>循环结构: <code>for, in, while, continue, break</code></li><li>逻辑判断: <code>and, or, not, is</code></li></ul></li><li>类,函数,对象: <code>class, def, return, pass ,lambda, del</code></li><li>异常处理: <code>assert, try, except, finally, raise</code></li><li>包: <code>import, from, as</code></li><li>线程: <code>async, yield, await</code></li><li>其他: <code>global, nonlocal, with</code></li></ul></li></ol><h3 id="0-2-特性"><a href="#0-2-特性" class="headerlink" title="0.2 特性"></a>0.2 特性</h3><ol><li><p><strong>易于学习</strong>: Python 关键字较少,结构简单, 代码定义清晰</p></li><li><p><strong>广泛的标准库</strong>: Python 的最大的优势之一是丰富的库.可跨平台</p></li><li><p><strong>互动模式</strong>: 可从终端输入执行代码并获得结果的语言,互动的测试和调试代码片断</p></li><li><p><strong>可移植</strong>: 基于其开放源代码的特性.Python 已经被移植到许多平台</p></li><li><p><strong>可扩展</strong>: 如果需要关键代码有性能要求,或者不想公开算法.可以使用 C&#x2F;C++ 完成,然后由 Python 调用</p></li><li><p><strong>数据库</strong>: Python 提供所有主要的商业数据库的接口</p></li><li><p><strong>GUI 编程</strong>: Python 支持 GUI 可以创建和移植到许多系统调用</p></li><li><p><strong>可嵌入</strong>: Python 可以嵌入到 C&#x2F;C++ 程序,让程序的用户获得”脚本化”的能力</p></li><li><p><strong>Python 之禅</strong>: <code>import this</code></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs applescript">The Zen <span class="hljs-keyword">of</span> Python, <span class="hljs-keyword">by</span> Tim Peters<br><br>Beautiful <span class="hljs-keyword">is</span> better than ugly.<br>Explicit <span class="hljs-keyword">is</span> better than implicit.<br>Simple <span class="hljs-keyword">is</span> better than complex.<br>Complex <span class="hljs-keyword">is</span> better than complicated.<br>Flat <span class="hljs-keyword">is</span> better than nested.<br>Sparse <span class="hljs-keyword">is</span> better than dense.<br>Readability counts.<br>Special cases aren&#x27;t special enough <span class="hljs-keyword">to</span> break <span class="hljs-keyword">the</span> rules.<br>Although practicality beats purity.<br>Errors should never pass silently.<br>Unless explicitly silenced.<br>In <span class="hljs-keyword">the</span> face <span class="hljs-keyword">of</span> ambiguity, refuse <span class="hljs-keyword">the</span> temptation <span class="hljs-keyword">to</span> guess.<br>There should be one<span class="hljs-comment">-- and preferably only one --obvious way to do it.</span><br>Although <span class="hljs-keyword">that</span> way may <span class="hljs-keyword">not</span> be obvious <span class="hljs-keyword">at</span> <span class="hljs-keyword">first</span> unless you&#x27;re Dutch.<br>Now <span class="hljs-keyword">is</span> better than never.<br>Although never <span class="hljs-keyword">is</span> often better than *right* now.<br>If <span class="hljs-keyword">the</span> implementation <span class="hljs-keyword">is</span> hard <span class="hljs-keyword">to</span> explain, <span class="hljs-keyword">it</span>&#x27;s a bad idea.<br>If <span class="hljs-keyword">the</span> implementation <span class="hljs-keyword">is</span> easy <span class="hljs-keyword">to</span> explain, <span class="hljs-keyword">it</span> may be a good idea.<br>Namespaces are one honking great idea <span class="hljs-comment">-- let&#x27;s do more of those!</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="0-3-注释"><a href="#0-3-注释" class="headerlink" title="0.3 注释"></a>0.3 注释</h3><ol><li><p><strong>单行注释</strong>: <code># text</code></p></li><li><p>文件编码声明注释(位于文件首行): <code># coding:utf-8</code></p></li><li><p><strong>多行注释</strong>: <code>&#39;&#39;&#39; text &#39;&#39;&#39; </code> or <code>&quot;&quot;&quot; text &quot;&quot;&quot;</code></p></li><li><p>文档注释:</p><ul><li>其本质是多行注释</li><li>位于方法体最前面</li><li><strong>方法的 <code>__doc__</code> 属性可以获取文档注释</strong></li></ul></li><li><p>行与缩进</p><ul><li><strong>python 使用缩进来表示代码块,不需要使用大括号</strong></li><li>缩进的空格数是可变的,但同一代码块的语句必须包含相同的缩进空格数</li><li>与 C 相同: Python 同样以在行尾加上续行转义符 <code>\</code> 来实现多行语句</li><li>在 <code>[], &#123;&#125;, ()</code> 中的多行语句自动续行.不需要使用反斜杠 <code>\</code> 续行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_hi</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param name: 被打印的字符串</span><br><span class="hljs-string">    :return: None</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Hi, <span class="hljs-subst">&#123;name&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="0-4-运算符"><a href="#0-4-运算符" class="headerlink" title="0.4 运算符"></a>0.4 运算符</h3><ol><li><p>算术运算符</p><ul><li>基本算术运算符: <code>+, -, *, /, %</code>.  <strong>整除: <code>//</code>. 乘方: <code>**</code></strong></li><li><strong>注意与 C 不同的是: Python 中 <code>/</code> 是实数除法,而非整数除法</strong></li></ul></li><li><p>赋值运算符</p><ul><li>基本赋值: <code>=, +=, -=, *=, /=, %=</code>. <code>**=</code>: 乘方后赋值. <code>//=</code>: 整除后赋值</li><li><code>:=</code> <strong>海象运算符(Python3.8 新增),可在表达式内部进行赋值</strong></li></ul></li><li><p><strong>逻辑运算符</strong>: <code>and, or, not</code></p></li><li><p><strong>成员运算符</strong>: <code>in, not in</code></p></li><li><p><strong>身份运算符</strong>: <code>is, is not</code></p></li><li><p>运算符优先级</p><table><thead><tr><th>优先级</th><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td>1</td><td align="left"><code>(expressions), [exp], &#123;exp&#125;, &#123;key: value&#125;</code></td><td align="left">括号内的表达式</td></tr><tr><td>2</td><td align="left"><code>x[index], x[:], x(arguments), x.attribute</code></td><td align="left">读取,切片,调用,属性引用</td></tr><tr><td>3</td><td align="left"><code>await x</code></td><td align="left"><code>await</code> 表达式</td></tr><tr><td>4</td><td align="left"><code>**</code></td><td align="left">乘方(指数)</td></tr><tr><td>5</td><td align="left"><code>+x, -x, ~x</code></td><td align="left">正,负,按位非 NOT</td></tr><tr><td>6</td><td align="left"><code>*, @, /, //, %</code></td><td align="left">乘,矩阵乘,除,整除,取余</td></tr><tr><td>7</td><td align="left"><code>+, -</code></td><td align="left">加,减</td></tr><tr><td>8</td><td align="left"><code>&lt;&lt;, &gt;&gt;</code></td><td align="left">移位</td></tr><tr><td>9</td><td align="left"><code>&amp;</code></td><td align="left">按位与 AND</td></tr><tr><td>10</td><td align="left"><code>^</code></td><td align="left">按位异或 XOR</td></tr><tr><td>11</td><td align="left">|</td><td align="left">按位或 OR</td></tr><tr><td>12</td><td align="left"><code>in, not in, is, is not, &lt;, &lt;=, &gt;, &gt;=, !=, ==</code></td><td align="left">成员检测, 比较运算</td></tr><tr><td>13</td><td align="left"><code>not x</code></td><td align="left">逻辑非 NOT</td></tr><tr><td>14</td><td align="left"><code>and</code></td><td align="left">逻辑与 AND</td></tr><tr><td>15</td><td align="left"><code>or</code></td><td align="left">逻辑或 OR</td></tr><tr><td>16</td><td align="left"><code>if - else</code></td><td align="left">条件表达式</td></tr><tr><td>17</td><td align="left"><code>lambda</code></td><td align="left">lambda 表达式</td></tr><tr><td>18</td><td align="left"><code>:=</code></td><td align="left">赋值表达式</td></tr></tbody></table></li></ol><h3 id="0-5-字符串"><a href="#0-5-字符串" class="headerlink" title="0.5 字符串"></a>0.5 字符串</h3><ol><li><p>表示形式: 用 <code>&#39;</code> 或 <code>&quot;</code> 或 <code>&#39;&#39;&#39;</code> 包围.特别地,<strong>三引号允许字符串跨行</strong></p></li><li><p><strong>Python 没有 <code>char</code> 类型.转而用长度为 1 的字符串代替</strong></p></li><li><p><strong>字符串的运算符重载</strong></p><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td><code>+</code></td><td>拼接字符串</td></tr><tr><td><code>*</code></td><td>重复字符串</td></tr><tr><td><code>[]</code></td><td>下标索引</td></tr><tr><td><code>in / not in</code></td><td>成员运算</td></tr><tr><td><code>r / R</code></td><td>raw string: 前缀 r 表示不进行字符转义</td></tr><tr><td><code>%</code></td><td>格式字符串.如 <code>print(&quot;%d&quot; % age)</code></td></tr></tbody></table></li><li><p>格式化输出: <code>.format</code> 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;age: &#123;&#125;, name: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(age, name))<br></code></pre></td></tr></table></figure></li><li><p><strong><code>f-string</code>(字面量格式化字符串,Python3.6添加)</strong></p><ul><li><p>以 f 作为字符串前缀,用 <code>&#123;&#125;</code> 包围表达式</p></li><li><p><code>&#123;&#125;</code> 的表达式将会被计算后的值替换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;age: <span class="hljs-subst">&#123;age&#125;</span>, name: <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>print()</code>: 默认换行输出.如果要实现不换行输出,需要在变量末尾加上 <code>end=&quot;&quot;</code> </p></li><li><p><code>input([prompt])</code></p><ul><li>格式: <code>str = input(&quot;prompt&quot;)</code> </li><li>作用: 从标准输入(默认是键盘)读入一行文本</li><li>先将 <code>&quot;prompt&quot;</code> 字符串进行标准输出,然后等待用户输入,并以 <code>string</code> 类型返回</li></ul></li><li><p><code>string</code> 的内建函数</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>isdecimal() &#x2F; <strong>isdigit()</strong></td><td>非空 &amp; 只包含十进制字符 &#x2F; <strong>只包含数字</strong></td></tr><tr><td>isalnum()</td><td>非空 &amp; 所有字符都是字母或数字</td></tr><tr><td>isspace()</td><td>非空 &amp; 只包含空白</td></tr><tr><td>endswith(suffix, beg&#x3D;0, end&#x3D;len(string))</td><td>字符串以 suffix 结束</td></tr><tr><td><strong>startswith(substr, beg&#x3D;0,end&#x3D;len(string))</strong></td><td><strong>字符串以 substr 开头</strong></td></tr><tr><td>strip([chars])</td><td>删除字符串左右的指定字符(默认空格)</td></tr><tr><td>center(width[, fillchar])</td><td>居中对齐</td></tr><tr><td><strong>split(str&#x3D;””, num&#x3D;string.count(str))</strong></td><td><strong>分割字符串</strong></td></tr><tr><td>splitlines([keepends])</td><td>按行 (<code>&#39;\r&#39;, &#39;\r\n&#39;, \n&#39;</code>) 分割字符串</td></tr><tr><td>count(str, beg&#x3D;0, end&#x3D;len(string))</td><td>计算 str 出现的次数</td></tr><tr><td><strong>find(str, beg&#x3D;0, end&#x3D;len(string))</strong></td><td><strong>查找</strong></td></tr><tr><td>rfind(str, beg&#x3D;0,end&#x3D;len(string))</td><td>反向查找</td></tr><tr><td>replace(old, new, max)</td><td>替换字符串. max 指定最大替换次数</td></tr><tr><td>encode(encoding&#x3D;’UTF-8’, errors&#x3D;’strict’)</td><td>指定编码的格式</td></tr></tbody></table></li></ol><h3 id="0-6-内置函数"><a href="#0-6-内置函数" class="headerlink" title="0.6 内置函数"></a>0.6 内置函数</h3><ol><li><p>判断对象所属类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">type</span>(obj)                   <span class="hljs-comment"># 返回对象的类型</span><br><span class="hljs-built_in">isinstance</span>(obj, class_name)<span class="hljs-comment"># 判断对象是否是已知类型</span><br><span class="hljs-comment"># 区别在于 type 不认子类,而 isinstance 认为子类是父类类型</span><br></code></pre></td></tr></table></figure></li><li><p>数学函数(<code>import math</code>)</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>abs(x) &#x2F; fabs(x)</td><td>绝对值 &#x2F; 浮点绝对值</td></tr><tr><td>ceil(x) &#x2F; floor(x)</td><td>向上&#x2F;下取整</td></tr><tr><td>sqrt(x) &#x2F; exp(x) &#x2F; pow(x, y)</td><td>$\sqrt{x}$ &#x2F; $e^x$ &#x2F; $x^y$</td></tr><tr><td>log(x) &#x2F; log10(x)</td><td>$\mathrm{ln}x$ &#x2F; $\mathrm{log}_{10}x$</td></tr><tr><td><strong>max(x, y,…) &#x2F; min(x, y,…)</strong></td><td><strong>取最大&#x2F;小值,参数可以为序列</strong></td></tr><tr><td>modf(x)</td><td>返回x的整数部分与小数部分,符号与x相同</td></tr><tr><td><strong>round(x[, n])</strong></td><td><strong>4舍6进5看齐,奇进偶舍. n 指定位数</strong></td></tr></tbody></table></li><li><p>随机函数(<code>import random</code>)</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><strong>seed(x)</strong></td><td><strong>设定随机数种子</strong></td></tr><tr><td><strong>choice(seq)</strong></td><td><strong>从序列的元素中随机挑选一个元素</strong></td></tr><tr><td>randint(x, y)</td><td>随机生成一个整数.范围: <code>[x, y]</code></td></tr><tr><td><strong>random()</strong></td><td><strong>随机生成一个实数.范围: <code>[0, 1)</code></strong></td></tr><tr><td>uniform(x, y)</td><td>随机生成一个实数.范围: <code>[x, y]</code></td></tr><tr><td>shuffle(lst)</td><td>将序列的所有元素随机排序</td></tr></tbody></table></li></ol><div STYLE="page-break-after: always;"></div><h2 id="1-数据容器"><a href="#1-数据容器" class="headerlink" title="1 数据容器"></a>1 数据容器</h2><h3 id="1-1-list"><a href="#1-1-list" class="headerlink" title="1.1 list"></a>1.1 list</h3><ol><li><p><strong>元素类型: 可以有不同类型.允许嵌套列表.基本允许任何对象</strong></p></li><li><p>创建方式: 用 <code>[]</code> 包围元素.用 <code>,</code> 分隔元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">spam = [<span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;rat&quot;</span>]  <span class="hljs-comment"># spam 为列表,拥有3个元素</span><br></code></pre></td></tr></table></figure></li><li><p>获取列表元素</p><ul><li>使用 <code>l[index: int]</code> 获取列表 <code>l</code> 在索引为 <code>index</code> 处的元素</li><li>允许使用负数作为索引值,表示倒数.如 -1 表示最后一个元素</li><li>当索引(从0开始)越界时,将会抛出 <code>IndexError</code></li></ul></li><li><p><strong>切片: 获取列表的一部分,也是一个列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">list_name[start=<span class="hljs-number">0</span> : end=<span class="hljs-built_in">len</span>(list_name) : step=<span class="hljs-number">1</span>]<br><span class="hljs-comment"># start: 开始位置.默认为0</span><br><span class="hljs-comment"># end:   结束位置.默认为列表的长度</span><br><span class="hljs-comment"># step:  切片步长.默认为1,可省略.负数表示反向</span><br></code></pre></td></tr></table></figure></li><li><p><strong>运算符重载: 用 <code>+</code> 进行连接,用 <code>*</code> 运算符进行重复</strong>(与字符串类似)</p></li><li><p>删除部分元素: 使用 <code>del</code> 关键字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> list_name[:<span class="hljs-number">3</span>]  <span class="hljs-comment"># 删除前3个元素</span><br></code></pre></td></tr></table></figure></li><li><p>技巧: 在遍历列表的同时获取下标</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> index, obj <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(obj_list):<br>    <span class="hljs-built_in">print</span>(index, obj)<br></code></pre></td></tr></table></figure></li><li><p>list 常用方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>append(obj)</strong></td><td><strong>在列表末尾添加新的对象</strong></td></tr><tr><td>count(obj)</td><td>统计某个元素在列表中出现的次数</td></tr><tr><td>extend(seq)</td><td>将可迭代序列的内容拓展到列表末尾</td></tr><tr><td><strong>remove(obj) &#x2F; index(obj)</strong></td><td><strong>移除对象 &#x2F; 获取索引(只针对第一次匹配成功的)</strong></td></tr><tr><td><strong>reverse()</strong> &#x2F; clear() &#x2F; copy()</td><td><strong>原地翻转列表</strong> &#x2F; 清空列表 &#x2F; 复制列表</td></tr><tr><td><strong>pop(index&#x3D;-1)</strong></td><td><strong>移除列表中的一个元素并返回(默认最后一个)</strong></td></tr><tr><td><strong>insert(index, obj)</strong></td><td><strong>将对象插入列表的指定下标</strong></td></tr><tr><td><strong>sort(key&#x3D;None, reverse&#x3D;False)</strong></td><td><strong>原地排序. <code>key</code> 是关键字函数,指定排序规则</strong></td></tr></tbody></table></li></ol><h3 id="1-2-tuple"><a href="#1-2-tuple" class="headerlink" title="1.2 tuple"></a>1.2 tuple</h3><ol><li><p><strong><code>tuple</code> 与 <code>list</code> 类似,区别在于 <code>tuple</code> 不可更改</strong></p></li><li><p>创建方式: 用 <code>()</code> 包围.用 <code>,</code> 分隔元素(区别于列表使用 <code>[]</code>)</p></li><li><p>切片: 与 <code>list</code> 相同</p></li><li><p>当函数返回多个值时,其本质返回的是元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">return</span> width, height  <span class="hljs-comment"># 相当于返回 (width, height)</span><br></code></pre></td></tr></table></figure></li><li><p>字符串可看作一种特殊的 <code>tuple</code></p></li></ol><h3 id="1-3-dictionary"><a href="#1-3-dictionary" class="headerlink" title="1.3 dictionary"></a>1.3 dictionary</h3><ol><li><p>特点</p><ul><li><strong>无序的对象集合</strong>(在 Python 3.6 后变得有序)</li><li><strong>通过 <code>key</code> 存取 <code>value</code></strong> (<code>list</code> 通过下标偏移)</li><li><strong><code>key</code> 必须是不可变类型的,且必须唯一</strong>(常用数字,字符串,元组充当)</li></ul></li><li><p>字典元素访问</p><ul><li><p>元素形如: <code>key : value</code> </p></li><li><p>整体形如: <code>dict = &#123;key1 : value1, key2 : value2, ..., keyn : valuen&#125;</code> </p></li><li><p>访问方式: <code>dict[key]</code>.需注意若 <code>key</code> 不存在将会抛出 <code>KeyError</code></p></li><li><p><strong>添加元素: <code>dict[key] = value</code></strong> </p></li><li><p><strong>遍历字典: 当对字典进行遍历时,默认遍历所有的 <code>key</code></strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dictionary:<br>    <span class="hljs-built_in">print</span>(key, dictionary[key])<br></code></pre></td></tr></table></figure></li></ul></li><li><p>dictionary 常用方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>keys() &#x2F; values()</strong></td><td><strong>返回动态视图对象,具有所有的 key &#x2F; value 信息</strong></td></tr><tr><td><strong>items()</strong></td><td><strong>返回动态视图对象,具有所有的 key-value 信息</strong></td></tr><tr><td><strong>get(key, default&#x3D;None)</strong></td><td><strong>返回 value.若 key 不存在,返回 default</strong></td></tr><tr><td>setdefault(key, default&#x3D;None)</td><td>返回 value.若 key 不存在,添加 (key, value&#x3D;default)</td></tr><tr><td><strong>pop(key, default)</strong></td><td><strong>删除 key 所对应的值,返回 value</strong></td></tr><tr><td>popitem()</td><td>删除最后的 key-value,并返回</td></tr><tr><td>update(dict)</td><td>加入 dict 的 key-value</td></tr></tbody></table></li></ol><h3 id="1-4-set"><a href="#1-4-set" class="headerlink" title="1.4 set"></a>1.4 set</h3><ol><li><p><strong>特点: 无序,可变,元素唯一</strong></p></li><li><p>创建方式: </p><ul><li>用 <code>&#123;&#125;</code> 包围.用 <code>,</code> 分隔元素</li><li>创建空集合: <code>set()</code></li></ul></li><li><p>操作符重载: 并集(<code>|</code>), 交集(<code>&amp;</code>), 差集(<code>-</code>), 异或(<code>^</code>)</p></li><li><p>set 常用方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>add(element)</strong></td><td><strong>添加元素</strong></td></tr><tr><td><strong>pop</strong>()</td><td><strong>随机移除元素,并将其返回</strong></td></tr><tr><td>update(set)</td><td>添加元素,可以有多个</td></tr><tr><td>discard(element)</td><td>删除集合中指定的元素.若不存在,不会引发错误</td></tr><tr><td><strong>remove(element)</strong></td><td><strong>移除指定元素.若不存在会发生错误</strong></td></tr><tr><td>isdisjoint(set)</td><td>认为两个集合不包含相同的元素</td></tr><tr><td>issubset(set)</td><td>认为指定集合是子集</td></tr><tr><td>issuperset(set)</td><td>认为指定集合是超集</td></tr></tbody></table></li><li><p>list, tuple, dictionary, set 通用 方法&#x2F;函数</p><table><thead><tr><th>函数&#x2F;方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>len(object)</strong></td><td><strong>计算元素个数</strong></td></tr><tr><td>clear()</td><td>清空容器</td></tr><tr><td>copy()</td><td>(浅)复制容器</td></tr></tbody></table></li></ol><h3 id="1-5-bytes"><a href="#1-5-bytes" class="headerlink" title="1.5 bytes"></a>1.5 bytes</h3><ol><li>含义: 不可变的二进制序列</li><li>元素类型: 0 ~ 255 的整数</li><li>作用: 用于处理二进制数据(如图像, 音频, 视频)</li><li>创建方式: <ul><li>使用 <code>b</code> 前缀 (如 <code>x=b&quot;hello&quot;</code>)</li><li>使用 <code>bytes()</code> 函数将其他类型对象转换为 <code>bytes</code> 类型</li></ul></li></ol><h3 id="1-6-类型转换"><a href="#1-6-类型转换" class="headerlink" title="1.6 类型转换"></a>1.6 类型转换</h3><ol><li><p>Python 数据类型</p><ul><li><code>number(int, bool, float, complex), string, list, tuple, set, dictionary</code></li><li>其中 <code>number, string, tuple</code> 不可变; <code>list, dictionary, set</code> 可变</li></ul></li><li><p>复数形如 <code>a+bj</code> 或 <code>complex(a, b)</code></p></li><li><p>隐式类型转换</p><ul><li>运算时较低数据类型会自动转换为较高数据类型,以避免信息丢失</li><li><code>bool &lt; int &lt; float &lt; complex</code></li></ul></li><li><p>显式类型转换</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>int(x, base&#x3D;10)</strong></td><td align="left"><strong>返回整数</strong></td></tr><tr><td align="left">float(x)</td><td align="left">返回浮点数</td></tr><tr><td align="left">complex(real[, imag])</td><td align="left">返回复数</td></tr><tr><td align="left"><strong>str(object&#x3D;””)</strong></td><td align="left"><strong>将对象 object 转换为字符串</strong></td></tr><tr><td align="left"><strong>repr(object)</strong></td><td align="left"><strong>将对象 object 转换为表达式字符串</strong></td></tr><tr><td align="left"><strong>eval(str)</strong></td><td align="left"><strong>计算字符串中的有效 Python 表达式,并返回一个对象</strong></td></tr><tr><td align="left"><strong>list(iterable)</strong></td><td align="left"><strong>将可迭代序列转换为列表</strong></td></tr><tr><td align="left">tuple(iterable)</td><td align="left">将可迭代序列转换为元组</td></tr><tr><td align="left">set([iterable])</td><td align="left">将可迭代序列转换为可变集合</td></tr><tr><td align="left">dict(d)</td><td align="left">创建一个字典.其中 d是(key, value)元组序列</td></tr><tr><td align="left">frozenset([iterable])</td><td align="left">将可迭代序列转换为不可变集合</td></tr><tr><td align="left"><strong>chr(x)</strong></td><td align="left"><strong>将一个整数(0~255)转换为一个字符</strong></td></tr><tr><td align="left"><strong>ord(c)</strong></td><td align="left"><strong>将一个字符转换为整数值(与 chr 相对)</strong></td></tr><tr><td align="left"><strong>hex(x)</strong></td><td align="left"><strong>将一个整数转换为一个十六进制字符串</strong></td></tr><tr><td align="left">oct(x)</td><td align="left">将一个整数转换为一个八进制字符串</td></tr></tbody></table></li></ol><h2 id="2-程序控制"><a href="#2-程序控制" class="headerlink" title="2 程序控制"></a>2 程序控制</h2><h3 id="2-1-分支"><a href="#2-1-分支" class="headerlink" title="2.1 分支"></a>2.1 分支</h3><ol><li><p>与 C 的区别: 用 <code>elif</code> 代替了 <code>else if</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> &lt;condition_1&gt;:  <span class="hljs-comment"># 条件表达式的值为 True 时,则执行,且下面的判断不在执行</span><br>    &lt;statement_block_1&gt;<br><span class="hljs-keyword">elif</span> condition_2:  <span class="hljs-comment"># 当 condition_1 的值为 False,才会进行判断</span><br>    &lt;statement_block_2&gt;<br><span class="hljs-keyword">else</span>:              <span class="hljs-comment"># 当所有的条件表达式都为 False,才会执行</span><br>    &lt;statement_block_3&gt;<br></code></pre></td></tr></table></figure></li><li><p><code>match - case</code>(Python3.10添加)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">match</span> subject:         <span class="hljs-comment"># 类似于 C 中的 switch-case</span><br>    <span class="hljs-keyword">case</span> &lt;pattern_1&gt;:  <span class="hljs-comment"># 当成功匹配时,执行相应的语句</span><br>        &lt;action_1&gt;<br>    <span class="hljs-keyword">case</span> &lt;pattern_2&gt;:<br>        &lt;action_2&gt;<br>    <span class="hljs-keyword">case</span> _:             <span class="hljs-comment"># 可以匹配一切.该语句与 C 中的 &#x27;default:&#x27; 作用类似</span><br>        &lt;action_wildcard&gt;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-循环"><a href="#2-2-循环" class="headerlink" title="2.2 循环"></a>2.2 循环</h3><ol><li><p><code>while</code> 语句与 C 的区别: 没有 <code>do while</code> 语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> &lt;expr&gt;:       <span class="hljs-comment"># 当表达式的值为 True,则执行循环</span><br>    &lt;statement(s)&gt;  <span class="hljs-comment"># 可以使用 continue 和 break 语句</span><br><span class="hljs-keyword">else</span>:               <span class="hljs-comment"># 若循环语句未被 break 打断,则 else 语句将会被执行</span><br>    &lt;additional_statement(s)&gt;<br></code></pre></td></tr></table></figure></li><li><p><code>for</code> 经常用来遍历可迭代对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> &lt;variable&gt; <span class="hljs-keyword">in</span> &lt;sequence&gt;:  <span class="hljs-comment"># 当可以取到序列对象的元素时,则执行循环</span><br>    &lt;statements&gt;               <span class="hljs-comment"># 可以使用 continue 和 break 语句</span><br><span class="hljs-keyword">else</span>:                          <span class="hljs-comment"># 若循环语句未被 break 打断,则 else 语句将会被执行</span><br>    &lt;statements&gt;<br></code></pre></td></tr></table></figure><ul><li><code>for</code> 可与 <code>else</code> 进行匹配.当循环完成时,执行<code>else</code>语句块(遇到 <code>break</code> 不会执行)</li><li>遍历数字序列时,可用内置的 <code>range</code> 函数生成数列</li><li><strong><code>range(start=0, stop, step=1)</code> 返回一个整数序列对象,仅在迭代时返回数字</strong></li></ul></li><li><p><strong>不要在<code>for</code>循环遍历列表时修改列表,否则将导致Python难以追踪其中的元素.此时应使用<code>while</code></strong></p></li><li><p><code>pass</code> 语句: 用于占位,表示什么也不做</p></li></ol><h3 id="2-3-推导式"><a href="#2-3-推导式" class="headerlink" title="2.3 推导式"></a>2.3 推导式</h3><ol><li><p><strong>列表推导式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># [表达式 for 变量 in 列表 if 条件].其中条件语句是可选的</span><br><span class="hljs-comment"># 目的: 过滤出长度大于3的字符串,并将其全大写</span><br>names = [<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;Jerry&#x27;</span>, <span class="hljs-string">&#x27;Wendy&#x27;</span>, <span class="hljs-string">&#x27;Smith&#x27;</span>]<br>new_names = [name.upper() <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(name) &gt; <span class="hljs-number">3</span>]<br><br>[ out_exp_res <span class="hljs-keyword">for</span> out_exp <span class="hljs-keyword">in</span> input_list <span class="hljs-keyword">if</span> condition ]<br><span class="hljs-comment"># out_exp_res: 列表生成元素表达式,可以是有返回值的函数</span><br><span class="hljs-comment"># 迭代时: input_list 将 out_exp 传入到 out_exp_res 表达式中</span><br><span class="hljs-comment"># condition: 条件表达式</span><br></code></pre></td></tr></table></figure></li><li><p>字典推导式</p><ul><li>格式: <code>&#123; key_expr: value_expr for key, value in collection if condition &#125;</code> </li><li><code>key_expr : value_expr</code>: 字典生成元素表达式</li></ul></li><li><p>集合推导式</p><ul><li>格式: <code>&#123; expression for item in Sequence if condition &#125;</code></li></ul></li><li><p>元组推导式</p><ul><li>格式: <code>(expression for item in Sequence if condition )</code> </li><li><strong>注意: 元组推导式返回的结果是一个生成器对象,需要使用 <code>tuple()</code> 函数才会成为元组</strong></li></ul></li></ol><h3 id="2-4-迭代器"><a href="#2-4-迭代器" class="headerlink" title="2.4 迭代器"></a>2.4 迭代器</h3><ol><li><p>迭代器</p><ul><li>迭代器可以记住遍历的位置,只能往前不会后退</li><li>从第一个元素开始访问.直到所有的元素被访问完结束</li><li>当没有元素可以访问时, <code>next()</code> 函数将会抛出 <code>StopIteration</code> 异常</li><li>迭代器基础函数: <code>iter(), next()</code></li></ul></li><li><p>迭代器使用示例</p><ul><li><p>使用 <code>iter()</code> 函数创建迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">l = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]  <span class="hljs-comment"># string, list, tuple 均可创建迭代器</span><br>it = <span class="hljs-built_in">iter</span>(l)      <span class="hljs-comment"># 创建迭代器对象</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>next()</code> 函数获取值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">it = <span class="hljs-built_in">next</span>(it)  <span class="hljs-comment"># 获取当前元素,并将迭代器指向下一元素</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>for</code> 循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> it:<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>类的迭代器</p><ul><li>需要在类中实现 <code>__iter__, __next__</code> 方法  </li><li><code>StopIteration</code> 异常用于标识迭代的完成,防止出现无限循环的情况</li></ul></li></ol><h3 id="2-5-生成器"><a href="#2-5-生成器" class="headerlink" title="2.5 生成器"></a>2.5 生成器</h3><ol><li><p><strong>生成器: 使用了 <code>yield</code> 的函数</strong></p><ul><li>生成器函数是一种特殊的函数,可以在迭代过程中逐步产生值,而不是一次性返回所有结果</li><li>生成器是一个返回迭代器的函数,只能用于迭代操作</li></ul></li><li><p>生成器执行过程</p><ul><li>生成器函数中遇到 <code>yield</code> 语句时,函数的执行暂停,然后将 <code>yield</code> 后面的表达式作为当前迭代的值返回</li><li>每次调用生成器的 <strong>next</strong> 函数或使用 <code>for</code> 循环进行迭代时,函数会从上次暂停的地方继续执行,直到再次遇到 <code>yield</code> 语句</li></ul></li><li><p>生成器使用示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci</span>():<br>    before, after = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">yield</span> before<br>        before, after = after, before + after<br></code></pre></td></tr></table></figure><ul><li><p>对生成器使用 <code>next</code> 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">f = fibonacci()  <span class="hljs-comment"># 获取迭代器</span><br><span class="hljs-built_in">next</span>(f)          <span class="hljs-comment"># 使用迭代器产生值.每次调用 next 只会生成一个值,且不会回头</span><br></code></pre></td></tr></table></figure></li><li><p>对生成器使用 <code>for</code> 循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> f:  <span class="hljs-comment"># 注意,由于 fib 生成永远不会结束,会导致这是一个死循环</span><br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="2-6-函数"><a href="#2-6-函数" class="headerlink" title="2.6 函数"></a>2.6 函数</h3><ol><li><p>定义方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">paraList</span>):  <span class="hljs-comment"># 不带表达式的 return 相当于返回 None</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure></li><li><p><strong>参数传递</strong></p><ul><li>不可变对象: 类似 C++ 的值传递.如整数, 字符串, 元组</li><li>可变对象:类似 C++ 的引用传递.如字典, 列表(传递<code>listName[:]</code>则原列表不会被修改)</li><li>函数可以直接作为参数进行传递</li></ul></li><li><p>参数类型</p><ul><li><strong>位置参数</strong><ul><li>必须按顺序传入函数,调用时 给定的参数数量需与声明一致</li><li><strong>强制位置参数: 在函数定义中参数 <code>/</code> 左侧的必须是位置参数</strong></li></ul></li><li><strong>关键字参数</strong><ul><li>在调用时指出参数名并显式赋值.可以不按顺序书写</li><li><strong>强制关键字参数: 在函数定义中参数 <code>*</code> 右侧的必须时关键字参数</strong></li></ul></li><li>默认参数: 与 C++ 类似.在函数定义时直接指定参数的默认值</li><li><strong>收集参数</strong><ul><li>声明时不会对这些参数命名,因为长度未知</li><li>以 <code>*</code> 为前缀的参数将会以 <code>tuple</code> 的形式接受参数(常用 <code>*args</code>)</li><li>以 <code>**</code> 为前缀的参数将会以 <code>dictionary</code> 的形式接受参数(常用 <code>**kwargs</code>)</li></ul></li></ul></li><li><p><strong>匿名函数</strong></p><ul><li><p><code>lambda</code> 只是一个表达式,而非代码块,无法访问全局命名空间</p></li><li><p><code>lambda</code> 函数拥有自己的命名空间,仅能访问参数列表的参数.函数体只能有一行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> arg1 ,arg2, ..., argn : expression<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="2-7-模块"><a href="#2-7-模块" class="headerlink" title="2.7 模块"></a>2.7 模块</h3><ol><li><p><code>import</code>: 导包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> moudle1[, moudle2, ..., moudleN]<br></code></pre></td></tr></table></figure><ul><li>模块只会被导入1次, 无论执行了多少次 <code>import</code> </li><li>此时对模块中的内容进行调用需要 <code>.</code> 运算符: <code>moudle1.func</code></li></ul></li><li><p><code>from</code>: 简化调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> moudle_name <span class="hljs-keyword">import</span> name1[, name2, ..., nameN]<br></code></pre></td></tr></table></figure><ul><li>从模块中导入指定的部分到当前命名空间中.此时不需要使用<code>.</code>运算符调用</li><li><code>from moudle_name import *</code> 会将模块的全部内容导入到当前命名空间中(不推荐)</li></ul></li><li><p><code>as</code>: 为对象(模块,函数…)指定别名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-keyword">from</span> moudle_name] <span class="hljs-keyword">import</span> object_name [<span class="hljs-keyword">as</span> alias]  <span class="hljs-comment"># 导入模块完整语法</span><br></code></pre></td></tr></table></figure></li><li><p><code>__name__</code> 属性</p><ul><li><p>每个模块都有 <code>__name__</code> 属性</p></li><li><p><strong>当 <code>__name__</code> 的值为 <code>&#39;__main__&#39;</code> 时.表明该模块自身在运行.否则是被导入</strong></p></li><li><p>如需要模块的某块代码仅在其自身运行时执行,可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>: <br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>dir()</code> 函数: 模块内定义的所有名称.以字符串列表的形式返回</p></li><li><p><strong>包: 将模块以文件夹的形式组织到一起(包下面可以有子包)</strong></p><ul><li>注意当目录包含一个名为 <code>__init__.py</code> 的文件才会被认为是一个包</li></ul></li><li><p>导入包中的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">form packeage_name <span class="hljs-keyword">import</span> moudle_name  <span class="hljs-comment"># moudle_name 可以是子包, 模块, 函数, 类, 变量, *</span><br></code></pre></td></tr></table></figure></li><li><p><code>__all__</code>属性: 这是一个列表,以字符串的形式存放</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__all__ = [<span class="hljs-string">&quot;func1&quot;</span>, <span class="hljs-string">&quot;func2&quot;</span>]<br></code></pre></td></tr></table></figure><ul><li>该属性作用于 <code>from xx import *</code> 语句.对可以访问的内容进行了限制.只会包含列表内的功能</li><li>在模块中,该属性直接存在于该文件中</li><li>在包中,该属性存放在必需的文件<code>__init__.py</code>中</li></ul></li></ol><h2 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3 面向对象"></a>3 面向对象</h2><h3 id="3-1-面向对象"><a href="#3-1-面向对象" class="headerlink" title="3.1 面向对象"></a>3.1 面向对象</h3><ol><li><p>类成员</p><ul><li><strong>类命名空间中所有的命名都是有效属性名,而不需要特别声明</strong></li><li><strong>类的方法必须提供一个额外参数 <code>self</code>.指向实例本身</strong></li><li>类属性位于类中,方法外.而实例属性位于 <code>__init__</code> 方法中</li><li>私有属性(双下划线开头): <code>__private_atrrs</code> </li><li>私有方法(双下划线开头): <code>__private_methods()</code></li></ul></li><li><p>构造方法</p><ul><li>名称固定为 <code>__init__()</code>.在实例化时自动调用.且只允许存在一个构造方法</li><li>没有 <code>this</code> 指针.但可以使用 <code>self</code> 表示正在调用该方法的对象(<code>self</code> 名称只是惯例,不是规定)</li><li>调用父类的方法: 使用 <code>super()</code> 函数.获取父类</li></ul></li><li><p>继承: Python 允许多继承</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class_name</span>(BaseClass1, BaseClass2): <br></code></pre></td></tr></table></figure></li></ol><h3 id="3-2-异常处理"><a href="#3-2-异常处理" class="headerlink" title="3.2 异常处理"></a>3.2 异常处理</h3><ol><li><p><code>try - except - else - finally</code> </p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 可能出现异常的代码</span><br><span class="hljs-keyword">except</span> [异常 [<span class="hljs-keyword">as</span> 别名]]:  <span class="hljs-comment"># 如 Exception as e</span><br>    <span class="hljs-comment"># 发生异常时,执行的代码</span><br>[<span class="hljs-keyword">else</span>:]<br><span class="hljs-comment"># 没有发生异常时,执行的代码</span><br>[<span class="hljs-keyword">finally</span>:]<br>    <span class="hljs-comment"># 无论是否发生异常,都要执行的代码</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>若执行时发生异常. <code>try</code> 子句的剩余部分将被忽略</strong></p></li><li><p><strong>异常类型将与 <code>except</code> 提供名称进行匹配.匹配成功则将执行相应的 <code>expect</code> 子句</strong></p></li><li><p><strong>若没有匹配的 <code>expect</code>.则异常传递给 <code>try</code></strong> </p></li><li><p><code>except</code> 子句可以同时处理多个异常.以 tuple 的方式进行存放</p></li><li><p>最后一个 <code>except</code> 子句可以忽略异常的名称,将被当作通配符使用</p></li></ul></li><li><p><strong><code>raise</code>: 抛出一个指定的异常</strong></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">raise</span> [Exception [, args [, traceback]]]<br><span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;x 不能为负&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>raise</code> 指定了要被抛出的异常. 必须是一个异常的实例或者是异常的类(Exception 的子类)</li></ul></li><li><p><strong>异常传递: 如果一个异常发生,但没有捕获异常,则传递给调用者处理.若都没处理,最终由系统处理</strong></p></li><li><p><strong>取得原谅比许可更简单(EAFP: easier to ask for forgiveness than permission)</strong></p><ul><li><strong>即直奔主流程,而将意外情况放在异常处理中</strong></li><li>而不是 LBYL(look before you leap): 先进行数据检查,然后进行操作</li></ul></li><li><p><code>with</code>: 用于异常处理,封装了 <code>try - except - finally</code> 编码范式,提高易用性</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用 try</span><br>file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./hello.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br><span class="hljs-keyword">try</span>:<br>    file.write(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><span class="hljs-keyword">finally</span>:<br>    file.close()<br><br><span class="hljs-comment"># 使用 with</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./hello.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(<span class="hljs-string">&#x27;hello,world!&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><p><code>with</code> 语句的实现在于上下文管理器</p></li><li><p><strong>上下文管理器</strong>: 实现了<code>__enter__(), __exit__()</code>的类</p></li></ul></li></ol><h3 id="3-3-自定义异常"><a href="#3-3-自定义异常" class="headerlink" title="3.3 自定义异常"></a>3.3 自定义异常</h3><ol><li><p><strong>异常类继承自 <code>Exception</code> 类</strong></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyError</span>(<span class="hljs-title class_ inherited__">Exception</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):  <span class="hljs-comment"># Exception类默认的 __init__() 被重写</span><br>        <span class="hljs-variable language_">self</span>.value = value<br></code></pre></td></tr></table></figure></li><li><p>若创建一个模块有可能抛出多种不同的异常时</p><ul><li>通常为这个包建立一个基础异常类.然后基于这个基础类为不同的错误情况创建子类</li><li>大多数的异常的名字都以 <code>Error</code> 结尾,就像标准的异常命名</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Error</span>(<span class="hljs-title class_ inherited__">Exception</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InputError</span>(<span class="hljs-title class_ inherited__">Error</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Exception raised for errors in the input.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Attributes:</span><br><span class="hljs-string">        expression -- input expression in which the error occurred</span><br><span class="hljs-string">        message -- explanation of the error</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, expression, message</span>):<br>        <span class="hljs-variable language_">self</span>.expression = expression<br>        <span class="hljs-variable language_">self</span>.message = message<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransitionError</span>(<span class="hljs-title class_ inherited__">Error</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Raised when an operation attempts a state transition that&#x27;s not allowed.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Attributes:</span><br><span class="hljs-string">        previous -- state at beginning of transition</span><br><span class="hljs-string">        next -- attempted new state</span><br><span class="hljs-string">        message -- explanation of why the specific transition is not allowed</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, previous, <span class="hljs-built_in">next</span>, message</span>):<br>        <span class="hljs-variable language_">self</span>.previous = previous<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>        <span class="hljs-variable language_">self</span>.message = message<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-文件"><a href="#3-4-文件" class="headerlink" title="3.4 文件"></a>3.4 文件</h3><ol><li><p><strong><code>open()</code> 方法: 打开一个文件,并返回文件对象.若无法被打开,抛出 <code>OSError</code></strong></p></li><li><p><strong><code>close()</code> 方法: 关闭文件对象.使用 <code>open()</code> 方法打开的文件必须关闭</strong></p></li><li><p>常用 <code>with - as</code> 语句打开文件(此时无需手动关闭文件)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打开名为 &quot;pi_digits.txt&quot; 的文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;pi_digits.txt&#x27;</span>) <span class="hljs-keyword">as</span> fileObject:<br>    <span class="hljs-built_in">print</span>(fileObject.read().rstrip())<br></code></pre></td></tr></table></figure></li><li><p><code>open</code>的完整语法格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">open</span>(file, mode=<span class="hljs-string">&#x27;r&#x27;</span>, buffering=-<span class="hljs-number">1</span>, encoding=<span class="hljs-literal">None</span>, <br>     errors=<span class="hljs-literal">None</span>, newline=<span class="hljs-literal">None</span>, closefd=<span class="hljs-literal">True</span>, opener=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><ul><li><code>file</code>: 文件路径(必须指定)</li><li><code>mode</code>: 文件打开模式</li><li><code>buffering</code>: 设置缓冲</li><li><code>encoding</code>: 指定编码方式,一般为 ‘utf-8’</li><li><code>errors</code>: 报错级别</li><li><code>newline</code>: 区分换行符</li><li><code>closefd</code>: 传入的 <code>file</code> 参数类型</li><li><code>opener</code>: 设置自定义开启器.开启器的返回值必须是一个打开的文件描述符</li></ul></li><li><p><code>mode</code> 参数可以为</p><table><thead><tr><th align="left">模式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>t &#x2F; b</strong></td><td align="left"><strong>文本格式(默认) &#x2F; 二进制格式</strong></td></tr><tr><td align="left"><strong>r &#x2F; w</strong></td><td align="left"><strong>只读模式(默认) &#x2F; 只写模式(若文件已存在,则写入后会从头覆盖,若不存在则创建文件)</strong></td></tr><tr><td align="left"><strong>a</strong></td><td align="left"><strong>追加模式.若文件已存在,则写入内容追加到文件末尾,若不存在则创建文件</strong></td></tr><tr><td align="left">x</td><td align="left">写模式.需先新建文件,若该文件已存在则会报错</td></tr><tr><td align="left"><strong>+</strong></td><td align="left"><strong>打开一个文件进行更新(可读可写)</strong></td></tr></tbody></table><ul><li>打开格式(t, b) 可与 读写方式(r, w, a, x)进行组合,<code>+</code>也可以进行组合</li><li>如<code>wb+</code>: 用二进制格式打开文件进行读写.一般用于非文本文件,如图片</li></ul></li><li><p>file 对象的常用方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>read(size&#x3D;-1)</strong></td><td><strong>读取指定字节数的数据.默认读取整个文件</strong></td></tr><tr><td>readline(size)</td><td>读取整行,包括 <code>&quot;\n&quot;</code>.返回值为读取到的字节数</td></tr><tr><td><strong>readlines()</strong></td><td><strong>读取所有行(直到EOF)并以列表形式返回.可与<code>for - in</code>连用</strong></td></tr><tr><td><strong>write(str)</strong></td><td><strong>将字符串写入文件,返回值为写入的字符长度</strong></td></tr><tr><td>writelines(sequence)</td><td>向文件写入字符串序列(不会自行添加换行符)</td></tr><tr><td>flush()</td><td>刷新缓冲区,将缓冲区中的数据立即写入文件</td></tr><tr><td>tell()</td><td>获取文件指针的当前位置</td></tr><tr><td><strong>seek(offset, whence&#x3D;0)</strong></td><td><strong>移动文件指针到指定位置.并将其作为返回值,失败返回-1<br />whence: 基准位置(0: 文件头,1: 当前位置,2: 文件末尾)<br />offset: 偏移量(可为负数).</strong></td></tr></tbody></table></li><li><p>JSON 数据</p><ul><li><p>json 模块可以对 JSON 数据进行编解码,包含两个函数</p><ul><li><code>json.dumps()</code>: 对数据编码  Python string  -&gt;   JSON Object</li><li><code>json.loads()</code>: 对数据解码   JSON string   -&gt; Python Object</li></ul></li><li><p>Python 编解码为 JSON 对照表</p><table><thead><tr><th>Python</th><th>JSON</th></tr></thead><tbody><tr><td>int, float, int- &amp; float-derived Enums</td><td>number</td></tr><tr><td>True &#x2F; False &#x2F; None</td><td>true &#x2F; false &#x2F; null</td></tr><tr><td>list, tuple</td><td>array</td></tr><tr><td>dict &#x2F; str</td><td>object &#x2F; string</td></tr></tbody></table></li><li><p>示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 写入 JSON 数据.缩进2,可写入中文</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    json.dump(data, f, indent=<span class="hljs-number">2</span>, ensure_ascii=<span class="hljs-literal">False</span>)<br> <br><span class="hljs-comment"># 读取数据</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.json&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    data = json.load(f)<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="4-Python-库"><a href="#4-Python-库" class="headerlink" title="4 Python 库"></a>4 Python 库</h2><h3 id="4-1-标准库概括"><a href="#4-1-标准库概括" class="headerlink" title="4.1 标准库概括"></a>4.1 标准库概括</h3><ol><li><code>os</code> 模块: 提供与操作系统交互的函数</li><li><code>sys</code> 模块:提供与 Python 解释器和系统相关的功能</li><li><code>time</code> 模块: 提供处理时间的函数</li><li><code>datetime</code> 模块: 提供更高级的日期和时间处理函数</li><li><code>random</code> 模块: 提供生成随机数的函数</li><li><code>math</code> 模块: 提供数学函数</li><li><code>re</code> 模块: 提供正则表达式处理函数</li><li><code>json</code> 模块: 提供 JSON 编解码函数.可将 Python 对象转换为 JSON 格式,并从 JSON 格式解析出 Python 对象</li><li><code>urllib</code> 模块: 提供访问网页和处理 URL 的功能.包括下载文件,发送 POST 请求,处理 cookies 等</li></ol><h3 id="4-2-第三方库"><a href="#4-2-第三方库" class="headerlink" title="4.2 第三方库"></a>4.2 第三方库</h3><ol><li><p><strong><a href="https://pypi.org/project/pip/">pip</a>: Python 的包管理工具.提供对 Python 包的查找, 下载, 安装, 卸载功能</strong></p><ul><li><p>配置 <code>pip</code> 从清华源下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure></li><li><p>更新 <code>pip</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pip<br></code></pre></td></tr></table></figure></li><li><p>安装 &#x2F; 升级 &#x2F; 卸载包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install SomePackage            # 最新版本<br>pip install SomePackage==1.0.4     # 指定版本<br>pip install &#x27;SomePackage&gt;=1.0.4&#x27;   # 最小版本<br>pip install --upgrade SomePackage  # 升级包<br>pip uninstall SomePackage          # 卸载包<br></code></pre></td></tr></table></figure></li><li><p>升级 pip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install -U pip               # Linux 环境<br>sudo easy_install --upgrade pip  # 若上一条命令出错可使用<br>python -m pip install -U pip     # Windows 环境<br></code></pre></td></tr></table></figure></li><li><p>其他功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip list                 # 显示已安装的包<br>pip list -o              # 查看可升级的包<br>pip show                 # 显示安装包信息<br>pip show -f SomePackage  # 查找指定包的信息<br>pip search SomePackage   # 搜索包<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>pytest</code>: Python 测试框架.用于代码测试</p></li><li><p><code>pygame</code>: 基于 Python 的游戏开发库</p></li><li><p><code>Matplotlib</code>: Python 2D-绘图领域使用最广泛的套件</p></li><li><p><code>Plotly</code>: 创建漂亮的基于 web 的交互式可视化</p></li></ol><h3 id="4-3-pytest"><a href="#4-3-pytest" class="headerlink" title="4.3 pytest"></a>4.3 pytest</h3><ol><li><p>在虚拟环境安装 <code>pytest</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m pip install --user pytest<br></code></pre></td></tr></table></figure></li><li><p>测试函数</p><ul><li><p><strong>文件名必须用 <code>test_</code> 开头或 <code>_test</code> 结尾.而测试函数只能用 <code>test_</code> 开头</strong></p></li><li><p>测试中 <code>pytest</code> 将找出这些文件,并运行其中需要进行测试的函数</p></li><li><p>考虑到测试函数会被 <code>pytest</code> 自动调用.其名称可以起得很长.便于阅读</p></li><li><p>作出断言(<code>assert</code>): 在测试函数中应成立的条件语句,一个函数可以有多个 <code>assert</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_add</span>(): <span class="hljs-comment"># 测试函数</span><br>    <span class="hljs-keyword">assert</span> add(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure></li><li><p>常用的 <code>assert</code> 形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">assert</span> xx：     <span class="hljs-comment"># 判断 xx 为真</span><br><span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> xx： <span class="hljs-comment"># 判断 xx 不为真</span><br><span class="hljs-keyword">assert</span> a <span class="hljs-keyword">in</span> b： <span class="hljs-comment"># 判断 b 包含 a</span><br><span class="hljs-keyword">assert</span> a == b： <span class="hljs-comment"># 判断 a 等于 b</span><br><span class="hljs-keyword">assert</span> a != b： <span class="hljs-comment"># 判断 a 不等于 b</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>在终端窗口执行 <code>pytest</code>.将自动完成测试,并在终端输出测试信息</p><p><img src="/2023/07/01/Computer/Python-Crash-Course/4-Pytest.png"></p></li><li><p>为管理测试函数,还可以将其封装在类中</p></li><li><p>测试类方法时需实例化对象.然后测试过程与测试函数相似</p></li><li><p>夹具(fixture)</p><ul><li><p>使用 <code>@pytest.fixture</code> 装饰函数,使得该函数可以成为其他测试函数的参数</p></li><li><p>其他测试函数可接收该参数(被装饰的函数名)继续测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-string">&quot;&quot;&quot; Dog类有2个属性: name, age.以及对应的 setter 方法 &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-variable language_">self</span>.age = age<br>        <span class="hljs-variable language_">self</span>.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setAge</span>(<span class="hljs-params">self, age</span>):<br>        <span class="hljs-variable language_">self</span>.age = age<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test_class_Dog</span>:<br>    <span class="hljs-string">&quot;&quot;&quot; 将测试函数封装在类中 &quot;&quot;&quot;</span><br><span class="hljs-meta">    @pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;class&quot;</span></span>)</span><br>    <span class="hljs-comment"># scope可为 session -&gt; module(默认) -&gt; class -&gt; function</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dog_object_test</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot; 实例化一个 Dog 对象,将其作为测试用例 &quot;&quot;&quot;</span><br>        dog = Dog(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">return</span> dog<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_set_name</span>(<span class="hljs-params">self, dog_object_test</span>):<br>        <span class="hljs-string">&quot;&quot;&quot; 测试 setName 方法&quot;&quot;&quot;</span><br>        dog_object_test.setName(<span class="hljs-string">&quot;Jerry&quot;</span>)<br>        <span class="hljs-keyword">assert</span> dog_object_test.name == <span class="hljs-string">&quot;Jerry&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_set_age</span>(<span class="hljs-params">self, dog_object_test</span>):<br>        <span class="hljs-string">&quot;&quot;&quot; 测试 setAge 方法 &quot;&quot;&quot;</span><br>        dog_object_test.setAge(<span class="hljs-number">5</span>)<br>        <span class="hljs-keyword">assert</span> dog_object_test.age == <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="附录A-Python-环境"><a href="#附录A-Python-环境" class="headerlink" title="附录A Python 环境"></a>附录A Python 环境</h2><ol><li><p>Windows 环境(<code>pip</code> 会随着 Python 一起安装)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip --version                        # 查看 pip 版本<br>python -m pip install --upgrade pip  # 更新 pip<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一个 .venv 的虚拟环境文件夹.并使用 --upgrade-deps 自动升级 pip 和 setuptools</span><br>python -m venv .venv --upgrade-deps<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">激活指定的虚拟环境, 此时终端(cmd)提示符前会显示 (.venv)</span><br>.\.venv\Scripts\activate<br><span class="hljs-meta prompt_"># </span><span class="language-bash">若出现 Execution Policy 报错,使用 管理员身份打开 PowerShell,运行下面命令</span><br>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force<br></code></pre></td></tr></table></figure></li><li><p>linux 环境: 在 Ubuntu 20.04.6 LTS 中,默认安装 Python2 (<code>python</code>) 和 Python3 (<code>python3</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">python --version   # Python 2.7.18<br>python3 --version  # Python 3.8.10<br><br>sudo apt update<br>sudo apt install python3-pip  # 安装官方仓库的 pip<br>pip3 --version                # 验证安装<br><br>pip3 install virtualenv       # 安装 virtualenv<br>python3 -m virtualenv .venv   # 创建虚拟环境<br>source .venv/bin/activate     # 激活虚拟环境<br></code></pre></td></tr></table></figure></li><li><p>虚拟环境的使用与删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入虚拟环境后安装的第三方库不会影响到其他环境</span><br>pip install numpy<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">退出虚拟环境. 将会退出到默认全局 Python 环境</span><br>deactivate<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除虚拟环境. 只需删除对应的目录文件即可</span><br>rm -rf .venv<br></code></pre></td></tr></table></figure></li><li><p>在 VS Code 中使用虚拟环境</p><ul><li>安装 <code>python</code> 拓展.在状态栏中直接选择 python 虚拟环境</li><li>或 <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>P</kbd> 搜索 <code>Python: Select Interpreter</code>. 选择虚拟环境</li><li>后续 <kbd>Ctrl</kbd><kbd>`</kbd> 打开的终端直接会进入虚拟环境</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>Code</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2023/06/02/Tool/Git/"/>
    <url>/2023/06/02/Tool/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1-Git-基础"><a href="#1-Git-基础" class="headerlink" title="1 Git 基础"></a>1 <a href="https://www.bilibili.com/video/BV1HM411377j/?spm_id_from=333.1387.favlist.content.click">Git 基础</a></h2><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><ol><li><p>git 安装</p><ul><li><p>在 <a href="https://git-scm.com/download">git 官网</a> 下载对应系统的安装包.一直下一步安装即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git --version  <span class="hljs-comment"># 验证安装</span><br></code></pre></td></tr></table></figure></li><li><p>在 Windows 中,会自动安装 <code>Git Bash</code>(在文件夹中右键即可看到)</p></li></ul></li><li><p>git 的使用方式分为</p><ul><li>命令行(最基本,最常见)</li><li>图形化界面(GUI)</li><li>IDE 插件&#x2F;扩展(推荐使用 VS Code 中的 git 插件)</li></ul></li><li><p>初始化操作</p><ul><li><p><strong>git 的所有命令均以 <code>git</code> 开头,后面再接具体的命令.如: <code>git init</code> 表示初始化仓库</strong></p></li><li><p>git 安装后需要进行配置用户名和邮箱,以便查看代码提交者(只需设置一次)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;user&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;email&quot;</span><br>git config --list  <span class="hljs-comment"># 检查配置是否成功</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>vim</code> 作为默认编辑器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global core.editor &quot;vim&quot;<br></code></pre></td></tr></table></figure></li><li><p>如果用户名参数包含空格,则需要使用双引号包裹</p></li><li><p><code>--global</code> 表示全局配置,对所有仓库有效.如果省略则表示本地配置,只对本地仓库有效</p></li></ul></li><li><p>新建仓库</p><ul><li><p>仓库 &#x2F; 版本库(Repository, 简称 Reop): 是一个文件目录,其中的文件被 <code>git</code> 管理</p></li><li><p>对仓库中文件的 修改, 删除, 添加操作都将被 <code>git</code> 追踪</p></li><li><p><strong>本地创建仓库</strong>: 此时 <code>git</code> 将会创建一个 <code>.git</code> 的隐藏目录.用于存放仓库的数据(不要自己更改其中的内容)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure></li><li><p><strong>从服务器克隆仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> url<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-2-概念"><a href="#1-2-概念" class="headerlink" title="1.2 概念"></a>1.2 概念</h3><ol><li><p>工作区域</p><ul><li><p><strong>工作目录(Working Directory)</strong>: 实际操作的目录</p></li><li><p><strong>暂存区(Staging Area&#x2F;Index)</strong>: 临时存储区域.保存即将提交到 <code>git</code> 仓库的修改内容</p></li><li><p><strong>本地仓库(Local Repository)</strong>: 存储代码和版本信息的主要位置.包含完整的项目历史和元数据</p><p><img src="/2023/06/02/Tool/Git/1-Git-workingArea.png"></p></li></ul></li><li><p>提交流程</p><ul><li><p>在对工作目录的文件进行修改后,需要先提交到暂存区,然后将暂存区的修改提交到本地仓库</p></li><li><p>在上述过程中,可以使用 <code>git</code> 命令进行查看, 比较, 撤销修改</p></li><li><p><strong>添加(git add): 从工作目录 -&gt; 暂存区</strong></p></li><li><p><strong>提交(git commit): 从暂存区 -&gt; 本地仓库</strong></p></li><li><p>在多次添加到暂存区后,到达需要增加版本的地步,就可以进行提交(push)</p></li></ul></li><li><p>文件状态</p><ul><li><p><strong>未跟踪(Untrack)</strong>: 新创建的,未被 <code>git</code> 管理的文件</p></li><li><p><strong>未修改(Unmodified)</strong>: 已经被 <code>git</code> 管理,但内容没有变化</p></li><li><p><strong>已修改(Modified)</strong>: 修改了文件,但未添加到暂存区</p></li><li><p><strong>已暂存(Staged)</strong>: 修改后,并添加到暂存区的文件</p><p><img src="/2023/06/02/Tool/Git/1-Git-fileState.png"></p></li></ul></li></ol><h3 id="1-3-提交"><a href="#1-3-提交" class="headerlink" title="1.3 提交"></a>1.3 提交</h3><ol><li><p>查看状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log    # 查看提交记录.包含: 提交 ID, 作者, 时间, 备注信息<br>git status # 查看目录中的文件的状态<br></code></pre></td></tr></table></figure></li><li><p><strong>添加: 将指定的文件添加到暂存区(会排除 <code>.gitignore</code> 中匹配的文件)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add &lt;filename&gt; # 添加指定文件(无论是修改, 新建, 删除均使用 add 暂存)<br>git add .          # 添加当前目录及其所有子目录下的所有新文件和已修改文件<br></code></pre></td></tr></table></figure></li><li><p><strong>提交: 将暂存区中的修改提交到本地仓库(注意不会提交工作目录的文件)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m &quot;message&quot; # 提交并直接在命令行中提供提交信息的标题<br>git commit --amend      # 修改提交信息 或 添加遗漏的文件<br></code></pre></td></tr></table></figure></li><li><p>放弃修改</p><p><img src="/2023/06/02/Tool/Git/1-Git-Reset.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --&lt;mode&gt; &lt;commit&gt;<br></code></pre></td></tr></table></figure><ul><li><p><strong><code>git reset</code> 本质上是移动当前分支所指向的提交(即 <code>HEAD</code> 指针)到指定的历史提交</strong></p><table><thead><tr><th>mode 参数</th><th>效果</th></tr></thead><tbody><tr><td><code>soft</code></td><td>自 <code>&lt;commit&gt;</code> 后的提交在提交历史中暂时消失(可以通过 <code>git relog</code> 找回).<br />之前提交的所有修改(相对于 <code>&lt;commit&gt;</code> 的改动)都变成了 <strong>已暂存的更改</strong>.<br />不影响暂存区,也不影响工作目录</td></tr><tr><td><code>mixed</code>(默认参数)</td><td>自 <code>&lt;commit&gt;</code> 后的提交在提交历史中暂时消失.<br />之前提交的所有修改(相对于 <code>&lt;commit&gt;</code> 的改动)都变成了 <strong>未暂存的更改</strong>.<br />重置暂存区,但不影响工作目录</td></tr><tr><td><code>hard</code>(极其危险)</td><td>自 <code>&lt;commit&gt;</code> 以来的所有后续提交在提交历史中暂时消失.<br />暂存区被清空,工作目录中所有未提交(包括未暂存和已暂存)的更改都会被永久丢弃</td></tr></tbody></table></li><li><p><code>commit</code> 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset a1b2c3d # 提交的哈希值.通常只需要前 7 个字符就足够唯一标识<br>git reset main    # 分支名.表示重置到该分支当前指向的提交<br>git reset v1.0    # 标签名.表示重置到该标签指向的提交<br>git reset HEAD    # 表示当前提交<br>git reset HEAD~n  # 表示当前提交的第 n 个提交<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>soft</code> 最佳实践: 多次 <code>commit</code> 后,想要将其合并为一次 <code>commit</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --soft &lt;commit&gt; # 先回退到修改前的 commit,此时所有的改动都回到暂存区<br>git add                   # 如果存在遗漏继续添加,否则不需要该步骤<br>git commit -m &quot;message&quot;   # 再次提交,此时先前的多个提交变成一次提交<br></code></pre></td></tr></table></figure></li><li><p><code>mixed</code> 最佳实践: 提交了不需要的东西,想撤销这些提交,但工作目录中实际修改的代码仍需保留</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset HEAD~1 # 撤销最新一次 commit.但提交的修改以未暂存的状态保留到工作目录<br>git reset file   # 撤销特定文件的 add.但保留文件在工作目录的修改<br></code></pre></td></tr></table></figure></li><li><p><code>hard</code> 最佳实践: 确保不需要工作目录和暂存区中未提交的修改情况下使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard HEAD # 丢弃所有未提交修改<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-4-差异"><a href="#1-4-差异" class="headerlink" title="1.4 差异"></a>1.4 差异</h3><ol><li><p><strong>查看差异</strong>: 后续可以使用 IDE 更美观地查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff           <span class="hljs-comment"># 工作目录 vs 暂存区</span><br>git diff HEAD      <span class="hljs-comment"># 工作目录 + 暂存区 vs 本地仓库</span><br>git diff --cached  <span class="hljs-comment"># 暂存区 vs 本地仓库</span><br>git diff --staged  <span class="hljs-comment"># 暂存区 vs 本地仓库</span><br><br>git diff &lt;commit_hash&gt; &lt;commit_hash&gt;  <span class="hljs-comment"># 比较指定两次提交的差异</span><br>git diff HEAD~ HEAD                   <span class="hljs-comment"># 上一次提交 vs 本地仓库</span><br>git diff &lt;branch_hash&gt; &lt;branch_hash&gt;  <span class="hljs-comment"># 比较两个分支的差异</span><br></code></pre></td></tr></table></figure><p><img src="/2023/06/02/Tool/Git/1-Git-diff.png"></p></li><li><p><strong>删除文件</strong>: 删除工作目录和暂存区中的指定文件.但版本库不变</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> &lt;filename&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>忽略文件</strong>: 通过 <code>.gitignore</code> 文件来指定忽略特定的文件</p><p><img src="/2023/06/02/Tool/Git/1-Gitignore.png"></p><ul><li>新建一个 <code>.gitignore</code> 文件,在其中存储想要被忽略的文件名</li><li>会从上往下逐行匹配,每行表示一个忽略模式</li></ul></li><li><p><strong><code>.gitignore</code> 匹配规则: 使用标准的 Blob 模式匹配</strong></p><ul><li>文件可以使用通配符.如 <code>*.log</code> 表示忽略所有后缀为 log 的文件</li><li>文件夹需要以 <code>/</code> 结尾</li><li>以 <code>#</code> 开头的行表示注释</li></ul></li></ol><h3 id="1-5-分支"><a href="#1-5-分支" class="headerlink" title="1.5 分支"></a>1.5 分支</h3><ol><li><p><strong>分支(Branch): 代码的不同版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch           # 查看分支信息.结果中 * 表示当前所处的分支<br>git branch &lt;name&gt;    # 创建新分支.创建新分支后并不会自动切换分支<br>git branch -d &lt;name&gt; # 删除指定的已合并分支(安全删除,因为必须已合并到其他分支才能被删除)<br>git switch &lt;name&gt;    # 切换分支.同时工作目录的文件会被自动替换为目标分支的状态<br>git merge &lt;name&gt;     # 将指定分支合并到当前分支.该指令会执行一次提交,因此需要输入提交信息<br>git log --graph --oneline --decorate --all # 查看分支图<br></code></pre></td></tr></table></figure></li><li><p>合并冲突</p><ul><li><strong>当合并分支时,出现同一文件被不同分支修改时,会出现冲突,需要手动解决冲突</strong></li><li>此时,使用 <code>git status</code> 命令查看冲突文件的列表.<code>git diff</code> 可以查看冲突的具体内容</li></ul></li><li><p>变基(Rebase)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rebase main # 将当前分支变基到 main 分支<br></code></pre></td></tr></table></figure><ul><li>每个分支都有一个 <code>HEAD</code> 指针,指向当前分支的最新提交记录</li><li>当执行变基时,将寻找两个分支的共同的祖先节点</li><li>然后将当前分支的祖先节点之后的提交移植到目标分支的后面</li><li>变基使得分支始终保持简单的线性结构.但破坏了原分支的提交记录.不要在公共分支 <code>rebase</code></li><li>分支合并不会破坏提交记录,方便回溯.但产生了额外的节点</li></ul></li></ol><h3 id="1-6-暂存"><a href="#1-6-暂存" class="headerlink" title="1.6 暂存"></a>1.6 暂存</h3><ol><li><p><strong>暂存(Stash): 临时保存工作目录和暂存区的修改.可以快速切换上下文而不需要提交未完成的工作</strong></p><ul><li><code>stash</code> 默认管理的对象<ul><li>已追踪的修改(工作目录中)</li><li>已暂存的文件</li></ul></li><li><code>stash</code> 默认不管理的对象<ul><li>未追踪的文件(新创建的文件)</li><li>被 <code>.gitignore</code> 忽略的文件</li></ul></li></ul></li><li><p>基础保存功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">git stash                 # 保存当前修改到新 stash(默认消息)<br>git stash save &quot;message&quot;  # 保存并添加自定义消息<br><br>git stash list            # 查看所有 stash 列表<br><br>git stash pop             # 恢复最新 stash 并删除<br>git stash pop stash@&#123;2&#125;   # 恢复特定 stash<br><br>git stash apply           # 恢复 stash,但不删除<br>git stash apply stash@&#123;1&#125; # 恢复特定 stash,但不删除<br></code></pre></td></tr></table></figure></li><li><p>包含未追踪的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git stash -u  # 包含未跟踪文件(新文件)<br>git stash -a  # 包含所有文件(包括被忽略的文件)<br></code></pre></td></tr></table></figure></li><li><p>查看暂存信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git stash show stash@&#123;0&#125;     # 查看 stash 简略信息<br>git stash show -p stash@&#123;0&#125;  # 查看详细 diff 内容<br>git stash show -u stash@&#123;0&#125;  # 查看包含未跟踪文件的信息<br></code></pre></td></tr></table></figure></li><li><p>管理 <code>stash</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git stash push -m &quot;message&quot;  # 创建带描述的新 stash<br>git stash push file1 file2   # 选择性 stash 部分文件<br>git stash drop stash@&#123;1&#125;     # 删除特定 stash<br>git stash clear              # 清空所有 stash<br></code></pre></td></tr></table></figure></li><li><p>分支操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git stash branch new-branch-name stash@&#123;0&#125;  # 在新分支上应用 stash<br>git log --oneline stash@&#123;0&#125;  # 检查 stash 创建时的提交状态<br></code></pre></td></tr></table></figure></li><li><p>最佳实践: 测试其他分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git stash push -am &quot;message&quot; # 将本地所有的修改暂存<br>git switch other-branch      # 切换到其他进行工作<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进行测试工作...</span><br>git switch original-branch   # 工作完成后切换回来<br>git stash pop                # 将暂存恢复<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-7-最佳实践"><a href="#1-7-最佳实践" class="headerlink" title="1.7 最佳实践"></a>1.7 最佳实践</h3><ol><li><p>保证 <code>master</code> 分支中的代码是可发布的.不允许直接修改,只能合并,每当合并时生成一个版本号</p><p><img src="/2023/06/02/Tool/Git/1-Git-GitHubFlow.png"></p></li><li><p>case1: 接到开发 cpu 的需求,开发完成后 push</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">git switch &lt;main&gt;                   # 1.确保在待开发的分支上.以 main 分支为例<br>git pull origin &lt;main&gt;              # 2.确保更新到最新版本<br>git switch -c &lt;feature/cpu-test&gt;    # 3.创建 cpu 开发分支<br><br>git add .                           # 4.进行开发工作.修改文件,添加功能等<br>git commit -m &quot;update cpu&quot;          # 5.测试完成后在本地提交<br><br>git switch &lt;main&gt;                   # 6.完成对 cpu 的开发后,返回 main 分支<br>git pull origin &lt;main&gt;              # 7.再次更新 main 分支到最新.如果存在冲突需手动解决<br>git merge --squash feature/cpu-test # 8.将 cpu 分支的所有变更压缩成一个提交合并到 main 分支<br>git commit -m &quot;complete cpu test&quot;   # 9.提交到本地 main 分支<br>git push origin main                # 10.推送到远程仓库<br></code></pre></td></tr></table></figure></li><li><p>case2: 在上面开发 cpu 的第 4 或 5 步时可能接收到紧急任务,如需要开发 gpu 驱动.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">git stash push -u -m &quot;cpu developing&quot; # 1. 暂存所有未提交的修改(包括已跟踪和未跟踪文件)<br>git stash list                        # 2. 验证暂存列表<br>git switch &lt;main&gt;                     # 3. 切换到 main 分支<br>git pull origin &lt;main&gt;                # 4. 确保更新到最新版本<br>git switch -c &lt;feature/gpu-test&gt;      # 5. 创建并切换到干净的 gpu 开发分支<br><br>git add drivers/gpu/                  # 6.模拟本地对文件的修改<br>git commit -m &quot;update gpu&quot;            # 7.测试完成后在本地提交<br>git switch &lt;main&gt;                     # 8.完成对 gpu 的开发后,返回 main 分支<br>git pull origin &lt;main&gt;                # 9.更新 main 分支到最新<br>git merge --squash feature/gpu-test   # 10.将 gpu 分支的所有变更压缩成一个提交合并到 main 分支<br>git commit -m &quot;complete cpu test&quot;     # 11.提交到本地 main 分支<br>git push origin main                  # 12.推送到远程仓库<br>git branch -d feature/gpu-test        # 13.删除已合并的本地 gpu 开发分支<br><br>git switch feature/cpu-test           # 14.回到 cpu 开发分支,继续开发<br>git stash pop                         # 15.恢复工作现场<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-GitHub-Pages"><a href="#2-GitHub-Pages" class="headerlink" title="2 GitHub Pages"></a>2 GitHub Pages</h2><h3 id="2-1-关联-github"><a href="#2-1-关联-github" class="headerlink" title="2.1 关联 github"></a>2.1 关联 github</h3><ol><li><p>要关联本地仓库与远程仓库,首先需要设置 SSH 密钥</p><ul><li><p>检查主机是否已经存在 ssh key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls ~/.ssh/id_rsa.pub  # 查看是否已经生成过密钥 id_rsa(私钥) id_rsa.pub(公钥)<br>cat ~/.ssh/id_rsa.pub # 查看生成的密钥(复制输出的内容.以 ssh-rsa AAA... 开头)<br></code></pre></td></tr></table></figure></li><li><p>如果没有 ssh key.则需要先生成(如果有 ssh key.则直接获取)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~/.ssh                 # 切换到.ssh目录<br>ssh-keygen -t rsa -b 4096 # 生成 rsa 密钥,大小为 4096<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在 GitHub 账号中添加公钥</p><ul><li><p>回到 GitHub,点击头像 -&gt; <code>Settings</code> -&gt; <code>SSH and GPG keys</code> -&gt; <code>New SSH key</code></p><p><img src="/2023/06/02/Tool/Git/1-Git-github-sshkey.png"></p></li><li><p>将 <code>id_rsa.pub</code> 文件中的内容复制到 Key 中即可</p></li><li><p>验证设置是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br><span class="hljs-meta prompt_"># </span><span class="language-bash">成功将显示: Hi Fxs21! You<span class="hljs-string">&#x27;ve successfully authenticated...</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>完成 SSH 的设置后,可以直接使用 SSH 进行 <code>git clone</code> 操作</p></li><li><p>本地仓库和远程仓库是不同的仓库.想要将两者的文件同步.需要 <code>git pull, git push</code> 指令</p><p><img src="/2023/06/02/Tool/Git/1-Git-push.png"></p></li><li><p>此时,完成了关联本地仓库与远程仓库的准备工作</p></li><li><p>在 github 上创建一个新仓库.然后进行操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add &lt;shortname&gt; &lt;url&gt; # 将本地仓库关联到远程仓库.同时创建了远程库的别名<br>git remote -v # 查看当前仓库对应的远程仓库的别名和地址(默认 shortname == origin)<br>git branch -M main # 指定分支名为 main<br>git push -u origin main # 将本地的 main 分支与远程仓库 origin 的 main 分支关联.并推送<br>git pull # 拉取远程仓库中的分支.默认为 origin 的 main 分支<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-创建-Pages"><a href="#2-2-创建-Pages" class="headerlink" title="2.2 创建 Pages"></a>2.2 创建 Pages</h3><ol><li><p><a href="https://github.com/">github</a>: 代码托管平台</p></li><li><p>创建仓库: 名称格式为 <code>username.github.io</code></p><p><img src="/2023/06/02/Tool/Git/1-Git-githubCreateRepo.png"></p></li><li><p>在 <code>settings</code> 中找到 <code>Pages</code>.此时 <code>Source</code> 为空.因此需要上传静态页面</p></li><li><p>拉取代码到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone git@github.com:Fxs21/Fxs21.github.io.git<br></code></pre></td></tr></table></figure></li><li><p>上传代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加 git@github.com:Fxs21/Fxs21.github.io.git 远程仓库. 别名为 origin</span><br>git remote add origin git@github.com:Fxs21/Fxs21.github.io.git<br><br>git remote -v             # 检查是否已经添加了远程仓库<br>ssh -T git@github.com     # 测试 SSH 连接<br>git push -u origin master # 提交代码.并建立本地分支与远程分支的跟踪关系<br>git pull                  # 等同于 git pull origin master<br></code></pre></td></tr></table></figure></li><li><p>此时再次进入 github. 在 <code>settings</code> 中找到 <code>Pages</code>.此时 <code>Source</code> 就有了 <code>master</code> 分支</p><p><img src="/2023/06/02/Tool/Git/2-Git-githubSource.png"></p></li><li><p>显示 Your site is live at <a href="https://fxs21.github.io/">https://fxs21.github.io/</a>: 表示成功部署可以在网页中打开</p></li></ol><h2 id="3-hexo"><a href="#3-hexo" class="headerlink" title="3 hexo"></a>3 hexo</h2><h3 id="3-1-安装-hexo"><a href="#3-1-安装-hexo" class="headerlink" title="3.1 安装 hexo"></a>3.1 安装 <a href="https://hexo.io/zh-cn/">hexo</a></h3><ol><li><p>安装 <code>git</code> 并配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;fxs&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;yshuang68@163.com&quot;</span><br>git config --list<br></code></pre></td></tr></table></figure></li><li><p>安装 NodeJS: <a href="https://nodejs.org/en">官网下载</a>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">node -v  # 验证安装<br>npm config set prefix &quot;D:\code\npm_path&quot;  # 配置 npm 的全局安装路径<br></code></pre></td></tr></table></figure></li><li><p>安装 <code>hexo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g  <span class="hljs-comment"># 安装 hexo</span><br>hexo -v                  <span class="hljs-comment"># 验证安装</span><br></code></pre></td></tr></table></figure></li><li><p>初始化 <code>hexo</code>(新建一个空目录,然后使用 <code>git bash</code> 打开)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init  <span class="hljs-comment"># 从 github 拉取代码</span><br>git init   <span class="hljs-comment"># 初始化 git 仓库</span><br></code></pre></td></tr></table></figure></li><li><p><code>hexo</code> 的 hello world</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s<br></code></pre></td></tr></table></figure><ul><li><p>打开网址 <a href="http://localhost:4000/">http://localhost:4000/</a>. 能看到 hello world 网页表示配置成功</p><p><img src="/2023/06/02/Tool/Git/3-hexo-hello-world.png"></p></li></ul></li></ol><h3 id="3-2-hexo-部署"><a href="#3-2-hexo-部署" class="headerlink" title="3.2 hexo 部署"></a>3.2 hexo 部署</h3><ol><li><p>配置 SSH 免密登录</p><ul><li><p>先检查是否已经生成过密钥(<code>PowerShell </code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls ~/.ssh/id_rsa.pub  # 查看是否已经生成过密钥 id_rsa(私钥) id_rsa.pub(公钥)<br>cat ~/.ssh/id_rsa.pub # 查看生成的密钥(复制输出的内容.以 ssh-rsa AAA... 开头)<br></code></pre></td></tr></table></figure></li><li><p>若没有生成过则生成密钥(默认保存路径为 <code>C:\Users\你的用户名\.ssh\id_rsa</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -b 4096<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在 GitHub 上添加公钥(参考 [1.7章](# 1.7 关联 github 仓库))</p></li><li><p>安装部署插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li><li><p>配置 hexo 上传的地址(打开 <code>_config.yml</code> 文件,在最后添加内容.<strong>注意这里的配置决定了仓库地址</strong>)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">&#x27;git&#x27;</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:Fxs21/Fxs21.github.io.git</span><br></code></pre></td></tr></table></figure></li><li><p>使用 hexo 命令将代码部署到远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl <span class="hljs-comment"># 清除文件</span><br>hexo g  <span class="hljs-comment"># 生成静态文件.路径为 ./public/</span><br>hexo d  <span class="hljs-comment"># 上传到服务器</span><br></code></pre></td></tr></table></figure></li><li><p>对于调试不需要生成静态文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo cl &amp;&amp; hexo s<br></code></pre></td></tr></table></figure></li><li><p>hexo 文章按照 <code>date</code> 字段(建立日期)排序.下面是 Windows 中修改创建日期的指令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">(<span class="hljs-built_in">Get-Item</span> <span class="hljs-string">&quot;文件路径&quot;</span>).CreationTime = <span class="hljs-string">&quot;新时间&quot;</span>  <span class="hljs-comment"># 修改单个文件的创建时间</span><br>(<span class="hljs-built_in">Get-Item</span> <span class="hljs-string">&quot;文件路径&quot;</span>).CreationTime.ToString(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>) <span class="hljs-comment"># 查看创建时间</span><br><br><span class="hljs-comment"># 示例: 将 D:\blog\post.md 创建时间设为 2023-01-01 12:00</span><br>(<span class="hljs-built_in">Get-Item</span> <span class="hljs-string">&quot;D:\blog\post.md&quot;</span>).CreationTime = <span class="hljs-string">&quot;2023-01-01 12:00&quot;</span><br><br><span class="hljs-comment"># 批量修改文件夹内所有文件</span><br><span class="hljs-built_in">Get-ChildItem</span> <span class="hljs-string">&quot;文件夹路径&quot;</span> | <span class="hljs-built_in">ForEach-Object</span> &#123; <span class="hljs-variable">$_</span>.CreationTime = <span class="hljs-string">&quot;新时间&quot;</span> &#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-3-hexo-配置"><a href="#3-3-hexo-配置" class="headerlink" title="3.3 hexo 配置"></a>3.3 hexo 配置</h3><ol><li><p><strong>更换主题</strong>: 在 <a href="https://hexo.io/themes/">Themes | Hexo</a> 选择合适的主题.这里以 <code>Fluid</code> 为例,根据 <a href="https://github.com/fluid-dev/hexo-theme-fluid">参考文档</a> 安装</p><ul><li><p>安装 <code>Fluid</code> 主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure></li><li><p>在博客目录下创建 <code>_config.fluid.yml</code> 文件</p></li><li><p>将 <code>./node_modules/hexo-theme-fluid/_config.yml</code> 的内容复制到 <code>_config.fluid.yml</code> 文件</p></li><li><p>更改默认的主题: 打开 <code>_config.yml</code> 文件,修改 <code>theme, language</code> 项</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>     <span class="hljs-comment"># 指定主题</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CH</span>  <span class="hljs-comment"># 指定语言</span><br></code></pre></td></tr></table></figure></li><li><p>创建关于页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about<br></code></pre></td></tr></table></figure></li><li><p>在 <code>./source/about/index.md</code> 文件中添加一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">layout: about<br></code></pre></td></tr></table></figure></li></ul></li><li><p>工作目录(初始化之后的目录)</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br><span class="hljs-string">|   ├── _drafts</span><br><span class="hljs-string">|   └── _posts</span><br>└── themes<br></code></pre></td></tr></table></figure><ul><li><strong><code>_config.yml</code>: 网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 文件.可以在此配置大部分的参数</strong></li><li><code>package.json</code>: 应用程序的信息. <a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> 渲染引擎 已默认安装</li><li><code>scaffolds</code>: 模板文件夹.新建文章时根据此文件创建</li><li><strong><code>source</code>: 存放用户资源</strong><ul><li>除 <code>_posts</code> 文件夹之外,开头命名为 <code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略</li><li>Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹,而其他文件会被拷贝过去</li></ul></li><li><code>themes</code>: 主题文件夹.Hexo 会根据主题来生成静态页面</li></ul></li><li><p><strong>站点配置</strong>: Hexo 博客目录下的 <code>_config.yml</code> 文件</p><ul><li><p>站点名称</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Shuang</span> <span class="hljs-string">blog</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">&#x27;Shuang blog&#x27;</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;Shuang blog&#x27;</span><br><span class="hljs-attr">keywords:</span> <span class="hljs-string">Shuang</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">Shuang</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">&#x27;Asia/Shuanghai&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>资源文件夹</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ul><li>启用后,资源图片将会被自动解析为其对应文章的路径</li><li>如: <code>image.jpg</code> 位置为 <code>/2020/01/02/foo/image.jpg</code>.表示是 <code>/2020/01/02/foo/</code> 文章的一张图片</li><li><code>![](image.jpg)</code> 将会被解析为 <code>&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt;</code></li></ul></li></ul></li></ol><h3 id="3-4-Fluid-主题"><a href="#3-4-Fluid-主题" class="headerlink" title="3.4 Fluid  主题"></a>3.4 <a href="https://hexo.fluid-dev.com/docs/start/">Fluid </a> 主题</h3><ol><li><p>配置文件的修改</p><ul><li><strong>主题配置</strong>: <code>theme/fluid/_config.yml</code> 或者 <code>_config.fluid.yml</code> 文件</li></ul></li><li><p>Fluid 主题默认总体概览</p><p><img src="/2023/06/02/Tool/Git/3-fluid-appearance.png"></p></li><li><p>主题字体</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 主题字体配置</span><br><span class="hljs-attr">font:</span><br>  <span class="hljs-attr">font_size:</span> <span class="hljs-string">16px</span><br>  <span class="hljs-attr">font_family:</span> <span class="hljs-string">consolas</span>  <span class="hljs-comment"># 使用 consolas 字体</span><br>  <span class="hljs-attr">letter_spacing:</span> <span class="hljs-number">0.</span><span class="hljs-string">02em</span><br>  <span class="hljs-attr">code_font_size:</span> <span class="hljs-number">85</span><span class="hljs-string">%</span><br></code></pre></td></tr></table></figure></li><li><p>导航栏左侧标题(默认为 <code>Fluid</code>)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">blog_title:</span> <span class="hljs-string">&quot;windsand&quot;</span>  <span class="hljs-comment"># 将会以文本的形式显示</span><br></code></pre></td></tr></table></figure></li><li><p>首页背景图以及 slogan 文本</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">index:</span><br>  <span class="hljs-comment"># 首页 Banner 头图,可以是相对路径或绝对路径,以下相同</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/train.png</span>  <span class="hljs-comment"># 首页背景图.注意要自己存放图片资源到路径</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">100</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br>  <span class="hljs-comment"># 首页副标题的独立设置</span><br>  <span class="hljs-attr">slogan:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">text:</span> <span class="hljs-string">&quot;人生如逆旅,我亦是行人&quot;</span>  <span class="hljs-comment"># 首页 slogan</span><br></code></pre></td></tr></table></figure></li><li><p>文章页背景图(归档页, 分类页, 标签页, 关于页, 自定义页, 404 页, 友链页 同理)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/train.png</span>  <span class="hljs-comment"># 与上面的首页背景图配置方法相同</span><br></code></pre></td></tr></table></figure></li><li><p>文章内数学公式</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">math:</span><br>  <span class="hljs-comment"># 开启后文章默认可用,自定义页面如需使用,需在 Front-matter 中指定 math: true</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>   <br>  <span class="hljs-comment"># 开启后,只有在文章 Front-matter 里指定 math: true 才会在文章页启动公式转换</span><br>  <span class="hljs-comment"># 以便在页面不包含公式时提高加载速度</span><br>  <span class="hljs-attr">specific:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-5-文章属性"><a href="#3-5-文章属性" class="headerlink" title="3.5 文章属性"></a>3.5 文章属性</h3><ol><li><p>以本文为例,在 <code>front-matter</code> 中编写内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">typora-root-url:</span> <span class="hljs-string">./Git</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Git</span> <span class="hljs-string">使用</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Git</span>, <span class="hljs-string">工具箱</span>, <span class="hljs-string">笔记</span>, <span class="hljs-string">Code</span>]<br><span class="hljs-attr">categories:</span> <span class="hljs-string">工具箱</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">|</span><br><span class="hljs-string">  - Git 的使用方式介绍;</span><br><span class="hljs-string">  - GitHub Pages 页面的配置方法;</span><br><span class="hljs-string">  - 在 IDE 中使用 Git;</span><br><span class="hljs-string">  - hexo 的安装使用;</span><br><span class="hljs-string">  * typora 的配置;</span><br><span class="hljs-string">  * MarkDown 语法.</span><br><span class="hljs-string"></span><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/Git.svg</span><br><span class="hljs-attr">math:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><img src="/2023/06/02/Tool/Git/3-Hexo-front-matter.png"></p></li><li><p><code>typora-root-url</code>: typora 中图片的根目录</p></li><li><p><code>title</code>: 文章的标题.将会在主页中显示</p></li><li><p><code>tags</code>: 文章的标签.将会在主页中显示,点击可以跳转.一篇文章可以有多个 tag</p></li><li><p><code>categories</code>: 文章的类别.分类下面可以有多篇文章</p></li><li><p><code>excerpt</code>: 文章的摘要</p></li><li><p><code>index_img</code>: 文章封面图的路径.本示例的路径为 <code>./source/img/Git.svg</code></p></li></ol><h2 id="4-typora"><a href="#4-typora" class="headerlink" title="4 typora"></a>4 typora</h2><h3 id="4-1-typora-配置"><a href="#4-1-typora-配置" class="headerlink" title="4.1 typora 配置"></a>4.1 typora 配置</h3><ol><li><p><strong>为了与 hexo 部署兼容(主要是图片存放路径),对 typora 进行配置</strong></p><ul><li><p>文件 -&gt; 偏好设置 -&gt; 图像 -&gt; 插入图片时 -&gt; 复制到指定路径 <code>./$&#123;filename&#125;</code></p><p><img src="/2023/06/02/Tool/Git/5-typora-image-setting.png"></p></li><li><p>格式 -&gt; 图像 -&gt; 设置图片根目录 -&gt; 将 <code>./$&#123;filename&#125;</code> 目录设置为根目录</p></li></ul></li><li><p>图片命令不要包含中文或空格.否则可能显示异常</p></li><li><p>为了更好的结构化管理,图片命名时前缀加上图片所在的章节</p></li></ol><h3 id="4-2-MarkDown"><a href="#4-2-MarkDown" class="headerlink" title="4.2 MarkDown"></a>4.2 MarkDown</h3><ol><li><p>基础使用</p><ul><li>标题: 使用 <code>#</code> 表示(数量 1~6, 对应 html 的 <code>&lt;h1&gt; ~ &lt;h6&gt;</code>)</li><li>段落: 在文本之间插入空行,即是新段落</li><li>换行: 在行的末尾加上2个空格,然后回车</li><li>字体: 使用 <code>*</code> 包裹为 <em>斜体</em>; 使用 <code>**</code> 包裹为 <strong>粗体</strong>; 使用 <code>***</code> 包裹为 <em><strong>斜粗体</strong></em>; 使用 <code>~~</code> 包裹为 <del>删除线</del></li><li>列表: 使用 <code>*, +, -</code> 进行标记(后面需要空格)</li><li>有序列表: 使用 <code>数字.</code> 进行标记(后面需要空格.数字本身并不重要,渲染时会自动排序)</li><li>图片: 使用 <code>![替代文本](路径)</code> 进行标记(markdown 本身无法处理图片的对齐和大小)</li><li>链接: 使用 <code>[链接文本](url)</code> 进行标记</li><li>代码: 使用 &#96; 包裹进行标记</li><li>代码块: 使用 &#96;&#96;&#96; 包裹进行标记(指定语言名称可以实现高亮)</li><li>引用: 使用 <code>&gt;</code> 进行标记</li><li>分隔线: 使用三个或以上的 <code>*, -, _</code> 进行标记</li><li>转义字符: 使用 <code>\</code> 显示原本用于 markdown 格式的字符</li><li>目录: 使用 <code>[TOC]</code> 或 <code>&lt;!--- TOC ---&gt;</code> 进行标记</li></ul></li><li><p>表格: 使用 <code>|, -</code> 创建表格. 表头与内容行之间使用分隔线.使用 <code>:</code> 指定对齐方式</p><ul><li><p>示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">| 左对齐 | 居中对齐 | 右对齐 |<br>| :----- | :------: | -----: |<br>| 单元格 |  单元格  |  单元格 |<br>| 单元格 |  单元格  |  单元格 |<br></code></pre></td></tr></table></figure></li><li><p>效果</p><table><thead><tr><th align="left">左对齐</th><th align="center">居中对齐</th><th align="right">右对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="center">单元格</td><td align="right">单元格</td></tr><tr><td align="left">单元格</td><td align="center">单元格</td><td align="right">单元格</td></tr></tbody></table></li></ul></li><li><p>任务列表: 使用 <code>[]</code> 比松hi未完成的任务, <code>[x]</code> 表示已完成的任务</p><ul><li><p>示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> [x] 完成文章大纲<br><span class="hljs-bullet">-</span> [ ] 撰写初稿<br><span class="hljs-bullet">-</span> [ ] 校对并发布<br></code></pre></td></tr></table></figure></li><li><p>效果</p><ul><li><input checked="" disabled="" type="checkbox"> 完成文章大纲</li><li><input disabled="" type="checkbox"> 撰写初稿</li><li><input disabled="" type="checkbox"> 校对并发布</li></ul></li></ul></li></ol><h3 id="4-3-数学公式"><a href="#4-3-数学公式" class="headerlink" title="4.3 数学公式"></a>4.3 数学公式</h3><ol><li><p>行内公式: 使用 <code>$</code> 包裹.如 <code>$a^2 + b^2 = c^2$</code> 显示为 $a^2 + b^2 &#x3D; c^2$</p></li><li><p>完整公式: 使用 <code>$$</code> 包裹</p><ul><li><p>示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$$<br>x = \frac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125;<br>$$<br></code></pre></td></tr></table></figure></li><li><p>效果<br>$$<br>x &#x3D; \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}<br>$$</p></li></ul></li><li><p><a href="https://katex.org/docs/support_table.html">常用符号</a></p><table><thead><tr><th>功能</th><th>语法</th><th>示例</th><th>效果</th></tr></thead><tbody><tr><td>分组</td><td><code>&#123; &#125;</code></td><td><code>x^&#123;10&#125;</code></td><td>$x^{10}$</td></tr><tr><td>上标</td><td><code>^</code></td><td><code>x^2</code></td><td>$x^2$</td></tr><tr><td>下标</td><td><code>_</code></td><td><code>a_n</code></td><td>$a_n$</td></tr><tr><td>分式</td><td><code>\frac&#123;分子&#125;&#123;分母&#125;</code></td><td><code>\frac&#123;x&#125;&#123;y+z&#125;</code></td><td>$\frac{x}{y+z}$</td></tr><tr><td>平方根</td><td><code>\sqrt&#123;表达式&#125;</code></td><td><code>\sqrt&#123;2&#125;</code></td><td>$\sqrt{2}$</td></tr><tr><td>无穷大</td><td><code>\infty</code></td><td><code>\infty</code></td><td>$\infty$</td></tr><tr><td>点乘</td><td><code>\cdot</code></td><td><code>x \cdot y</code></td><td>$x \cdot y$</td></tr><tr><td>加减</td><td><code>\pm \mp</code></td><td><code>a \pm b</code></td><td>$a \pm b$</td></tr><tr><td>不等于</td><td><code>\ne</code></td><td><code>a \ne b</code></td><td>$a \ne b$</td></tr><tr><td>约等于</td><td><code>\approx</code></td><td><code>\pi \approx 3.14</code></td><td>$\pi \approx 3.14$</td></tr></tbody></table></li><li><p>大型运算符</p><table><thead><tr><th>功能</th><th>语法</th><th>示例</th><th>效果</th></tr></thead><tbody><tr><td>求和</td><td><code>\sum_&#123;下标&#125;^&#123;上标&#125;</code></td><td><code>\sum_&#123;i=1&#125;^&#123;n&#125; i</code></td><td>$\sum_{i&#x3D;1}^{n} i$</td></tr><tr><td>求积</td><td><code>\int_&#123;下限&#125;^&#123;上限&#125;</code></td><td><code>\int_&#123;0&#125;^&#123;\infty&#125; f(x)dx</code></td><td>$\int_{0}^{\infty} f(x)dx$</td></tr><tr><td>积分</td><td><code>\prod_&#123;下标&#125;^&#123;上标&#125;</code></td><td><code>\prod_&#123;i=1&#125;^&#123;n&#125; i</code></td><td>$\prod_{i&#x3D;1}^{n} i$</td></tr><tr><td>极限</td><td><code>\lim_&#123;变量 \to 值&#125;</code></td><td><code>\lim_&#123;x \to 0&#125; \frac&#123;\sin x&#125;&#123;x&#125;</code></td><td>$\lim_{x \to 0} \frac{\sin x}{x}$</td></tr></tbody></table></li><li><p>矩阵: 使用 <code>matrix</code>(无括号), <code>pmatrix</code>(小括号), <code>bmatrix</code>(方括号), <code>vmatrix</code>(单竖线)环境.用 <code>&amp;</code> 分隔列,用 <code>\\</code> 换行</p><ul><li><p>示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$$<br>\begin&#123;matrix&#125;<br>a &amp; b \\<br>c &amp; d<br>\end&#123;matrix&#125;<br>$$<br></code></pre></td></tr></table></figure></li><li><p>效果<br>$$<br>\begin{matrix}<br>a &amp; b \<br>c &amp; d<br>\end{matrix}<br>$$</p></li></ul></li><li><p>分段函数: 使用 <code>case</code> 环境.用 <code>&amp;</code> 分隔列,用 <code>\\</code> 换行</p><ul><li><p>示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$$<br>n! = <br>\begin&#123;cases&#125;<br><span class="hljs-code">    1 &amp; \text&#123;if &#125; n = 0 \\</span><br><span class="hljs-code">    n \cdot (n-1)! &amp; \text&#123;if &#125; n \geq 1</span><br><span class="hljs-code">\end&#123;cases&#125;</span><br><span class="hljs-code">$$</span><br></code></pre></td></tr></table></figure></li><li><p>效果<br>$$<br>n! &#x3D;<br>\begin{cases}<br>1 &amp; \text{if } n &#x3D; 0 \<br>n \cdot (n-1)! &amp; \text{if } n \geq 1<br>\end{cases}<br>$$</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具箱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Code</tag>
      
      <tag>Git</tag>
      
      <tag>工具箱</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2023/06/01/Tool/Linux/"/>
    <url>/2023/06/01/Tool/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-使用"><a href="#Linux-使用" class="headerlink" title="Linux 使用"></a>Linux 使用</h1><h2 id="0-环境搭建"><a href="#0-环境搭建" class="headerlink" title="0 环境搭建"></a>0 环境搭建</h2><h3 id="0-1-VMware"><a href="#0-1-VMware" class="headerlink" title="0.1 VMware"></a>0.1 VMware</h3><ol><li>Linux 环境搭建目标: 在 Windows 中创建一个虚拟机,然后安装 <code>CentOS</code>(wsl 更方便,搭配 <code>Ubuntu</code>)</li><li>安装 <code>VMware</code><ul><li>先在 BIOS 中开启 <code>虚拟化设备支持</code></li><li>安装只需一直下一步即可</li></ul></li><li>安装 <code>CentOS</code><ul><li>将界面修改为中文: 在快捷方式的目标栏添加 <code> --locale zh_CN</code></li></ul></li><li>如果遇到打开虚拟机就蓝屏: 在 Windows 功能中打开 <code>虚拟机监控程序平台, 虚拟机平台</code></li><li><strong>网络连接模式</strong><ul><li>桥接模式: 虚拟系统可和外部系统通讯,但容易造成 IP 冲突</li><li>NAT 模式: 网络地址转化模式.可和外部系统通讯,而不造成 IP 冲突</li><li>主机模式: 独立的系统.不进行通讯</li></ul></li><li>虚拟机功能<ul><li>克隆: 直接复制文件,系统也是文件,复制文件即可克隆系统</li><li>快照: 保存快照后,可以在快照管理回到之前的状态</li><li>删除和迁移: 与克隆类似,直接操作文件</li></ul></li></ol><h3 id="0-2-远程登陆"><a href="#0-2-远程登陆" class="headerlink" title="0.2 远程登陆"></a>0.2 远程登陆</h3><ol><li><p>Xshell &amp; Xftp 使用(Xshell 用于执行指令.Xftp 用于文件传输)</p><ul><li><p>在 Linux 终端查询 ip 地址(inet 后面即为 ip 地址)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig<br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>Windows 中命令行输入 <code>ping ip</code>,检查是否联通</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ping &lt;ip&gt;<br></code></pre></td></tr></table></figure></li><li><p>进入 Xshell -&gt; 新建会话 -&gt; 主机输入 Linux 的 ip -&gt; 完成</p></li><li><p>双击左侧主机名 -&gt; 接收并保存 -&gt; 输入用户名和密码.即可登录</p></li></ol></li><li><p>ssh 登录(直接在 powershell 中使用)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ssh [用户名]<span class="hljs-selector-tag">@</span>[服务器地址] <span class="hljs-literal">-p</span> [端口号]<br></code></pre></td></tr></table></figure><ul><li>用户名: 远程服务器上的用户名</li><li>服务器地址: ip 地址或域名</li><li>-p 端口号: ssh 服务监听的端口.默认为 <code>22</code></li></ul></li></ol><h3 id="0-3-wsl-安装"><a href="#0-3-wsl-安装" class="headerlink" title="0.3 wsl 安装"></a>0.3 wsl 安装</h3><ol><li><p>先在 BIOS 中开启 <code>虚拟化设备支持</code>(任务管理器中显示 <code>虚拟化已开启</code> 即可)</p><p><img src="/2023/06/01/Tool/Linux/0-Virtualization.png"></p></li><li><p>win + R 输入 <code>control</code> 进入控制面板 -&gt; 程序和功能 -&gt; 启用或关闭 Windows 功能.<br>开启 <code>Virtual Machine Platform</code> 和 <code>适用于 Linux 的 Windos 子系统</code>(完成该步骤后需要重启电脑)</p><p><img src="/2023/06/01/Tool/Linux/0-Windows-feature.png"></p></li><li><p>打开 <code>powershell</code> 执行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--update</span>                <span class="hljs-comment"># 更新 wsl</span><br>wsl <span class="hljs-literal">--version</span>               <span class="hljs-comment"># 检查版本信息</span><br>wsl <span class="hljs-literal">--list</span> <span class="hljs-literal">--online</span>         <span class="hljs-comment"># 列出可以在线安装的版本 </span><br>wsl <span class="hljs-literal">--install</span> Ubuntu<span class="hljs-literal">-24</span>.<span class="hljs-number">04</span>  <span class="hljs-comment"># 安装 Ubuntu 24.04</span><br>wsl                         <span class="hljs-comment"># 启动 wsl.然后根据提示新建用户</span><br></code></pre></td></tr></table></figure></li><li><p>更新 <code>wsl</code> 中的软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/os-release         # 查看发行版信息.Ubuntu 24.04.2 LTS<br>sudo apt update             # 拉取可更新软件列表<br>sudo apt upgrade -y         # 更新所有软件<br></code></pre></td></tr></table></figure></li></ol><h3 id="0-4-wsl-使用"><a href="#0-4-wsl-使用" class="headerlink" title="0.4 wsl 使用"></a>0.4 wsl 使用</h3><ol><li><p>安装 <code>neofetch, htop</code>(非必需)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install neofetch htop  # 安装 neofetch, htop<br>neofetch                        # 运行 neofetch.显示系统信息<br>htop                            # 交互式界面显示系统资源使用情况<br></code></pre></td></tr></table></figure></li><li><p>修改 <code>wsl</code> 主机名(非必需)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">hostname          # 查看主机名<br>vim /etc/wsl.conf # 编辑 wsl 的配置文件<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">增加下面内容.然后退出重启</span><br>[network]<br>hostname = wsl         # 设置你想要的固定主机名<br>generateHosts = false  # 阻止 WSL 自动覆盖 /etc/hosts<br></code></pre></td></tr></table></figure></li><li><p>取消 <code>wsl</code> 的 <code>beep</code>(非必需)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/inputrc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">找到下面的内容,将其取消注释.然后退出重启</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">set</span> bell-style none</span><br></code></pre></td></tr></table></figure></li><li><p>图形界面应用(非必需).以一些图形操作密集的软件为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install gimp blender kdenlive krita -y<br></code></pre></td></tr></table></figure><ul><li>gimp: GNU Image Manipulation Program(GNU 图像处理程序)</li><li>blender: 开源的 3D 建模, 动画, 渲染和视频编辑软件</li><li>kdenlive: 免费开源的非线性视频编辑软件</li><li>krita: 免费开源的专业绘画软件</li></ul></li><li><p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/connect-usb">访问 USB 设备</a></p><ul><li><p>在 Windows 安装 <a href="https://github.com/dorssel/usbipd-win">usbipd-win</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">winget install <span class="hljs-literal">--interactive</span> <span class="hljs-literal">--exact</span> dorssel.usbipd<span class="hljs-literal">-win</span><br></code></pre></td></tr></table></figure></li><li><p>查看 usb 设备</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">usbipd list<br><span class="hljs-comment"># 输出结果形如</span><br><span class="hljs-comment"># Connected:</span><br><span class="hljs-comment"># BUSID  VID:PID    DEVICE                              STATE</span><br><span class="hljs-comment"># 1-1    1a86:55d3  USB-Enhanced-SERIAL CH343 (COM5)    Not shared</span><br></code></pre></td></tr></table></figure></li><li><p>这里需要共享的是 <code>1-1</code> 设备</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">usbipd bind <span class="hljs-literal">--busid</span> <span class="hljs-number">1</span><span class="hljs-literal">-1</span> <span class="hljs-comment"># 需要管理员权限.只需共享一次</span><br></code></pre></td></tr></table></figure></li><li><p>附加 usb 设备到 <code>wsl</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">usbipd attach <span class="hljs-literal">--wsl</span> <span class="hljs-literal">--busid</span> <span class="hljs-number">1</span><span class="hljs-literal">-1</span><br></code></pre></td></tr></table></figure></li><li><p>在 <code>ubuntu</code> 中查看设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsusb<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Bus 001 Device 002: ID 1a86:55d3 QinHeng Electronics USB Single Serial</span><br></code></pre></td></tr></table></figure></li><li><p>断开 usb 设备</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">usbipd detach <span class="hljs-literal">--busid</span> &lt;busid&gt;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-Linux-基础"><a href="#1-Linux-基础" class="headerlink" title="1 Linux 基础"></a>1 Linux 基础</h2><h3 id="1-1-目录结构"><a href="#1-1-目录结构" class="headerlink" title="1.1 目录结构"></a>1.1 目录结构</h3><ol><li><p><strong>Linux 一切皆文件</strong></p><p><img src="/2023/06/01/Tool/Linux/1-Linux-Struct.jpg"></p></li><li><p><code>/</code>: 根目录,包含整个文件系统</p><ul><li><code>/bin</code>: 二进制文件目录.包含一些常用的命令和工具.如 ls, cp, mv…</li><li><code>/sbin</code>: 系统二进制文件目录.包含一些系统管理命令和工具.如 shutdown, reboot…</li><li><code>/boot</code>: 启动目录.包含启动 Linux 系统所需的文件,如内核文件和引导程序</li><li><strong><code>/dev</code>: 设备目录.包含系统中的设备文件.如 硬盘, 光驱, 键盘…</strong></li><li><code>/etc</code>: 配置文件目录.包含系统和应用程序的配置文件.如网络配置, 用户配置…</li><li><strong><code>/home</code>: 用户主目录.包含系统中所有用户的主目录</strong></li><li><code>/lib</code>: 库文件目录.包含系统和应用程序所需的共享库文件</li><li><code>/media</code>: 挂载目录.包含可移动设备的挂载点,如 U盘, 光盘…</li><li><strong><code>/mnt</code>: 挂载目录.包含临时挂载的文件系统</strong></li><li><strong><code>/opt</code>: 可选目录.包含第三方应用程序的安装目录</strong></li><li><code>/proc</code>: 进程目录.包含系统和进程的信息.如 内存使用, CPU使用…</li><li><code>/root</code>: root 用户主目录</li><li><code>/tmp</code>: 临时目录.包含系统和应用程序的临时文件</li><li><code>/usr</code>: 用户程序目录.包含系统和用户安装的应用程序和文件</li><li><code>/var</code>: 可变目录.包含系统和应用程序的可变数据.如日志文件, 缓存文件…</li></ul></li></ol><h3 id="1-2-vim"><a href="#1-2-vim" class="headerlink" title="1.2 vim"></a>1.2 vim</h3><ol><li><p>vim 键盘图</p><p><img src="/2023/06/01/Tool/Linux/1-vi-vim-cheat-sheet-sch.gif"></p></li><li><p>vim 的工作模式: 命令模式, 输入模式, 命令行模式</p><p><img src="/2023/06/01/Tool/Linux/1-vim-vi-workmodel.png"></p></li><li><p>命令模式: 当启动 vi &#x2F; vim 时,默认为命令模式</p><ul><li><kbd>x</kbd>: 删除当前光标所在处的字符</li><li><kbd>G</kbd>: 定位到最后一行, <kbd>gg</kbd> 定位到首行</li><li><strong><kbd>yy</kbd>: 复制当前行,在前面加一个数字可以选定行数,如 5yy</strong></li><li><strong><kbd>dd</kbd>: 剪切当前行,在前面加一个数字可以选定行数,如 3dd</strong></li><li><strong><kbd>p</kbd>: 粘贴复制的内容</strong></li><li><kbd>u</kbd>: 撤销操作</li><li><kbd>Ctrl</kbd><kbd>r</kbd>: 重做上一次的撤销</li><li>定位到指定行: 输入行数然后 <kbd>Shif</kbd><kbd>g</kbd></li></ul></li><li><p>插入模式: 可以直接输入文本</p><ul><li><strong><kbd>ESC</kbd>: 进入命令行模式</strong></li><li><kbd>Page Up</kbd> &#x2F; <kbd>Page Down</kbd>: 上下翻页</li></ul></li><li><p>命令行模式: 保存或退出文件,设置编辑环境</p><ul><li><code>:w</code>: 保存文件</li><li><code>:q</code>: 退出编辑器</li><li><code>:q!</code>: 强制退出,且不保存</li><li><code>:set nu</code>: 显示行号.<code>:set nonu</code>: 隐藏行号. <code>:整数</code>:跳转到某行</li><li><strong><code>/text</code>: 查找文本信息.此时输入 <kbd>n</kbd> 查找下一个. <kbd>N</kbd> 查找下一个</strong></li><li><code>?text</code>: 向上查找文本信息</li></ul></li></ol><h2 id="2-Linux-命令"><a href="#2-Linux-命令" class="headerlink" title="2. Linux 命令"></a>2. Linux 命令</h2><h3 id="2-1-用户"><a href="#2-1-用户" class="headerlink" title="2.1 用户"></a>2.1 用户</h3><ol><li><p>linux 的命令格式为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">command [-options] [parameter]<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">command</span>: 命令名称也可以是 Shell 脚本</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">options: 长格式(man --<span class="hljs-built_in">help</span>) / 短格式(man -h)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">parameter: 通常是命令的指向目标.如文件, 目录等资源</span><br></code></pre></td></tr></table></figure></li><li><p>开 &#x2F; 关机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">shutdown -h now # 立即关机<br>shutdown -h 1   # 1分钟后关机.是 shutdown 的默认形式<br>shutdown -r now # 立即重启<br><br>halt   # 立即关机<br>reboot # 立即重启<br>sync   # 把内存里的数据同步到磁盘(建议在关机前先执行该指令)<br></code></pre></td></tr></table></figure></li><li><p>登录 Linux(一般仅使用普通用户登录,而非 root)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">su &lt;username&gt; # 切换到指定用户<br>logout        # 注销当前登录用户.Ubuntu 使用 exit<br></code></pre></td></tr></table></figure></li><li><p>用户管理(要想使用 Linux 系统资源,需要向管理员申请账号)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd &lt;username&gt; # 添加用户.登陆后将默认进入 /home/username 目录<br>userdel &lt;username&gt; # 删除用户,但保留目录<br>passwd &lt;username&gt;  # 指定 / 修改 用户密码<br>id &lt;username&gt;      # 查询用户信息<br>whoami             # 查看当前登录用户<br></code></pre></td></tr></table></figure></li><li><p>用户组(对具有相似权限的用户分组管理)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupadd &lt;groupname&gt; # 创建用户组(若创建用户时未指定组,默认创建同名组)<br>groupdel &lt;groupname&gt; # 删除用户组<br><br>groupmod -n &lt;newname&gt; &lt;oldname&gt;   # 更改用户组名<br>usermod -g &lt;groupname&gt; &lt;username&gt; # 修改用户的组别<br>gpasswd -d &lt;groupname&gt; &lt;username&gt; # 从组中删除用户<br></code></pre></td></tr></table></figure></li><li><p>帮助指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">man &lt;command&gt;  # 获取帮助信息.如 man ls<br>help &lt;command&gt; # 获取 shell 内置命令的帮助信息.如 help cd<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-文件目录"><a href="#2-2-文件目录" class="headerlink" title="2.2 文件目录"></a>2.2 文件目录</h3><ol><li><p>路径切换</p><ul><li><p><strong><code>pwd</code>: 显示当前目录的绝对路径</strong></p></li><li><p><strong><code>ls &lt;path&gt;</code>: 列出文件和目录.默认显示当前目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -a # 显示所有文件和目录(包括隐藏文件,即以 . 开头的文件)<br>ls -l # 以列表形式显示<br>ls -h # 以易于阅读的形式,列出文件大小<br></code></pre></td></tr></table></figure></li><li><p><strong><code>cd &lt;path&gt;</code>: 切换到指定目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~  # 回到 home 目录<br>cd .. # 回到上一级目录<br>cd -  # 返回上一次目录<br></code></pre></td></tr></table></figure></li></ul></li><li><p>目录与文件</p><ul><li><p>创建 &#x2F; 删除目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir &lt;directory&gt; # 创建目录(默认只能创建一级目录)<br>rmdir &lt;directory&gt; # 删除目录(只能删除空目录)<br><br>mkdir -p &lt;directory1/directory2&gt; # 创建多级目录<br></code></pre></td></tr></table></figure></li><li><p>删除文件 &#x2F; 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm &lt;path&gt;    # 删除文件或目录<br>rm -r &lt;path&gt; # 递归删除整个文件夹<br>rm -f &lt;path&gt; # 强制删除不提示<br></code></pre></td></tr></table></figure></li><li><p>拷贝文件 &#x2F; 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp    &lt;src_path&gt; &lt;dst_path&gt; # 将文件 / 目录复制到指定路径<br>\cp   &lt;src_path&gt; &lt;dst_path&gt; # 直接覆盖同名文件,不进行提示<br>cp -r &lt;src_path&gt; &lt;dst_path&gt; # 递归复制整个目录<br></code></pre></td></tr></table></figure></li><li><p>移动文件 &#x2F; 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv &lt;src_path&gt; &lt;dst_path&gt; # 移动文件或目录到指定路径<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果位于同一目录,则作用为重命名</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo             # 输出内容到控制台(如 echo $PATH)<br>touch &lt;filename&gt; # 创建空文件<br>cat   &lt;filename&gt; # 查看文件内容.不能修改.(-n: 显示行号)<br>more  &lt;filename&gt; # 分批显示文件内容.Space 翻页, Enter 下一行, Q 离开<br>less  &lt;filename&gt; # 分批查看文件内容<br>tail  &lt;filename&gt; # 查看文件尾部内容(-f实时追踪文件的所有更新)<br><br>diff &lt;path1&gt; &lt;path2&gt; # 比较文件 / 目录的差异.(-c: 查看具体信息)<br></code></pre></td></tr></table></figure></li><li><p><strong>指令 <code>&gt;</code> 和 <code>&gt;&gt;</code>: 重定向和追加</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat file1 &gt; file2         # 将 file1 内容覆盖到 file2<br>echo &quot;string&quot; &gt;&gt; filename # 将内容追加到文件中<br></code></pre></td></tr></table></figure></li><li><p><strong>创建软链接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s &lt;path&gt; &lt;linkname&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong><code>history</code>: 查看 &#x2F; 执行历史指令</strong></p></li></ol><h3 id="2-3-查找"><a href="#2-3-查找" class="headerlink" title="2.3 查找"></a>2.3 查找</h3><ol><li><p><strong><code>find</code>: 从指定目录向下递归遍历各个子目录,将满足条件的文件 &#x2F; 目录显示在终端</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">find &lt;path&gt; &lt;options&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-name: 按文件名查找</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-user: 按用户所属查找</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-size: 按文件大小查找(+n 大于, -n 小于, n 等于)</span><br></code></pre></td></tr></table></figure></li><li><p><code>find</code> 使用示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /home -name hello.txt # 查找 /home 目录的 hello.txt 文件<br>find /opt -user nobody     # 查找 /opt 目录中拥有者为 nobody 的文件<br>find / -size +200M         # 查找整个系统中大于 200M 的文件<br></code></pre></td></tr></table></figure></li><li><p><strong><code>locate</code>: 事先建立系统中所有文件名称及路径的 <code>locate</code> 数据库</strong></p><ul><li>第一次运行时,必须先使用 <code>updatedb</code> 指令创建 <code>locate</code> 数据库</li><li>查询速度快,但需要及时更新 <code>locate</code> 时刻</li></ul></li><li><p><strong><code>which command</code>: 查看 command 所在的路径</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">which python3 # 查看 python3 命令所在的路径. /usr/bin/python3<br></code></pre></td></tr></table></figure></li><li><p><strong><code>grep</code>: 过滤查找(实际常和 | 结合使用)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep &quot;content&quot; &lt;path&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-n: 显示匹配行及行号</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-i: 忽略大小</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-r: 递归查找</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-v: 反向过滤</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-压缩解压"><a href="#2-4-压缩解压" class="headerlink" title="2.4 压缩解压"></a>2.4 压缩解压</h3><ol><li><p><strong><code>gzip filename</code>: 压缩为 <code>*.gz</code> 文件</strong></p></li><li><p><strong><code>gunzip 文件名</code>: 解压 <code>*.gz</code> 解压文件</strong></p></li><li><p>zip 格式压缩解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zip -r file.zip &lt;path&gt;   # 递归的压缩 path 目录<br>unzip file.zip -d &lt;path&gt; # 解压 file.zip 到 path 目录<br></code></pre></td></tr></table></figure></li><li><p><strong><code>tar</code>: 打包指令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -cvf file.tar file1 file2 ...     # 将文件打包为 file.tar<br>tar -czvf file.tar.gz file1 file2 ... # 将文件压缩到 file.tar.gz<br><br>tar -xvf file.tar -C &lt;path&gt;           # 解包 file.tar 到 path 目录<br>tar -xzvf file.tar.gz -C &lt;path&gt;       # 解包 file.tar.gz 到 path 目录<br></code></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>打包.产生 <code>.tar</code> 打包文件</td></tr><tr><td>-z</td><td>gzip 模式</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后文件名</td></tr><tr><td>-x</td><td>解包 <code>.tar</code> 文件</td></tr></tbody></table></li></ol><h3 id="2-5-运行级别"><a href="#2-5-运行级别" class="headerlink" title="2.5 运行级别"></a>2.5 运行级别</h3><ol><li><p>运行级别一般为 3 或 5</p><ul><li>0: 系统停机状态,即关机状态</li><li>1: 单用户模式,只有 root 用户可以登录.用于系统维护和修复</li><li>2: 多用户模式,没有 NFS 服务.但可以使用网络</li><li>3: <strong>多用户模式,完全启动系统.可以使用所有服务</strong></li><li>4: 保留,未使用</li><li>5: <strong>多用户模式,与运行级别3相同.但是在此级别下启动X Window系统,即图形界面</strong></li><li>6: 系统重启级别</li></ul></li><li><p>运行级别指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">init 1   # 切换到运行级别1<br>runlevel # 查看当前运行级别<br></code></pre></td></tr></table></figure></li><li><p>时间与日期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">date     # 显示当前日期<br>date +%Y # 显示当前年份<br>date +%m # 显示当前月份<br>date +%d # 显示当前天数<br><br>date &quot;+%Y-%m-%d %H:%M:%S&quot;     # 显示时间.年-月-日 时:分:秒<br>date -s &quot;2021-06-18 08:00:00&quot; # 设置时间<br><br>cal      # 显示本月日历<br>cal 2025 # 显示 2025年日历<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-权限管理"><a href="#3-权限管理" class="headerlink" title="3 权限管理"></a>3 权限管理</h2><h3 id="3-1-用户组"><a href="#3-1-用户组" class="headerlink" title="3.1 用户组"></a>3.1 用户组</h3><ol><li><p><strong>Linux 每个用户都属于某个组.每个文件有 所有者, 所在组, 其他组</strong></p></li><li><p>所有者: 文件的创建者自然成为文件的所有者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -ahl # 查看文件 / 目录的所有者<br>chown username filename           # 修改文件 / 目录的所有者<br>chown username:groupname filename # 修改所有者以及所在组<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-R: 将目录的子目录和文件进行递归修改</span><br></code></pre></td></tr></table></figure></li><li><p>所在组: 文件 &#x2F; 目录的所在组 为 所有者的所在组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chgrp &lt;groupname&gt; &lt;filename&gt; # 修改文件 / 目录所在组<br></code></pre></td></tr></table></figure></li><li><p>其他组: 除所有者和所在组之外的用户</p></li></ol><h3 id="3-2-文件权限"><a href="#3-2-文件权限" class="headerlink" title="3.2 文件权限"></a>3.2 文件权限</h3><ol><li><p><strong>文件所属分为 拥有者(owner), 所属群组(group), 其他人(other).</strong><br><strong>而三种身份各有 读(read), 写(write), 执行(execute)权限</strong></p></li><li><p>考虑 <code>ls -l</code> 命令,显示的信息形如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">文件权限, 链接数, 文件拥有者, 文件所属用户组, 文件大小(Bytes), 最后被修改的时间, 文件名</span><br>-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc<br></code></pre></td></tr></table></figure></li><li><p>文件权限共 9位.其含义为</p><ul><li><strong>第 0 位: 文件类型(d ,-, l, c, b)</strong><ul><li><code>d</code>: 目录.相当于文件夹</li><li><code>-</code>: 普通文件</li><li><code>l</code>: 链接.相当于快捷方式</li><li><code>c</code>: 字符设备.如鼠标键盘</li><li><code>b</code>: 块设备.如硬盘</li></ul></li><li><strong>1 ~ 3位: 文件所有者的权限.如 rwx 表示可读可写可执行</strong></li><li><strong>4 ~ 6位: 所在组用户的权限.如 rw- 表示可读可写,但不能执行</strong></li><li><strong>7 ~ 9位: 其他用户对该文件的权限.如 r– 表示仅能读</strong></li></ul></li><li><p><strong>目录权限表示方式</strong></p><ul><li><code>r</code>: 可读.可以查看文件 或 可用 <code>ls</code> 查看目录内容</li><li><code>w</code>: 可写.可创建, 删除, 重命名, 移动其中的文件或目录</li><li><code>x</code>: 可执行.可以执行文件 或 可进入该目录(成为工作目录)</li><li><code>-</code>: 对应位置如果出现 <code>-</code>,表示没有该类型权限</li><li><code>rwx</code> 还可以用数字形式表示(<code>r = 4, w = 2, x = 1</code>).如 rwx &#x3D; 4 + 2 +1 &#x3D; 7</li></ul></li><li><p><strong><code>chmod</code>: 修改文件 &#x2F; 目录的权限</strong></p><ul><li><p><code>u</code>: 所有者, <code>g</code>: 所在组, <code>o</code>: 其他人, <code>a</code>: 所有人. 使用 <code>+, -, =</code>赋予权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod u=rwx,g=rx,o=x filename # 对文件设置权限<br>chmod o+w filename # 对其他组增加 w 可写权限<br>chmod a-x filename # 对所有人取消 x 可执行权限<br>chmod 751 filename # 与 chmod u=rwx,g=rx,o=x filename 等价<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="3-3-环境变量"><a href="#3-3-环境变量" class="headerlink" title="3.3 环境变量"></a>3.3 环境变量</h3><ol><li><p><code>env</code>: 查看系统中记录的环境变量(以 key-value 的形式存储)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">env # 结果形如 SHELL=/bin/bash<br></code></pre></td></tr></table></figure></li><li><p><code>PATH</code> 变量中记录了系统执行命令的搜索路径(使用 <code>:</code> 分隔)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">env | grep PATH # 结果形如 PATH=/usr/local/sbin:/usr/local/bin<br></code></pre></td></tr></table></figure></li><li><p><code>$</code> 用于取值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo $PATH # 结果与 env | grep PATH 相同<br></code></pre></td></tr></table></figure></li><li><p>设置环境变量</p><ul><li><p>临时设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=$PATH:&lt;path&gt;  # 将 path 追加到 PATH 中.仅当前终端有效<br></code></pre></td></tr></table></figure></li><li><p>永久设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim ~/.bashrc  # 将 export 语句追加到末行<br>source .bashrc # 使 .bashrc 生效<br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意 .bashrc 仅对当前用户生效.对所有用户生效需要修改 /etc/profile 文件</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="3-4-定时任务"><a href="#3-4-定时任务" class="headerlink" title="3.4 定时任务"></a>3.4 定时任务</h3><ol><li><p>任务调度: 系统在某个时间执行的特定命令或程序</p><ul><li>系统工作.需要周期性的执行,如病毒扫描</li><li>用户工作.如对 mysql 数据库的备份</li></ul></li><li><p><code>crond</code> 定时任务</p><ul><li>基础语法: <code>crontab [选项]</code><ul><li><code>-e</code>: 编辑 <code>crontab</code> 任务</li><li><code>-l</code>: 查询 <code>crontab</code> 任务</li><li><code>-r</code>: 删除当前用户的所有 <code>crontab</code> 任务</li></ul></li><li>示例: <code>*/1**** ls -l /etc &gt; /tmp/to.txt</code> 将会每分钟都执行一次</li></ul></li><li><p>时间规则</p><ul><li><p>5个占位符的含义</p><table><thead><tr><th>序号</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>1</td><td>每小时的分钟数</td><td>0 ~ 59</td></tr><tr><td>2</td><td>每天的小时数</td><td>0 ~ 23</td></tr><tr><td>3</td><td>每月的天数</td><td>1 ~ 31</td></tr><tr><td>4</td><td>每天的月份</td><td>1 ~ 12</td></tr><tr><td>5</td><td>每周星期数</td><td>0 ~ 7(0和7均为星期天)</td></tr></tbody></table></li><li><p>特殊符号</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>通配符,表示任意时间</td></tr><tr><td>,</td><td>分隔不连续的时间.如 <code>08,17***</code> 表示每天的8时0分,17时0分</td></tr><tr><td>-</td><td>连续的时间范围.如 <code>05**1-6</code> 表示周一到周六的5时0分</td></tr><tr><td>*&#x2F;n</td><td>每次的间隔时间.如 <code>*/10****</code> 表示每次间隔10分钟</td></tr></tbody></table></li></ul></li></ol><h3 id="3-5-进程"><a href="#3-5-进程" class="headerlink" title="3.5 进程"></a>3.5 进程</h3><ol><li><p>进程</p><ul><li>Linux 中每个执行的程序都是一个进程.每个进程都会分配一个ID号(pid)</li><li>每个进程可以以前台或后台的形式存在</li><li>一般系统服务均以后台进程形式存在,且常驻于系统,直到关机才结束</li></ul></li><li><p><strong><code>ps</code>: 查看当前系统中正在执行的进程</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -a # 显示当前终端的所有进程信息<br>ps -u # 以用户的格式显示进程信息<br>ps -x # 显示后台进程运行的参数<br></code></pre></td></tr></table></figure></li><li><p>父子进程</p><ul><li><strong><code>ps -ef</code>: 全格式显示当前所有进程</strong></li><li>显示的 ppid 指出该进程的父进程</li><li>搭配 <code>| grep</code> 可以进行过滤</li></ul></li><li><p>终止进程</p><ul><li><strong><code>kill [选项] 进程号</code>: 通过进程号终止进程</strong></li><li><code>killall 进程名称</code>: 通过进程名称终止进程,同时会终止其所有子进程</li></ul></li><li><p><code>pstree</code>: 查看进程树</p><ul><li><code>-p</code>: 显示进程的 pid</li><li><code>-u</code>: 显示进程的用户</li></ul></li><li><p>服务(service): 其本质仍然是进程.通常会监听某个端口,等待其他程序的请求</p><ul><li><code>service 服务名 [start | stop | restart | reload | status]</code></li><li>CentOS7.0后,很多服务不再使用 <code>service</code> 指令管理,而使用 <code>systemctl</code></li><li><code>systemctl [start | stop | restart | status] 服务名</code></li><li><code>systemctl</code> 管理的服务在 <code>/user/lib/systemd/system</code> 查看</li></ul></li></ol><h2 id="4-开发环境"><a href="#4-开发环境" class="headerlink" title="4 开发环境"></a>4 开发环境</h2><h3 id="4-1-rpm"><a href="#4-1-rpm" class="headerlink" title="4.1 rpm"></a>4.1 rpm</h3><ol><li><p><strong>rpm(RedHat Package Manager) 用于互联网下载包的打包,安装.生成 <code>.RPM</code> 的文件</strong></p></li><li><p>查询软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -qa                # 查询所有安装的 rpm 软件包<br>rpm -qa | grep firefox # 查询具体的某个软件包<br>rpm -qi firefox        # 查询软件包的具体信息<br></code></pre></td></tr></table></figure></li><li><p>安装与删除软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -ivh &lt;path&gt; # 安装软件包需要有全路径<br>rpm -e firefox  # 删除软件包<br></code></pre></td></tr></table></figure></li><li><p>yum: Shell 前端软件包管理器</p><ul><li>yum 基于 rpm 包管理.能从指定服务器自动下载 rpm 包并安装</li><li>yum 将会自动处理依赖性关系,并一次安装所有依赖的软件包</li></ul></li><li><p>yum 指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum list | grep firefox # 查询 yum 服务器中的相关软件包信息<br>yum install firefox     # 下载安装软件包及依赖<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-2-Ubuntu"><a href="#4-2-Ubuntu" class="headerlink" title="4.2 Ubuntu"></a>4.2 Ubuntu</h3><ol><li><p><strong>Ubuntu: 一个以桌面应用为主的开源 GNU&#x2F;Linux 操作系统</strong></p><ul><li>基于 GNU&#x2F;Linux.支持 x86, amd64, ppc 架构.由 Canonical 打造</li><li>Python 开发者一般选择 Ubuntu 作为生产平台</li><li>下载桌面版: <a href="https://cn.ubuntu.com/download">Ubuntu系统下载 | Ubuntu</a></li></ul></li><li><p>中文支持</p><ul><li>Ubuntu 默认只有英文.需要安装中文语言包(需要联网)</li><li>打开 Language Support 菜单 -&gt; Language Support 选项卡 -&gt; Install</li><li>选中 Chinese(Simplified) -&gt; Apply Changes 提交.此时系统将会自动下载</li><li>默认显示中文需要将 <code>汉语(中国)</code> 拖动到第一位</li></ul></li><li><p>root 权限</p><ul><li><strong>Ubuntu 安装后只有普通用户权限.若需要 root 权限,应在命名前加上 <code>sudo</code></strong></li><li>当使用 <code>su root</code> 切换到 root 用户时,因还未设置密码,将会抛出 <code>error</code></li><li>设置 root 用户的密码并使用<ul><li><code>sudo password</code>: 给 root 用户设置密码</li><li><code>su root</code>: 切换到 root 用户</li><li>提示符 <code>$</code> 表示一般用户.<code>#</code> 表示 root 用户</li><li><code>exit</code>: 退出 root 用户</li></ul></li></ul></li><li><p>python</p><ul><li>Ubuntu 默认安装 python 的开发环境</li><li><code>python3</code> 将会展示版本信息</li></ul></li><li><p><strong>apt(Advanced Packaging Tool): 安装包管理工具</strong></p><ul><li><p>Ubuntu 使用 <code>apt</code> 命令进行软件包的安装, 删除, 清理…</p></li><li><p><code>/etc/apt/sources.list</code> 文件中存放着 apt 服务器的地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update              # 更新源<br>sudo apt install &lt;package&gt;   # 安装 package<br>sudo apt remove &lt;package&gt;    # 删除 package<br><br>sudo apt search &lt;package&gt;    # 搜索软件包<br>sudo apt show &lt;package&gt;      # 获取包的相关信息<br>sudo apt install &lt;package&gt; --reinstall  # 重新安装包<br><br>sudo apt --fix-broken install # 修复安装<br>sudo apt purge &lt;package&gt;      # 删除包，包括配置文件<br>sudo apt build-dep &lt;package&gt;  # 安装相关编译环境<br><br>sudo apt upgrade             # 更新已安装的包<br>sudo apt full-upgrade        # 升级系统<br>sudo apt depends &lt;package&gt;   # 查看该包所依赖的包<br>sudo apt rdepends &lt;package&gt;  # 查看该包被哪些包依赖<br>sudo apt source &lt;package&gt;    # 下载软件包的源代码<br></code></pre></td></tr></table></figure></li></ul></li><li><p>修改 apt 更新源(镜像网站: 因为服务器位于美国,连接缓慢,由镜像网站获取其资源)</p><ul><li><p>备份文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cp /ect/apt/sources.list /etc/apt/sources.list.backup # Ubuntu 24.04 之前<br>sudo cp /etc/apt/sources.list.d/ubuntu.sources /etc/apt/sources.list.d/ubuntu.sources.backup # Ubuntu 24.04 之后<br></code></pre></td></tr></table></figure></li><li><p>使用 root 用户,清空源文件中的所有内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;&#x27; &gt; source.list<br></code></pre></td></tr></table></figure></li><li><p>将需要的<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">镜像地址(清华源)</a>拷贝到 <code>source.list</code> 文件中</p></li></ul></li><li><p>远程登录</p><ul><li><p>SSH(Secure Shell): 建立于应用层和传输层基础上的安全协议</p></li><li><p>与 CentOS 不同,Ubuntu 默认没有安装 SSHD 服务</p></li><li><p>安装 SSH</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install openssh-server<br></code></pre></td></tr></table></figure></li><li><p>启动 SSH</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service sshd restart<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Linux 登录到 Ubuntu</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh 目标主机的用户名@目标主机IP地址 # 登录<br>logout # 退出<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-Shell"><a href="#5-Shell" class="headerlink" title="5 Shell"></a>5 Shell</h2><h3 id="5-1-脚本"><a href="#5-1-脚本" class="headerlink" title="5.1 脚本"></a>5.1 脚本</h3><ol><li><p><strong>Shell: 命令行解释器.为用户提供一个向 Linux 内核发送请求以便运行程序的界面系统级程序</strong></p><ul><li>运维工程师对服务器集群进行管理时,需要编写 Shell 程序进行服务器管理</li><li>JavaEE, Python程序员需要编写 Shell 维护程序和服务器</li><li>大数据程序员需要编写 Shell 程序管理集群</li></ul></li><li><p>Shell 脚本</p><ul><li><p>文件内容需要以 <code>#!/bin/bash</code> 开头,一般后缀为 <code>.sh</code></p></li><li><p>文件本身需要有可执行权限.赋予权限: <code>chmod u+x hello.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>echo &quot;Hello,world!&quot;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>执行脚本</p><ul><li><code>脚本的绝对路径或相对路径</code>: 即可执行(需要有 <code>+x</code> 权限)</li><li><code>sh 脚本路径</code>: 这样执行无需 <code>+x</code> 执行权限</li></ul></li><li><p>注释</p><ul><li>单行注释: <code># content</code></li><li>多行注释: <code>:&lt;&lt;! content !</code></li></ul></li></ol><h3 id="5-2-变量"><a href="#5-2-变量" class="headerlink" title="5.2 变量"></a>5.2 变量</h3><ol><li><p>系统变量</p><ul><li>如: <code>$HOME, $PWD, $SHELL, $USER</code>.可使用 <code>echo $HOME</code> 打印当前用户的家目录</li><li>显示当前 Shell 的所有系统变量</li></ul></li><li><p>自定义变量</p><ul><li>语法: <code>变量名=value</code>.注意语句中不要加入空格.变量名的命名限制与C相同</li><li>销毁变量: <code>unset 变量名</code>.Shell 编程变量名一般大写</li><li>声明静态变量: <code>readonly 变量名</code>.不能使用 <code>unset</code> 销毁</li><li>打印变量: <code>echo $变量名</code>.注意需要加上 <code>$</code> 符号</li></ul></li><li><p>将命令的返回值赋给变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">A=`command` # 将 command 作为一个命令执行,然后将结果赋值给变量 A<br>A=$(date)   # 与上述写法等价.变量 A 将会存储当前时间信息<br></code></pre></td></tr></table></figure></li><li><p>环境变量</p><ul><li><code>export 变量名=值</code>: 将 Shell 变量输出为环境变量 &#x2F; 全局变量</li><li><code>export 配置文件</code>: 使修改后的配置信息立即生效</li><li><code>echo $变量</code>: 查询环境变量的值</li></ul></li><li><p>位置参数</p><ul><li><code>$0</code>: 表示命令本身,<code>$1 ~ $9</code>表示第1 ~ 9个参数.对于超过10的,要用 <code>&#123;&#125;</code> 包裹</li><li><code>$*</code>: 表示所有的参数.且将所有参数当作整体处理</li><li><code>$@</code>: 表示所有的参数.但将每个参数分开处理</li><li><code>$#</code>: 获取命令行中所有参数的个数</li></ul></li><li><p>预定义变量: Shell 已定义的变量,可以直接在 Shell 脚本中使用</p><ul><li><code>$$</code>: 当前进程的进程号 pid</li><li><code>$!</code>: 后台运行的最后一个进程的进程号 pid</li><li><code>#?</code>: 最后一次执行的命令的返回状态.0表示正确执行</li></ul></li><li><p>运算</p><ul><li>语法: <code>$((运算式))</code> 或 <code>$[运算式]</code></li></ul></li></ol><h3 id="5-3-控制流"><a href="#5-3-控制流" class="headerlink" title="5.3 控制流"></a>5.3 控制流</h3><ol><li><p>条件表达式: <code>[ condition ]</code>.注意两端的空格,非空返回 true</p></li><li><p>分支语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ condition1 ]<br>then<br>code block1<br>elif [ condition2 ]<br>then<br>code block2<br>fi<br></code></pre></td></tr></table></figure></li><li><p>case</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $变量名 in<br>&quot;value1&quot;)<br>code block1<br>;;<br>&quot;value2&quot;)<br>code block2<br>*)<br>code block<br>esac<br></code></pre></td></tr></table></figure></li><li><p>for</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for 变量名 in value1 value2...<br>do<br>code block<br>done<br></code></pre></td></tr></table></figure></li><li><p>while</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">while [ condition ]<br>do<br>code block<br>done<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-4-函数"><a href="#5-4-函数" class="headerlink" title="5.4 函数"></a>5.4 函数</h3><ol><li><p>读取控制台输入</p><ul><li>基础语法: <code>read 选项 参数</code></li><li>选项: <code>-p</code> 指定读取值时的提示符. <code>-t</code> 指定等待的秒数</li><li>参数: 指定存储输入值的变量名</li></ul></li><li><p>系统函数</p><ul><li><code>basename</code>: 返回完整路径最后一个 <code>/</code> 后的内容,常用于获取文件名</li><li><code>basename [pathname] [suffix]</code></li><li><code>dirname</code>: 返回完整路径最后一个 <code>/</code> 前的内容,常用于获取路径</li></ul></li><li><p>自定义函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ function ] funname[()]<br>&#123;<br>Action;<br>[return int;]<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具箱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Code</tag>
      
      <tag>工具箱</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Language Data Structures</title>
    <link href="/2023/05/04/Computer/C-Language-Data-Structures/"/>
    <url>/2023/05/04/Computer/C-Language-Data-Structures/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法分析"><a href="#数据结构与算法分析" class="headerlink" title="数据结构与算法分析"></a>数据结构与算法分析</h1><h2 id="0-算法分析"><a href="#0-算法分析" class="headerlink" title="0 算法分析"></a>0 算法分析</h2><h3 id="0-1-基础概念"><a href="#0-1-基础概念" class="headerlink" title="0.1 基础概念"></a>0.1 基础概念</h3><ol><li>概念<ul><li>数据结构: 组织大量数据的方法</li><li>算法分析: 对算法运行时间的评估</li><li><strong>算法(algorithm)</strong>: 为求解一个问题所需遵循的,被清楚指定的简单指令集合</li><li>当某种算法被给定时,则需要确定该算法所需的时间和空间等资源量</li></ul></li><li><strong>抽象数据类型(Abstract Data Type,ADT)</strong>: 是一些操作的集合,是数学上的抽象<ul><li>例如表,集合,图以及它们的操作可看作抽象数据类型</li><li>例如集合ADT,可以有 并(union), 交(intersection), 补(complement), 求大小(size)等操作</li><li>基本思路: 只在程序中编写一次,其他地方需要运行 ADT 上的操作时,可通过调用函数实现</li></ul></li><li>定义: 建立无穷大量之间的相对级别<ul><li>$\mathrm{if} \quad \exists c,n_0\in N_+,N\geq n_0\quad\mathrm{s.t.} T(N)\leq cf(N), \mathrm{then} \quad T(N)&#x3D;O(f(N))$</li><li>$\mathrm{if} \quad \exists c,n_0\in N_+,N\geq n_0  \quad  \mathrm{s.t.} T(N)\geq cg(N),\mathrm{then} \quad T(N)&#x3D;\Omega(g(N))$</li><li>$T(N)&#x3D;O(h(N))  \quad and\quad T(N)&#x3D;\Omega(h(N)) \iff T(N)&#x3D;\Theta(h(N))$</li><li>$T(N)&#x3D;O(p(N)) \quad and \quad T(N)\neq \Theta(p(N)), \mathrm{then} \quad T(N)&#x3D;o(f(N))$</li></ul></li><li>简要说明<ul><li>$O$: 高阶无穷大</li><li>$\Omega$: 低阶无穷大</li><li>$\Theta$: 同阶无穷大</li><li>$o$: 严格的高阶无穷大</li></ul></li><li><strong>一般采用大$O$记法</strong>.例如 $T(N)&#x3D;2N^2+N&#x3D;O(N^2)$<ul><li>不要将常数或低阶项放入大$O$,直接忽略即可</li><li>典型的增长率(递增排列): $C, \mathrm{log}N, \mathrm{log}^2N, N, N\mathrm{log}N, N^2, N^3, 2^N$</li><li>可以使用洛必达法则确定两个函数的相对级别</li></ul></li></ol><h3 id="0-2-计算方式"><a href="#0-2-计算方式" class="headerlink" title="0.2 计算方式"></a>0.2 计算方式</h3><ol><li>为在正式的框架中分析算法,需要一个计算模型<ul><li>假定一个标准计算机,它顺序执行指令.拥有简单的指令系统(如加减乘除,赋值等)</li><li>特别地,该模型机执行任意一条简单指令都恰好花费一个时间单元</li><li>该模型机具有无限内存</li></ul></li><li>待分析的问题<ul><li>最重要的资源一般为运行时间</li><li>在这里分析对运行时间的影响因素有: 使用的算法, 对该算法的输入(主要方面)</li><li>考虑两个函数<ul><li>$T_{avg}(N)$: 输入为 N 时算法所花费的平均时间</li><li>$T_{worst}(N)$: 输入为 N 时算法在最坏情况下花费的时间</li><li><strong>主要考虑 $T_{worst}(N)$.因为它为所有的输入提供了一个运行时间上界</strong></li></ul></li><li>当两个程序花费的时间大致相同时,判断运行速度的方法是将其编码并运行</li><li>为简化分析,系数,低阶项,常数项直接抛弃.只计算其上界: 大$O$</li></ul></li></ol><h3 id="0-3-运行时间计算"><a href="#0-3-运行时间计算" class="headerlink" title="0.3 运行时间计算"></a>0.3 运行时间计算</h3><ol><li><p>分析案例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 计算 1~n 的立方和 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> partialSum = <span class="hljs-number">0</span>;<span class="hljs-comment">// 声明不计时间,赋值计1个时间单元</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i &lt;= n, i++) &#123;<span class="hljs-comment">// 初始化赋值计1次,判断循环条件计n+1次,自增计n次</span><br>        partialSum += i * i * i;<span class="hljs-comment">// 乘法2次,加法1次,赋值1次.重复n次,共计4n个时间单元</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> partialSum;<span class="hljs-comment">// 返回计1个时间单元</span><br>&#125;  <span class="hljs-comment">// 本算法共计6n+4个时间单元,即 O(N)</span><br></code></pre></td></tr></table></figure></li><li><p>一般法则</p><ul><li><code>for</code>: 运行时间最多为循环语句的运行时间乘以迭代次数</li><li>嵌套 <code>for</code>: 由里向外分析循环.嵌套循环内部一条语句总运行时间为: 该语句运行时间乘以<code>for</code>循环大小的乘积</li><li>顺序语句: 对各语句的运行时间求和(事实上,只需考虑运行时间最长的语句)</li><li><code>if/else</code>: 判断语句运行时间加上分支语句中最长的运行时间</li><li><strong>分析的基本策略为从内部向外扩展.如果有函数调用,则应该首先分析</strong></li></ul></li><li><p>考虑 Fibonacci 数列递归求和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-1</span>) + fib(n<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>运行时间为: $T(N)&#x3D;T(N-1)+T(N-2)\quad (n\geq2)$.这是一个指数级增长</li><li>运行效率低下的原因为: 进行了大量的重复计算,且计算结果被抛弃</li><li>改进: 用一个数组将计算结果存储起来,将可以大大提高运行效率</li></ul></li><li><p>最大子序列和问题的四种算法</p></li></ol><ul><li><p>问题: 给定整数 $A_1,A_2,\dots,A_n$, 求  $\sum\limits^j_{k&#x3D;i}A_k$ 的最大值(假定数组中均为负数,则最大子序列和为0)</p></li><li><p>穷举所有的可能 $\Theta(n^3)$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumN3</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i; j&lt;n; j++) &#123;<br>            <span class="hljs-type">int</span> thisSum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i; k&lt;=j; k++) &#123;<br>                thisSum += a[k];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(thisSum &gt; maxSum)<br>                maxSum = thisSum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分析可知,最内层的 for 冗余,将其去掉 $O(N^2)$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumN2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-type">int</span> thisSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i; j&lt;n; j++) &#123;<br>            thisSum += a[j];<br>            <span class="hljs-keyword">if</span>(thisSum &gt; maxSum)<br>                maxSum = thisSum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>递归 $O(N\mathrm{logN})$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumNlogN</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left == right) <span class="hljs-comment">// 参数为数组,左边界,右边界</span><br>        <span class="hljs-keyword">return</span> a[left] &gt; <span class="hljs-number">0</span> ? a[left] : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> center = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> maxLeftSum, maxRightSum;<br>    maxLeftSum = maxSubseqSumNlogN(a, left, center);  <span class="hljs-comment">// 递归调用</span><br>    maxRightSum = maxSubseqSumNlogN(a, center + <span class="hljs-number">1</span>, right);<br><br>    <span class="hljs-type">int</span> maxLeftBrdSum,  maxRightBrdSum,     leftBrdSum,     rightBrdSum;<br>    maxLeftBrdSum = <span class="hljs-number">0</span>;  maxRightBrdSum = <span class="hljs-number">0</span>; leftBrdSum = <span class="hljs-number">0</span>; rightBrdSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=center; i&gt;=left; i--) &#123;  <span class="hljs-comment">// 计算中值到左边界的最大和</span><br>        leftBrdSum += a[i];<br>        <span class="hljs-keyword">if</span>(leftBrdSum &gt; maxLeftBrdSum)<br>            maxLeftBrdSum = leftBrdSum;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=center+<span class="hljs-number">1</span>; i&lt;=right; i++) &#123;  <span class="hljs-comment">// 计算中值到右边界的最大和</span><br>        rightBrdSum += a[i];<br>        <span class="hljs-keyword">if</span>(rightBrdSum &gt; maxRightBrdSum)<br>            maxRightBrdSum = rightBrdSum;<br>    &#125;<br>    <span class="hljs-comment">// 返回三者的最大值</span><br>    <span class="hljs-keyword">if</span> (maxLeftSum &gt;= maxRightSum)<br>        <span class="hljs-keyword">return</span> maxLeftSum &gt;= maxLeftBrdSum + maxRightBrdSum ? maxLeftSum : maxLeftBrdSum + maxRightBrdSum;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> maxRightSum &gt;= maxLeftBrdSum + maxRightBrdSum ? maxRightSum : maxLeftBrdSum + maxRightBrdSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>线性算法 $O(N)$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumN</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> thisSum, maxSum;<br>    thisSum = <span class="hljs-number">0</span>; maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++) &#123;<br>        thisSum += a[j];<br>        <span class="hljs-keyword">if</span>(thisSum &gt; maxSum)<br>            maxSum = thisSum;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(thisSum &lt; <span class="hljs-number">0</span>)<br>            thisSum = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行代码(将上述代码置于一个文件下即可运行)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">-2</span>&#125;;<br>    <span class="hljs-type">int</span> arrLength = <span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(N^3)   = %d\n&quot;</span>,maxSubseqSumN3(a, arrLength));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(N^2)   = %d\n&quot;</span>,maxSubseqSumN2(a, arrLength));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(NlogN) = %d\n&quot;</span>,maxSubseqSumNlogN(a, <span class="hljs-number">0</span>, arrLength - <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(N)     = %d\n&quot;</span>,maxSubseqSumN(a, arrLength));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li><p>运行时间中的对数</p><ul><li><p>对数经常出现的场景有</p><ul><li>若算法利用 $O(1)$ ,即在常数时间里将问题的规模削减一部分(如50%).则该算法为 $O(\mathrm{log}N)$</li><li>若算法利用 $O(1)$ ,即在常数时间里将问题的规模消减一个常数(如 -1).则该算法为 $O(N)$</li></ul></li><li><p>考虑到仅仅是将 N 个数据读入耗费的时间即为 $\Theta(N)$ .当谈及$O(\mathrm{log}N)$ 时均假定数据已读入</p></li></ul></li><li><p>下面三个算法均为 $O(\mathrm{log}N)$</p><ul><li><p>二分查找(给定整数$X$,已排序数组 $A_0,A_1,\dots,A_{n-1}$ ,求满足$A_i&#x3D;X$的下标 $i$)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">float</span> elementType;<br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> elementType arr[], elementType x, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> low, mid, high;<br>    low = <span class="hljs-number">0</span>; high =n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>        mid = (low+high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(arr[mid] &lt; x)<br>            low = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; x)<br>            high = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>欧几里得算法(计算最大公因数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> m,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rem;<br>    <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>) &#123;<br>        rem = m % n;<br>        m = n;<br>        n = rem;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>幂运算</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">int</span> x,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == n)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> == n % <span class="hljs-number">2</span> ? <span class="hljs-built_in">pow</span>(x * x, n / <span class="hljs-number">2</span>) : <span class="hljs-built_in">pow</span>(x * x, n / <span class="hljs-number">2</span>) * x;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1 线性表"></a>1 线性表</h2><h3 id="1-1-单链表"><a href="#1-1-单链表" class="headerlink" title="1.1 单链表"></a>1.1 单链表</h3><ol><li><p>表: 形如 $a_1, a_2,\dots ,a_n$ 的有限序列.其中 $a_i$ 为数据元素 </p><ul><li>其大小为 n (当 n&#x3D;&#x3D;0 称为空表,empty list)</li><li>表的操作: 创建空表(makeEmpty), 插入元素(Insert), 删除元素(Delete), 查找元素(find), 打印表(printList)</li><li>由于数组对于插入和删除元素的运行太慢,一般不用简单数组实现表</li></ul></li><li><p>链表: 由一系列的无需在内存中相连的结构组成</p><ul><li>每个结构含有表元素以及指向该元素后继元结构的指针(next 指针)</li><li>最后一个元素的 next 指针 指向 NULL</li><li><strong>预留一个标志节点作为表头(head).其位置为0</strong></li></ul></li><li><p>链表接口(具体实现见 <code>single_linked_list</code>.不考虑数组实现方式)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SINGLE_LINKED_LIST_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SINGLE_LINKED_LIST_H</span><br><br><span class="hljs-comment">/*********************************************************/</span><br><span class="hljs-comment">/* node:        结构体类型名,链表结点</span><br><span class="hljs-comment">** ptr2node:    结构体指针,指向链表结点的指针</span><br><span class="hljs-comment">** list:        结构体指针,一般将头结点声明为 list 类型</span><br><span class="hljs-comment">** position:    结构体指针,一般将其它结点声明为 position 类型</span><br><span class="hljs-comment">** elementType: 元素类型名 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr2node</span>;</span><br><span class="hljs-keyword">typedef</span> ptr2node <span class="hljs-built_in">list</span>;<br><span class="hljs-keyword">typedef</span> ptr2node position;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    elementType element;<br>    position next;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(elementType x, elementType y)</span>;<br><br><span class="hljs-comment">/*********************************************************/</span><br><span class="hljs-comment">/* 链表相关函数.除了创建空链表,其它函数都需要参数 list l,以指明操作对象 */</span><br><span class="hljs-comment">/********** 1.创建与销毁 **********/</span><br><span class="hljs-built_in">list</span> <span class="hljs-title function_">makeList</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">clearList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deleteList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><br><span class="hljs-comment">/********** 2.获取长度 **********/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmptyList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isLast</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, position p)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">lenList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><br><span class="hljs-comment">/********** 3.增删改查 **********/</span><br>position <span class="hljs-title function_">findPosition</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x)</span>;<br>position <span class="hljs-title function_">findPrevious</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">findIndex</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x, compare func)</span>;<br>elementType *<span class="hljs-title function_">findElem</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, <span class="hljs-type">int</span> index)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x, position p)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* SINGLE_LINKED_LIST_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p>常见错误</p><ul><li>未初始化指针: 如果不知道应将指针初始化为什么,则将其初始化为 NULL</li><li><code>malloc</code> 函数的使用<ul><li>声明一个结构体指针是并不创建该结构.仅留出足够容纳结构的空间</li><li>若只需要一个结构体指针沿着表前进(例: <code>printList</code> 函数中的 <code>tmp</code>),则不需要使用 <code>malloc</code></li><li>当空间不再需要时.应使用 <code>free</code> 函数回收</li><li>若链表未执行过删除操作,则 <code>malloc</code> 调用次数应等于表的大小.若有表头,调用次数会多一次</li></ul></li></ul></li></ol><h3 id="1-2-链表使用"><a href="#1-2-链表使用" class="headerlink" title="1.2 链表使用"></a>1.2 链表使用</h3><ol><li><p>双链表: 在数据结构中增加一个域,使其指向前一个单元</p><ul><li><p>增加空间需求.因为需要额外存储一个指针</p></li><li><p>使得插入和删除的开销增加一倍.因为需要对增加的指针进行定位</p></li><li><p>简化删除操作.因为不再需要定位前驱元</p></li></ul></li><li><p>循环链表: 令最后一个单元指向第一个单元(可以存在表头,令最后一个单元指向表头)</p></li><li><p><strong>桶排序(bucket sort)</strong></p><ul><li>问题: 存在 $n$ 个整数 $a_i(0\leq x_i\leq M-1,1\leq i\leq n)$ 需要排序</li><li>预留一个大小为 $M$ 的 count 数组.即 count 有 $M$ 个单元(桶).初始情况下 count 内元素为空</li><li>当 $a_i$ 被读入时,$\mathrm{count}[a_i]$ 自增1;所有的输入被读入后,扫描数组 count,打印排好序的表</li><li>该算法的时间花费为 $O(M+N)$</li></ul></li><li><p><strong>基数排序(radix sort)是桶式排序的推广</strong></p><ul><li><p>考虑当桶的数量远大于数的个数时.桶排序便不再适合</p></li><li><p>若存在 $n$ 个整数 $a_i(0\leq x_i\leq n^p-1,1\leq i\leq n)$ 需要排序.进行多次桶式排序</p></li><li><p>第一步以最低位进行桶式排序,依次按位数桶式排序,直到最高位完成进行桶式排序</p></li><li><p>该算法的时间花费为 $O(p(n+b))$.其中 p 为趟数,n 为元素个数,b 为桶数</p></li><li><p>例: 对 0~9 的立方进行基数排序</p><ul><li>原始数组: [0, 1, 512, 343, 64, 125, 216, 27, 8, 729]</li><li>第一次排序结果: [0, 1, 512 ,343, 64, 125, 216, 27, 8, 729]</li><li>第二次排序结果: [8, 1, 0], [216, 512], [729,27,125],  [343], [64]</li><li>第三次排序结果: [64,27,8,1,0], [125], [216], [343], [512], [729]</li></ul></li></ul></li></ol><h3 id="1-3-栈"><a href="#1-3-栈" class="headerlink" title="1.3 栈"></a>1.3 栈</h3><ol><li><p>栈(stack): 限制插入和删除只能在一个位置(栈顶, top)进行的表</p><ul><li>栈的基本操作有: 入栈(push),出栈(pop)</li><li>栈的特点: 后进先出(LIFO),且只有栈顶元素可访问</li><li>栈的链表实现及其操作不涉及栈的大小,因此均为常数时间开销.缺点在于需要承担 <code>malloc,free</code> 的开销</li><li>当栈采用头插法进行入栈,则头节点的后继元即为栈顶,因此出栈只需删除头节点的后继元</li></ul></li><li><p>栈接口(具体实现见 <code>stack</code>.不考虑数组实现方式)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STACK_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr2node</span>;</span><br><span class="hljs-keyword">typedef</span> ptr2node <span class="hljs-built_in">stack</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    elementType element;<br>    ptr2node next;<br>&#125;;<br><br><span class="hljs-built_in">stack</span> <span class="hljs-title function_">makeStack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deleteStack</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s, elementType x)</span>;<br>elementType <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* STACK_H */</span></span><br></code></pre></td></tr></table></figure></li></ol><h3 id="1-4-队列"><a href="#1-4-队列" class="headerlink" title="1.4 队列"></a>1.4 队列</h3><ol><li><p>队列(queue): 限制插入(队尾, rear)和删除(队头, front)只能在两端分别进行的表</p><ul><li>队列的基本操作有入队(enqueue),出队(dequeue)</li><li>队列的特点: 先进先出(FIFO);只有队头元素可访问</li></ul></li><li><p>队列的链表实现的注意事项</p><ul><li>队列需要指向队头(front)和队尾(rear)的两个指针</li><li>当进行入队操作时,采用尾插法,且需要将 rear 指针向后移动一位</li><li>当进行出队操作时,需要先判断队列是否为空(front &#x3D;&#x3D; rear),然后删除 front 指针的后继元</li></ul></li><li><p>队列接口(具体实现见 <code>queue</code>.不考虑数组实现方式)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> QUEUE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUEUE_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr2node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    elementType element;<br>    ptr2node next;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ptr2node front;<br>    ptr2node rear;<br>&#125; *<span class="hljs-built_in">queue</span>;<br><br><span class="hljs-built_in">queue</span> <span class="hljs-title function_">makeQueue</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deleteQueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q, elementType e)</span>;<br>elementType <span class="hljs-title function_">dequeue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* QUEUE_H */</span></span><br></code></pre></td></tr></table></figure></li></ol><h2 id="2-树"><a href="#2-树" class="headerlink" title="2 树"></a>2 树</h2><h3 id="2-1-树的实现"><a href="#2-1-树的实现" class="headerlink" title="2.1 树的实现"></a>2.1 树的实现</h3><ol><li><p>树的递归定义: 一棵<strong>树</strong>是一些节点的集合(可以是空集).若非空,则一棵树由称为<strong>根</strong>(root)的节点 r,以及0个或多个非空的(子)树 $T_1,T_2,\dots,T_k$ 组成,这些<strong>子树</strong>中的每一颗的根都被来自根 r 的一条有向边所连接</p><ul><li><strong>叶</strong>(leaf): 没有子节点的节点</li><li><strong>兄弟</strong>(sibling): 具有相同父节点的节点</li><li><strong>路径</strong>(path): 从节点 $n_1$ 到 $n_k$ 的路径为 $n_1, n_2,\dots,n_k$ 的一个序列.且对于 $1\leq i&lt;k$,有 $n_i$ 是 $n_{i+1}$ 的父节点</li><li><strong>路径的长</strong>(length): 路径上 边的条数,即 $k-1$.每一节点到自身的路径长为0</li><li><strong>深度</strong>(depth): 对于任意节点 $n_i$,其深度为从根到 $n_i$ 的唯一路径的长</li></ul></li><li><p>树的实现</p><ul><li><p>在每一个节点除数据外,还需要的两个指针指向它的第一子节点(向下)及下一个兄弟节点(向右)</p></li><li><p>树的节点声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">prtToNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> &#123;</span><br>    elementType element;<br>    prtToNode firstChild;<br>    prtToNode nextSibling;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>树的遍历</p><ul><li><p>树经常用于操作系统中的目录结构</p><ul><li>例如 Unix 系统中的文件 <code>/usr/mark/book/ch1.r</code></li><li>第一个 &#x2F; 后的每个 &#x2F; 都表示一条边</li></ul></li><li><p>考虑以下述格式打印目录中的所有文件: 深度为 $d_i$ 的文件的名称前有 $d_i$ 个 <kbd>tab</kbd> 进行缩进,然后打印</p></li><li><p>实现思路: 以递归的方式打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">listDir</span><span class="hljs-params">(directoryOrFile d, <span class="hljs-type">int</span> depth)</span> &#123;<br>    <span class="hljs-keyword">if</span>(d is a legitimate entry) &#123;<br>        printName(d, depth);<br>        <span class="hljs-keyword">if</span>(d is a directory) &#123;<br>            <span class="hljs-keyword">for</span> each child, c, of d<br>                <span class="hljs-title function_">listDir</span><span class="hljs-params">(c, depth + <span class="hljs-number">1</span>)</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">listDirectory</span><span class="hljs-params">(directoryOrFile d)</span> &#123;<br>    listDir(d, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>算法核心函数 <code>listDir</code>: 参数为目录树的引用.如果是目录,则递归的处理子节点,文件名则被缩进后打印</li><li>驱动函数 <code>listDirectory</code>: 考虑到 <code>listDir</code> 的参数 <code>depth</code> 为内部递归变量.<br>因此需要驱动函数(这里赋值为0)</li></ul></li></ul></li></ol><h3 id="2-2-二叉树"><a href="#2-2-二叉树" class="headerlink" title="2.2 二叉树"></a>2.2 二叉树</h3><ol><li><p><strong>二叉树</strong>: 每个节点的子节点都不超过2个的树</p><ul><li>平均二叉树的深度通常比节点数 N 小得多,平均深度为 $O(\sqrt N)$</li><li><strong>二叉查找树</strong>(binary search tree)的平均深度为 $O(\log N)$.但在最坏的情况下可以为 N-1</li></ul></li><li><p>二叉树的实现</p><ul><li><p>由于二叉树最多有两个子节点,因此可以直接用指针指向它们</p></li><li><p>二叉树的节点声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">ptrToNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ptrToNode</span> <span class="hljs-title">tree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> &#123;</span><br>    elementType element;<br>    tree left;<br>    tree right;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="2-3-二叉查找树"><a href="#2-3-二叉查找树" class="headerlink" title="2.3 二叉查找树"></a>2.3 二叉查找树</h3><ol><li><p>二叉树经常用于查找.给树中的每个节点指定一个关键字值(假定为整数,且唯一)</p></li><li><p><strong>二叉查找树</strong>: 对于树中的每个节点 X,其左子树所有关键字值小于X关键字值,右子树所有关键字值大于X关键字值</p><ul><li>考虑到树的递归定义,对二叉查找树的操作通常采用递归处理</li><li>考虑到所有的元素都是有序的,因此假定运算符 <code>&lt;, =, &gt;</code> 均可用于这些元素</li></ul></li><li><p>二叉查找树的声明(<code>searchTree.h</code>文件中)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SEARCH_TREE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEARCH_TREE_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">position</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">searchTree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> &#123;</span><br>    elementType element;<br>    searchTree left;<br>    searchTree right;<br>&#125;<br><br>searchTree <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">(searchTree t)</span>;  <span class="hljs-comment">// 创建空树</span><br>position <span class="hljs-title function_">find</span><span class="hljs-params">(elementType x, searchTree t)</span>;  <span class="hljs-comment">// 查找元素位置</span><br>position <span class="hljs-title function_">findMin</span><span class="hljs-params">(searchTree t)</span>;  <span class="hljs-comment">// 查找最小值位置</span><br>position <span class="hljs-title function_">findMax</span><span class="hljs-params">(searchTree t)</span>;  <span class="hljs-comment">// 查找最大值位置</span><br>searchTree <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, searchTree t)</span>;  <span class="hljs-comment">// 插入元素</span><br>searchTree <span class="hljs-title function_">delete</span><span class="hljs-params">(elementType x, searchTree t)</span>;  <span class="hljs-comment">// 删除元素</span><br>elementType <span class="hljs-title function_">retrieve</span><span class="hljs-params">(position p)</span>;  <span class="hljs-comment">// 检索位置信息</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* SEARCH_TREE_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p>源文件 <code>searchTree.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c">searchTree <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">(searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t != <span class="hljs-literal">NULL</span>) &#123;<br>        makeEmpty(t-&gt;left);<br>        makeEmpty(t-&gt;right);<br>        <span class="hljs-built_in">free</span>(t);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>position <span class="hljs-title function_">find</span><span class="hljs-params">(elementType x, searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(x &lt; t-&gt;element)<br>        <span class="hljs-keyword">return</span> find(x, t-&gt;left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t-&gt;element)<br>        <span class="hljs-keyword">return</span> find(x, t-&gt;right);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> t;<br>&#125;<br><br>position <span class="hljs-title function_">findMin</span><span class="hljs-params">(searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;left == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> t;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> findMin(t-&gt;left);<br>&#125;<br><br>position <span class="hljs-title function_">findMax</span><span class="hljs-params">(searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t != <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">while</span>(t-&gt;right != <span class="hljs-literal">NULL</span>)<br>            t = t-&gt;right;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br>searchTree <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>) &#123;<br>        t = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> treeNode));<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">NULL</span>)<br>            fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            t-&gt;element = x;<br>            t-&gt;left = t-&gt;right = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; t-&gt;element)<br>        t-&gt;left = insert(x, t-&gt;left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t-&gt;element)<br>        t-&gt;right = insert(x, t-&gt;right);<br>    <span class="hljs-comment">/* else x已经在树中,不在执行任何操作 */</span><br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br>searchTree <span class="hljs-title function_">delete</span><span class="hljs-params">(elementType x, searchTree t)</span> &#123;<br>    position tmp;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)  <span class="hljs-comment">/* 空树 */</span><br>        Error(<span class="hljs-string">&quot;Element not found&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; t-&gt;element)  <span class="hljs-comment">/* 向左 */</span><br>        t-&gt;left = delete(x, t-&gt;left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t-&gt;element)  <span class="hljs-comment">/* 向右 */</span><br>        t-&gt;right = delete(x, t-&gt;right);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;left &amp;&amp; t-&gt;right) &#123; <span class="hljs-comment">/* 2个子节点 */</span><br>        tmp = findMin(t-&gt;right);<br>        t-&gt;element = tmp-&gt;element;<br>        t-&gt;right = delete(t-&gt;element, t-&gt;right);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        tmp = t;<br>        <span class="hljs-keyword">if</span>(t-&gt;left == <span class="hljs-literal">NULL</span>)<br>            t = t-&gt;right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;right == <span class="hljs-literal">NULL</span>)<br>            t = t-&gt;left;<br>        <span class="hljs-built_in">free</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-AVL-树"><a href="#2-4-AVL-树" class="headerlink" title="2.4 AVL 树"></a>2.4 AVL 树</h3><ol><li><strong>AVL树</strong>(Adelson-Velskii Landis): 带有平衡条件(需易保持)的二叉查找树.且保证树的深度为$O(\log N)$<ul><li>AVL 树要求每个节点的左子树和右子树的高度最多差1(空树的高度定义为-1)</li><li>AVL 树的高度最多为$1.44\log (N+2)-1.328$. 因此可以保证除插入外的操作(删除为惰性)均为 $O(\log N)$</li></ul></li><li><strong>旋转</strong>: AVL 树的插入操作可能会破坏平衡条件,因此隐含着困难.但总是可以经过修正使得性质恢复<ul><li>插入后,只有插入点到根节点路径上的节点的平衡可能被改变.沿着此路径向上找到一个破坏了 AVL 条件的节点,调整该节点重新平衡该树,将会使得整棵树满足 AVL 条件</li><li>设需要重新平衡的节点为 $\alpha$.导致不平衡出现的插入位置共有4种情况<ol><li>左子节点的左子树</li><li>左子节点的右子树</li><li>右子节点的左子树</li><li>右子节点的右子树</li></ol></li><li>情形1,4 与 情形2,3 为关于 $\alpha$节点的对称.分别通过单旋转和双旋转进行处理</li></ul></li></ol><h2 id="3-散列"><a href="#3-散列" class="headerlink" title="3 散列"></a>3 散列</h2><h3 id="3-1-散列函数"><a href="#3-1-散列函数" class="headerlink" title="3.1 散列函数"></a>3.1 散列函数</h3><ol><li><p>散列表(hash table)ADT: 仅支持二叉查找树所允许的一部分操作,其实现常称为<strong>散列</strong>(hashing)</p><ul><li>散列以常数平均时间执行 插入,删除,查找,但需要元素间任何排序信息的操作不会得到有效支持</li><li>理想的散列表数据结构是一个含有<strong>关键字</strong>的具有固定大小的数组</li><li>关键字的典型是带有信息的字符串,而表的大小记为 Table-Size</li></ul></li><li><p><strong>映射函数</strong>(hash function): 将关键字映射到 [0, Table-Size) 区间中的某个数,且放到适当的单元中</p><ul><li>理想的映射函数应运算简单,且保证不同的关键字映射到不同的单元</li><li>实际上不可能,因为关键字是无穷的,而单元的数量是有限的</li><li>因此要找一个散列函数,能在单元间均匀的分配关键字</li><li><strong>冲突</strong>(collision): 两个关键字散列到同一个值</li></ul></li><li><p>散列函数</p><ul><li><p>若输入的关键字为整数,一般采用返回 <code>key mod tableSize</code>.保证表的大小为素数时效果较好</p></li><li><p>若输入的关键字为字符串</p><ol><li><p>可以将字符串中的字符的 ASCII 码值之和作为关键字(简单,但当表很大时将会分配不均)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index;<br>index <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">int</span> tableSize)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashVal = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*key != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        hashVal += *key++;<br>    <span class="hljs-keyword">return</span> hashVal % tableSize;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>考虑计算 $\mathrm{\sum\limits_{i&#x3D;0}^{keySize&#x3D;1}key[keySize-i-1]}\cdot 32^i$(根据 Horner 法则计算 32 的多项式函数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">index <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">int</span> tableSize)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashVal = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*key != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        hashVal = (hashVal &lt;&lt; <span class="hljs-number">5</span>) + *key++;<br>    <span class="hljs-keyword">return</span> hashVal % tableSize;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如计算 $h_k &#x3D; k_1 + 32k_2 + 32^2k_3$ 的方式为 $h_k &#x3D; ((k_3) \times 32 + k_2) \times 32+k_1$ </li><li>关键行中的 <code>&lt;&lt; 5</code> 即为乘以32, 且其中的加法还可以使用按位异或 <code>^</code> 代替</li><li>该算法的优点在于极其简单,当允许溢出时速度很也快</li><li>如果关键字特别长,不仅时间花费大,而且前面的字符还会被移出.此时通常不采用全部字符</li></ul></li></ol></li></ul></li></ol><h3 id="3-2-消除冲突"><a href="#3-2-消除冲突" class="headerlink" title="3.2 消除冲突"></a>3.2 消除冲突</h3><ol><li><p>当一个元素被插入处已存在另一个元素(即不同关键字的散列值相同),此时将产生冲突</p><ul><li>解决冲突的方式有: 分离链接法(separate chaining), 开放定址法(open addressing)</li></ul></li><li><p>分离链接法: 将散列到同一个值的所有元素保存到一个表中</p><ul><li><p>示例: 关键字为前10个数的平方(0, 1, 4, 9, 16, 25, 36, 49, 64, 81).散列函数为 $hash(x) &#x3D; x \space mod \space 10$</p></li><li><p>则分离链接散列表形如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"> 哈希表 (桶数组)<br>   +-------+<br>| 索引0 | --&gt; [ (&quot;key_a&quot;, value_a) | next ] --&gt; [ (&quot;key_b&quot;, value_b) | next ] --&gt; NULL<br>   +-------+<br>| 索引1 | --&gt; NULL<br>   +-------+<br>| 索引2 | --&gt; [ (&quot;key_c&quot;, value_c) | next ] --&gt; NULL<br>   +-------+<br>   | 索引3 | --&gt; [ (&quot;key_d&quot;, value_d) | next ] --&gt; [ (&quot;key_e&quot;, value_e) | next ] --&gt; NULL<br>   +-------+<br>   |  ...  |<br>   +-------+<br>   |索引n-1| --&gt; NULL<br>   +-------+<br></code></pre></td></tr></table></figure></li><li><p>插入操作: 遍历相应的表以检查该元素是否以处于适当的位置.如果是新元素,则将其插入到表的前端&#x2F;末尾</p></li><li><p>分离链接散列表的的实现</p><ul><li><p>头文件 <code>hashSeq.h</code> 中(其中 listNode 的结构与链表相同)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HASH_SEQ_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HASH_SEQ_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTbl</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">position</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTbl</span> *<span class="hljs-title">hashTable</span>;</span><br><br>hashTable <span class="hljs-title function_">initializeTable</span><span class="hljs-params">(<span class="hljs-type">int</span> tableSize)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">destroyTable</span><span class="hljs-params">(hashTable h)</span>;<br>position <span class="hljs-title function_">find</span><span class="hljs-params">(elementType key, hashTable h)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType key, hashTable h)</span>;<br>elementType <span class="hljs-title function_">retrieve</span><span class="hljs-params">(position p)</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br>    elementType element;<br>    position next;<br>&#125;<br><span class="hljs-keyword">typedef</span> position <span class="hljs-built_in">list</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTbl</span> &#123;</span><br>    <span class="hljs-type">int</span> tableSize;<br>    <span class="hljs-built_in">list</span> *theLists;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>源文件 <code>hashSeq.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">hashTable <span class="hljs-title function_">initializeTable</span><span class="hljs-params">(<span class="hljs-type">int</span> tableSize)</span> &#123;<br>    hashTable h;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>(tableSize &lt; minTableSize) &#123;<br>        error(<span class="hljs-string">&quot;Table size too small&quot;</span>);<br>        retrun <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>    h = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> hashTbl));<br>    <span class="hljs-keyword">if</span>(h == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    h-&gt;tableSize = nextPrime(tableSize);<br>    <br>    h-&gt;theLists = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">list</span>) * h-&gt;tableSize);<br>    <span class="hljs-keyword">if</span>(h-&gt;theLists == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; h-&gt;tableSize; i++) &#123;<br>        h-&gt;theLists[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> listNode));<br>        <span class="hljs-keyword">if</span>(h-&gt;theLists[i] == <span class="hljs-literal">NULL</span>)<br>            fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            h-&gt;theLists[i]-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType key, hashTable h)</span> &#123;<br>    position pos, newCell;<br>    <span class="hljs-built_in">list</span> l;<br>    pos = find(key, h);<br>    <span class="hljs-keyword">if</span>(pos == <span class="hljs-literal">NULL</span>) &#123;<br>        newCell = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> listNode));<br>        <span class="hljs-keyword">if</span>(newCell == <span class="hljs-literal">NULL</span>)<br>            fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            l = h-&gt;thelists[hash(key, h-&gt;tableSize)];<br>            newCell-&gt;next = l-&gt;next;<br>            newCell-&gt;element = key;<br>            l-&gt;next = newCell;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>开放定址法: 当冲突发生时,尝试选择另外的单元,知道找出空的单元为止</p><ul><li>考虑单元 $h_0(X),h_1(X),h_2(X), \cdots,$相继试选.其中 $h_i(X) &#x3D; (hash(x)+F(i))\mod \mathrm{tableSize}$</li><li>函数 $F$ 是冲突解决方法,且 $F(0) &#x3D; 0$ </li><li>开放地址法需要将所有数据置于表内,因此散列表较大.但省去了给新单元分配地址的时间</li></ul></li></ol><h3 id="3-3-再散列"><a href="#3-3-再散列" class="headerlink" title="3.3 再散列"></a>3.3 再散列</h3><ol><li><p><strong>再散列</strong>(rehashing): 对于开放定址法,如果表的元素太满,则操作时间消耗增长,且插入可能失败.此时可以建立另外一个约两倍大的表(同时使用一个相关的新散列函数),扫描整个原始散列表,计算每个元素的新散列值并将其插入到新表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">hashTable <span class="hljs-title function_">rehash</span><span class="hljs-params">(hashTable h)</span> &#123;<br>    <span class="hljs-type">int</span> i, oldSize;<br>    cell *oldCell;<br>    oldCells = h-&gt;theCells;<br>    oldSize = h-&gt;tableSize;<br>    h = initializeTable(<span class="hljs-number">2</span> * oldSize);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; oldSize; i++) &#123;<br>        <span class="hljs-keyword">if</span>(oldCells[i].info == legitimate)<br>            insert(oldCells[i].element, h);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(oldCells);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-优先队列"><a href="#4-优先队列" class="headerlink" title="4 优先队列"></a>4 优先队列</h2><h3 id="4-1-优先队列"><a href="#4-1-优先队列" class="headerlink" title="4.1 优先队列"></a>4.1 优先队列</h3><ol><li><strong>优先队列</strong>(priority queue): 是允许至少插入(入队)和删除最小(出队:找出,返回,删除优先队列中的最小元素)的数据结构</li><li>优先队列的简单实现方式<ul><li>使用简单链表: 在表头进行插入$O(1)$,遍历链表以实现删除最小元$O(n)$</li><li>始终让表保持排序状态: 进行顺序插入$O(n)$和删除操作$O(1)$</li><li>二叉查找树: 对插入和删除操作均为 $O(\log n)$</li></ul></li></ol><h3 id="4-2-二叉堆"><a href="#4-2-二叉堆" class="headerlink" title="4.2 二叉堆"></a>4.2 二叉堆</h3><ol><li><p>二叉堆(binary heap) 具有两个性质: 结构性和堆序性.因此堆的操作需要堆的所有性质都被满足才终止</p></li><li><p>结构性质: <strong>堆</strong>(heap): 一颗被完全填满的二叉树(完全二叉树, complete binary tree),底层可以例外(从左到右填入)</p><ul><li>高为 h 的完全二叉树节点数为: $[2^h, 2^{h+1})$.因而完全二叉树的高是 $\lfloor \log N \rfloor$</li><li>完全二叉树可以用数组进行表示,而不需要指针</li><li>考虑位置为 i 的元素,其左子节点位于 2i,右子节点位于左子节点后的 2i+1,父节点位于 $\lfloor i&#x2F;2 \rfloor$ </li><li>堆数据结构将由 一个数组(无论关键为什么类型),一个代表最大值的整数,当前堆大小的整数 组成</li></ul></li><li><p>堆序性质: 使操作快速执行</p><ul><li>考虑需要找出最小元,因此最小元应该在根上</li><li>将任意子树也视为一个堆,则任意节点应小于其所有后裔</li><li><strong>堆序性质</strong>: 在一个堆中,对于任意节点 X, X父节点的关键字小于X的关键字(根节点除外)</li></ul></li><li><p>优先队列的声明(<code>binaryHeap.h</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BIN_HEAP_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIN_HEAP_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapStruct</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapStruct</span> *<span class="hljs-title">priorityQueue</span>;</span><br><br>priorityQueue <span class="hljs-title function_">initialize</span><span class="hljs-params">(<span class="hljs-type">int</span> maxElements)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, priorityQueue h)</span>;<br>elementType <span class="hljs-title function_">deleteMin</span><span class="hljs-params">(priorityQueue h)</span>;<br>elementType <span class="hljs-title function_">findMin</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">(priorityQueue h)</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapStruct</span> &#123;</span><br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> size;<br>    elementType *elements;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>优先队列的操作(<code>binaryHeap.c</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">priorityQueue <span class="hljs-title function_">initialize</span><span class="hljs-params">(<span class="hljs-type">int</span> maxElements)</span> &#123;<br>    priorityQueue h;<br>    <span class="hljs-keyword">if</span>( maxElements &lt; minPQSize )<br>        error(<span class="hljs-string">&quot;Priority queue size is too small&quot;</span>);<br>    h = <span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>( <span class="hljs-keyword">struct</span> heapStruct ) );<br>    <span class="hljs-keyword">if</span>(h == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    h-&gt;elements = <span class="hljs-built_in">malloc</span>( ( maxElements + <span class="hljs-number">1</span> ) * <span class="hljs-keyword">sizeof</span>(elementsType) );<br>    <span class="hljs-keyword">if</span>( h-&gt;elements == <span class="hljs-literal">NULL</span> )<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    h-&gt;capacity = maxElements;<br>    h-&gt;size = <span class="hljs-number">0</span>;<br>    h-&gt;elements[<span class="hljs-number">0</span>] = minData;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, priorityQueue h)</span> &#123;<br>    <span class="hljs-keyword">if</span>(isFull(h)) &#123;<br>        error(<span class="hljs-string">&quot;Priority queue is full&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = ++h-&gt;size; h-&gt;elements[ i / <span class="hljs-number">2</span> ] &gt; x; i /= <span class="hljs-number">2</span>)<br>        h-&gt;elements[ i ] = h-&gt;elements[ i / <span class="hljs-number">2</span> ];<br>    h-&gt;elements[i] = x;<br>&#125;<br><br>elementType <span class="hljs-title function_">deleteMin</span><span class="hljs-params">(priorityQueue h)</span> &#123;<br>    <span class="hljs-type">int</span> child;<br>    elementType minElement, lastElement;<br>    <span class="hljs-keyword">if</span>( isEmpty(h) ) &#123;<br>        error(<span class="hljs-string">&quot;Priority queue is full&quot;</span>);<br>        <span class="hljs-keyword">return</span> h-&gt;elements[<span class="hljs-number">0</span>];<br>    &#125;<br>    minElement = h-&gt;elements[<span class="hljs-number">1</span>];<br>    lastElement = h-&gt;elements[h-&gt;size--];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i * <span class="hljs-number">2</span> &lt;=  h-&gt;size; i = child) &#123;<br>        child = i * <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(child != h-&gt;size &amp;&amp; h-&gt;elements[child+<span class="hljs-number">1</span>] &lt; h-&gt;elements[child])<br>            child++;<br>        <span class="hljs-keyword">if</span>(lastElement &gt; h-&gt;elements[child])<br>            h-&gt;elements[i] = h-&gt;elements[child];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    h-&gt;elements[i] = lastElement;<br>    <span class="hljs-keyword">return</span> minElement;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-排序"><a href="#5-排序" class="headerlink" title="5 排序"></a>5 排序</h2><ol><li>排序算法接受的参数为: 数组首地址, 及一个表示数组元素个数的整数</li><li>基于比较的排序: 假定对于元素而言,运算符 <code>&lt;, &gt;</code> 是存在的</li><li>逆序(inversion): 与线性代数中的关于排列的逆序数定义类似<ul><li>n 个互异数的数组的平均逆序数为 $\frac{n(n-1)}4$</li><li>通过交换相邻元素进行排序的任何算法平均需要 $\Omega(N^2)$</li><li>排序算法通过删除逆序进行,为了有效运行,必须每次删除不止一个逆序</li></ul></li><li>间接排序(indirect sorting): 由于交换结构的操作是昂贵的,因而可以创建数组(其元素为指向结构的指针).通过比较指针指向的关键字,并在必要时交换指针来进行排序</li><li>排序的一般下界<ul><li>任何只用到比较的算法在最坏的情况下需要 $\Omega(N\log N)$ 次比较,因而归并排序和堆排序最优</li><li>任何只用到比较的算法在平均的情况下需要 $\Omega(N\log N)$ 次比较,因而快速排序是最优的</li></ul></li></ol><h3 id="5-1-插入排序"><a href="#5-1-插入排序" class="headerlink" title="5.1 插入排序"></a>5.1 插入排序</h3><ol><li><p>插入排序(insert sort)</p><ul><li><p>将数组假想为两部分: 前面的为已排序数组,后面的为待排序数组</p></li><li><p>初始状态为已排序数组只有第一个元素,剩余为待排序数组</p></li><li><p>遍历待排序数组,将每个未排序元素插入到已排序数组中恰当的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    elementType tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>; p &lt; n; ++p) &#123;<br>        tmp = arr[p];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = p; j&gt;<span class="hljs-number">0</span> &amp;&amp; arr[j<span class="hljs-number">-1</span>] &gt; tmp; --j)<br>            arr[j] = arr[j<span class="hljs-number">-1</span>];<br>        arr[j] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>时间复杂度: $O(N^2)$</p><ul><li>当输入数据为逆序时,达到此上界</li><li>当输入数据已排序时,运行时间为 $O(N)$</li><li><strong>对于几乎已经排序的数据(逆序数 I 较小),插入排序很快,其时间为 $O(I+N)$</strong></li></ul></li></ol><h3 id="5-2-希尔排序"><a href="#5-2-希尔排序" class="headerlink" title="5.2 希尔排序"></a>5.2 希尔排序</h3><ol><li><p>希尔排序(缩小增量排序, diminishing increment sort): 先将整个待排序的序列分割为若干子序列分别进行直接插入排序,待整个序列中的记录基本有序时,在对全体进行直接插入排序</p><ul><li><p>增量序列: $h_1, h_2, \dots,h_t$,其中 $h_1 &#x3D; 1$</p></li><li><p>$h_k$-排序数组: $\forall i,arr[i] \leq arr[i+h_k]$</p></li><li><p>希尔增量通常取 $h_t &#x3D; \lfloor n&#x2F;2 \rfloor, h_k &#x3D; \lfloor h_{k+1}&#x2F;2 \rfloor$ </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    elementType tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> increment = n/<span class="hljs-number">2</span>; increment &gt; <span class="hljs-number">0</span>; increment /= <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = increment; i &lt; n; ++i) &#123;<br>            tmp = arr[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &gt;= increment; j -= increment)<br>                <span class="hljs-keyword">if</span>(tmp &lt; arr[j - increment])<br>                    a[j] = a[j - increment];<br>            <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">break</span>;<br>                arr[j] = tmp;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>时间复杂度(希尔排序算法简单,但分析极其困难)</p><ul><li>希尔增量下的希尔排序的最坏情形运行时间 $\Theta(N^2)$</li><li>Hibbard 增量: 形如 $1, 3, 7, \dots , 2^k-1$.最坏情形运行时间 $\Theta(N^\frac32)$</li></ul></li></ol><h3 id="5-3-堆排序"><a href="#5-3-堆排序" class="headerlink" title="5.3 堆排序"></a>5.3 堆排序</h3><ol><li><p>堆排序(heap sort): 考虑建立二叉堆 $O(N)$,执行 N 次 <code>deleteMin</code> $O(N\log N)$.按照顺序,最小的元素将会先离开堆,将这些元素记录到第二个数组即可得到排序数组</p></li><li><p>上述算法需要额外的数组空间,可以每次在 <code>deleteMin</code> 操作后,将最后空出来的单元用于存放元素.此时得到的将是逆序的排序数组,因而可以构建具有 <code>deleteMax</code> 操作的二叉堆</p></li><li><p>堆排序是非常稳定的算法: 平均使用的比较只比最坏情形略少</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> leftChild(i) (2 * (i) + 1)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">percDown</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> child;<br>    <span class="hljs-keyword">for</span>(elementType tmp = arr[i]; leftChild(i) &lt; n; i = child) &#123;<br>        <span class="hljs-keyword">if</span>(child != n - <span class="hljs-number">1</span> &amp;&amp; arr[child + <span class="hljs-number">1</span>] &gt; arr[child])<br>            child++;<br>        <span class="hljs-keyword">if</span>(tmp &lt; a[child])<br>            arr[i] = arr[child];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    arr[i] = tmp;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        percDown(arr, i, n);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>        swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[i]);<br>        percDown(arr, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-4-归并排序"><a href="#5-4-归并排序" class="headerlink" title="5.4 归并排序"></a>5.4 归并排序</h3><ol><li><p>考虑合并2个已排序的数组: 设定2个指针分别指向数组的起始位置.比较2个指针指向的元素,将较小的元素放入输出数组,并移动指针.重复这一过程,直到某一指针到达末尾</p></li><li><p>归并排序(merge sort): 以分治递归的形式合并已排序数组 $O(N\log N)$.使用的比较次数几乎最优</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mSort</span><span class="hljs-params">(elementType arr[], elementType tmpArr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> center;<br>    <span class="hljs-keyword">if</span>(left &lt; right) &#123;<br>        center = (left + right) / <span class="hljs-number">2</span>;<br>        mSort(arr, tmpArr, left, center);<br>        mSort(arr, tmpArr, center + <span class="hljs-number">1</span>, right);<br>        merge(arr, tmpArr, left, center + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mergeSord</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    elementType *tmpArr = <span class="hljs-built_in">malloc</span>( n * <span class="hljs-keyword">sizeof</span>(elementType) );<br>    <span class="hljs-keyword">if</span>(tmpArr != <span class="hljs-literal">NULL</span>) &#123;<br>        mSort(arr, tmpArr, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">free</span>(tmpArr);<br>    &#125; <span class="hljs-keyword">else</span><br>        fatalError(<span class="hljs-string">&quot;No space for tmp array!&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(elementType arr[], elementType tmpArr[], <span class="hljs-type">int</span> lpos, <span class="hljs-type">int</span> rpos, <span class="hljs-type">int</span> rightEnd)</span> &#123;<br>    <span class="hljs-type">int</span> leftEnd = rpos - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> tmpPos = lpos;<br>    <span class="hljs-type">int</span> numElements = rightEnd - lpos + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(lpos &lt;= leftEnd &amp;&amp; rpos &lt;= rightEnd)<br>        <span class="hljs-keyword">if</span>(arr[lpos] &lt;= arr[rpos])<br>            tmpArr[tmpPos++] = arr[lpos++];<br>    <span class="hljs-keyword">else</span><br>            tmpArr[tmpPos++] = arr[rpos++];<br>    <span class="hljs-keyword">while</span>(lpos &lt;= leftEnd)<br>        tmpArr[tmpPos++] = arr[lpos++];<br>    <span class="hljs-keyword">while</span>(rpos &lt;= rightEnd)<br>        tmpArr[tmpPos++] = arr[rpos++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numElements; ++i, --rightEnd) &#123;<br>        arr[rightEnd] = tmpArr[rightEnd];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-5-快速排序"><a href="#5-5-快速排序" class="headerlink" title="5.5 快速排序"></a>5.5 快速排序</h3><ol><li><p>快速排序(quick sort): 实践中最快的已知排序算法,平均运行时间 $O(N\log N)$</p><ul><li>若 S 中元素个数为 0 或 1,则直接返回</li><li>选取 S 中的任意元素 v,其称为基准(pivot)</li><li>分区并排序: 将 $S-{v}$ 分为两个不相交集合: $S_1 &#x3D;{x\in S-{v}|x\leq v},S_2 &#x3D;{x\in S-{v}|x\geq v} $ </li><li>递归地将小于基准元素的子数列和大于基准值元素的子数组排序</li></ul></li><li><p>选取基准</p><ul><li>错误的方式: 选取第一个元素作为基准.若输入是预排序或反序的,将会产生劣质的分割</li><li>安全的方式: 随机选取基准.但考虑到生成随机数是昂贵的,因而无法减少算法其余部分的平均运行时间</li><li>数中值分割法: 基准的最好选择是数组的中值,但这很难算出.因而可以考虑三个元素(左侧,中心,右侧位置)的中值作为基准.消除了预排序输入的坏情形,并减少约 5% 的时间</li></ul></li><li><p>分割策略</p><ul><li>将基准元与最后的元素进行交换,使得基准元离开要被分割的数据段</li><li>设置双指针 i, j. 初始时刻分别指向数组的第一个元素和倒数第二个元素(因为最后一个元素为基准)</li><li>当 i &lt; j 时,将 i 右移,直到遇到大于基准元的数.同理,将 j 左移,直到遇到小于基准元的数</li><li>若停止后的仍满足 i &lt; j,则将 i, j 指向的两个元素互换.重复该过程,直到 i, j 彼此交错</li><li>当 i, j 交错后,将基准元与 i 所指向的元素互换,即可完成分割</li></ul></li><li><p>对于小数组(n &lt; 20),快速排序不如插入排序好</p><ul><li>由于快速排序是递归的,因此小数组排序的情况经常发生</li><li>对小数组不进行递归排序,而进行插入排序将会节约15%的时间.截至范围可选择 n&#x3D;10</li></ul></li><li><p>快速排序的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    qSort(arr, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>&#125;<br><br>elementType <span class="hljs-title function_">median3</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> center = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(arr[left] &gt; arr[center])<br>        swap(&amp;arr[left], &amp;arr[center]);<br>    <span class="hljs-keyword">if</span>(arr[left] &gt; arr[right])<br>        swap(&amp;arr[left], &amp;arr[right]);<br>    <span class="hljs-keyword">if</span>(arr[center] &gt; arr[right])<br>        swap(&amp;arr[center], &amp;arr[right]);<br>    swap(&amp;arr[center], &amp;arr[right - <span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> arr[right - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">qSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    elementType pivot;<br>    <span class="hljs-keyword">if</span>(left + cutOff &lt;= right) &#123;<br>        pivot = median3(arr, left, right);<br>        <span class="hljs-type">int</span> i = left;<br>        <span class="hljs-type">int</span> j = right - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(;;) &#123;<br>            <span class="hljs-keyword">while</span>(arr[++i] &lt; pivot) &#123;&#125;<br>            <span class="hljs-keyword">while</span>(arr[--j] &lt; pivot) &#123;&#125;<br>            <span class="hljs-keyword">if</span>(i &lt; j)<br>                swap(&amp;arr[i], &amp;arr[j]);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        swap(&amp;arr[i], &amp;arr[right - <span class="hljs-number">1</span>]);<br>        qSort(arr, left, i - <span class="hljs-number">1</span>);<br>        qSort(arr, i + <span class="hljs-number">1</span>, right);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        insertSort(arr + left, right - left + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-图论算法"><a href="#6-图论算法" class="headerlink" title="6 图论算法"></a>6 图论算法</h2><h3 id="6-1-图的定义"><a href="#6-1-图的定义" class="headerlink" title="6.1 图的定义"></a>6.1 图的定义</h3><ol><li>图(graph): 由顶点(vertex)的集合 V,边(edge)的集合 E 组成<ul><li>每条边都是点对(v, w), 其中 $v,w\in V$</li><li>若点对是有序的,则图是有向(directed)的,称为有向图(digraph)</li><li>顶点 v, w 邻接等价于当 $(v,w)\in E$</li><li>边可以有第三种成分: 权(weight) 或 值(cost)</li></ul></li><li>图中的路径(path)<ul><li>路径是顶点序列: $w_1, w_2, \dots, w_N \space\space \mathrm{s.t.}(w_i,w_{i+1})\in E,1\leq i&lt;E$ </li><li>路径的长(length): 边的数量,即 N-1</li><li>环(loop): 从一个顶点到自身的边</li><li>简单路径: 所有的顶点都互异,但第一个和最后一个顶点可以相同</li></ul></li><li>图中的圈(cycle)<ul><li>有向图中的圈: 满足 $w_1 &#x3D; w_N$ 且长至少为1的一条路径</li><li>无向图中的圈则额外要求边是互异的</li></ul></li><li>连通(connected)<ul><li>在无向图中从每一个顶点到每个其他顶点都存在一条路径</li><li>在有向图中,这种性质称为强连通(strongly connected)</li><li>若有向图不是强连通的,但其基础图(underlying graph, 即去掉弧的方向)是连通的,则称为弱连通(weakly connected)</li><li>完全图(complete graph): 每个顶点间都存在一条边</li></ul></li><li>图的表示(有向图)<ul><li>使用一个二维数组,即**邻接矩阵(adjacent matrix)**表示<ul><li>对于每条边(u, v),置 <code>A[u][v] = 1</code>.其他元素为0</li><li>若该边有一个权,则可置 <code>A[u][v]</code> 等于该权.使用很大&#x2F;小的数表示不存在的边</li><li>若图是稀疏的(sparse), 该方法所需求的空间 $\Theta(|V|^2)$ 过大了</li></ul></li><li><strong>邻接表(adjacent list)</strong>: 对每一个顶点,使用一个表存放所有的邻接点<ul><li>空间需求为 $O(|E|+|V|)$</li><li>邻接表是图的标准表示方法</li></ul></li><li>考虑到实际中顶点都有名字,因此需要使用散列表建立名字到数字的映射<ul><li>散列表中对每个顶点存储一个名字和一个内部编号( 1 ~ |V| 之间)</li></ul></li></ul></li></ol><h3 id="6-2-最短路径算法"><a href="#6-2-最短路径算法" class="headerlink" title="6.2 最短路径算法"></a>6.2 最短路径算法</h3><ol><li><p>输入一个赋权图: 与每条边 $(v_i, v_j)$ 联系的是穿越该弧的代价 $c_{i,j}$</p><ul><li>赋权路径长(weighted path length): $v_1v_2\dots v_N$ 路径的值为 $\sum\limits^{N-1}<em>{i&#x3D;1}c</em>{i,j}$</li></ul></li><li><p>单源最短路径问题: 给定赋权图 $G&#x3D;(V,E)$ 和特定顶点 s 作为输入,找出 s 到 G 每个点的最短赋权路径</p></li><li><p>无权最短路径</p><ul><li><p>广度优先搜索(breadth-first search): 按层处理顶点,距离最近的先辈赋值,最远的最后赋值</p></li><li><p>显然顶点s到自身距离为0,然后考察与s邻接的点,其距离为1.然后考察邻接的邻接,直到完成所有点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unWeigted</span><span class="hljs-params">(table t)</span> &#123;<br>    vertex v, w;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> currDist = <span class="hljs-number">0</span>; currDist &lt; numVetex; ++currDist)<br>        <span class="hljs-keyword">for</span> each vertex v<br>            <span class="hljs-title function_">if</span><span class="hljs-params">(!t[v].known &amp;&amp; t[v].dist == currDist)</span> &#123;<br>                t[v].known = True;<br>                <span class="hljs-keyword">for</span> each w adjacent to v<br>                    <span class="hljs-title function_">if</span><span class="hljs-params">(t[w].dist == infinity)</span> &#123;<br>                        t[w].dist = currDist + <span class="hljs-number">1</span>;<br>                        t[w].path = v;<br>                    &#125;<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Dijkstra 算法: 考虑赋权图的单源最短路径问题.仍借鉴无权时的思路</p><ul><li>顶点 s 到自身的距离为0,将其标记为已知,因为此时多了一个已知点,则可以获得其到达邻接点的距离</li><li>选取距离最小的点(贪心法,greedy algorithm)标记为已知,则有可以更新其到达邻接点的距离</li><li>重复该过程,直到获得到达目标点的最短距离</li><li>对于没有负值边的图,该算法总能完成.一旦出现负值边,则可能出现错误的答案</li></ul></li></ol><h2 id="7-算法设计技巧"><a href="#7-算法设计技巧" class="headerlink" title="7 算法设计技巧"></a>7 算法设计技巧</h2><h3 id="7-1-贪婪算法"><a href="#7-1-贪婪算法" class="headerlink" title="7.1 贪婪算法"></a>7.1 贪婪算法</h3><ol><li>贪婪算法分阶段工作.在每一个阶段,认为所作的决定是最好的,而不考虑将来的后果(即局部最优)<ul><li>当算法终止时,若局部最优就是全局最优,则算法正确.否则将得到一个次优解(suboptimal solution)</li><li>若不要求绝对最佳答案,也可通过简单的贪婪算法生成近似答案</li></ul></li><li>Huffman 编码<ul><li>ASCII 编码有约100个可打印字符和控制字符组成,需要 $\lceil \log 128\rceil&#x3D;7$ 位表示,可添加第8位作为校验位<ul><li>现实中,许多文件都含有大量的数字,空格和换行,而 q, x 很少</li><li>采用非等长编码,使经常出现的字符代码较短,可以节约磁盘空间</li></ul></li><li>对于代表字符的二进制代码,可以用二叉树来表示<ul><li>只在树叶上有数据.且每个字符从根节点开始,用0指示向左分支,用1指示向右分支</li><li>若字符 $c_i$ 在深度 $d_i$ 处,且出现 $f_i$ 次.则该字符代码的值(cost)为 $\sum d_i f_i$</li></ul></li></ul></li><li>Huffman 算法<ul><li>假设字符数量为 C.算法开始时存在 C 棵单节点树(每个字符一颗)</li><li>任意选取有最小权(树的权等于其树叶频率的和)的两棵树,任意形成以这两棵树为子树的新树</li><li>将这样的过程进行 C-1 次.即可得到最优 Huffman 编码树</li></ul></li></ol><h3 id="7-2-分治算法"><a href="#7-2-分治算法" class="headerlink" title="7.2 分治算法"></a>7.2 分治算法</h3><ol><li>分治(divide and conquer)算法<ul><li>分: 递归解决较小的问题(基本情况除外)</li><li>治: 从子问题的解 构建原问题的解</li></ul></li><li>最近点问题: 找出平面上点列中最近(欧几里得距离)的一对点<ul><li>暴力算法: 计算每个点对之间的距离,找出最小值 $O(N^2)$</li><li>分治算法思路<ul><li>将平面上的点分为两半,最近点对存在三种可能: 均在左, 均在右, 一个在左一个在右</li><li>记不同情况的最近点对的最小距离为: 左侧点集 $d_l$,右侧点集 $d_r$,两侧点间的距离 $d_c$</li><li>对于 $d_l, d_r$,可以递归的进行计算.关键在于如何计算 $d_c$</li></ul></li><li>$d_c$ 的计算<ul><li>令 $\delta &#x3D; \min(d_l, d_r)$.如果 $d_c$ 对 $\delta$ 有改进,则只需计算 $d_c$</li><li>若 $d_c$ 是这样的距离,则定义 $d_c$ 的两个点必然在分割线的 $\delta$ 邻域内(一个带状区域).限制考察点的数量</li><li>对于均匀分布的点集,则平均有 $O(\sqrt N)$ 个点位于邻域内,此时可采用暴力求解 $O(N)$</li></ul></li></ul></li><li>选择问题: 找出含有 N 个元素的表 S 中的第 k 个最小的元素(对于中位数 $k &#x3D; \lceil N&#x2F;2 \rceil$ 特别关注)<ul><li>通过对元素的快速排序,此问题以 $O(N\log N)$ 的最坏情形时间解决</li><li>五分化中项的中项 选择快速排序的基准<ul><li>将 N 个元素分为 $\lfloor N&#x2F;5 \rfloor$ 组,每5个元素一组,最多忽略4个元素</li><li>找出每组的中项,得到 $\lfloor N&#x2F;5 \rfloor$ 个中项的表 M,找出 M 的中项并返回</li></ul></li><li>使用五分化中项的中项的快速选择算法的运行时间为 $O(N)$.但实践中该算法并不实用</li></ul></li></ol><h3 id="7-3-动态规划"><a href="#7-3-动态规划" class="headerlink" title="7.3 动态规划"></a>7.3 动态规划</h3><ol><li><p>动态规划(dynamic programming)</p><ul><li>数学递归公式均可直接翻译为递归算法,但现实中编译器往往不发正确对待递归算法,而导致低效</li><li>当这种情况发生时,便需要给编译器提供帮助.改写为非递归的算法,并将子问题的答案记录在一个表内</li></ul></li><li><p>使用表代替递归</p><ul><li><p>计算 Fibonacci 数的自然递归效率非常低,是指数级别的</p></li><li><p>使用一个表将中间的计算结果存储起来,则可避免大量的冗余计算,下面计算 $c_n &#x3D; \frac2n\sum\limits_{i&#x3D;0}^{n-1}c_i+n,\space c_0 &#x3D; 1$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">double</span> *c = <span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>( <span class="hljs-type">double</span> ) * ( n + <span class="hljs-number">1</span> ) );<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    c[<span class="hljs-number">0</span>] = <span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j)<br>            sum += c[j];<br>        c[i] = <span class="hljs-number">2.0</span> * sum / i + i;<br>    &#125;<br>    <span class="hljs-type">int</span> answer = c[n];<br>    <span class="hljs-built_in">free</span>(c);<br>    <span class="hljs-keyword">return</span> answer;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C 语言</tag>
      
      <tag>计算机</tag>
      
      <tag>Code</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Language Advanced</title>
    <link href="/2023/05/03/Computer/C-Language-Advanced/"/>
    <url>/2023/05/03/Computer/C-Language-Advanced/</url>
    
    <content type="html"><![CDATA[<h1 id="C-语言进阶"><a href="#C-语言进阶" class="headerlink" title="C 语言进阶"></a>C 语言进阶</h1><h2 id="0-库函数"><a href="#0-库函数" class="headerlink" title="0 库函数"></a>0 库函数</h2><h3 id="0-1-字符处理"><a href="#0-1-字符处理" class="headerlink" title="0.1 字符处理"></a>0.1 字符处理</h3><ol><li><p>字符分类(返回值非零时表示真,函数声明于 <code>&lt;ctype.h&gt;</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">isalnum</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 字母或数字</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isalpha</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 字母</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isblank</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 空白字符(空格或\t)(C99新增)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">iscntrl</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 控制字符</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isdigit</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 十进制数字</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isgraph</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 可显示字符(除空格)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">islower</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 小写字母</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isprint</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 可打印字符(包括空格)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ispunct</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 标点符号</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isspace</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 空白字符(空格, \f, \n, \r, \t, \v)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isupper</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 大写字母</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isxdigit</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>; <span class="hljs-comment">// 十六进制数字</span><br></code></pre></td></tr></table></figure></li><li><p>字符转换(声明于 <code>&lt;ctype.h&gt;</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">tolower</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 转换为小写</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">toupper</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 转换为大写</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="0-2-字符串处理"><a href="#0-2-字符串处理" class="headerlink" title="0.2 字符串处理"></a>0.2 字符串处理</h3><ol><li><p>下列函数声明于 <code>&lt;string.h&gt;</code></p></li><li><p>字符串操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span>;<br><span class="hljs-type">char</span> *<span class="hljs-title function_">strncat</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">size_t</span> n)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">strncmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s1, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s2, <span class="hljs-type">size_t</span> n)</span>;<br><span class="hljs-type">size_t</span> <span class="hljs-title function_">strlen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;<br></code></pre></td></tr></table></figure></li><li><p>内存操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> n)</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">memmove</span><span class="hljs-params">(<span class="hljs-type">void</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> n)</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *s, <span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> n)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">memcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *s1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *s2, <span class="hljs-type">size_t</span> n)</span>;<br></code></pre></td></tr></table></figure></li><li><p>搜索函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">strchr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> c)</span>;    <span class="hljs-comment">// 查找字符首次出现</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">strrchr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> c)</span>;   <span class="hljs-comment">// 查找字符最后出现</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">strstr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *haystack, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *needle)</span>; <span class="hljs-comment">// 查找子串</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">strtok</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *delim)</span>;  <span class="hljs-comment">// 字符串分割</span><br><br><span class="hljs-comment">/* 在字符串中查找指定字符集合中任意字符的首次出现位置 */</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">strpbrk</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *accept)</span>;<br><br><span class="hljs-comment">/* 在指定内存区域中查找特定字符的首次出现 */</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">memchr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">int</span> value, <span class="hljs-type">size_t</span> num)</span>;<br></code></pre></td></tr></table></figure></li><li><p>其他</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 计算字符串开头连续包含指定字符集合中字符的字符数 */</span><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">strspn</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *accept)</span>;<br><br><span class="hljs-comment">/* 计算字符串开头连续不包含指定字符集合中字符的字符数 */</span><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">strcspn</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *reject)</span>;<br><br><span class="hljs-comment">/* 将错误号转换为可读的错误描述字符串 */</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> errnum)</span>;<br></code></pre></td></tr></table></figure></li></ol><h3 id="0-3-输入输出"><a href="#0-3-输入输出" class="headerlink" title="0.3 输入输出"></a>0.3 输入输出</h3><ol><li><p>字符 IO(函数声明于 <code>stdio.h</code>.且通常实现为宏)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">getchar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <span class="hljs-comment">// 从 stdin 读取一个字符.通常对应键盘输入</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">putchar</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>; <span class="hljs-comment">// 向 stdout 写入一个字符.通常输出到屏幕</span><br></code></pre></td></tr></table></figure><ul><li><code>getchar</code> 成功时返回读取的字符; 失败 &#x2F; 文件结束返回 <code>EOF</code>(在 <code>stdio.h</code> 中定义)</li><li><code>putchar</code> 成功时返回输出的字符; 失败时返回 <code>EOF</code></li></ul></li><li><p>报告错误信息(函数声明于 <code>stdio.h</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">perror</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;  <span class="hljs-comment">// 向标准错误流 (stderr) 输出错误信息</span><br></code></pre></td></tr></table></figure><ul><li><code>perror</code> 内部会检查 <code>errno</code> 的值.根据 <code>errno</code> 查找对应的错误描述字符串</li><li>错误描述来自 <code>errno</code> 宏(定义在 <code>&lt;errno.h&gt;</code>).表示最近一次错误的错误码</li><li>输出格式为 <code>&quot;自定义字符串: 错误描述\n&quot;</code></li><li>多线程环境中需注意 <code>errno</code> 是线程局部的,每个线程有自己的 <code>errno</code></li></ul></li><li><p><code>printf</code>: 将字符串进行格式化转换,然后进行标准化输出.等价于 <code>fprintf(stdout, ...)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br><span class="hljs-comment">// format: 格式化字符串, 包含普通字符和格式说明符</span><br><span class="hljs-comment">// ...: 可变参数列表, 对应格式字符串中的格式说明符</span><br><span class="hljs-comment">// 返回值: 成功时返回输出的字符数, 失败时返回负值</span><br></code></pre></td></tr></table></figure></li></ol><ul><li><p>格式化字符串结构分为</p><ul><li><p>普通字符: 原样输出</p></li><li><p>转义序列: 如 <code>\n, \t</code></p></li><li><p>格式说明符: 以 <code>%</code> 开头,形式为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">%[flags][width][.precision][length]specifier<br></code></pre></td></tr></table></figure></li></ul></li><li><p>基本格式说明符(若<code>%</code>后的字符不是转换字符,则为未定义行为)</p><table><thead><tr><th>specifier</th><th>参数类型 &amp; 转换结果</th></tr></thead><tbody><tr><td>d, i</td><td>int. 有符号十进制表示</td></tr><tr><td>u</td><td>int. 无符号十进制表示</td></tr><tr><td>o</td><td>unsigned int. 无符号八进制表示(无前导0)</td></tr><tr><td>x, X</td><td>unsigned int. 无符号十六进制表示(无前导0x&#x2F;0X),区分大小写</td></tr><tr><td>f</td><td>double. 形式为: [-]mmm.ddd 的十进制表示</td></tr><tr><td>e, E</td><td>double. 形式为: [-]m.dddddd e&#x2F;E xx 的十进制表示</td></tr><tr><td>g, G</td><td>double. 自动选择科学计数法(%e &#x2F; %E)或 %f</td></tr><tr><td>c</td><td>int. 转换为 unsigned char 类型后的单个字符</td></tr><tr><td>s</td><td>char *. 打印字符串.直到 <code>&#39;\0&#39;</code> 或 达到精度指定的字符数</td></tr><tr><td>p</td><td>void *. 打印指针值</td></tr><tr><td>%</td><td>不进行参数转化.打印 <code>%</code></td></tr></tbody></table></li><li><p>标志(flags 出现顺序不限): 用于修改转换说明</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>-</td><td>左对齐</td></tr><tr><td>+</td><td>强制显示正负号</td></tr><tr><td><kbd>space</kbd></td><td>正数前加空格代替加号</td></tr><tr><td>0</td><td>用0填充而非空格(配合 width 使用)</td></tr><tr><td>#</td><td>%0: 加前导0<br />%x &#x2F; %X: 加前导 0x &#x2F; 0X<br />%f &#x2F; %e &#x2F; %E &#x2F; %g &#x2F; %G: 强制带小数点</td></tr></tbody></table></li><li><p>宽度(width): 最小输出宽度(可以使用 <code>*</code> 来用参数指定)</p></li><li><p>精度(.precision): 不同转换类型含义不同(可以使用 <code>*</code> 来用参数指定)</p><table><thead><tr><th>转换类型</th><th>精度的含义</th></tr></thead><tbody><tr><td>整数</td><td>最小数字位数(不足补0)</td></tr><tr><td>浮点数(<code>e/E/f</code>)</td><td>小数点后的位数</td></tr><tr><td>科学计数法(<code>g/G</code>)</td><td>有效数字位数</td></tr><tr><td>字符串</td><td>最大输出字符数</td></tr></tbody></table></li><li><p>长度修饰符(length): 用于将参数指定为某种类型</p><table><thead><tr><th align="left">修饰符</th><th align="left">适用类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">hh</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">signed &#x2F; unsigned char</td></tr><tr><td align="left">h</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">short</td></tr><tr><td align="left">l</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">long</td></tr><tr><td align="left">ll</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">long long</td></tr><tr><td align="left">L</td><td align="left">%f, %e, %E, %g, %G</td><td align="left">long double</td></tr><tr><td align="left">z</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">size_t</td></tr><tr><td align="left">t</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">ptrdiff_t</td></tr></tbody></table></li></ul><ol start="4"><li><p><code>scanf</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 从标准输入读取输入,根据 format 进行匹配, 匹配到赋给后续的各个参数</span><br><span class="hljs-comment">// 后续的参数必须是指针. 等价于 scanf(stdout, ...)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">scanf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br><span class="hljs-comment">// format: 格式化字符串,指定输入数据的预期格式</span><br><span class="hljs-comment">// ...: 可变参数列表, 对应格式字符串中的格式说明符</span><br><span class="hljs-comment">// 返回实际被转换并赋值的输入项的数目.若到达文件的末尾或在转换输入前出错,则返回 EOF</span><br></code></pre></td></tr></table></figure></li></ol><ul><li><p>格式串字符串结构</p><ul><li><p>空白字符: 空格, 制表符, 换行符</p></li><li><p>非空白字符: 必须与输入精确匹配的字符</p></li><li><p>格式说明符: 以 <code>%</code> 开头,形式为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">%[*][width][length]specifier<br></code></pre></td></tr></table></figure></li></ul></li><li><p>基本格式说明符</p><table><thead><tr><th>specifier</th><th>参数类型 &amp; 输入数据</th></tr></thead><tbody><tr><td>d</td><td>int *. 十进制整型数</td></tr><tr><td>i</td><td>int *. 整数(自动检测进制)</td></tr><tr><td>u</td><td>unsigned int *. 无符号十进制整型数</td></tr><tr><td>o</td><td>unsigned int *. 无符号八进制整型数</td></tr><tr><td>x, X</td><td>unsigned int *. 十六进制整型数</td></tr><tr><td>e &#x2F; f &#x2F; g</td><td>float *. 格式为: \pm(可选), 数字串(可能有小数), 指数字段(可选)</td></tr><tr><td>c</td><td>char *. 字符</td></tr><tr><td>s</td><td>char *. 由非空白符组成的字符串(不包含引号).自动在数组末尾增加 <code>&#39;\0&#39;</code></td></tr><tr><td>p</td><td>void **. 指针地址.无实用价值</td></tr><tr><td>[…]</td><td>char *.与方括号中的字符集. 匹配的输入字符中 最长的非空字符串<br />如 <code>[]...]</code> 表示集合中包含字符<code>]</code>. 会自动在数组末尾增加 <code>&#39;\0&#39;</code></td></tr><tr><td>[^…]</td><td>char *.与方括号中的字符集. <strong>不匹配</strong>的输入字符中 最长的非空字符串<br />如 <code>[^]...]</code> 表示集合中<strong>不包含</strong>字符<code>]</code>. 自动在数组末尾增加 <code>&#39;\0&#39;</code></td></tr><tr><td>%</td><td>表示 <code>%</code>,不进行赋值</td></tr></tbody></table></li><li><p><code>*</code>: 赋值抑制.匹配但不存储输入</p></li><li><p><code>width</code>: 指定最大输入宽度</p></li><li><p><code>length</code>: 用于将参数指定为某种类型</p><table><thead><tr><th align="left">修饰符</th><th align="left">适用类型</th><th align="left">参数类型</th></tr></thead><tbody><tr><td align="left">hh</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">signed &#x2F; unsigned char *</td></tr><tr><td align="left">h</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">short *</td></tr><tr><td align="left">l</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">long *</td></tr><tr><td align="left"></td><td align="left">%f, %e, %g</td><td align="left">double *</td></tr><tr><td align="left">ll</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">long long *</td></tr><tr><td align="left">L</td><td align="left">%f, %e, %g</td><td align="left">long double *</td></tr></tbody></table></li></ul><h3 id="0-4-整型函数"><a href="#0-4-整型函数" class="headerlink" title="0.4 整型函数"></a>0.4 整型函数</h3><ol><li><p>算术(下列整型函数均声明于 <code>&lt;stdlib.h&gt;</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">abs</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>;             <span class="hljs-comment">// 绝对值</span><br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">labs</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">int</span> value)</span>;  <span class="hljs-comment">// abs 的 long int 形式</span><br><span class="hljs-type">div_t</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> numerator, <span class="hljs-type">int</span> denominator)</span>;<br><span class="hljs-type">ldiv_t</span> <span class="hljs-title function_">ldiv</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">int</span> numerator, <span class="hljs-type">long</span> <span class="hljs-type">int</span> denominator)</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>div</code> 函数进行带余整数除法,返回一个 <code>div_t</code> 的结构.包含两个字段:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> quot; <span class="hljs-comment">// 商</span><br><span class="hljs-type">int</span> rem;  <span class="hljs-comment">// 余数</span><br></code></pre></td></tr></table></figure></li><li><p><code>ldiv</code> 函数处理的对象为 <code>long int</code> 类型,而返回 <code>ldiv_t</code> 结构</p></li></ul></li><li><p>随机数</p><ul><li><p>用于产生伪随机数的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">rand</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">srand</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seed)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>rand</code> 返回一个范围在 0~RAND_MAX(至少为32767) 的伪随机数</p></li><li><p>可以用对 <code>rand</code> 返回值取模,然后加上一个偏移量的方式获取一个固定区间的随机数</p></li><li><p><code>srand</code> 函数可以设置随机数种子.根据参数对随机数发生器初始化</p></li><li><p>可以用时间作为随机数产生器的种子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">srand( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) time(<span class="hljs-number">0</span>) );<br></code></pre></td></tr></table></figure></li></ul></li><li><p>字符串转换</p><ul><li><p>字符串转换函数将 字符串转换为数值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">atoi</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>)</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">atol</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>)</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strtol</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">char</span> **unused, <span class="hljs-type">int</span> base)</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strtoul</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">char</span> **unused, <span class="hljs-type">int</span> base)</span>; <br><span class="hljs-type">double</span> <span class="hljs-title function_">atof</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">strtod</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">char</span> **unused)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>atoi,atol</code> 函数进行基数为10的转换</li><li><code>strtol,strtoul</code> 函数允许指定基数,还允许访问字符串的剩余部分</li><li>如果参数 <code>string</code> 中包含了前导空白字符 以及非法缀尾字符,将会被忽略</li><li>参数 <code>base</code> 的取值范围为 2<del>36,此时字母 A</del>Z 分别表示 10~35</li><li>特别的,当 <code>base</code> 的值为0时,表示接受 程序中任何可书写的整型字面值</li></ul></li><li><p><code>strol</code> 函数示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">x = strol(<span class="hljs-string">&quot;   590bear&quot;</span>, next, <span class="hljs-number">12</span>);<br></code></pre></td></tr></table></figure><ul><li>该指令的返回值为 9947,由于 e 在基数为12时非法,转换终止</li><li><code>next</code> 是一个指向指针的指针,指向的内容为: 指向字母 e 的指针</li></ul></li><li><p>如果参数 <code>string</code> 中不包含任何一个合法数值,返回0</p></li><li><p>如果被转换的值无法表示,函数将在 <code>errno</code> 中存储值 <code>ERANGE</code>.并返回下表中的一个值</p><table><thead><tr><th>函数</th><th>返回值</th></tr></thead><tbody><tr><td>strol</td><td>若值过大且为负,返回 <code>LONG_MIN</code>. 若值过大且为正,返回 <code>LONG_MAX</code></td></tr><tr><td>stroul</td><td>若值过大,返回 <code>ULONG_MAX</code></td></tr></tbody></table></li></ul></li></ol><h3 id="0-5-浮点型函数"><a href="#0-5-浮点型函数" class="headerlink" title="0.5 浮点型函数"></a>0.5 浮点型函数</h3><ol><li><p>下列函数声明于 <code>&lt;math.h&gt;</code>.绝大多数的参数和返回值类型为 <code>double</code></p><ul><li>若函数的参数不在定义域内,出现<code>定义域错误</code>.函数返回一个由编译器提供的错误值,并置 <code>errno</code> 值为 <code>EDOM</code></li><li>若函数的结果值过大&#x2F;小,超出 <code>double</code> 的范围,出现返回错误.<ul><li>若过大,函数返回 <code>HUGE_VAL</code>(在<code>math.h</code>中定义)</li><li>若过小,函数返回 0,事实上也是范围错误</li></ul></li></ul></li><li><p>三角函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 参数为弧度制的角度值 */</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">sin</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">cos</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">tan</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><br><span class="hljs-comment">/* 返回值为弧度制的角度值 */</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">asin</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">acos</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">atan</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span>;<br><br><span class="hljs-comment">/* 返回值为 y/x 的反正切值,利用参数的符号决定象限 */</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">atan2</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br></code></pre></td></tr></table></figure></li><li><p>双曲函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 参数为弧度制的角度值 */</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">sinh</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">cosh</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">tanh</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br></code></pre></td></tr></table></figure></li><li><p>对数和指数函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">exp</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">log</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">log10</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>exp</code> 返回 $e^x$</li><li><code>log</code> 返回 $\mathrm{ln}x$</li><li><code>log10</code> 返回 $\mathrm{log}_{10} x$</li><li>利用换底公式 $\mathrm{log}_b x&#x3D;\frac{\mathrm{ln} x}{\mathrm{ln} b}$ 可计算任意底数的对数</li></ul></li><li><p>浮点表示形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">frexp</span><span class="hljs-params">(<span class="hljs-type">double</span> value, <span class="hljs-type">int</span> *exponent)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">ldexp</span><span class="hljs-params">(<span class="hljs-type">double</span> fraction, <span class="hljs-type">int</span> exponent)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">modf</span><span class="hljs-params">(<span class="hljs-type">double</span> value, <span class="hljs-type">double</span> *ipart)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>frexp</code> 函数返回值 <code>fraction</code>,取值范围为 [0.5, 1).满足 $\mathrm{fraction}\cdot2^\mathrm{exponent} &#x3D; \mathrm{value}$</li><li><code>ldexp</code> 函数相对地返回 <code>value</code>: $\mathrm{value}&#x3D;\mathrm{fraction}\cdot2^\mathrm{exponent}$</li><li><code>modf</code> 函数将浮点值分成整数和小数两部分,它们拥有与原值相同的符号</li></ul></li><li><p>幂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">pow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>pow</code> 函数返回 $x^y$. 计算时可能会用到对数</li><li><code>sqrt</code> 函数返回 $\sqrt{x}$</li></ul></li><li><p>底数, 顶数, 绝对值, 余数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">floor</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">ceil</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">fabs</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">fmod</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>floor</code> 函数返回不大于参数的最大整数值,即向下取整</li><li><code>ceil</code> 函数返回不小于参数的最小整数值,即向上取整</li><li><code>fabs</code> 函数返回参数的绝对值</li><li><code>fmod</code> 函数返回 <code>x / y</code> 的余数,符号与 <code>x</code> 相同</li></ul></li></ol><h3 id="0-6-日期时间"><a href="#0-6-日期时间" class="headerlink" title="0.6 日期时间"></a>0.6 日期时间</h3><ol><li><p>处理器时间(下列时间&#x2F;日期函数均声明于 <code>&lt;time.h&gt;</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">clock_t</span> <span class="hljs-title function_">clock</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>clock</code> 函数返回程序开始起处理去所消耗的时间,可能是个近似值</li><li>若需要精确时间,可在<code>main</code>函数开始调用一次<code>clock</code>,随后的调用进行减法来获取时间</li><li>若时间值过大,或机器无法获得时间,返回 -1</li><li><code>clock</code> 函数返回的数字由编译器定义,一般为处理器时钟滴答的次数</li><li>若需要将返回值换算成秒,应将其除以 <code>CLOCKS_PER_SEC</code></li></ul></li><li><p>当天时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">time_t</span> <span class="hljs-title function_">time</span><span class="hljs-params">(<span class="hljs-type">time_t</span> *returned_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>若参数为非NULL指针,则时间值将通过这个指针存储</li><li>若时间值太大,或机器无法提供日期和时间,返回 -1</li><li>标准并未规定时间的编码方式,因此不应使用字面值常量</li></ul></li><li><p>日期和时间的转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">ctime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> <span class="hljs-type">const</span> *time_value)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">difftime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> time1, <span class="hljs-type">time_t</span> time2)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>ctime</code> 函数的参数为 指向 <code>time_t</code> 的指针,返回一个指向字符串的指针<ul><li>返回的字符串格式为: <code>Sun Jul 4 04:02:48 1976\n\0</code></li><li>字符串内部的空格是固定的</li></ul></li><li><code>difftime</code> 函数计算 <code>time2 - time1</code> 的值,并将结果转换为秒</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> tm *<span class="hljs-title function_">gmtime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> <span class="hljs-type">const</span> *time_value)</span>;<br><span class="hljs-keyword">struct</span> tm *<span class="hljs-title function_">localtime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> <span class="hljs-type">const</span> *time_value)</span>;<br></code></pre></td></tr></table></figure></li><li><p>将一个 <code>time_t</code> 的值转换为一个 <code>tm</code> 结构,可以方便地访问各组成部分</p><ul><li><p><code>gmtime</code> 函数转换为世界协调时间</p></li><li><p><code>localtime</code> 函数转换为当地时间</p></li><li><p><code>tm</code> 结构的字段</p><table><thead><tr><th>类型 &amp; 名称</th><th>范围</th><th>含义</th></tr></thead><tbody><tr><td><code>int tm_sec</code></td><td>0~61</td><td>分之后的秒数</td></tr><tr><td><code>int tm_min</code></td><td>0~59</td><td>小时后的分数</td></tr><tr><td><code>int tm_hour</code></td><td>0~23</td><td>午夜后的小时数</td></tr><tr><td><code>int tm_mday</code></td><td>1~31</td><td>当月的日期</td></tr><tr><td><code>int tm_mon</code></td><td>0~11</td><td>1月后的月数</td></tr><tr><td><code>int tm_year</code></td><td>0~?</td><td>1900年后的年数</td></tr><tr><td><code>int tm_wday</code></td><td>0~6</td><td>星期天之后的天数</td></tr><tr><td><code>int tm_yday</code></td><td>0~365</td><td>1月1日后的天数</td></tr><tr><td><code>int tm_isdat</code></td><td></td><td>夏令时标志</td></tr></tbody></table></li></ul></li><li><p>将 <code>tm</code> 结构转换为字符串格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">asctime</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tm <span class="hljs-type">const</span> *tm_ptr)</span>;<br><span class="hljs-type">size_t</span> <span class="hljs-title function_">strftime</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">size_t</span> maxsize, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *format, <span class="hljs-keyword">struct</span> tm <span class="hljs-type">const</span> *tm_str)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>asctime</code> 转换为字符串的格式与 <code>ctime</code> 一致</p><ul><li><p><code>strftime</code> 格式化的非常灵活</p></li><li><p>若转换的结果字符串长度小于 <code>maxsize</code>,则该字符串将被复制到 <code>string</code> 中</p></li><li><p><code>strftime</code> 的返回值为字符串的长度.若返回的是 -1,则 <code>string</code> 内容未定义</p></li><li><p><code>strftime</code> 格式代码</p><table><thead><tr><th>代码</th><th>被 … 替代</th></tr></thead><tbody><tr><td>%%</td><td><code>%</code></td></tr><tr><td>%a(%A)</td><td>星期中的某天,用当地的简写(全写)表示</td></tr><tr><td>%b(%B)</td><td>月份,用当地的简写(全写)表示</td></tr><tr><td>%c</td><td>日期和时间,使用 <code>%x %X</code></td></tr><tr><td>%d</td><td>月份中的某天(01~31)</td></tr><tr><td>%H</td><td>小时.24小时制(00~23)</td></tr><tr><td>%I</td><td>小时.12小时制(00~12)</td></tr><tr><td>%J</td><td>一年中的某天(001~366)</td></tr><tr><td>%m</td><td>月份(01~12)</td></tr><tr><td>%M</td><td>分钟(00~59)</td></tr><tr><td>%P</td><td>AM &#x2F; PM</td></tr><tr><td>%S</td><td>秒(00~61)</td></tr><tr><td>%U(%W)</td><td>一年中的第几个星期(00~53),以星期日&#x2F;星期一为第一天</td></tr><tr><td>%w</td><td>一星期的第几天,星期日为 0</td></tr><tr><td>%x(%X)</td><td>日期&#x2F;时间,本地格式</td></tr><tr><td>%y(%Y)</td><td>当前世纪的年份(00~99)&#x2F;年份的全写(如2023)</td></tr><tr><td>%z</td><td>时区的简写,无法判断时为空</td></tr></tbody></table></li></ul></li><li><p>将 <code>tm</code> 结构转化为 <code>time_t</code> 值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">time_t</span> <span class="hljs-title function_">mktime</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tm *tm_ptr)</span>;<br></code></pre></td></tr></table></figure></li></ol><h3 id="0-7-排序查找"><a href="#0-7-排序查找" class="headerlink" title="0.7 排序查找"></a>0.7 排序查找</h3><ol><li><p>排序 <code>&lt;stdlib.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">qsort</span><span class="hljs-params">(<span class="hljs-type">void</span> *base, <span class="hljs-type">size_t</span> n_elements, <span class="hljs-type">size_t</span> el_size, \</span><br><span class="hljs-params">           <span class="hljs-type">int</span> (*compare)(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *) )</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>qsort</code> 函数是类型无关的,对任意数据类型的,固定长度的数组进行升序排序</p></li><li><p><code>base</code> 参数: 指向待排序的数组</p></li><li><p><code>n_elements</code> 参数: 指定数组中的元素数目</p></li><li><p><code>el_size</code> 参数: 指定每个元素的长度(单位为 字符)</p></li><li><p><code>compare</code> 是一个函数指针,对需要排序的元素类型进行比较.在排序时,调用该函数进行大小比较</p></li><li><p>比较函数接受2个参数,指向待比较的值.返回一个整数,表示参数的大小关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">// 定义一个结构,根据 key 排序</span><br> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>     <span class="hljs-type">char</span> key[<span class="hljs-number">10</span>];<br>     <span class="hljs-type">int</span> otherData;<br> &#125; Record;<br><br><span class="hljs-comment">// 比较函数,直接返回 strcmp 的计算结果</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">recordCompare</span><span class="hljs-params">(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *a, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *b)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>( (Record *)a-&gt;key, (Record *)b-&gt;key );<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Record <span class="hljs-built_in">array</span>[<span class="hljs-number">50</span>];<br>    qsort(<span class="hljs-built_in">array</span>, <span class="hljs-number">50</span>, <span class="hljs-keyword">sizeof</span>(Record), recordCompare);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>二分查找 <code>&lt;stdlib.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">bsearch</span><span class="hljs-params">(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *key, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *base, <span class="hljs-type">size_t</span> n_elements,\</span><br><span class="hljs-params">             <span class="hljs-type">size_t</span> el_size, <span class="hljs-type">int</span> (*compare)(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *) )</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>key</code> 参数: 待查找的值,必须和目标数组元素的类型相同</p></li><li><p><code>base</code> 参数: 指向目标数组</p></li><li><p><code>n_elements</code> 参数: 数组的元素数目</p></li><li><p><code>el_size</code> 参数: 每个元素的长度(以字符为单位)</p></li><li><p><code>compare</code> 参数: 指向比较参数.与 <code>qsort</code> 函数相同</p></li><li><p><code>bsearch</code> 函数: 返回一个指针,指向查找到的数组元素.若不存在,返回 <code>NULL</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">// 定义一个结构,根据 key 排序</span><br> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>     <span class="hljs-type">char</span> key[<span class="hljs-number">10</span>];<br>     <span class="hljs-type">int</span> otherData;<br> &#125; Record;<br><br><span class="hljs-comment">// 比较函数,直接返回 strcmp 的计算结果</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">recordCompare</span><span class="hljs-params">(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *a, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *b)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>( (Record *)a-&gt;key, (Record *)b-&gt;key );<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Record <span class="hljs-built_in">array</span>[<span class="hljs-number">50</span>];<br>    Record key; <span class="hljs-comment">// 待查找的对象</span><br>    Record *ans;<br>    <br>    <span class="hljs-built_in">strcpy</span>(key.key, <span class="hljs-string">&quot;value&quot;</span>); <span class="hljs-comment">// 比较函数中用到的 key 字段必须填充</span><br>    qsort(<span class="hljs-built_in">array</span>, <span class="hljs-number">50</span>, <span class="hljs-keyword">sizeof</span>(Record), recordCompare); <span class="hljs-comment">// 注意: 二分查找需要先排序</span><br>    ans = bsearch(&amp;key, <span class="hljs-built_in">array</span>, <span class="hljs-number">50</span>, <span class="hljs-keyword">sizeof</span>(Record, recordCompare));<br>    <span class="hljs-comment">/* 现在 ans 指向查找到的目标 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-8-信号"><a href="#0-8-信号" class="headerlink" title="0.8 信号"></a>0.8 信号</h3><ol><li><p>信号</p><ul><li>程序中绝大部分事件由其本身引发.但对于外部中断等事件,程序需要预备对这类时间作出反应</li><li><strong>信号表示一种事件,可能会异步发生.程序可设置一个信号处理函数,当信号发生,就调用它</strong></li><li>下面的函数位于 <code>&lt;signal.h&gt;</code></li></ul></li><li><p>信号名</p><table><thead><tr><th>信号</th><th>说明</th></tr></thead><tbody><tr><td>SIGABRT</td><td>程序请求异常终止</td></tr><tr><td>SIGFPE</td><td>发生一个算术错误</td></tr><tr><td>SIGILL</td><td>检测到非法指令</td></tr><tr><td>SIGSEGV</td><td>检测到对内存的非法访问</td></tr><tr><td>SIGINT</td><td>收到一个交互性注意信号</td></tr><tr><td>SIGTERM</td><td>收到一个终止程序的请求</td></tr></tbody></table><ul><li><code>SIGABRT</code> 是由 <code>abort</code> 函数引发的信号,用于终止程序</li><li><code>SIGILL</code> 提示 CPU 试图执行一条非法指令</li><li><code>SIGINT</code> 和 <code>SIGTERM</code> 是异步的,由程序外部产生</li></ul></li><li><p>处理信号</p><ul><li><p>显式的引发一个信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">raise</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span>;<br></code></pre></td></tr></table></figure></li><li><p>当一个信号发生时,程序可以有3种反应: 缺省方式(终止程序); 将其忽略; 设置信号处理函数对其反应</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*signal(<span class="hljs-type">int</span> sig, <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">int</span>))) (<span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><ul><li><code>signal</code> 是一个函数.返回一个函数指针,指向一个参数为 <code>int</code> 的无返回值函数</li><li><code>sig</code> 参数是<code>信号名</code>中列举的信号之一</li><li><code>handler</code> 参数是希望为该信号设置的处理函数,是一个函数指针,指向一个参数为 <code>int</code> 的无返回值函数</li><li>当信号发生时,信号的代码作为参数传递给 <code>handler</code> 指向的信号处理函数</li><li><code>signal</code> 返回一个指向该信号以前的处理函数的指针</li><li><code>signal.h</code> 定义了宏 <code>SIG_DFL, SIG_IGN</code>,可作为 <code>handler</code> 参数的值.分别表示缺省处理&#x2F;忽略信号</li></ul></li></ul></li><li><p>信号处理函数</p><ul><li>当一个已设置的信号处理函数的信号发生时,系统恢复对该信号的缺省行为(防止处理函数内部再次发生该信号而引起无限循环),然后,信号处理函数被调用,信号代码作为参数传入</li><li>信号处理函数可能执行的工作非常有限.对于异步信号,不应调用除 <code>signal.h</code> 以外的库函数</li><li>信号处理函数仅能向一个类型为 <code>volatile sig_atomic_t</code> 的静态变量赋值,其他静态数据可能无法访问</li><li>从一个信号处理函数返回,将导致执行流从信号发生的地点恢复执行(除了<code>SIGFPE</code>,无法完成计算)</li><li>若希望将来再次捕获同类型信号,需要在处理函数返回前,调用 <code>signal</code> 函数进行设置</li></ul></li></ol><h3 id="0-9-非本地跳转"><a href="#0-9-非本地跳转" class="headerlink" title="0.9 非本地跳转"></a>0.9 非本地跳转</h3><ol><li><p>类似于 <code>goto</code> 语句,但作用域并非局限于函数作用域</p></li><li><p>需要包含头文件 <code>&lt;setjump.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">setjump</span><span class="hljs-params">(jmp_buf state)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">longjump</span><span class="hljs-params">(jmp_buf state, <span class="hljs-type">int</span> value)</span>;<br></code></pre></td></tr></table></figure><ul><li>调用方式: 声明一个 <code>jmp_buf</code> 变量,使用 <code>setjump</code> 函数进行初始化,返回值为0</li><li><code>setjump</code> 会将程序信息保存到缓冲区.调用 <code>sejump</code> 时所处的函数成为 <code>顶层函数</code></li><li>在<code>顶层函数</code>或其他被它调用的函数处 调用 <code>longjump</code> 时,被保存的程序信息将会恢复.跳回 <code>顶层函数</code></li><li>当 <code>setjump</code> 函数第一次被调用返回0.当 <code>setjump</code> 作为 <code>longjump</code> 的执行结果时,返回 <code>value</code></li></ul></li></ol><h3 id="0-10-执行环境"><a href="#0-10-执行环境" class="headerlink" title="0.10 执行环境"></a>0.10 执行环境</h3><ol><li><p>终止执行 <code>&lt;stdlib.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">atexit</span><span class="hljs-params">(<span class="hljs-type">void</span> (func)(<span class="hljs-type">void</span>))</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>abort</code> 函数用于不正常地终止一个正在执行的程序.它将引发 <code>SIGABRT</code>,可为它设置信号处理函数</li><li><code>atexit</code> 函数可将一些函数注册为 <code>退出函数</code>.当程序要正常终止时,退出函数将被调用</li><li><strong><code>exit</code> 函数用于正常终止程序.当它被调用时,所有被 <code>atexit</code> 注册为退出函数按被注册顺序逆序依次调用.然后所有用于流的缓冲区被刷新,所有打开的文件被关闭,用<code>tempfile</code>函数创建的文件被删除.退出状态返回给宿主环境.程序停止执行</strong></li><li><code>exit</code> 函数的<code>status</code> 参数将会返回给操作系统</li><li><code>exit</code> 函数没有返回值: 当 <code>exit</code> 结束时,程序已经消失,它已无处可返</li></ul></li><li><p><strong>断言: 声明某事应该为真</strong> <code>&lt;assert.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">assert</span><span class="hljs-params">(<span class="hljs-type">int</span> expression)</span>; <span class="hljs-comment">// 实际上这是不是函数,而是一个宏</span><br><span class="hljs-comment">/* expression 若为假,向标准错误打印一条诊断信息并终止程序.若为真,程序继续执行 */</span><br></code></pre></td></tr></table></figure></li><li><p>断言一般用于程序调试.当程序被完整地测试完毕,可在包含头文件 <code>aseert.h</code> 之前增加:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDEBUG</span><br><span class="hljs-comment">/* 定义了 NDEBUG 之后,预处理将丢弃所有的断言,而不必在源文件中实际将其删除 */</span><br></code></pre></td></tr></table></figure></li><li><p>执行系统命令 <code>&lt;stdlib.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">system</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *command)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>system</code> 函数将字符串参数传递给宿主操作系统</li><li><code>system</code> 函数可用 <code>NULL</code> 参数进行调用,用于询问命令处理器是否存在.若存在,返回一个非零值</li></ul></li></ol><h2 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1 内存管理"></a>1 内存管理</h2><h3 id="1-1-内存布局"><a href="#1-1-内存布局" class="headerlink" title="1.1 内存布局"></a>1.1 内存布局</h3><ol><li><p>C 程序在运行时,内存分为以下几个主要区域(Segments)</p><table><thead><tr><th align="left"><strong>内存区域</strong></th><th align="left"><strong>存储内容</strong></th><th align="left"><strong>特点</strong></th></tr></thead><tbody><tr><td align="left"><strong>代码段(Text)</strong></td><td align="left">存放编译后的机器指令(二进制代码)</td><td align="left">只读.程序运行时不可修改</td></tr><tr><td align="left"><strong>数据段(Data)</strong></td><td align="left"><strong>已初始化全局变量 &amp; 静态变量</strong></td><td align="left">程序启动时分配.生命周期直到程序结束</td></tr><tr><td align="left"><strong>BSS 段(BSS)</strong></td><td align="left"><strong>未初始化全局变量 &amp; 静态变量</strong></td><td align="left">程序启动时清零.生命周期直到程序结束</td></tr><tr><td align="left"><strong>堆(Heap)</strong></td><td align="left">动态分配(<code>malloc, calloc, realloc, free</code>)</td><td align="left">手动管理.增长方向从低地址向高地址</td></tr><tr><td align="left"><strong>栈(Stack)</strong></td><td align="left">局部变量,函数参数,返回地址等</td><td align="left">自动管理(函数调用时入栈,返回时出栈).<br />增长方向从高地址向低地址,大小有限</td></tr></tbody></table></li><li><p>内存布局图示(Linux 64bit)</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss">高地址<br>┌─────────────────────┐<br>│        Stack        │ ← 由高地址向低地址增长<br>├─────────────────────┤<br>│          ↓          │<br>│          ↑          │<br>├─────────────────────┤<br>│        Heap         │ ← 由低地址向高地址增长<br>├─────────────────────┤<br>│        BSS          │ (未初始化全局变量)<br>├─────────────────────┤<br>│        Data         │ (已初始化全局变量)<br>├─────────────────────┤<br>│        <span class="hljs-selector-tag">Text</span>         │ (程序指令)<br>低地址<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-2-内存分配"><a href="#1-2-内存分配" class="headerlink" title="1.2  内存分配"></a>1.2  内存分配</h3><ol><li><p>需要使用到 <code>&lt;stdlib.h&gt;</code> 头文件中的库函数</p></li><li><p><code>malloc</code>: 向系统申请分配 <code>size</code> 个字节的内存空间,返回一个指向该空间的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-comment">// 调用成功返回一个申请的内存空间指针,类型为 void *</span><br><span class="hljs-comment">// 调用失败返回 NULL.若设置 size = 0,同样返回 NULL</span><br></code></pre></td></tr></table></figure></li><li><p><code>calloc</code>: 在内存中动态的申请 <code>nmemb</code> 个长度为 <code>size</code> 的连续内存空间,并全部初始化为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> nmemb, <span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-comment">// 调用成功返回一个申请的内存空间指针,类型为 void *</span><br><span class="hljs-comment">// 调用失败返回 NULL.若设置 size = 0,同样返回 NULL</span><br></code></pre></td></tr></table></figure></li><li><p><code>realloc</code>: 重新分配内存空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><ul><li>可以增大或减小已分配内存的大小</li><li>其实现通常为新分配内存,然后复制内容,最后释放原内存.注意新内存仍不会初始化</li><li><code>ptr</code> 指向先前分配的内存空间.当参数 <code>ptr==NULL</code> 时,等同于调用 <code>malloc</code></li></ul></li><li><p><code>free</code>: 释放动态空间内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>free</code> 释放的内存空间必须是由 <code>malloc, calloc, realloc</code> 函数申请.否则会导致未定义行为</li><li>若参数 <code>ptr==NULL</code>,则不执行任何操作.多次对同一指针调用 <code>free</code>,将导致未定义行为</li><li><code>free</code> 函数不改变参数 <code>ptr</code> 的值.为避免悬空指针,释放空间后需将指针的值置为 <code>NULL</code></li></ul></li></ol><h3 id="1-3-内存管理"><a href="#1-3-内存管理" class="headerlink" title="1.3 内存管理"></a>1.3 内存管理</h3><ol><li><p>内存泄漏</p><ul><li>C 语言不具备垃圾回收机制,需要手动释放内存.<code>malloc</code> 和 <code>free</code> 应该成对编写</li><li><code>malloc</code> 可以申请任意尺寸的内存空间.得到的空间是连续的,经常使用数组索引</li></ul></li><li><p>内存池</p><ul><li>频繁使用 <code>malloc</code> 和 <code>free</code> 手动分配和释放内存很容易产生大量的内存碎片</li><li>调用 <code>malloc</code> 函数向操作系统申请堆内存经历了从应用层切入系统内核层的过程.造成时间浪费</li><li>内存池: 让程序额外维护一个缓存区域.当一块内存将要释放时,不调用 <code>free</code>,而将其放入内存池,下次需要分配内存空间时直接从内存池中获取</li></ul></li><li><p>内存池的维护方式</p><ul><li>当用户申请一个内存块时,先在内存池中查找是否有合适的内存块<ul><li>若有: 则直接从内存池中取出使用</li><li>若无: 调用 <code>malloc</code> 函数申请</li></ul></li><li>当用户释放一个内存块时,先检查内存池是否已满<ul><li>不满: 则将指向内存块的指针存放到内存池</li><li>已满: 调用 <code>free</code> 函数释放</li></ul></li></ul></li><li><p>内存池实现思路: 使用单链表维护一个简单的内存池</p><ul><li>将没用到的内存空间地址用单链表记录</li><li>需要使用时从单链表获取</li></ul></li></ol><h2 id="2-文件-IO"><a href="#2-文件-IO" class="headerlink" title="2 文件 IO"></a>2 文件 IO</h2><h3 id="2-1-打开和关闭文件"><a href="#2-1-打开和关闭文件" class="headerlink" title="2.1 打开和关闭文件"></a>2.1 打开和关闭文件</h3><ol><li><p><code>fopen</code>: 打开一个文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *<span class="hljs-title function_">fopen</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode )</span>;<br></code></pre></td></tr></table></figure><ul><li><p>调用成功返回一个指向 <code>FILE</code> 结构的文件指针.通过该指针对文件进行操作.失败返回 <code>NULL</code></p></li><li><p>打开模式</p><p>| 模式 | 说明                                                         |</p></li></ul></li></ol><p>  | —- | ———————————————————— |<br>     | “r”  | 只读模式打开;  从文件头读取;  该文本文件必须存在             |<br>     | “w”  | 只写模式打开;  从文件头写入;  文本不存在时则先创建;  重新写入内容会覆盖所有内容 |<br>     | “a”  | 追加模式打开;  从文件末追加;  文本不存在时则先创建           |<br>     | “r+” | 读写模式打开;  从文件头读写;  该文本文件必须存在; 只覆盖重写入内容,原有内容保留 |<br>     | “w+” | 读写模式打开;  从文件头读写;  文本不存在时则先创建; 重新写入内容会覆盖所有内容 |<br>     | “a+” | 读和追加模式打开;  读从头开始,写从末尾追加;  文本不存在时则先创建 |<br>     | b    | 可与以上6种模式结合(如 “rb, “r+b”); 含义相同,但操作对象为二进制文件 |</p><ol start="2"><li><p><code>fclose</code> 函数: 关闭一个文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fclose</span><span class="hljs-params">( FILE *fp )</span>;<br><span class="hljs-comment">/* fp: 使用 fopen 获取的文件指针</span><br><span class="hljs-comment"> * 调用成功返回0,失败返回 EOF</span><br><span class="hljs-comment"> * 调用 fclose 后系统才会将缓冲区的数据写入文件,并释放该文件的相关资源*/</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-顺序读写文件"><a href="#2-2-顺序读写文件" class="headerlink" title="2.2 顺序读写文件"></a>2.2 顺序读写文件</h3><ol><li><p>读取单个字符(下列函数均声明于 <code>&lt;stdio.h&gt;</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fgetc, getc: 从文件流中读取下一个字符,并推进文件的位置指示器 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fgetc</span><span class="hljs-params">(FILE *stream)</span>;  <span class="hljs-comment">// 函数原型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getc</span><span class="hljs-params">(FILE *stream)</span>;   <span class="hljs-comment">// 通常实现为宏</span><br></code></pre></td></tr></table></figure></li><li><p>写入单个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fputc, putc 函数: 向文件流写入单个字符 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *stream)</span>;  <span class="hljs-comment">// 函数原型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *stream)</span>;   <span class="hljs-comment">// 通常实现为宏</span><br><span class="hljs-comment">/* 返回值: 遇到错误或文件结束时返回 EOF.否则返回已写入的字符本身 */</span><br></code></pre></td></tr></table></figure></li><li><p>读取字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fgets 函数: 从指定的文件中读取字符串 */</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> size, FILE *stream)</span>;<br><span class="hljs-comment">/* s: 指向存放读取得到字符串的位置</span><br><span class="hljs-comment"> * size: 指定读取的字符数(包括自动添加的 &#x27;\0&#x27;).想读取10个字符,应令 size = 11</span><br><span class="hljs-comment"> * stream: 指定一个待操作的数据流</span><br><span class="hljs-comment"> * 返回值: 调用成功,返回 s 指向的地址.若发生错误,返回 NULL</span><br><span class="hljs-comment"> * 当遇到换行符 &#x27;\n&#x27; 就会停止本次字符串的读取</span><br><span class="hljs-comment"> * 注意 gets 函数不安全,已被 C99 弃用并从 C11 除名 */</span><br></code></pre></td></tr></table></figure></li><li><p>写入字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fputs 函数: 将字符串写入到指定的文件中,结尾的 &#x27;\0&#x27; 不会被写入 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, FILE *stream)</span>;<br><br><span class="hljs-comment">/* puts 函数: 将字符串写入 stdout 并自动追加换行符.方便打印消息 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">puts</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;<br></code></pre></td></tr></table></figure></li><li><p>格式化读写文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fscanf 函数: f 表示 file,对文件进行读取 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fscanf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br><br><span class="hljs-comment">/* fprintf 函数: f 表示 file,对文件进行写入 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br></code></pre></td></tr></table></figure></li><li><p>二进制读写文件</p><ul><li><code>fopen</code> 函数可以指定文件的打开模式(文本, 二进制).但后续对文件的操作并不一定是对应的形式</li><li>无论以哪种模式打开文件,都不能决定写入数据的形式.它们只是影响换行符的表现形式.</li><li>真正决定数据写入模式的是 相关的文件读写函数</li></ul></li><li><p><code>fread</code> 函数: 从指定文件中读取指定尺寸的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">fread</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span>;<br><span class="hljs-comment">/* ptr:     指向存放数据的内存块地址</span><br><span class="hljs-comment"> * size:    待读取的每个元素的尺寸</span><br><span class="hljs-comment"> * nmemb:   指定待读取的元素个数</span><br><span class="hljs-comment"> * stream:  指向一个待读取的文件流</span><br><span class="hljs-comment"> * 返回值:  调用成功返回实际读取到的元素个数,即 nmemb</span><br><span class="hljs-comment"> * 如果返回值小于 nmemb,说明读取到文件末尾或发生错误 */</span><br></code></pre></td></tr></table></figure></li><li><p><code>fwrite</code> 函数: 将指定数据写入到指定文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">fwrite</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span>;<br><span class="hljs-comment">/* ptr:    指向存放数据的内存块地址</span><br><span class="hljs-comment"> * size:   待写入的每个元素的尺寸</span><br><span class="hljs-comment"> * nmemb:  指定待写入的元素个数</span><br><span class="hljs-comment"> * stream: 指向一个待写入的文件流 */</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-随机读写文件"><a href="#2-3-随机读写文件" class="headerlink" title="2.3 随机读写文件"></a>2.3 随机读写文件</h3><ol><li><p>系统为每个打开的文件设置了一个位置指示器,用于表示当前的读写位置</p></li><li><p><code>ftell</code> 函数: 返回当前的读写位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">ftell</span><span class="hljs-params">(FILE *stream)</span>;<br><span class="hljs-comment">/* stream: 指定待操作的文件流</span><br><span class="hljs-comment"> * 返回值: 指定文件的当前读写位置</span><br><span class="hljs-comment"> * 如果将文件看作一个数组,那么 ftell 的返回值就是&quot;数组&quot;的下标 */</span><br></code></pre></td></tr></table></figure></li><li><p><code>fseek</code> 函数: 设置文件位置指示器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">long</span> <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> whence)</span>;<br><span class="hljs-comment">/* stream: 指定待操作的文件流</span><br><span class="hljs-comment"> * offset: 指定偏移的字节数量</span><br><span class="hljs-comment"> * whence: 指定开始偏移的位置 */</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>whence 的值</th><th>说明</th></tr></thead><tbody><tr><td>SEEK_SET</td><td>文件开头</td></tr><tr><td>SEEK_CUR</td><td>当前位置</td></tr><tr><td>SEEK_END</td><td>文件末尾</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">fseek(fp, <span class="hljs-number">100</span>, SEEK_SET); <span class="hljs-comment">// 定位到文件的第100字节位置</span><br>fseek(fp, <span class="hljs-number">-5</span>, SEEK_END);  <span class="hljs-comment">// 定位到文件的倒数第5个字节位置</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>fseek</code> 需要考虑可移植性</p><ul><li>不同操作系统对换行符的处理不同,导致定位会出现误差</li><li>对于二进制模式打开的文件, <code>fseek</code> 在某些操作系统中可能不支持 SEEK_END</li><li>对于文本模式打开的文件, <code>whence</code> 参数只有取 SEEK_SET 才有意义.传递给 offset 的参数值要么为 0,要么是上一次对同一文件调用 <code>ftell</code> 函数获得的返回值</li></ul></li></ol><h3 id="2-4-标准流"><a href="#2-4-标准流" class="headerlink" title="2.4 标准流"></a>2.4 标准流</h3><ol><li><p>标准 输入 &#x2F; 输出 &#x2F; 错误输出</p><ul><li><p>当一个程序被执行时, C 语言自动为其打开3个面向终端的文件流(在 <code>&lt;stdio.h&gt;</code> 中声明)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stdin</span>;   <span class="hljs-comment">// 标准输入(standard input)</span><br><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stdout</span>;  <span class="hljs-comment">// 标准输出(standard output)</span><br><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stderr</span>;  <span class="hljs-comment">// 标准错误输出(standard error output)</span><br></code></pre></td></tr></table></figure></li><li><p>C 语言对应提供3种文件指针: <code>stdin, stdout, stderr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 若打开文件失败,则输出 &quot;打开文件失败\n&quot;,并退出 */</span><br>FILE *fp;<br><span class="hljs-keyword">if</span>((fp = open(<span class="hljs-string">&quot;nonexistent.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>)) == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;打开文件失败\n&quot;</span>, <span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT FALLURE);<br>&#125;<br>fclose(fp);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>错误处理</p><ul><li><p>每个流对象内部都有2个指示器</p><ul><li><p><strong>文件结束指示器</strong>: 遇到文件末尾时被设置</p></li><li><p><strong>错误指示器</strong>: 当读写文件出错时被设置</p></li><li><p>使用 <code>feof, ferror</code> 函数检查这两个指示器是否被设置(置1)</p></li><li><p>使用 <code>clearerr</code> 函数可以人为清除文件末尾指示器和错误指示器的状态</p></li><li><p><code>ferror</code> 函数只能检测是否出错,并不能提供出现错误的原因</p></li><li><p>大多数系统函数在出错时会将错误原因记录在 <code>errno</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开文件失败: %d\n&quot;</span>, errno);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>各种错误原因都有对应的错误码记录在 <code>errno</code> 中,但仅打印 <code>errno</code> 的值很不直观</p></li><li><p>C 语言将各种错误码对应信息打包在 <code>perror</code> 函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">perror</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;<br><span class="hljs-comment">/* s: 指定在错误信息前输出的自定义内容.然后自动添加一个冒号 */</span><br></code></pre></td></tr></table></figure></li><li><p>如果只想要系统返回错误信息的本体.可使用 <code>stderror</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> errnum)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>errnum</code>: 指定的 <code>errno</code> 值</li><li>返回值: 错误码对应的错误信息</li></ul></li></ul></li></ol><h3 id="2-5-IO-缓冲区"><a href="#2-5-IO-缓冲区" class="headerlink" title="2.5 IO 缓冲区"></a>2.5 IO 缓冲区</h3><ol><li><p>对于写入操作,程序会先将数据写入缓冲区,直到缓冲区被写满或文件关闭时才一次性写入设备中</p></li><li><p>对于读取操作,如果数据已经在缓冲区中,则立即返回给程序.否则,系统会将一大块数据从设备读入缓冲区</p></li><li><p>如果需要立即将数据写入设备中,可使用 <code>fflush</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fflush</span><span class="hljs-params">(FILE *stream)</span>;<br></code></pre></td></tr></table></figure></li><li><p>标准 IO 提供三种类型的缓冲模式</p><ul><li>按块缓存(全缓存): 在缓冲区填满后才进行实际的设备读写</li><li>按行缓存: 接受到换行符之前,数据缓存在缓冲区</li><li>不缓存: 允许直接读写设备上的数据</li></ul></li><li><p>可以通过 <code>setvbuf</code> 函数自定义缓存的模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">setvbuf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> mode, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>stream</code>: 待操作的文件流</p></li><li><p><code>buf</code>: 指定一个用户分配的缓冲区.设置为 <code>NULL</code> 时,由函数自动分配</p></li><li><p><code>mode</code>: 缓存模式</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>_IOFBF</td><td>按块缓存</td></tr><tr><td>_IOLBF</td><td>按行缓存</td></tr><tr><td>_IONBF</td><td>不缓存</td></tr></tbody></table></li><li><p><code>size</code>: 缓冲区的实际尺寸</p></li></ul></li></ol><h2 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3 面向对象"></a>3 面向对象</h2><h3 id="3-1-封装"><a href="#3-1-封装" class="headerlink" title="3.1 封装"></a>3.1 封装</h3><ol><li><p><strong>封装: 隐藏实现细节,仅暴露必要接口</strong></p></li><li><p>实现方式: 使用 <code>struct</code> 存储数据,使用头文件(<code>.h</code>)声明公共接口,而源文件(<code>.c</code>)隐藏私有实现</p></li><li><p><code>person.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 不完整类型(此处仅声明,不定义)隐藏数据细节 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> <span class="hljs-title">Person</span>;</span><br><br><span class="hljs-comment">/* 构造函数 / 析构函数 */</span><br>Person* <span class="hljs-title function_">person_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">person_destroy</span><span class="hljs-params">(Person *p)</span>;<br><br><span class="hljs-comment">/* 公共方法(接口)隐藏实现细节 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_name</span><span class="hljs-params">(Person *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">person_get_name</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_age</span><span class="hljs-params">(Person *p, <span class="hljs-type">int</span> age)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">person_get_age</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">person_greet</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>person.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span></span><br><br><span class="hljs-comment">/* 完整定义 Person(仅在此文件可见) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">/* 实现构造函数 / 析构函数 */</span><br>Person* <span class="hljs-title function_">person_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age)</span> &#123;<br>    Person *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Person));<br>    p-&gt;name = strdup(name);<br>    p-&gt;age = age;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_destroy</span><span class="hljs-params">(Person *p)</span> &#123;<br>    <span class="hljs-built_in">free</span>(p-&gt;name);<br>    <span class="hljs-built_in">free</span>(p);<br>&#125;<br><br><span class="hljs-comment">/* 公共方法实现 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_greet</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, I&#x27;m %s, age %d!\n&quot;</span>, p-&gt;name, p-&gt;age);<br>&#125;<br><br><span class="hljs-comment">/* set, get 方法实现 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_name</span><span class="hljs-params">(Person *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span> &#123;<br>    <span class="hljs-built_in">free</span>(p-&gt;name);<br>    p-&gt;name = strdup(name);<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">person_get_name</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span> &#123;<br>    <span class="hljs-keyword">return</span> p-&gt;name;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_age</span><span class="hljs-params">(Person *p, <span class="hljs-type">int</span> age)</span> &#123;<br>    p-&gt;age = age;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">person_get_age</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span> &#123;<br>    <span class="hljs-keyword">return</span> p-&gt;age;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code> 使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;student.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    Person *p = person_create(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>);<br>    person_greet(p);  <span class="hljs-comment">// 输出: Hello, I&#x27;m Alice, age 25!</span><br>    person_set_age(p, <span class="hljs-number">10</span>);<br>    person_set_name(p, <span class="hljs-string">&quot;Bob&quot;</span>);<br>    person_greet(p);  <span class="hljs-comment">// 输出: Hello, I&#x27;m Bob, age 10!</span><br>    person_destroy(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-2-继承"><a href="#3-2-继承" class="headerlink" title="3.2 继承"></a>3.2 继承</h3><ol><li><p><strong>继承: 子类继承父类的属性和方法</strong></p></li><li><p>实现方式: 结构体嵌套(父结构体作为子结构体的第一个成员),通过类型转换模拟继承</p></li><li><p><code>student.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">Student</span>;</span><br>Student* <span class="hljs-title function_">student_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *university)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">student_destroy</span><span class="hljs-params">(Student *s)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">student_study</span><span class="hljs-params">(<span class="hljs-type">const</span> Student *s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *subject)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>student.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;student.h&quot;</span></span><br><br><span class="hljs-comment">/* Student 的私有定义 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> &#123;</span><br>    Person *base;     <span class="hljs-comment">// 通过指针持有 Person(避免不完整类型问题)</span><br>    <span class="hljs-type">char</span> *university; <span class="hljs-comment">// 子类特有的数据</span><br>&#125;;<br><br><span class="hljs-comment">/* Student 的构造函数.通过调用 Person 的构造函数工作 */</span><br>Student* <span class="hljs-title function_">student_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *university)</span> &#123;<br>    Student *s = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Student));<br>    s-&gt;base = person_create(name, age);<br>    s-&gt;university = strdup(university);<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-comment">/* Student 的构造函数.通过调用 Person 的析构函数工作 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">student_destroy</span><span class="hljs-params">(Student *s)</span> &#123;<br>    person_destroy(s-&gt;base);<br>    <span class="hljs-built_in">free</span>(s-&gt;university);<br>    <span class="hljs-built_in">free</span>(s);<br>&#125;<br><br><span class="hljs-comment">/* 子类 Student 独有的方法 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">student_study</span><span class="hljs-params">(<span class="hljs-type">const</span> Student *s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *subject)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s is studying %s at %s.\n&quot;</span>, person_get_name(s-&gt;base), subject, s-&gt;university);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code> 使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;student.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">/* 创建 Student 对象(已经完全隐藏了 Person 的细节) */</span><br>    Student *s = student_create(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Stanford&quot;</span>);<br>    student_study(s, <span class="hljs-string">&quot;Computer Science&quot;</span>);  <span class="hljs-comment">// 只能依赖公共接口工作</span><br>    student_destroy(s);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-3-多态"><a href="#3-3-多态" class="headerlink" title="3.3 多态"></a>3.3 多态</h3><ol><li><p><strong>多态: 同一接口,不同实现</strong>(使用函数指针实现动态绑定.类似 C++ 的虚函数表)</p></li><li><p><code>shape.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Shape 基类前向声明 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Shape</span> <span class="hljs-title">Shape</span>;</span><br><br><span class="hljs-comment">/* Shape 虚函数表(模拟 C++ 的 vtable).并为子类提供必要的定义 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ShapeVTable</span> &#123;</span><br>    <span class="hljs-type">void</span> (*draw)(<span class="hljs-type">const</span> Shape *);<br>    <span class="hljs-type">double</span> (*area)(<span class="hljs-type">const</span> Shape *);<br>&#125; ShapeVTable;<br><br><span class="hljs-comment">/* Shape 基类结构体(子类需要了解布局) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Shape</span> &#123;</span><br>    <span class="hljs-type">const</span> ShapeVTable *vtable; <span class="hljs-comment">// 每个对象绑定自己的虚表</span><br>&#125;;<br><br><span class="hljs-comment">/* Shape 公共接口(多态方法) */</span><br><span class="hljs-type">void</span>   <span class="hljs-title function_">shape_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">shape_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span>;<br><span class="hljs-type">void</span>   <span class="hljs-title function_">shape_delete</span><span class="hljs-params">(Shape *shape)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>shape.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><br><span class="hljs-comment">/* 多态方法: 通过虚表调用具体实现 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">shape_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-keyword">if</span> (shape &amp;&amp; shape-&gt;vtable &amp;&amp; shape-&gt;vtable-&gt;draw) &#123;<br>        shape-&gt;vtable-&gt;draw(shape);<br>    &#125;<br>    <span class="hljs-comment">// 可以添加错误处理</span><br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">shape_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-keyword">if</span> (shape &amp;&amp; shape-&gt;vtable &amp;&amp; shape-&gt;vtable-&gt;area) &#123;<br>        <span class="hljs-keyword">return</span> shape-&gt;vtable-&gt;area(shape);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>; <span class="hljs-comment">// 可以添加错误处理</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">shape_delete</span><span class="hljs-params">(Shape *shape)</span> &#123;<br>    <span class="hljs-built_in">free</span>(shape);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>circle.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> <span class="hljs-title">Circle</span>;</span><br>Circle *<span class="hljs-title function_">circle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>circle.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;circle.h&quot;</span></span><br><br><span class="hljs-comment">/* Circle 的私有定义 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> &#123;</span><br>    Shape base;  <span class="hljs-comment">// 继承 Shape(必须放在首位)</span><br>    <span class="hljs-type">double</span> radius;<br>&#125;;<br><br><span class="hljs-comment">/* Circle 的 draw 实现 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">circle_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Circle *circle = (<span class="hljs-type">const</span> Circle *)shape; <span class="hljs-comment">// 向下转型</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Circle (radius=%.2f)\n&quot;</span>, circle-&gt;radius);<br>&#125;<br><br><span class="hljs-comment">/* Circle 的 area 实现 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">circle_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Circle *circle = (<span class="hljs-type">const</span> Circle *)shape;<br>    <span class="hljs-keyword">return</span> M_PI * circle-&gt;radius * circle-&gt;radius;<br>&#125;<br><br><span class="hljs-comment">/* Circle 的虚表 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> ShapeVTable circle_vtable = &#123;<br>    .draw = circle_draw,<br>    .area = circle_area<br>&#125;;<br><br><span class="hljs-comment">/* Circle 构造函数 */</span><br>Circle *<span class="hljs-title function_">circle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br>    Circle *circle = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Circle));<br>    <span class="hljs-keyword">if</span> (circle) &#123;<br>        circle-&gt;base.vtable = &amp;circle_vtable;<br>        circle-&gt;radius = radius;<br>    &#125;<br>    <span class="hljs-keyword">return</span> circle;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>rectangle.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span> <span class="hljs-title">Rectangle</span>;</span><br>Rectangle *<span class="hljs-title function_">rectangle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>rectangle.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rectangle.h&quot;</span></span><br><br><span class="hljs-comment">/* Rectangle 的私有定义 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span> &#123;</span><br>    Shape base;  <span class="hljs-comment">// 继承 Shape(必须放在首位)</span><br>    <span class="hljs-type">double</span> width, height;<br>&#125;;<br><br><span class="hljs-comment">/* Rectangle 的 draw 实现 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rectangle_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Rectangle *rect = (<span class="hljs-type">const</span> Rectangle *)shape;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Rectangle (%.2f x %.2f)\n&quot;</span>, rect-&gt;width, rect-&gt;height);<br>&#125;<br><br><span class="hljs-comment">/* Rectangle 的 area 实现 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">rectangle_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Rectangle *rect = (<span class="hljs-type">const</span> Rectangle *)shape;<br>    <span class="hljs-keyword">return</span> rect-&gt;width * rect-&gt;height;<br>&#125;<br><br><span class="hljs-comment">/* Rectangle 的虚表 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> ShapeVTable rectangle_vtable = &#123;<br>    .draw = rectangle_draw,<br>    .area = rectangle_area<br>&#125;;<br><br><span class="hljs-comment">/* Rectangle 构造函数 */</span><br>Rectangle *<span class="hljs-title function_">rectangle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height)</span> &#123;<br>    Rectangle *rect = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Rectangle));<br>    <span class="hljs-keyword">if</span> (rect) &#123;<br>        rect-&gt;base.vtable = &amp;rectangle_vtable;<br>        rect-&gt;width = width;<br>        rect-&gt;height = height;<br>    &#125;<br>    <span class="hljs-keyword">return</span> rect;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;circle.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rectangle.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">/* 创建不同子类对象 */</span><br>    Circle *circle = circle_create(<span class="hljs-number">3.0</span>);<br>    Rectangle *rectangle = rectangle_create(<span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>);<br><br>    <span class="hljs-keyword">if</span> (!circle || !rectangle) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Memory allocation failed!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 用基类指针存储 */</span><br>    Shape *shapes[] = &#123;<br>        (Shape *)circle,<br>        (Shape *)rectangle,<br>    &#125;;<br><br>    <span class="hljs-comment">/* 多态调用 */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>        shape_draw(shapes[i]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Area: %.2f\n\n&quot;</span>, shape_area(shapes[i]));<br>    &#125;<br><br>    <span class="hljs-comment">/* 使用统一的删除接口 */</span><br>    shape_delete((Shape *)circle);<br>    shape_delete((Shape *)rectangle);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Circle (radius=3.00)<br>Area: 28.27<br><br>Rectangle (4.00 x 5.00)<br>Area: 20.00<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-重载"><a href="#3-4-重载" class="headerlink" title="3.4 重载"></a>3.4 重载</h3><ol><li><p><code>_Generic</code> 是 C11 标准引入的 <strong>编译时类型选择机制</strong><br>允许根据表达式的类型在编译期选择不同的代码分支.常用于模拟 <strong>函数重载</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">_Generic</span>(控制表达式,         \<br>         类型<span class="hljs-number">1</span>: 返回值<span class="hljs-number">1</span>,     \<br>         类型<span class="hljs-number">2</span>: 返回值<span class="hljs-number">2</span>,     \<br>         ...,               \<br>         <span class="hljs-keyword">default</span>: 默认返回值 \<br>)<br></code></pre></td></tr></table></figure></li><li><p>根据类型返回不同的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> type_name(X) _Generic((X), \</span><br><span class="hljs-meta">    int: <span class="hljs-string">&quot;int&quot;</span>, \</span><br><span class="hljs-meta">    double: <span class="hljs-string">&quot;double&quot;</span>, \</span><br><span class="hljs-meta">    char*: <span class="hljs-string">&quot;string&quot;</span>, \</span><br><span class="hljs-meta">    default: <span class="hljs-string">&quot;unknown&quot;</span> \</span><br><span class="hljs-meta">)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, type_name(<span class="hljs-number">10</span>));      <span class="hljs-comment">// 输出 &quot;int&quot;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, type_name(<span class="hljs-number">3.14</span>));    <span class="hljs-comment">// 输出 &quot;double&quot;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, type_name(<span class="hljs-string">&quot;hello&quot;</span>)); <span class="hljs-comment">// 输出 &quot;string&quot;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, type_name(<span class="hljs-string">&#x27;A&#x27;</span>));     <span class="hljs-comment">// 输出 &quot;unknown&quot;(char 未定义)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>模拟函数重载</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">print_int</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;int: %d\n&quot;</span>, x); &#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">print_double</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;double: %f\n&quot;</span>, x); &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> print(X) _Generic((X), \</span><br><span class="hljs-meta">    int: print_int,            \</span><br><span class="hljs-meta">    double: print_double       \</span><br><span class="hljs-meta">)(X) <span class="hljs-comment">/* 注意: 这里的 (X) 是进行函数调用 */</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    print(<span class="hljs-number">10</span>);   <span class="hljs-comment">// 调用 print_int</span><br>    print(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// 调用 print_double</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li><code>_Generic</code> 仅检查类型,不计算控制表达式的值</li><li><code>_Generic</code> 可以返回任意类型.如函数指针(然后立即进行函数调用,实现函数重载)</li><li><code>_Generic</code> 支持匹配各种类型.如指针, 数组, 结构体</li><li><code>_Generic</code> 会将 <code>const, volatile</code> 也作为区别类型的依据</li><li>必须有匹配到的类型. 若没有匹配到的类型且没有 <code>default</code>, 将会编译报错</li></ul></li></ol><h2 id="4-架构设计"><a href="#4-架构设计" class="headerlink" title="4 架构设计"></a>4 架构设计</h2><h3 id="4-1-solid"><a href="#4-1-solid" class="headerlink" title="4.1 solid"></a>4.1 solid</h3><ol><li><strong>单一职责原则(Single Responsibility Principle): 一个类应该只负责一项职责</strong><ul><li>避免上帝类(承担过多功能的类),将功能拆分到多个类中</li><li>每个类只关注自己的核心职责,降低修改带来的风险</li></ul></li><li><strong>开闭原则(Open Closed Principle): 软件实体(类, 模块, 函数等)应对扩展开放,对修改关闭</strong><ul><li>通过抽象(接口, 继承)实现新功能,而不是直接修改现有代码</li><li>减少对已有代码的影响,提高稳定性</li></ul></li><li><strong>里氏替换原则(Liskov Substitution Principle): 子类必须能够替换其父类,且不影响程序的正确性</strong><ul><li>子类不应破坏父类的行为契约(如方法参数, 返回值, 异常等)</li><li>避免滥用继承,确保 “is-a” 关系合理</li></ul></li><li><strong>接口隔离原则(Interface Segregation Principle): 客户端不应被迫依赖它不需要的接口</strong><ul><li>将庞大的接口拆分为更小,更具体的接口</li><li>减少 “胖接口” 导致的冗余依赖</li></ul></li><li><strong>依赖倒置原则(Dependence Inversion Principle): 高层模块不应依赖低层模块二者都应依赖抽象</strong><ul><li>通过抽象(接口)解耦,避免直接依赖具体实现</li><li>依赖注入(DI)是实现 DIP 的常见方式</li></ul></li></ol><h3 id="4-2-设计模式"><a href="#4-2-设计模式" class="headerlink" title="4.2 设计模式"></a>4.2 设计模式</h3><ol><li>观测者模式: 通知链</li><li>工厂方法: socket</li><li>模板方法: 内核调度器</li><li>策略模式: 内存压缩算法</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C 语言</tag>
      
      <tag>计算机</tag>
      
      <tag>Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Language Basic</title>
    <link href="/2023/05/01/Computer/C-Language-Basic/"/>
    <url>/2023/05/01/Computer/C-Language-Basic/</url>
    
    <content type="html"><![CDATA[<h2 id="0-开发环境"><a href="#0-开发环境" class="headerlink" title="0 开发环境"></a>0 开发环境</h2><h3 id="0-1-Windows-环境"><a href="#0-1-Windows-环境" class="headerlink" title="0.1 Windows 环境"></a>0.1 Windows 环境</h3><ol><li><p>下载安装 <a href="https://www.mingw-w64.org/downloads/#mingw-w64-builds">MinGW</a></p><ul><li><p>将 <code>x86_64-15.1.0-release-win32-seh-ucrt-rt_v12-rev0.7z</code> 解压得到 <code>mingw64</code> 目录</p></li><li><p>配置环境变量: 在系统 <code>path</code> 中添加 <code>mingw64</code> 路径. 形如: <code>D:\code\mingw64\bin</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc --version # 检查安装<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Windows 可以通过<a href="https://cmake.org/download/">官网下载安装 CMake</a>(如 <code>cmake-4.0.2-windows-x86_64.msi</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake --version # 检查安装<br></code></pre></td></tr></table></figure></li><li><p>配置环境使得可以使用 CMake 构建项目, gdb 进行调试</p><ul><li><p>在 VS Code 中安装 <code>CMake, CMake Tools, Code Runner</code> 插件</p></li><li><p>创建 <code>.vscode/tasks.json</code> 文件内容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake-configure&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake -B build -DCMAKE_BUILD_TYPE=Debug&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$gcc&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake-build&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake --build build --parallel&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$gcc&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Full Build&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;dependsOn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;cmake-configure&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;cmake-build&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;isDefault&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>创建 <code>.vscode/launch.json</code> 文件.内容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;GDB Debug&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;command:cmake.launchTargetPath&#125;&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 需要 CMake Tools 插件</span><br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Enable pretty-printing for gdb&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Set disassembly flavor to Intel&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-comment">// 调试前自动构建.注意与 tasks.json 匹配</span><br>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Full Build&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>创建 <code>./CmakeLists.txt</code> 文件.内容如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.20</span>)<br><br><span class="hljs-comment"># 项目设置</span><br><span class="hljs-keyword">project</span>(HelloCMake)<br><br><span class="hljs-comment"># 严格编译器设置</span><br><span class="hljs-keyword">set</span>(CMAKE_C_STANDARD <span class="hljs-number">17</span>)          <span class="hljs-comment"># 使用 C17 标准</span><br><span class="hljs-keyword">set</span>(CMAKE_C_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>) <span class="hljs-comment"># 强制要求编译器必须严格支持指定的 C 语言标准</span><br><span class="hljs-keyword">set</span>(CMAKE_C_EXTENSIONS <span class="hljs-keyword">OFF</span>)       <span class="hljs-comment"># 禁用编译器扩展(模拟-pedantic)</span><br><br><span class="hljs-comment"># 启用编译数据库生成.配合 clangd</span><br><span class="hljs-keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-comment"># 强制启用所有警告</span><br><span class="hljs-keyword">add_compile_options</span>(<br>    -Wall     <span class="hljs-comment"># 开启所有警告</span><br>    -Wextra   <span class="hljs-comment"># 启用额外警告</span><br>    -Werror   <span class="hljs-comment"># 将警告视为错误</span><br>    -pedantic <span class="hljs-comment"># 严格遵循标准</span><br>)<br><br><span class="hljs-comment"># 根据构建类型设置优化级别</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">NOT</span> CMAKE_BUILD_TYPE)<br>  <span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE <span class="hljs-string">&quot;Debug&quot;</span>) <span class="hljs-comment"># 默认 Debug 模式(自动包含-g)</span><br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># 显式包含当前目录(确保头文件能找到)</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)<br><br><span class="hljs-comment"># 添加可执行文件(推荐显式列出文件)</span><br><span class="hljs-keyword">add_executable</span>(<br>    <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span><br>    main.c<br>)<br></code></pre></td></tr></table></figure></li><li><p>至此即可点击状态栏的 <code>CMake Tool</code> 相关图标进行构建, 运行项目</p></li></ul></li><li><p><code>clangd</code> 插件</p><ul><li><p>需要下载安装包含 <code>clangd</code> 可执行文件的 LLVM&#x2F;Clang 工具链(直接使用 VS Code 提示安装)</p></li><li><p>解决标准库标红(在项目根目录下创建 <code>.clangd</code> 文件)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">CompileFlags:<br>  Add: [<br>    --target=x86_64-w64-mingw32,<br>    -isystem, D:/code/mingw64/x86_64-w64-mingw32/include,<br>    -isystem, D:/code/mingw64/include,<br>  ]<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-2-Linux-环境"><a href="#0-2-Linux-环境" class="headerlink" title="0.2 Linux 环境"></a>0.2 Linux 环境</h3><ol><li><p>在 Linux(发行版为 windows 的 wsl, Ubuntu 24.04) 使用 C 语言开发</p></li><li><p>在 Linux 安装必要的工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install build-essential gdb gcc g++ make<br></code></pre></td></tr></table></figure></li><li><p>Windows 远程连接到 Linux(需要先确保 Linux 服务器已开启 SSH 服务)</p><ul><li><p>在 PowerShell 中生成密钥(默认保存路径为 <code>C:\Users\你的用户名\.ssh\id_rsa</code>)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ssh<span class="hljs-literal">-keygen</span> <span class="hljs-literal">-t</span> rsa <span class="hljs-literal">-b</span> <span class="hljs-number">4096</span><br></code></pre></td></tr></table></figure></li><li><p>查看生成的密钥(复制输出的内容.以 <code>ssh-rsa AAA...</code> 开头)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure></li><li><p>在 Linux 上添加公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p ~/.ssh  # 如果目录不存在则创建<br>echo &quot;&lt;复制 Windows 中输出的公钥内容&gt;&quot; &gt;&gt; ~/.ssh/authorized_keys<br>chmod 600 ~/.ssh/authorized_keys  # 设置权限<br></code></pre></td></tr></table></figure></li><li><p>在 PowerShell 中测试 ssh 连接(若能够直接连接而无需密码,表示配置正确)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ssh username@linux_server_ip <span class="hljs-comment"># 格式为 用户名@ip地址</span><br>logout                       <span class="hljs-comment"># 退出 ssh</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>在 VS Code 安装 <code>remote</code> 扩展</p><ul><li><p>按 <kbd>F1</kbd> 或 <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>P</kbd> -&gt; <code>Remote-SSH: Connect to Host...</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh username@linux_server_ip<br></code></pre></td></tr></table></figure></li><li><p>VS Code 会提示选择 SSH 配置文件(默认是 <code>C:\Users\你的用户名\.ssh\config</code>),确认保存</p></li><li><p>ssh 连接 <code>config</code> 文件的含义(非必需项,仅了解含义)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host mylinux                   # 自定义别名.将会在插件中显示为主机名<br>    HostName linux_server_ip   # 远程服务器的真实 ip 地址或域名<br>    User username              # 登录远程服务器时使用的用户名<br>    IdentityFile ~/.ssh/id_rsa # 用于认证的私钥文件路径<br>    Port 22                    # ssh 服务端口号.默认为 22,若修改过需要对应调整<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>CMake</code> 使用(<code>.vscode/tasks.json, .vscode/launch.json, CmakeLists.txt</code> 文件内容同上)</p></li><li><p><code>clangd</code> 使用</p><ul><li><p>VS Code 中需安装 <code>clangd</code> 插件</p></li><li><p>Ubuntu 中下载, 验证安装 <code>clangd</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install clangd<br>clangd --version<br></code></pre></td></tr></table></figure></li><li><p>在 <code>.vscode/settings.json</code> 中添加配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;clangd.path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/clangd&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;clangd.arguments&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;--background-index&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;--clang-tidy&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;--completion-style=detailed&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;--header-insertion=never&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;C_Cpp.intelliSenseEngine&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;disabled&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 禁用微软引擎</span><br>  <span class="hljs-attr">&quot;C_Cpp.codeFolding&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;disabled&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-comment">// 避免冲突</span><br>  <span class="hljs-attr">&quot;editor.semanticHighlighting.enabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><code>clangd</code> 依赖 <code>compile_commands.json</code> 来获取项目的编译信息.CMake 生成该文件位于 <code>build</code> 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s build/compile_commands.json .  # 创建软连接供 clangd 使用<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>clang-format</code> 使用</p><ul><li><p>格式化代码(VS Code 快捷键 <kbd>Shift</kbd><kbd>Alt</kbd><kbd>F</kbd>)</p></li><li><p>安装 <code>clang-format</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install clang-format<br></code></pre></td></tr></table></figure></li><li><p>在项目根目录新建 <code>.clang-format</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">BasedOnStyle: Google  # 使用 Google 风格<br>IndentWidth: 4        # 覆盖为 4 空格缩进<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-3-GCC-编译器"><a href="#0-3-GCC-编译器" class="headerlink" title="0.3 GCC 编译器"></a>0.3 GCC 编译器</h3><ol><li><p>GCC(GNU Compiler Collection): gcc &#x2F; g++ 分别是 GNU 的 c&#x2F;c++ 编译器</p></li><li><p>gcc&#x2F;g++ 在执行编译工作的步骤</p><ul><li>预处理器 cpp: 预处理,生成 <code>.i</code> 的文件</li></ul><ul><li>编译器 egcs: 将预处理后的文件转换成汇编语言, 生成 <code>.s</code> 文件</li><li>汇编器 as: 有汇编变为目标代码(机器代码)生成 <code>.o</code> 的文件</li><li>链接器 ld: 连接目标代码, 生成可执行程序</li></ul></li><li><p>查看版本信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc --version<br></code></pre></td></tr></table></figure></li><li><p>gcc 编译选项(gcc 会按照后缀名进行编译.对于 C 程序,应当保持后缀名为 <code>.c</code>)</p><ul><li><p>基础编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc hello.c                    # 直接生成可执行文件(默认输出 a.out)<br>gcc hello.c -o hello           # 指定输出文件名<br>gcc main.c utils.c -o program  # 编译多个源文件<br></code></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>编译流程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -E hello.c &gt; hello.i  # 只激活预处理,不生成文件.但可以重定向到一个输出文件<br>gcc -S hello.i -o hello.s # 只激活预处理和编译.将文件编译成汇编代码<br>gcc -c hello.s -o hello.o # 只激活预处理, 编译, 汇编.生成 obj 文件<br>gcc hello.o -o hello      # 完整地编译文件<br></code></pre></td></tr></table></figure></li><li><p>调试, 优化</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -g hello.c -o hello  # 生成可供 gdb 调试可执行文件<br>gcc -O2 hello.c -o hello # 优化级别(O0 ~ O3,通常用-O2)<br>gcc -pg hello.c -o hello # 生成性能分析信息(用于 gprof)<br></code></pre></td></tr></table></figure></li><li><p>标准, 警告</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -Wall hello.c    # 打印 gcc 的警告信息<br>gcc -w hello.c       # 关闭 gcc 的警告信息<br>gcc -std=c11 hello.c # 使用 C11 标准<br></code></pre></td></tr></table></figure><ul><li><p>头文件与库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -I./include hello.c -o hello # 指定头文件搜索路径<br>gcc -L./lib hello.c -o hello     # 指定库文件搜索路径<br>gcc hello.c -lm -o hello         # 链接特定库(如数学库-lm)<br></code></pre></td></tr></table></figure></li><li><p>编译时定义宏</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -D宏名 hello.c<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="0-4-GDB-调试器"><a href="#0-4-GDB-调试器" class="headerlink" title="0.4 GDB 调试器"></a>0.4 GDB 调试器</h3><ol><li><p>GDB(GNU Project Debugger) 功能</p><ul><li>指定参数</li><li>设置断点</li><li>分析 crash 现场</li><li>直接修改程序,观测结果</li></ul></li><li><p>下载, 验证安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install gbd<br>gdb --version<br></code></pre></td></tr></table></figure></li><li><p>启动 gdb(注意: 在 gcc 编译时需要加上 <code>-g</code> 选项才能生成可供调试的可执行文件)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gdb filename       # 从头运行程序并调试<br>gdb filename core  # 调试 crash 的程序<br>gdb -p 进程号      # 调试运行中的程序<br></code></pre></td></tr></table></figure></li><li><p>gdb 命令(<kbd>Enter</kbd> 表示重复上一命令)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">run         # 运行<br>start       # 单步执行.停在第一行<br>quit(q)     # 退出<br>list(l)     # 查看代码<br>break(b)    # 设置断点,行数<br>delete(d)   # 删除断点<br>next(n)     # 单步执行,逐过程<br>step(s)     # 单步执行,逐语句<br>finish      # 结束当前函数,跳出<br>continue(c) # 继续运行<br>display     # 追踪变量<br>undisplay   # 取消追踪<br>watch       # 观察点修改时进行打印<br><br>print(p) # 查看变量<br>set var  # 设置变量<br>info(i)  # 查看信息<br>x 0x...  # 查看内存信息<br>!clear   # 清屏<br>thread   # 线程<br>disass   # 汇编<br></code></pre></td></tr></table></figure></li></ol><h3 id="0-5-CMake-环境"><a href="#0-5-CMake-环境" class="headerlink" title="0.5 CMake 环境"></a>0.5 CMake 环境</h3><ol><li><p><strong>CMake: 开源的 跨平台构建工具,用于管理软件编译过程</strong></p><ul><li>cmake 不直接构建项目,而是生成标准的构建文件(如 <code>Makefile</code>)</li><li>再由底层工具(如 <code>make, ninja</code>)完成实际编译</li><li>使用 <code>CMakeLists.txt</code> 文件定义构建规则,语法类似脚本语言</li></ul></li><li><p>cmake 安装</p><ul><li><p>Windows 可以通过<a href="https://cmake.org/download/">官网下载安装 <code>CMake</code></a>(如 <code>cmake-4.0.2-windows-x86_64.msi</code>)</p></li><li><p>Ubuntu 使用如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update         # 更新软件包列表<br>sudo apt install cmake  # 安装 CMake<br>cmake --version         # 验证安装<br></code></pre></td></tr></table></figure></li><li><p>通过源码安装(可选)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装编译依赖.下载 CMake 源码</span><br>sudo apt update &amp;&amp; sudo apt install -y build-essential libssl-dev<br>wget https://github.com/Kitware/CMake/releases/download/v4.0.3/cmake-4.0.3.tar.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压并编译安装 CMake</span><br>tar -zxvf cmake-4.0.3.tar.gz<br>cd cmake-4.0.3<br>./bootstrap --prefix=/usr/local --parallel=$(nproc) # 指定安装路径并启用多核编译<br>make -j$(nproc)   # 并行编译加速<br>sudo make install # 安装 CMake<br>cmake --version   # 验证安装<br></code></pre></td></tr></table></figure></li></ul></li><li><p>cmake 卸载</p></li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt remove cmake # 通过 apt 方式卸载<br><br>cd cmake-4.0.3/build<br>sudo make uninstall   # 通过源码编译安装的卸载方式<br></code></pre></td></tr></table></figure><h3 id="0-6-CMake-构建"><a href="#0-6-CMake-构建" class="headerlink" title="0.6 CMake 构建"></a>0.6 CMake 构建</h3><ol><li><p>编写 <code>CMakeLists.txt</code> 文件.下面是最基础的配置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.20</span>)   <span class="hljs-comment"># CMake 最低版本要求</span><br><span class="hljs-keyword">project</span>(hello)                         <span class="hljs-comment"># 配置项目名称为 hello</span><br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> main.c) <span class="hljs-comment"># 为生成可执行文件所使用到的源文件</span><br></code></pre></td></tr></table></figure></li><li><p>cmake 手动构建命令(若修改了 <code>CMakeLists.txt</code> 文件但并未及时生效,可以删除 <code>./build</code> 目录后重新构建)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">cmake -B build      <span class="hljs-comment"># 创建 build 目录,编译 CMakeList.txt</span><br>cmake --build build <span class="hljs-comment"># 构建项目,生成可执行文件</span><br></code></pre></td></tr></table></figure></li><li><p>cmake 语法</p><ul><li><p>cmake 项目基于 <code>CMakeLists.txt</code> 构建,其中(或 <code>*.cmake</code> 文件)使用的就是 CMake Language</p></li><li><p>cmake 命令行工具由5个可执行文件构成: <code>cmake, ctest, cpack, cmake-gui, ccmake</code></p></li><li><p>不通过 <code>CMakeLists.txt</code> 运行 cmake 的方法(该方法仅学习语法,实际并不会用到)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake -P *.cmake<br></code></pre></td></tr></table></figure></li><li><p>获取 cmake 变量</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>(<span class="hljs-variable">$&#123;CMAKE_VERSION&#125;</span>)  <span class="hljs-comment"># 打印版本号</span><br></code></pre></td></tr></table></figure><ul><li>cmake 的变量(区分大小写)分为: cmake 提供 和 自定义的</li><li>cmake 的变量存储时均为字符串</li></ul></li></ul></li><li><p>cmake  构建项目的方式</p><ul><li><code>add_executable</code> 中直接写入相对路径.此时在源码中引入头文件也需要写相对路径</li></ul></li><li><p>生成静态库和动态库</p><ul><li>静态库: 在连接阶段,将汇编的 <code>.o</code> 文件与引用到的库一起打包到可执行文件中</li><li>动态库: 不会在编译时连接,而是在运行时才载入</li></ul></li><li><p>调用静态库和动态库</p></li></ol><h2 id="1-编译链接"><a href="#1-编译链接" class="headerlink" title="1 编译链接"></a>1 编译链接</h2><h3 id="1-1-编译过程"><a href="#1-1-编译过程" class="headerlink" title="1.1 编译过程"></a>1.1 编译过程</h3><ol><li><strong>预处理(Preprocessing)</strong>: 对源代码(source code file)进行文本替换(宏定义, 条件编译, 文件包含)<ul><li>删除所有注释 <code>//, /* */</code></li><li>展开所有宏定义 <code>#define</code></li><li>处理所有的条件编译指令 <code>#if, #ifdef, #endif...</code></li><li>添加行号和文件名标识</li><li>保留所有的 <code>#pragma</code> 编译器指令,留给编译器</li></ul></li><li><strong>编译(Compilation)</strong>: 将经过预处理之后的程序转换成特定汇编代码(assembly code).生成文本文<ul><li><strong>词法分析</strong>: 将代码的字符序列转化为一系列 token(如关键字, 标识符, 特殊符号…)</li><li><strong>语法分析</strong>: 生成以表达式为节点的语法树</li><li><strong>语义分析</strong>: 进行静态语义分析(如类型转换).此时语法树有了类型</li></ul></li><li><strong>汇编(Assemble)</strong>: 将汇编代码转换成机器码(machine code),生成的文件称目标文件(二进制格式)</li><li><strong>链接(Linking)</strong>: 将多个目标文件以及所需的库文件(.so等)链接成最终的可执行文件(executable file)<ul><li><strong>符号解析</strong>: 链接器扫描所有目标文件收集所有符号,为每个符号引用找到对应的定义</li><li><strong>地址空间分配</strong>: 将目标文件的段信息进行合并</li><li><strong>重定位</strong>: 程序中调用的函数, 全局变量在编译并未确定其地址.此时修正它们的地址</li></ul></li></ol><h3 id="1-2-宏定义"><a href="#1-2-宏定义" class="headerlink" title="1.2 宏定义"></a>1.2 宏定义</h3><ol><li><p>程序扩展 <code>#define</code> 的步骤</p><ul><li>调用宏时,对参数进行检查.如果包含了 <code>#define</code>  定义的符号,将其替换(双引号中的除外)</li><li>替换文本被插入到程序原来的位置.对于带参数的宏,参数名会被值替换</li><li>再次对结果文本进行扫描.如果还有由 <code>#define</code> 定义的符号,重复上述步骤</li></ul></li><li><p>编译器预定义宏</p><table><thead><tr><th>符号</th><th>示例值</th><th>含义</th></tr></thead><tbody><tr><td><code>__FILE__</code></td><td>“name.c”</td><td>进行编译的源文件名</td></tr><tr><td><code>__LINE__</code></td><td>25</td><td>文件当前行号</td></tr><tr><td><code>__DATE__</code></td><td>“Aug 24 2023”</td><td>文件被编译的日期</td></tr><tr><td><code>__TIME__</code></td><td>“18:04:30”</td><td>文件被编译的时间</td></tr><tr><td><code>__STDC__</code></td><td>1</td><td>若编译器遵循 ANSI C,其值为1.否则未定义</td></tr></tbody></table></li><li><p><strong>无参宏定义</strong>: <code>#define name stuff</code> </p><ul><li><p>作用: 在该指令后面内容中,每当 <code>name</code> 出现,预处理器将其替换为 <code>stuff</code> </p></li><li><p>若 <code>stuff</code> 很长,可以将其分为几行,在行尾加上 <code>\</code> 表示下一行是上一行的延续</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG_PRINT print(<span class="hljs-string">&quot;File %s line %d: x=%d, y=%d, z=%d&quot;</span> \</span><br><span class="hljs-meta">__FILE__, __LINE__, x, y, z)</span><br>x *= <span class="hljs-number">2</span>; y += x; z = x * y;<br>DEBUG_PRINT; <span class="hljs-comment">// 将打印出 文件名, 行号, x, y, z的值</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>含参数宏定义</strong>: <code>#dedine name(parameter-list) stuff</code> </p><ul><li><p>其中参数列表 <code>parameter-list</code> 是由逗号分隔的符号列表,可能会出现在 <code>stuff</code> 中</p></li><li><p>作用: 在该指令后面内容中,每当 <code>name(parameter-list)</code> 出现,预处理器将其替换为 <code>stuff</code>,且每个参数均对应地被替换.注意在参数上加上括号,避免参数与操作符的相互作用而产生不可预料的后果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(x) ((x) * (x))</span><br>SQUARE(<span class="hljs-number">5</span>); <span class="hljs-comment">// 将被预处理器替换为 ((5) * (5))</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>可变参数宏定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHOWLIST(...) printf(__VA_ARGS__)</span><br>SHOWLIST(Clang, <span class="hljs-number">520</span>, pi); <span class="hljs-comment">// 输出为 Clang, 520, pi</span><br></code></pre></td></tr></table></figure><ul><li><code>...</code> 表示可变参数.可变参数允许空参数</li><li><code>__VA_ARGS__</code> 在预处理中被实际的参数集替换</li></ul></li><li><p><code>#</code>: <strong>记号字符串化运算符</strong></p><ul><li><p>带参数的宏定义中,<code>#</code> 运算符后面应该跟一个参数</p></li><li><p><code>#argument</code> 会被预处理器翻译为字符串 <code>&quot;argument&quot;</code> </p></li><li><p>多个空白字符将被替换为一个空格</p></li><li><p><code>&quot;</code>将被替换为<code>\&quot;</code>,<code>\</code>将被替换为<code>\\</code>.即<code>&quot;</code> 和<code>\</code>被自动转义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT(FORMAT, VALUE) printf(<span class="hljs-string">&quot;The value of &quot;</span> #VALUE <span class="hljs-string">&quot; is &quot;</span> FORMAT <span class="hljs-string">&quot;\n&quot;</span>, VALUE)</span><br> <br>PRINT(<span class="hljs-string">&quot;%d&quot;</span>, x+<span class="hljs-number">3</span>);<br><span class="hljs-comment">/* 上面将会被替换为 printf(&quot;The value of x+3 is %d\n&quot;, x+3); */</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>##</code>: <strong>标记粘贴运算符</strong>: 将两侧的符号连接为一个符号.可用于宏定义中从分离的文本片段创建标识符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADD_TO_SUM(sum_number, value)\</span><br><span class="hljs-meta">   sum ## sum_number += value</span><br> <br>ADD_TO_SUM(<span class="hljs-number">5</span>,<span class="hljs-number">25</span>);<br><span class="hljs-comment">/* 上面将被替换为 sum5 += 25; */</span><br></code></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li><p><strong>宏定义中的空格不能忽视</strong></p></li><li><p><strong><code>#define</code> 定义的符号可以嵌套,但不能递归</strong></p></li><li><p>预处理在编译之前,因此编译器不会对宏定义进行语法检查</p></li><li><p>预处理器搜索 <code>#define</code> 定义的符号时不检查字符串常量的内容</p></li><li><p><strong>利用 C 语言 <code>临近字符串自动连接</code> 的特性, 可将宏参数插入字符串常量</strong></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT(FORMAT, VALUE)\</span><br><span class="hljs-meta">   printf(<span class="hljs-string">&quot;The value is &quot;</span> FORMAT <span class="hljs-string">&quot;\n&quot;</span>, VALUE)</span><br><br>PRINT(<span class="hljs-string">&quot;%d&quot;</span>, x+<span class="hljs-number">3</span>);<br><span class="hljs-comment">/* 上面将会被替换为 printf(&quot;The value is &quot; &quot;%d&quot; &quot;\n&quot;, x+3); */</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>宏不是语句.因此不需要分号</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> assert(e) ((void)(e) || _assert_error(__FILE__,__LINE__))</span><br></code></pre></td></tr></table></figure><ul><li><code>e</code>: 一个表达式. 当 <code>e==0</code> 时, <code>_assert_error(__FILE__,__LINE__)</code> 函数将被调用</li><li>由于 <code>||</code> 顺序求值.当  <code>e!=0</code>,右侧不会被计算</li></ul></li><li><p><strong>宏不是类型定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 宏常用于多个不同变量的类型在一处说明.修改变量类型时仅需修改宏定义.提高可移植性 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOOTYPE struct foo</span><br>FOOTYPE a,b;<br><br><span class="hljs-comment">/* 类型定义更加通用 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> <span class="hljs-title">FOOTYPE</span>;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>宏不是函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> abs(x) (((x) &gt;= 0) ? (x) : -(x))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(a,b) ((a) &gt; (b)) ? (a) : (b)</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>宏定义只会被机械地替换.括号是为了保证不会因运算优先级出错</strong></p></li><li><p>在带参数的宏定义中,若一个操作数在多处用到,则会被求值多次</p><ul><li>例如 <code>max</code> 中,若 <code>a[i] &gt; b</code>,则 <code>max(a[i++], b)</code> 被展开为<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">((a[i++]) &gt; (b)) ? (a[i++]) : (b)  <span class="hljs-comment">// 使得 i 自增2次</span><br></code></pre></td></tr></table></figure></li><li>解决方法: 确保宏中的参数没有副作用 或 使用函数的方法实现</li></ul></li><li><p>如果宏参数在定义中出现的次数超过1次,且具有副作用.则使用时可能出现危险</p></li><li><p>带副作用的操作符和函数:</p><ul><li><code>++, --</code> 运算符</li><li><code>getchar()</code> 函数</li></ul></li></ul></li><li><p>宏与函数</p><ul><li><p>函数调用有压栈,弹栈的额外开销</p></li><li><p>命名约定: 使用宏的语法和函数完全一致,为进行区别.<strong>宏名一般全大写</strong></p></li><li><p>函数只需出现在代码的某一处.而每个宏出现的地方都会被替换,导致代码变长</p></li><li><p><strong>函数声明时需要指出参数的类型,宏不用</strong></p></li><li><p><strong>函数无法传递将 <code>类型</code> 作为函数参数传递,宏可以</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MALLOC(n, type) ( (type *)malloc( (n) * sizeof(type) ) )</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-3-条件编译"><a href="#1-3-条件编译" class="headerlink" title="1.3 条件编译"></a>1.3 条件编译</h3><ol><li><p><strong>预处理指令</strong></p><table><thead><tr><th align="left">指令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">#define</td><td align="left">定义宏</td></tr><tr><td align="left">#include</td><td align="left">包含一个源代码文件</td></tr><tr><td align="left">#undef</td><td align="left">取消已定义的宏</td></tr><tr><td align="left">#ifdef</td><td align="left">如果宏已经定义返回真</td></tr><tr><td align="left">#ifndef</td><td align="left">如果宏没有定义返回真</td></tr><tr><td align="left">#if</td><td align="left">如果给定条件为真,则编译下面代码</td></tr><tr><td align="left">#else</td><td align="left">#if 的替代方案</td></tr><tr><td align="left">#elif</td><td align="left">如果 #if 的条件不为真,且当前条件为真.则编译下面代码</td></tr><tr><td align="left">#endif</td><td align="left">结束一个 <code>#if……#else</code> 条件编译块</td></tr><tr><td align="left">#error</td><td align="left">当遇到标准错误时,输出错误消息</td></tr><tr><td align="left">#pragma</td><td align="left">使用标准化方法,向编译器发布特殊的命令到编译器中</td></tr></tbody></table></li><li><p><strong>条件编译的常量表达式一般为字面值 ,或是一个由 <code>#define</code> 定义的符号.必须在程序执行前确定该值</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> constant-expression    <span class="hljs-comment">// 常量表达式,由预处理器进行求值</span></span><br>    statements             <span class="hljs-comment">// constant-expression 为真(非零),则 statements 被编译.否则删除</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> constant-expression  <span class="hljs-comment">// #elif 子句出现的次数不限</span></span><br>    other statements1      <span class="hljs-comment">// #elif 后面的语句,只有前面的所有常量表达式全为假时,才会被编译</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    other statements2      <span class="hljs-comment">// #else 后面的语句,只有前面的所有常量表达式全为假时,才会被编译</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>检查是否被定义的指令</strong>(<code>defined</code> 的作用在于可以使用 <code>&amp;&amp;, ||</code> 逻辑运算符对多个符号进行判断)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span>     defined(symbol)   <span class="hljs-comment">// 如果定义了符号 symbol ...</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  symbol            <span class="hljs-comment">// 如果定义了符号 symbol ...</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span>     !defined(symbol)  <span class="hljs-comment">// 如果未定义符号 symbol ...</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> symbol            <span class="hljs-comment">// 如果未定义符号 symbol ...</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>指令嵌套</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined( OS_UNIX )</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OPTION1</span><br>        unix_version_of_option1();<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* OPTION1 */</span></span><br>            <br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OPTION2</span><br>        unix_version_of_option2();<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* OPTION2 */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined( OS_MSDOS )</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OPTION2</span><br>        msdos_version_of_option2();<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* OPTION2 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* defined( OS_UNIX ) */</span></span><br></code></pre></td></tr></table></figure><ul><li><code>#endif</code> 语句后加上一条注释标签,帮助阅读</li><li>上述代码的用意为: 在不同的操作系统中根据选项决定使用不同的方案</li></ul></li></ol><h3 id="1-4-文件包含"><a href="#1-4-文件包含" class="headerlink" title="1.4 文件包含"></a>1.4 文件包含</h3><ol><li><p>头文件(约定后缀为 <code>.h</code>)中通常会包含以下内容</p><ul><li><p>明示常量, 宏函数, 函数声明, 结构体模板定义, 类型定义</p></li><li><p>在头文件中声明外部变量,可实现与其他文件共享变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> status = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 该变量声明于源代码文件中(.c),且具有文件作用域</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> status; <span class="hljs-comment">// 该语句声明于头文件中(.h).则包含了该头文件的代码均可访问 status 变量</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>#include</code> 指令</strong></p><ul><li>预处理器将会删除此指令,然后用包含的文件内容取代</li><li>当头文件被包含时,位于头文件内的所有内容都要被编译</li><li>每个头文件仅需包含一组函数 &#x2F; 数据的声明</li></ul></li><li><p><strong>包含库函数的头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filename.h&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li><code>filename</code> 命令并不存在限制.但约定标准库文件以 <code>.h</code> 结尾</li></ul></li><li><p><strong>包含本地文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;filename&quot;</span></span><br></code></pre></td></tr></table></figure><ul><li>处理方式: 先在源文件的当前位置查找,若没有,则用查找函数库头文件的方式查找</li></ul></li><li><p>避免文件重复包含</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __HEADER_NAME_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __HEADER_NAME_H__ 1</span><br><span class="hljs-comment">/* All the stuff that you want in the header file */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li><strong>使用条件编译可以避免多重包含</strong></li><li>当第一次包含该文件时, <code>#define __HEADER_NAME_H__ 1</code> 被执行,再次包含时将被忽略</li><li>定义可以省略<code>1</code>. 即: <code>#define __HEADER_NAME_H__ </code>.该符号被定义为一个空字符,也是被定义的</li></ul></li><li><p><strong><code>#error</code>: 生成错误信息</strong></p><ul><li><p>语法: <code>#error text of error message</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span>defined(OPTION_A)</span><br><span class="hljs-comment">/* stuff needed for option A */</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span>defined(OPTION_B)</span><br><span class="hljs-comment">/* stuff needed for option B */</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span>defined(OPTION_C)</span><br><span class="hljs-comment">/* stuff needed for option C */</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">error</span> NO option selected!</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>#line</code> 指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">line</span> number <span class="hljs-string">&quot;string&quot;</span></span><br></code></pre></td></tr></table></figure><ul><li>作用: 通知编译器 <code>number</code> 是下一行输入的行号.<code>&quot;string&quot;</code> 为可选部分.表示将其作为当前文件的名字</li><li><strong><code>#line</code> 将会修改 <code>__LINE__</code> 和 <code>__FILE__</code> 的值</strong></li><li>常用于将其他语言代码转化为 C代码的程序</li></ul></li><li><p>无效指令</p><ul><li>语法: 以 <code>#</code> 开头,但后面没有内容的行</li><li>处理方式: 被预处理器简单地删除</li><li>用法: 凸显某一行<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">#<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>#<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-5-词法分析"><a href="#1-5-词法分析" class="headerlink" title="1.5 词法分析"></a>1.5 词法分析</h3><ol><li><p><code>token</code>: 程序的一个基本组成单元</p></li><li><p>词法分析器: 编译器中负责将程序分解为一个一个符号的部分</p><ul><li>符号之间的空白(空格符,制表符,换行符)将会被忽略</li></ul></li><li><p>词法分析的贪心法</p><ul><li>C 语言分为单字符符号和多字符符号</li><li><strong>编译器在读取符号时的规则为: 每一个符号应包含尽可能多的字符</strong></li><li>编译器将程序分解为符号的方法: 从左往右读入字符,如果该字符可能成为一个符号,那么再读入下一个字符.判断已读入的2个字符是否可能组成一个符号,如果可能继续读入,重复步骤,直到不可能组成一个有意义的符号</li><li>除了字符串和字符常量,符号的中间不能嵌入空白(空格符,制表符,换行符)</li></ul></li></ol><h3 id="1-6-链接"><a href="#1-6-链接" class="headerlink" title="1.6 链接"></a>1.6 链接</h3><ol><li><p>编译与链接</p><ul><li><strong>C 程序可由多个部分分别编译组成,连接器可以将其合并成一个整体</strong></li><li>编译器一般只处理一个文件,因此无法检测出需要了解多个文件才能察觉的错误</li><li>连接器在许多系统独立于 C 语言实现,因而如果错误与 C 语言相关,连接器是无法察觉的</li></ul></li><li><p>链接器</p><ul><li><strong><code>分别编译</code>是 C 语言的一个重要思想: 多个源程序分别编译,在恰当的时候整合</strong></li><li>连接器并不需要理解 C 语言.它理解机器语言和内存布局.而编译器将源程序翻译给连接器</li><li>连接器读入目标模块,同时生成载入模块</li><li>对于目标模块的每个外部对象,连接器需要检查载入模块中是否有同名的外部对象<ul><li>若没有,则将该外部对象添加到载入模块</li><li>若有,则处理命名冲突</li></ul></li><li>除了外部对象,目标模块还可能包含对其他模块中外部对象的引用<ul><li>如调用了 <code>printf</code> 函数的程序,包含一个对 <code>printf</code> 函数的引用</li><li>该引用指向一个位于某个库文件中的外部对象</li></ul></li></ul></li><li><p><strong>声明与定义: 每个外部对象必须在程序的某个地方定义</strong></p><ul><li><p>将语句声明于函数外部</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a; <span class="hljs-comment">// 定义 a 成为一个外部整型变量,且会为 a 分配存储空间.默认初始化为0</span><br></code></pre></td></tr></table></figure></li><li><p>下面声明语句并非是对 a 的定义(但仍是外部变量)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> a; <span class="hljs-comment">// 连接器认为这是对外部变量 a 的引用,而非定义</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="2-数据"><a href="#2-数据" class="headerlink" title="2 数据"></a>2 数据</h2><h3 id="2-1-基本数据类型"><a href="#2-1-基本数据类型" class="headerlink" title="2.1 基本数据类型"></a>2.1 基本数据类型</h3><ol><li><p><strong>C 语言中的所有类型,要么是对象类型,要么是函数类型</strong></p><ul><li><strong>对象</strong>: 可以在其中表示值的一块存储区域(注意并非面向对象的对象)</li><li><strong>函数</strong>: 并非对象,且其类型由 返回值类型, 参数的数量, 类型 共同决定</li></ul></li><li><p>C 语言的5种基本数据类型</p><ul><li>整型(<code>short, int, long, long long</code>)</li><li>浮点型(<code>float, double, long double</code>)</li><li>字符型(<code>char</code>)</li><li>布尔型(<code>_Bool</code>)</li><li>枚举(<code>enum</code>)</li></ul></li><li><p><strong>C 语言并未给定 int 的具体尺寸为多少字节,只需满足: <code>short &lt;= int &lt;= long &lt;= long int</code></strong><br><strong>因此需要 sizeof 运算符获取数据类型或表达式的尺寸</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">sizeof</span>(type_name);<br><span class="hljs-keyword">sizeof</span>(object);<br><span class="hljs-keyword">sizeof</span> object;<br></code></pre></td></tr></table></figure></li><li><p>ANSI C规定的整型的最小范围</p><table><thead><tr><th align="left">类型</th><th align="left">最小值</th><th>最大值</th></tr></thead><tbody><tr><td align="left">char</td><td align="left">0</td><td>127</td></tr><tr><td align="left">signed char</td><td align="left">-127</td><td>127</td></tr><tr><td align="left">unsigned char</td><td align="left">0</td><td>255</td></tr><tr><td align="left">short</td><td align="left">-32767</td><td>32767</td></tr><tr><td align="left">unsigned short</td><td align="left">0</td><td>65535</td></tr><tr><td align="left">int</td><td align="left">-32767</td><td>32767</td></tr><tr><td align="left">unsigned int</td><td align="left">0</td><td>65535</td></tr><tr><td align="left">long</td><td align="left">-2147483647</td><td>2147483647</td></tr><tr><td align="left">unsigned long</td><td align="left">0</td><td>4294967259</td></tr></tbody></table></li><li><p><strong><code>&lt;limits.h&gt;</code> 中说明了不同整数 &#x2F; 浮点数类型的特点</strong></p><table><thead><tr><th align="center"></th><th align="center">signed</th><th align="center">signed</th><th align="center">unsigned</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">最小值</td><td align="center">最大值</td><td align="center">最大值</td></tr><tr><td align="center">字符</td><td align="center">SCHAR_MIN</td><td align="center">SCHAR_MAX</td><td align="center">USCHAR_MAX</td></tr><tr><td align="center">短整型</td><td align="center">SHRT_MIN</td><td align="center">SHRT_MAX</td><td align="center">USHRT_MAX</td></tr><tr><td align="center">整型</td><td align="center">INT_MIN</td><td align="center">INT_MAX</td><td align="center">UINT_MAX</td></tr><tr><td align="center">长整型</td><td align="center">LONG_MIN</td><td align="center">LONG_MAX</td><td align="center">ULONG_MAX</td></tr><tr><td align="center">单精度</td><td align="center">FLT_MIN</td><td align="center">FLT_MAX</td><td align="center">&#x2F;</td></tr><tr><td align="center">双精度</td><td align="center">DBL_MIN</td><td align="center">DBL_MAX</td><td align="center">&#x2F;</td></tr><tr><td align="center">扩展精度</td><td align="center">LDBL_MIN</td><td align="center">LDBL_MAX</td><td align="center">&#x2F;</td></tr></tbody></table></li><li><p><strong>默认的 <code>char</code> 并未规定是否有符号</strong></p><ul><li>使用 <code>char</code> 型变量时最好将其范围限制在 [0, 127]</li><li>当明确声明了 <code>char</code> 是否有符号后,才对其进行算数运算</li></ul></li><li><p>整型字面值</p><ul><li><p><strong>默认情况下的十进制字面值将被指定为最短的能容纳该值的类型</strong></p></li><li><p><strong>在字面值加上后缀可以指定其整型的类型</strong></p><ul><li><p>l &#x2F; L: long</p></li><li><p>u &#x2F; U: unsigned</p></li><li><p>上面的 u &#x2F; l 可以进行组合</p></li></ul></li><li><p>八进制表示方法: 在数值前加上 <code>0</code></p></li><li><p>十六进制表示方法: 在数值前加上 <code>0x</code></p></li><li><p><strong>字符常量: 单引号下的单个字符(也可以是转义字符或三字母词)</strong></p></li></ul></li><li><p>枚举类型: 其值为符号常量,而非字面值</p><ul><li><strong>枚举类型的变量其本质上是整型</strong></li><li>枚举声明中的符号名会被当作整型常量处理(从0开始,后面的值比前面大1)</li></ul></li><li><p>浮点类型</p><ul><li><strong>浮点数字面值在默认情况下为 <code>double</code> 类型.后缀为 l&#x2F;L 可指定其为 <code>float</code></strong></li><li>所有浮点类型必须可以容纳 $10^{-37}\sim 10^{37}$ 间的任意值</li></ul></li></ol><h3 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h3><ol><li><p>变量和常量是程序处理的两种基本数据类型</p><ul><li>通常待处理的数据会被置于内存中</li><li>存放数据的位置即是一个地址,CPU 可以通过地址找到该数据</li></ul></li><li><p><strong>变量命名规则</strong></p><ul><li>只能由英文字母(<code>_</code> 也视为字母)和数字组成</li><li>英文字母开头</li><li>区分大小写</li><li>不能使用关键字</li></ul></li><li><p><strong>ANSI C 有32个关键字</strong></p><table><thead><tr><th>auto</th><th>break</th><th>case</th><th>char</th><th>const</th><th>continue</th><th>default</th><th>do</th></tr></thead><tbody><tr><td>double</td><td>else</td><td>enum</td><td>extern</td><td>float</td><td>for</td><td>goto</td><td>if</td></tr><tr><td>int</td><td>long</td><td>register</td><td>return</td><td>short</td><td>signed</td><td>sizeof</td><td>static</td></tr><tr><td>struct</td><td>switch</td><td>typedef</td><td>union</td><td>unsigned</td><td>void</td><td>volatile</td><td>while</td></tr></tbody></table><ul><li>C99 标准新增5个关键字: <code>inline, restrict, _Bool, _Complex, _Imaginary</code></li><li>C11 标准新增7个关键字: <code>_Alignas, _Alignof, _Atomic, _Static_assert, _Noreturn, _Thread_local, _Generic</code></li></ul></li><li><p>局部变量</p><ul><li><code>for</code> 语句中的初始化语句定义的是局部变量,仅适用于复合语句内部</li><li><strong>一个函数定义的变量无法在另一个函数中访问</strong></li><li>C 语言允许随处定义变量</li></ul></li><li><p>全局变量</p><ul><li><strong>定义于函数之外的即为全局变量.会自动初始化为 0</strong></li><li>函数内部存在同名全局变量和局部变量时,会屏蔽掉全局变量</li></ul></li><li><p>减少全局变量的使用</p><ul><li>全局在程序退出是才会被释放.导致占用更多内存</li><li>使用全局变量将导致: 命名空间污染, 耦合性提高</li></ul></li><li><p>C 语言的变量有用两种生存期: 静态存储期和自动存储期</p><ul><li><strong>静态存储期:</strong> 程序执行时一直占据存储空间,程序关闭才释放.如: 具有文件作用域的变量,函数名</li><li><strong>自动存储期</strong>: 代码块结束时自动释放存储空间.如: 具有代码块作用域的变量</li></ul></li><li><p>寄存器变量</p><ul><li>寄存器存在于 CPU 内部,CPU 对寄存器的读取和存储几乎没有延时</li><li><code>register</code> 关键字: 声明寄存器变量(实际很少用到)</li><li><code>register</code> 在编译器看来只是一个建议,编译器会考虑是否将其放入寄存器</li></ul></li><li><p>静态局部变量</p><ul><li><strong><code>static</code> 关键字: 用于声明局部变量时,将局部变量设为静态存储期,与全局变量一致</strong></li><li><strong>静态局部变量仅会被初始化一次</strong></li><li><strong>静态局部变量仍为局部变量,无法在别的函数中直接访问</strong></li></ul></li></ol><h3 id="2-3-常量"><a href="#2-3-常量" class="headerlink" title="2.3 常量"></a>2.3 常量</h3><ol><li><p>基本数据类型中的数据类型可作为常量.常用的还有字符串常量和符号常量</p><ul><li><p><strong>字符串常量: C 语言没有单独的字符串类型,采取字符数组的方式定义字符串</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> 变量名[字符数量];<br><span class="hljs-type">char</span> name[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br><span class="hljs-type">char</span> name[] = <span class="hljs-string">&quot;ys&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><p>C 语言约定用转义字符 <code>&#39;\0&#39;</code> (空字符)表示字符串的结束位置当系统读取到该转义字符时,说明字符串结束</p></li><li><p>以数组形式初始化时,需要给结尾的 <code>&#39;\0&#39;</code> 留出位置</p></li><li><p>使用字符串常量初始化并赋值时,编译器会自动在末尾补上 <code>&#39;\0&#39;</code></p></li></ul></li><li><p><strong>符号常量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> 标识符 常量</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> YEAR 2023</span><br></code></pre></td></tr></table></figure></li><li><p>转义字符</p><table><thead><tr><th>转义字符</th><th>含义</th><th>转义字符</th><th>含义</th></tr></thead><tbody><tr><td><code>\a</code></td><td>响铃(BEL)</td><td><code>\\</code></td><td>\</td></tr><tr><td><code>\b</code></td><td>退格(BS)</td><td><code>\&#39;</code></td><td>‘</td></tr><tr><td><code>\f</code></td><td>换页(FF)</td><td><code>\&quot;</code></td><td>“</td></tr><tr><td><code>\n</code></td><td>换行(LF)</td><td><code>\?</code></td><td>?</td></tr><tr><td><code>\r</code></td><td>回车(CR)</td><td><code>\0</code></td><td>NULL</td></tr><tr><td><code>\t</code></td><td>水平制表(HT)</td><td><code>\ddd</code></td><td>八进制值</td></tr><tr><td><code>\v</code></td><td>垂直制表(VT)</td><td><code>\xhh</code></td><td>十六进制值</td></tr></tbody></table></li></ul></li><li><p><strong><code>const</code> 关键字用来声明常量.常量与变量的区别仅在于其值是只读的</strong></p><ul><li><code>int const a;</code> 与 <code>const int a;</code> 声明方式变量时的效果完全相同</li><li>由于常量的值不可修改.因此声明时一般要进行初始化</li><li>作为形参的常量在函数被调用时会得到实参的值</li></ul></li><li><p><code>const</code> 与指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-type">const</span> *pci;      <span class="hljs-comment">// pci 指向一个整型常量</span><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> pci;      <span class="hljs-comment">// pci 指向一个整型变量,指向不可修改</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *<span class="hljs-type">const</span> pci <span class="hljs-comment">// pci 指向一个整型常量,且指向不可修改</span><br></code></pre></td></tr></table></figure></li><li><p><code>const</code> 与 <code>#define</code></p><ul><li><code>const</code> 只能使用于可以出现变量的地方</li><li><code>#define</code> 可以创建名字常量.只要字面值可以出现的地方均可使用</li></ul></li><li><p>变量初始化</p><ul><li>在程序链接时,静态变量存储位置被指定<ul><li><strong>因此若静态变量未显式地初始化,则会被初始化为0.且初始化只会进行一次</strong></li></ul></li><li>自动变量在链接时其存储位置无法判断.因此自动变量没有缺省的初始值.对其初始化会包含一条隐式的赋值语句<ul><li>对自动变量的初始化 相比于赋值语句效率不会提高(除非声明为 <code>const</code> 变量)</li><li>隐式的赋值语句会使得自动变量每次执行到它们的时候都会重新初始化</li><li>由于初始化在运行时执行,因此可以用任何表达式作为初始值</li><li><strong>若自动变量创建而未初始化时,则其值没有意义</strong></li></ul></li></ul></li></ol><h3 id="2-4-运算符"><a href="#2-4-运算符" class="headerlink" title="2.4 运算符"></a>2.4 运算符</h3><ol><li><p>使用括号可以完全避免因不清楚运算符优先级导致的问题.但括号太多反而会不好理解</p><table><thead><tr><th>优先级</th><th>运算符</th><th>结合律</th></tr></thead><tbody><tr><td>0</td><td>强制分组: <code>()</code></td><td>—&gt;</td></tr><tr><td>1</td><td>后缀运算符: <code>[]  ()  .  -&gt;</code></td><td>—&gt;</td></tr><tr><td>2</td><td>一元运算符: <code>++ -- ! ~ +  - * &amp; (type) sizeof _Alignof</code></td><td><strong>&lt;—</strong></td></tr><tr><td>3</td><td>乘除法运算符: <code>*  /  %</code></td><td>—&gt;</td></tr><tr><td>4</td><td>加减法运算符: <code>+  -</code></td><td>—&gt;</td></tr><tr><td>5</td><td>移位运算符: <code>&lt;&lt;  &gt;&gt;</code></td><td>—&gt;</td></tr><tr><td>6</td><td>关系运算符: <code>&lt;  &lt;=  &gt;  &gt;=</code></td><td>—&gt;</td></tr><tr><td>7</td><td>相等运算符: <code>==  !=</code></td><td>—&gt;</td></tr><tr><td>8</td><td>位运算符 AND: <code>&amp;</code></td><td>—&gt;</td></tr><tr><td>9</td><td>位运算符 XOR: <code>^</code></td><td>—&gt;</td></tr><tr><td>10</td><td>位运算符 OR: |</td><td>—&gt;</td></tr><tr><td>11</td><td>逻辑运算符 AND: <code>&amp;&amp;</code></td><td>—&gt;</td></tr><tr><td>12</td><td>逻辑运算符 OR: ||</td><td>—&gt;</td></tr><tr><td>13</td><td>条件运算符: <code>? :</code></td><td><strong>&lt;—</strong></td></tr><tr><td>14</td><td>赋值运算符: &#96;&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &amp;&#x3D; ^&#x3D;</td><td>&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D;&#96;</td></tr><tr><td>15</td><td>逗号运算符: <code>,</code></td><td>—&gt;</td></tr></tbody></table></li><li><p>单目运算符</p><ul><li><strong>单目运算符的优先级仅低于后缀运算符</strong></li><li>结合顺序为从右到左.即 <code>*p++</code> 会被认为是 <code>*(p++)</code></li></ul></li><li><p>双目运算符</p><ul><li><p>算术  –&gt;  移位  –&gt;  关系  –&gt;  位  –&gt;  逻辑(<strong>算移关位逻</strong>)</p></li><li><p>关系运算符中: 比较  –&gt; 判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 判断 a,b 的相对大小是否和 c,d 相同</span><br>a &lt; b == c &lt; d<br></code></pre></td></tr></table></figure></li><li><p>位运算符优先级: <code>~  --&gt;  &amp;  --&gt;  ^  --&gt;  |</code> (<strong>反,与,异,或</strong>)</p></li><li><p>逻辑运算符优先级: <code>!  --&gt;  &amp;&amp;  --&gt;  ||</code> (<strong>非与或</strong>)</p></li></ul></li><li><p>三目运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">taxRate = income &gt; <span class="hljs-number">40000</span> &amp;&amp; residence &lt; <span class="hljs-number">5</span> ? <span class="hljs-number">3.5</span> : <span class="hljs-number">2.0</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>三目运算符优先级低于: 算术, 移位, 关系, 位, 逻辑运算符.因而允许在条件表达式中包括关系运算符的逻辑组合</strong></li><li>三目运算符优先级高于: 赋值运算符.因而可以最后进行赋值操作</li></ul></li><li><p>逗号运算符</p><ul><li>优先级最低,其结果为最后一个表达式的值</li><li>在宏定义中作用明显</li></ul></li><li><p><strong>C 语言采用短路求值: 当前一个运算数的无法确定逻辑运算的结果时,才会对第二个运算数求值.</strong><br>换言之,如果第一个运算数已经可以确实整个逻辑运算的结果,后一个运算数便不会计算</p></li></ol><h3 id="2-5-作用域"><a href="#2-5-作用域" class="headerlink" title="2.5 作用域"></a>2.5 作用域</h3><ol><li>对象, 函数, 宏, 标识符均有作用域(scope)<ul><li>标识符的作用域: 程序中该标识符可以被使用的区域</li><li><strong>C 语言提供的作用域: 文件, 块, 函数原型, 函数</strong></li><li>对象, 函数, 标识符的作用域由其声明位置决定</li></ul></li><li><strong>文件作用域</strong><ul><li>位于代码块之外的标识符具有文件作用域</li><li>从声明到源文件结尾均可被访问</li><li>函数名具有文件作用域</li></ul></li><li><strong>代码块作用域</strong><ul><li>代码块: 位于一对 <code>&#123;&#125;</code> 之间的所有语句</li><li>代码块中标识符具有代码块作用域</li><li>代码块嵌套时,外层无法用名字访问内层的标识符.如果内层有同名标识符,外层的将会被屏蔽</li></ul></li><li><strong>原型作用域</strong><ul><li>仅适用于函数原型中的参数名</li><li>函数参数名不是必需的,也不用与函数定义的形参名匹配</li></ul></li><li><strong>函数作用域</strong><ul><li>仅适用于语句标签.即 <code>label</code> 语句</li><li>一个函数中所有语句标签必须唯一</li><li>作用: 将标签限制在同一函数内部,防止标签重名</li></ul></li></ol><h3 id="2-6-存储期"><a href="#2-6-存储期" class="headerlink" title="2.6 存储期"></a>2.6 存储期</h3><ol><li><strong>对象的存储期决定其生命周期.分为: 自动, 静态, 线程, 分配</strong></li><li><strong>自动存储期</strong><ul><li>自动存储期对象将在语句块执行结束时被释放</li><li>在语句块或作为函数参数声明的对象将会具有自动存储期</li></ul></li><li><strong>静态存储期</strong><ul><li>静态存储期对象在程序整个执行期间都有效</li><li>文件作用域中声明的对象将会具有静态存储期</li><li><code>static</code> 可将具有自动存储期的变量(位于代码块中)改为静态存储期</li></ul></li><li><strong>分配存储期</strong><ul><li>动态分配内存具有分配存储期.从分配开始,直到释放结束</li><li>动态分配的内存取自堆(heap).由内存管理器管理</li><li>内存管理器负责分配内存和释放内存.分配后由调用者管理内存</li></ul></li><li><strong>线程存储期</strong>(C11 引入)<ul><li>使用<code>_Thread_local</code>关键字声明线程局部变量</li><li>线程局部变量的地址在不同线程中是不同的,在每个线程中都有一份独立的实例</li><li>线程局部变量的析构在线程退出时进行</li></ul></li></ol><h3 id="2-7-链接属性"><a href="#2-7-链接属性" class="headerlink" title="2.7 链接属性"></a>2.7 链接属性</h3><ol><li><p>标识符的链接属性决定如何处理在不同文件中出现的标识符</p><ul><li>外部(<code>external</code>): 无论在哪个源文件,声明多少次.均当作同一实体</li><li>内部(<code>internal</code>): 在同一源文件中被当作同一实体,不同源文件则被看作不同实体</li><li>无(<code>none</code>): 总是被当作不同的独立个体</li><li><strong>具有文件作用域的标识符缺省的链接属性为: <code>external</code></strong></li><li><strong>具有代码块作用域的标识符缺省的链接属性为: <code>none</code></strong></li></ul></li><li><p>修改链接属性</p><ul><li><code>static</code>: 将链接属性为 <code>external</code> 的标识符(位于代码块外)改为 <code>internal</code><ul><li>可用于限制全局变量只能在单个源文件内部访问</li><li>可用于限制内部函数不被其他源文件调用</li></ul></li><li><code>extern</code>: 将链接属性为 <code>none</code> 的变量改为 <code>external</code><ul><li>可用于访问其他文件中的链接属性为 <code>external</code> 的变量</li></ul></li></ul></li><li><p><strong>作用域, 链接属性, 存储类型的总结</strong></p><table><thead><tr><th>变量类型</th><th>声明的位置</th><th>是否存在于堆栈</th><th>作用域</th><th>加上 static</th></tr></thead><tbody><tr><td>全局</td><td>代码块外</td><td>否</td><td>文件作用域</td><td>不允许其他源文件访问</td></tr><tr><td>局部</td><td>代码块内</td><td>是</td><td>代码块作用域</td><td>静态变量</td></tr><tr><td>形参</td><td>函数头部</td><td>是</td><td>函数作用域</td><td>&#x2F;</td></tr></tbody></table></li><li><p>存储类别</p><table><thead><tr><th>存储类别</th><th>存储期</th><th>作用域</th><th>链接</th><th>声明方式</th></tr></thead><tbody><tr><td>自动</td><td>自动</td><td>块</td><td>无</td><td>块内</td></tr><tr><td>寄存器</td><td>自动</td><td>块</td><td>无</td><td>块内, <code>register</code></td></tr><tr><td>静态外部链接</td><td>静态</td><td>文件</td><td>外部</td><td>所有函数外</td></tr><tr><td>静态内部链接</td><td>静态</td><td>文件</td><td>内部</td><td>所有函数外, <code>static</code></td></tr><tr><td>静态无链接</td><td>静态</td><td>块</td><td>无</td><td>块内, <code>static</code></td></tr></tbody></table></li></ol><h2 id="3-控制流"><a href="#3-控制流" class="headerlink" title="3 控制流"></a>3 控制流</h2><h3 id="3-1-分支"><a href="#3-1-分支" class="headerlink" title="3.1 分支"></a>3.1 分支</h3><ol><li><p><code>if</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (expression_1) &#123;<br>    code block <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expression_2) &#123;<br>    code block <span class="hljs-number">2</span>;<br>&#125;<br>...<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expression_n) &#123;<br>    code block n;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    code blcok;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>else if, else</code> 语句是可选的</li><li><strong><code>else</code> 只会和最近的 <code>if</code> 匹配,而与缩进无关</strong></li></ul></li><li><p><code>switch</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (expression) &#123;<br><span class="hljs-keyword">case</span> constant_expression_1:<br>    code block <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> constant_expression_2:<br>    code block <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">break</span>;<br>...<br><span class="hljs-keyword">case</span> constant_expression_n:<br>    code block n;<br>    <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>    code block;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>break</code> 语句是可选的,若没有 <code>break</code>,将发生 <code>break</code> 穿透</strong></li><li><strong><code>default</code> 语句是可选的,用于处理没有成功匹配的情况</strong></li></ul></li></ol><h3 id="3-2-循环"><a href="#3-2-循环" class="headerlink" title="3.2 循环"></a>3.2 循环</h3><ol><li><p><code>while</code>: 先计算表达式,若为真则执行循环体中的代码. 重复该步骤,直到条件表达式为假</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (expression) &#123;<br>    code block;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>do-while</code>: 先执行一次循环体中的代码,然后计算表达式,若为真则循环再次执行语句.重复该步骤,直到条件表达式为假</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br>    code block;<br>&#125; <span class="hljs-keyword">while</span> (expression);<br></code></pre></td></tr></table></figure></li><li><p><code>for</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(initialize; expression; adjust) &#123;<br>    code block;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>开始时,先进行一次初始化 -&gt; 判断循环条件 -&gt; 执行循环体 -&gt; 进行调整. 重复该步骤,直到循环条件为假</li><li><code>for</code> 语句的每一部分都是可选的<ul><li>初始化: 可在外部进行</li><li>循环条件: 省略后将默认为真(死循环)</li><li>调整: 也可在内部语句进行</li></ul></li><li><strong><code>for</code> 是 <code>while</code> 的语法糖,优点在于将决定迭代的条件整合到了一起</strong></li></ul></li><li><p><code>goto</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">goto</span> lable;<br>lable: 语句<br></code></pre></td></tr></table></figure><ul><li><code>:</code> 表示这里有一个标记</li><li><code>label</code> 可以是任何除 C 关键字以外的纯文本.设置在 <code>goto</code> 语句的前后均可</li><li><strong><code>goto</code> 关键字是不被推荐的实践,最好只用于在同一函数内使用</strong></li><li>可用于跳出多层循环, 或者 资源管理</li></ul></li><li><p><code>break</code>: 跳出本层循环</p></li><li><p><code>continue</code>: 跳过本轮循环,进入下一轮</p></li></ol><h3 id="3-3-函数"><a href="#3-3-函数" class="headerlink" title="3.3 函数"></a>3.3 函数</h3><ol><li><p>函数的定义方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">类型名 函数名(参数列表) &#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数的声明方式: 去掉函数体,加上分号即为声明语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">类型名 函数名(参数列表);<br></code></pre></td></tr></table></figure></li><li><p>函数的类型</p><ul><li><strong>任何一个 C 函数都有返回类型: <code>void</code> 或函数生成结果的类型</strong><ul><li>若函数在调用它的文件中,第一次调用之前进行了声明或定义.则其返回值类型是非常明确的</li><li><strong>若函数在被声明或定义之前被调用,则返回类型默认为 <code>int</code></strong></li><li>若需要调用另一文件中的函数,则应在调用它的文件中对其进行声明</li></ul></li><li>形参和实参的匹配<ul><li><strong>ANSI C 允许声明时指定函数的类型</strong></li><li>函数声明中可以省略参数类型的说明,而函数定义中不能省略</li></ul></li></ul></li><li><p><code>main</code> 函数和其他函数一样,如果未显示声明返回类型,则默认返回整型</p><ul><li>C 语言通过 <code>main</code> 函数的返回值告知系统是否执行成功(0 表示成功, 非0表示失败)</li></ul></li><li><p>参数的传递</p><ul><li><strong>C 语言是按值调用的(call-by-value),也称按值传递(pass-by-value)</strong></li><li><strong>形参(parameter)</strong>: 函数定义时的参数.仅在函数被调用时分配内存,调用结束后立即释放</li><li><strong>实参(argument)</strong>: 真实传递给函数的值.这种传值方式具有单向性</li><li>传址: 如果形参是指针,那么可以通过间接的方式修改地址存储的值</li><li>传数组: 本质上是传递数组首元素的地址</li></ul></li><li><p><strong>可变参数函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span>                <span class="hljs-comment">// 可变参数需要的头文件</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n, ...)</span> &#123;              <span class="hljs-comment">// ... 是占位符,表明参数个数不确定</span><br>    <span class="hljs-type">int</span> i, sum = <span class="hljs-number">0</span>;<br>    va_list vap;                   <span class="hljs-comment">// 定义参数列表</span><br>    va_start(vap, n);              <span class="hljs-comment">// 初始化参数列表, n 是第一个参数的名称</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        sum += va_arg(vap, <span class="hljs-type">int</span>);   <span class="hljs-comment">// 获取参数值, int 表示参数类型</span><br>    &#125;                              <span class="hljs-comment">// va_arg() 调用后, vap 自动指向下一个参数</span><br>    va_end(vap);                   <span class="hljs-comment">// 关闭参数列表</span><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>内联函数: 编译器像处理宏定义的方式,将整个内联函数直接在被调用处中展开</p><ul><li>内联函数的定义方式: 在函数定义的头前加上关键字 <code>inline</code></li><li>使用内联函数会导致代码编译的时间增加,但节省函数调用的时间消耗</li><li><strong>编译器会自动将一些常用的函数优化为内联函数</strong></li></ul></li></ol><h2 id="4-指针"><a href="#4-指针" class="headerlink" title="4 指针"></a>4 指针</h2><h3 id="4-1-指针与变量"><a href="#4-1-指针与变量" class="headerlink" title="4.1 指针与变量"></a>4.1 指针与变量</h3><ol><li><p><strong>指针就是内存地址. 而指针变量是: 存放内存地址的变量</strong></p></li><li><p>定义指针变量的方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">类型名 *指针变量名<br><span class="hljs-type">int</span> *pa<br></code></pre></td></tr></table></figure><ul><li>类型名: 指明对指针变量解引用(<code>*</code>)后得到的数据类型</li></ul></li><li><p><code>void</code> 指针</p><ul><li><strong><code>void</code> 指针称为通用指针,可以指向任意类型的数据</strong><ul><li>不要对 <code>void</code> 指针解引用</li><li>任何类型的指针均可转换为 <code>void</code> 指针,而再转换回来需要强制类型转换</li></ul></li></ul></li><li><p><code>NULL</code> 指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL ((void *)0)</span><br></code></pre></td></tr></table></figure><ul><li><code>(void *)</code>: 强制类型转换,将地址 0 强转为 <code>void</code> 指针<ul><li><strong>由于地址 0 通常不被使用,因此,<code>NULL</code> 是一个空指针,即不指向任何东西</strong></li><li>为防止解引用未初始化的指针,经常将其初始化为 <code>NULL</code></li><li>解引用 <code>NULL</code> 会直接使得程序崩溃.因此,在解引用指针时,应先判断是否为 <code>NULL</code></li></ul></li></ul></li><li><p>指针的运算</p><ul><li><strong>加减: 相当于将指针的位置移动相应的位置.即 <code>p+1</code> 表示指向 <code>p</code> 的下一个元素</strong></li><li>比较: 运用关系运算符进行比较时,可判断指针指向的前后关系</li></ul></li><li><p><code>*</code> 运算符</p><ul><li>在定义指针变量时,用于声明是指针</li><li>在对指针进行取值操作时,获取指针指向元素的值</li><li>定义指针和取值操作是不同的,属于符号的重用</li></ul></li><li><p><code>&amp;</code> 取址运算符: 对变量进行取址操作,获得变量的地址</p></li></ol><h3 id="4-2-指针与函数"><a href="#4-2-指针与函数" class="headerlink" title="4.2 指针与函数"></a>4.2 指针与函数</h3><ol><li><p>指针函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *<span class="hljs-title function_">fp</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// fp 是指针函数</span><br></code></pre></td></tr></table></figure><ul><li><strong>函数的类型由返回值决定.当函数返回值为指针类型时,函数即为指针函数</strong></li><li>指针函数的定义方式类似于定义指针: 在类型后面加上一个 <code>*</code></li><li><strong>不要返回局部变量的地址.因为局部变量仅存在于函数内部</strong></li></ul></li><li><p>函数指针(它是一个指针,指向函数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>);  <span class="hljs-comment">// fp 是函数指针</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>;  <span class="hljs-comment">// fun 是一个函数名,本质也是一个指针</span><br><br>fp = func;           <span class="hljs-comment">// 对函数指针的赋值方式.类型匹配可直接赋值</span><br>result = (*fp)(num); <span class="hljs-comment">// K&amp;R C 的调用方式.从声明形式的等价得出</span><br>result = fp(num);    <span class="hljs-comment">// UNIX 推广者的调用方式.从赋值语句的等价得出</span><br></code></pre></td></tr></table></figure><ul><li><p>函数名 <code>func</code> 是函数的首地址,类型为 <code>int (*)(int)</code></p></li><li><p><strong>对于函数名而言: 它本身是一个指针,且对其取值或取址的值仍是其本身</strong></p></li></ul></li><li><p>函数指针作为参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>), <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>; <span class="hljs-comment">// 第一个参数为函数指针</span><br><br><span class="hljs-comment">/* 函数名 add 作为实参传入 calc 函数.形参为 fp,是一个函数指针 */</span><br>result = calc(add, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure></li><li><p>函数指针作为返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>), <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><br><span class="hljs-comment">/* select 是一个函数.其参数为 char op.</span><br><span class="hljs-comment">** 返回值为一个函数指针.指向的函数类型为 int (*)(int, int) */</span><br><span class="hljs-type">int</span> (*select(<span class="hljs-type">char</span> op))(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><ul><li><code>select</code> 先与 <code>(char op)</code> 结合,成为一个函数,参数为 <code>char op</code></li><li>去掉 <code>*select(char op)</code> 后,剩余 <code>int (*)(int, int)</code> 成为 <code>select</code> 的返回值</li></ul></li></ol><h3 id="4-3-一维数组"><a href="#4-3-一维数组" class="headerlink" title="4.3 一维数组"></a>4.3 一维数组</h3><ol><li><p>声明方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">数据类型 数组名[数量];<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];  <span class="hljs-comment">// 数组下标索引从 0 开始</span><br></code></pre></td></tr></table></figure><ul><li><code>[]</code>: 后缀运算符,表示声明的对象是数组</li><li>数据类型: 指明当对数组中的元素进行访问时得到的数据类型</li><li>数量: 编译器需要根据 <code>数组类型和数量</code> 确定要分配的内存大小</li><li><strong>数组名: 其本质上是一个常量指针,其值为数组首元素的地址</strong></li></ul></li><li><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>若仅给部分元素进行初始化,则其他元素自动初始化为 0</strong></li><li>若省略数组长度,则将由编译器自行计算数组长度</li></ul></li><li><p>对于一个数组,需要的的数据为: 指向首个元素的指针 和 数组长度</p><ul><li>任何关于数组的操作,实际上均通过指针进行</li><li>任何一个数组下标运算等同于一个对应指针运算</li></ul></li><li><p><strong>访问数组元素: 数组名本质上是常量指针,指向数组的首个元素</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">arr[<span class="hljs-number">1</span>]; <span class="hljs-comment">// arr[1] 被计算为 *(arr+1)</span><br></code></pre></td></tr></table></figure></li><li><p>获取数组长度(数组名只有在作为 <code>sizeof</code> 运算符的参数时是数组)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> length = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);             <span class="hljs-comment">// 获取 arr 长度</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0])) <span class="hljs-comment">// 宏实现</span></span><br></code></pre></td></tr></table></figure></li><li><p>遍历数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;arr[%d]: %d\n&quot;</span>, i, arr[i]);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可变长数组: 可以用变量指定数组的维度</p><ul><li>C99 标准前,定义数组时,数组的长度必须为常量表达式或 <code>const</code> 常量</li><li><strong>C99 开始支持可变长数组.即数组的长度在程序运行时才决定.但完成定义后仍不能修改长度</strong></li></ul></li></ol><h3 id="4-4-二维数组"><a href="#4-4-二维数组" class="headerlink" title="4.4 二维数组"></a>4.4 二维数组</h3><ol><li><p>定义二维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">数据类型 数组名[行数][列数];<br><span class="hljs-type">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><ul><li><strong>二维数组在内存中线性存储</strong></li><li>根据后缀运算符的结合性分析<ul><li>从左到右,<code>a</code> 与 <code>[4]</code> 结合.因而 <code>a</code> 是一个拥有4个元素的数组</li><li><code>a[4]</code> 与 <code>[5]</code> 结合.因而 <code>a[4]</code> 的每个元素都是一个拥有5个元素的一维数组</li></ul></li></ul></li><li><p>初始化二维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 根据 线性存放特性 进行初始化 */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;;<br><br><span class="hljs-comment">/* 根据 二维数组本质上是数组的数组特性 进行初始化 */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>    &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;,<br>    &#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;<br>&#125;;<br><span class="hljs-comment">/* 部分值初始化 */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;&#123;<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>&#125;&#125;;<br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;<br><span class="hljs-comment">/* 指定元素初始化(C99) */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, [<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>, [<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>&#125;;<br><span class="hljs-comment">/* 第一个维度元素可不写,交由编译器计算 */</span><br><span class="hljs-type">int</span> a[][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>访问二维数组元素</p><ul><li><strong>数组名被理解为常量指针,而二维数组又是数组的数组</strong></li><li><strong>因而,<code>a[3][4]</code> 将被计算为 <code>*(*(a+3)+4)</code></strong></li></ul></li><li><p>遍历二维数组: 采用嵌套循环的方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; column; ++j) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;arr[%d][%d]: %d\n&quot;</span>, row, column, arr[row][column]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多维数组: 形式上与二维数组类似,仅需在定义时增加下标数量</p></li></ol><h3 id="4-5-指针的组合"><a href="#4-5-指针的组合" class="headerlink" title="4.5 指针的组合"></a>4.5 指针的组合</h3><ol><li><p><strong>二级指针(指针在定义就表明了如何解引用.定义时用到了多少 <code>*</code>,得到值就需要多少 <code>*</code>)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">520</span>;  <span class="hljs-comment">// int 类型变量</span><br><span class="hljs-type">int</span> *p = &amp;num;  <span class="hljs-comment">// int * 类型指针</span><br><span class="hljs-type">int</span> **pp = &amp;p;  <span class="hljs-comment">// int ** 类型的二级指针</span><br></code></pre></td></tr></table></figure></li><li><p>指针数组 和 二级指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *book[] = &#123;<br>    <span class="hljs-string">&quot;C 程序设计语言&quot;</span>,<br>    <span class="hljs-string">&quot;C 专家编程&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>book</code> 是指针数组,每个元素都是指针(字符串).现想要管理每个元素(字符串)</p></li><li><p>建立一个新数组,其中的每个元素都是指针,它们指向需要操作的对象(字符串).即:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> **cbook[<span class="hljs-number">2</span>];<br>cbook[<span class="hljs-number">0</span>] = &amp;book[<span class="hljs-number">0</span>];<br>cbook[<span class="hljs-number">1</span>] = &amp;book[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure></li></ul></li><li><p>指向常量的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> cnum = <span class="hljs-number">520</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;cnum;<br></code></pre></td></tr></table></figure><ul><li>指针可以指向被 <code>const</code> 修饰的变量,不能通过指针修改其值.指针指向可改变</li><li><code>const int</code> 表示指向的是一个整型常量</li></ul></li><li><p><strong>常量指针: 指向的是一个变量,其值可以修改,但指针指向不允许修改</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">520</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p = &amp;num;  <span class="hljs-comment">// const p 表示指针 p 是一个常量</span><br></code></pre></td></tr></table></figure></li><li><p>指向常量的常量指针: 指针自身不允许修改,其指向的值也不允许修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> cnum = <span class="hljs-number">520</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p = &amp;cnum;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-复合数据"><a href="#5-复合数据" class="headerlink" title="5 复合数据"></a>5 复合数据</h2><h3 id="5-1-结构体"><a href="#5-1-结构体" class="headerlink" title="5.1 结构体"></a>5.1 结构体</h3><ol><li><p>结构体定义方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名称 &#123;</span><br>    结构体成员<span class="hljs-number">1</span>;<br>    结构体成员<span class="hljs-number">2</span>;<br>    ...<br>    结构体成员n;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>关键字 <code>struct</code> 是必要的,结构体的声明需要分号</li><li><strong>结构体名称约定第一个字符使用大写</strong></li></ul></li><li><p>结构体声明方式(关键字 <code>struct</code> 是必要的)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名称 结构体变量名;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>访问结构体成员: 使用 <code>.</code> 运算符访问结构体变量</strong></p></li><li><p>初始化结构体</p><ul><li>在定义时即可对其初始化.形式与初始化数组一样:<br>用大括号包含所有成员值,逗号作为分隔符.此时需要将各个成员类型对号入座</li><li>C99 新增特性可以在初始化时指定成员值</li><li>数组初始化时指定成员方式为 <code>[下标]</code>.对应的,结构体初始化时使用 <code>.成员名</code> 的方式指定成员值</li><li><strong>未初始化的成员将被自动初始化.数值型初始化为 0 ,字符型初始化为 <code>&#39;\0&#39;</code></strong></li></ul></li><li><p><strong>编译器会对结构体的成员进行内存对齐.让 CPU 可以更快地读取 &#x2F; 处理数据</strong></p></li><li><p>结构体数组: 本质是数组,其成员为结构体类型的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名称 数组名[长度];</span><br></code></pre></td></tr></table></figure></li><li><p><strong>结构体指针: 指向结构体的指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Book</span> *<span class="hljs-title">pt</span>;</span>  <span class="hljs-comment">// pt 是一个指向 struct Book 类型的指针</span><br></code></pre></td></tr></table></figure><ul><li><p>数组名是指向第一个元素的地址,但结构体变量名并非指向该结构体的地址</p></li><li><p>结构体的地址需要通过 <code>&amp;</code> 运算符获取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Book</span> <span class="hljs-title">book</span>;</span><br>pt = &amp;book;  <span class="hljs-comment">// 获取结构体变量的地址</span><br></code></pre></td></tr></table></figure></li><li><p><strong>结构体指针访问结构体成员有两种方法(一般使用 <code>-&gt;</code>,简洁直观)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">(*结构体指针).成员名 <span class="hljs-comment">// 先解引用,再访问成员</span><br>结构体指针-&gt;成员名   <span class="hljs-comment">// 使用箭头符号,隐含这是一个指针</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>传递结构体信息: 结构变量可以直接赋值.作为参数传递时也可以直接传递</p></li><li><p>传递指向结构体变量的指针</p><ul><li>直接传递结构体时,如果结构体变量很大,将会导致函数调用过程中时间和空间的开销相对大</li><li>传递结构体指针可以避免这种开销</li></ul></li></ol><h3 id="5-2-typedef"><a href="#5-2-typedef" class="headerlink" title="5.2 typedef"></a>5.2 <code>typedef</code></h3><ol><li><p>给数据类型起别名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> integer;<br>integer a;<br></code></pre></td></tr></table></figure></li><li><p><strong><code>typedef</code> 与 <code>#define</code> 的区别</strong></p><ul><li><p>顺序并不一样(但可统一为前一个对象作为操作对象,后一个对象为操作后的结果)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> integer int  <span class="hljs-comment">// 将 integer 替换为 int</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> integer; <span class="hljs-comment">// 给 int 起别名为 integer</span><br></code></pre></td></tr></table></figure></li><li><p>有修饰符时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 程序编译通过. integer 被替换为 int,a = 4294967295</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> integer int</span><br><span class="hljs-type">unsigned</span> integer a = <span class="hljs-number">-1</span>; <br><br><span class="hljs-comment">// 程序编译报错</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> integer;<br><span class="hljs-type">unsigned</span> integer a = <span class="hljs-number">-1</span>; <br></code></pre></td></tr></table></figure></li><li><p>定义指针变量时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 该语句预处理后替换为 int *a, b</span><br><span class="hljs-comment">** 此时 a 类型为int *, b 类型为 int */</span><br>ptrInt a, b;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ptrInt int *</span><br><br><span class="hljs-comment">/* a, b 类型均为 int *  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> * ptrInt;<br>ptrInt a, b; <br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>与结构体搭配(数据结构的链表需要该技巧)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 将 struct Date   赋予别名 DATE</span><br><span class="hljs-comment">** 将 struct Date * 赋予别名 PDATE */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Date</span> &#123;</span><br>    <span class="hljs-type">int</span> year;<br>    <span class="hljs-type">int</span> month;<br>    <span class="hljs-type">int</span> day;<br>&#125; DATE, *PDATE;<br><br>DATE date;    <span class="hljs-comment">// 定义结构体不再需要关键字 struct</span><br>PDATE pdate;  <span class="hljs-comment">// 定义的是 结构体指针</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="5-3-简化声明"><a href="#5-3-简化声明" class="headerlink" title="5.3 简化声明"></a>5.3 简化声明</h3><ol><li><p>数组指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*ptr)[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*PTR2ARRAY)</span>[3];<br></code></pre></td></tr></table></figure></li><li><p>函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*PTR2FUN)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure></li><li><p>指针函数与数组指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* array 是一个指针数组,其元素指向指针函数.指针函数参数为 int,返回值为 int *  */</span><br><span class="hljs-type">int</span> *(*<span class="hljs-built_in">array</span>[<span class="hljs-number">3</span>])(<span class="hljs-type">int</span>);<br><br><span class="hljs-comment">/* 直接使用 typedef 会导致数组长度固定为3, 因此分成两句 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> *(*PRT2FUN)(<span class="hljs-type">int</span>);  <span class="hljs-comment">// PRT2FUN 是一个指针,指向指针函数</span><br>PRT2FUN <span class="hljs-built_in">array</span>[<span class="hljs-number">3</span>];              <span class="hljs-comment">// array 是一个拥有3个元素的数组,元素类型为 PRT2FUN</span><br></code></pre></td></tr></table></figure></li><li><p>参数为函数指针,返回值为函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*funA(<span class="hljs-type">int</span>, <span class="hljs-type">void</span> (*funB)(<span class="hljs-type">int</span>)))(<span class="hljs-type">int</span>);<br><span class="hljs-comment">/* funA 是一个指针函数.有两个参数 int, funB</span><br><span class="hljs-comment">** funB 是一个函数指针,指向的类型为 void (int)</span><br><span class="hljs-comment">** 分析 funA 的返回值: 先化简 void (*funA(参数))(int).</span><br><span class="hljs-comment">** 返回值类型为 void (int),即函数指针 */</span><br><br><span class="hljs-comment">/* 提取出共同点,可以有更为清晰的定义方式 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*PTR2FUN)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-comment">// PTR2FUN 是一个函数指针</span><br>PTR2FUN <span class="hljs-title function_">funA</span><span class="hljs-params">(<span class="hljs-type">int</span>, PTR2FUN)</span>;<br></code></pre></td></tr></table></figure></li><li><p>获取类型转换符的方法为: 去掉变量名和分号,再用括号整体封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> (*h)();  <span class="hljs-comment">// 声明 h 是一个指针,指向一个返回值为 float 的函数</span><br>(<span class="hljs-type">float</span> (*)())  <span class="hljs-comment">// 构造出对应的类型转换符</span><br></code></pre></td></tr></table></figure></li><li><p>以显式的方式调用首地址为0的子例程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(*( <span class="hljs-type">void</span> (*)() ) <span class="hljs-number">0</span>)()<br></code></pre></td></tr></table></figure><ul><li><p>先考虑 <code>(* 0)();</code></p><ul><li>本意: 想对地址0进行解引用,然后调用函数</li><li>实际: 无法生效,因为 <code>*</code> 需要一个指针作为操作数,且这里还要求是函数指针</li><li>解决方法: 先将 0 强转为函数指针</li></ul></li><li><p>考虑 <code>(void(*)())</code>.这是就是需要的类型转换符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*funcptr)</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 函数指针</span><br>(*(funcptr)<span class="hljs-number">0</span>)();  <span class="hljs-comment">// 先将0强转为函数指针,然后调用该函数</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="5-4-union"><a href="#5-4-union" class="headerlink" title="5.4 union"></a>5.4 union</h3><ol><li><p><strong>共用体可以将多个成员存储在同一空间中,它们拥有相同的起始地址.最终存储的值取决最后赋值的变量</strong></p></li><li><p>声明方式: 与 struct 类似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> 共用体名称 &#123;</span><br>    共用体成员<span class="hljs-number">1</span>;<br>    共用体成员<span class="hljs-number">2</span>;<br>    ...<br>    共用体成员n;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>共用体的定义与访问方式均与结构体类似</p></li><li><p>初始化共用体: 不能同时对所有成员都初始化</p></li></ol><h3 id="4-5-enum"><a href="#4-5-enum" class="headerlink" title="4.5 enum"></a>4.5 enum</h3><ol><li><p>如果一个变量只有几种可能的值,可以将其定义为枚举类型</p></li><li><p>枚举类型声明方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> 枚举类型名称 &#123;</span><br>    枚举值名称<span class="hljs-number">1</span>, <br>    枚举值名称<span class="hljs-number">2</span>,<br>    ...<br>    枚举值名称n,<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>枚举变量定义方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> 枚举类型名称 枚举变量名;</span><br></code></pre></td></tr></table></figure><ul><li><strong>枚举值名称可以直接像标识符那样命名,称为枚举常量</strong></li><li><strong>默认情况下 枚举常量的值从 0 开始,往后依次递增</strong></li><li>如果不希望从 0 开始,可以在声明时赋值,往后依然递增</li><li>枚举变量允许自增运算,而 C++ 中不允许</li><li>枚举常量的值和名称在编译时已经指定,不再允许修改</li></ul></li></ol><h3 id="5-6-位域"><a href="#5-6-位域" class="headerlink" title="5.6 位域"></a>5.6 位域</h3><ol><li><p><strong>位域将1字节(Byte)的二进制位划分为几个不同的区域,并指定每个区域的位数</strong></p></li><li><p>每个域有一个域名,允许在程序中按域名进行单独的操作</p></li><li><p>使用位域的方法: 在定义结构体时,在结构体成员使用冒号: 和数字表示该成员所占的位数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span> &#123;</span><br>    <span class="hljs-comment">// type [member_name] : width;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a : <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> b : <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> c : <span class="hljs-number">2</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>位域的宽度不能超过它所依附的数据类型的长度.成员变量是有类型的,位域的宽度被该类型所限制</strong></p></li><li><p>位域成员可以没有名称.但需要给出数据类型和位宽.用于填充或调整成员的位置,不能使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> :<span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-位操作"><a href="#6-位操作" class="headerlink" title="6 位操作"></a>6 位操作</h2><h3 id="6-1-位运算符"><a href="#6-1-位运算符" class="headerlink" title="6.1 位运算符"></a>6.1 位运算符</h3><ol><li><p>位操作</p><ul><li><strong>C 语言并未明确规定1字节(Byte)的尺寸.而是将其定义为:</strong><br><strong>可寻址的数据存储单位,其尺寸必须可以容纳运行环境的基本字符集的任何成员</strong></li><li>C 语言仅明确规定了 <code>char</code> 类型占用 1 Byte.其他类型仅给出相对的大小关系.具体尺寸由环境约束</li><li>编译器规定了 1 Byte 的位数.写在头文件 <code>&lt;limits.h&gt;</code> 中</li><li>C 语言允许通过位域的形式来按位存取,且允许精确到 位 的运算</li></ul></li><li><p>左移运算符</p><ul><li><p>左移运算符拥有两个操作数</p></li><li><p>左侧表示被移位的数据,右侧指定移动的位数</p></li><li><p><strong>左移移出的位数全部舍弃.右侧用 0 填充</strong></p></li><li><p>将整数左移 N 位相当于乘以 $2^N$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">result = <span class="hljs-number">0b1001010</span> &lt;&lt; <span class="hljs-number">2</span>;<br><span class="hljs-comment">// result = 0b00101000</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>右移运算符</p><ul><li><p>右移运算符拥有两个操作数</p></li><li><p>左侧表示被移位的数据,右侧指定移动的位数</p></li><li><p><strong>右移移出的位数全部舍弃.左侧用 0 填充(如果是负数,用1填充.因此负数右移永远不会为0)</strong></p></li><li><p>将整数右移 N 位相当于除以 $2^N$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">result = <span class="hljs-number">0b11001010</span> &gt;&gt; <span class="hljs-number">2</span>;<br><span class="hljs-comment">// result = 0b00110010</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>左移运算符,右移运算符均可与赋值号结合</p></li><li><p>未定义行为</p><ul><li>左移 &#x2F; 右移运算符右侧指定移动的位数为 负数 时</li><li>右侧指定移动的位数 大于 左侧操作数的最大宽度时</li></ul></li></ol><h3 id="6-2-掩码"><a href="#6-2-掩码" class="headerlink" title="6.2 掩码"></a>6.2 掩码</h3><ol><li><p>掩码</p><ul><li><strong>掩码是一串二进制数字,通过与目标数字的按位操作,达到屏蔽指定位实现需求</strong></li><li>掩码本身的值一般将想要操作的对象位 置1,不变的对象位 置0</li></ul></li><li><p><strong>判断指定位</strong>: 将源数据对指定的掩码进行按位与 <code>&amp;</code>.判断结果是否与掩码本身相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((value &amp; mask) == mask) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>打开位</strong>: 将源数据对指定的掩码进行按位或 <code>|</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">value |= mask;<br></code></pre></td></tr></table></figure></li><li><p><strong>关闭位</strong>: 将源数据对取反后的掩码进行按位与 <code>&amp;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">value &amp;= ~mask;<br></code></pre></td></tr></table></figure></li><li><p><strong>转置位</strong>: 将源数据对指定的掩码进行按位异或 ^</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">value ^= mask;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C 语言</tag>
      
      <tag>计算机</tag>
      
      <tag>Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
