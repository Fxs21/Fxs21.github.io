<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>FreeRTOS</title>
    <link href="/2024/05/01/Embedded/FreeRTOS/"/>
    <url>/2024/05/01/Embedded/FreeRTOS/</url>
    
    <content type="html"><![CDATA[<h1 id="FreeRTOS"><a href="#FreeRTOS" class="headerlink" title="FreeRTOS"></a>FreeRTOS</h1><h2 id="0-简介"><a href="#0-简介" class="headerlink" title="0 简介"></a>0 简介</h2><h3 id="0-1-优势"><a href="#0-1-优势" class="headerlink" title="0.1 优势"></a>0.1 优势</h3><ol><li>FreeRTOS 通过 MIT 开源许可免费分发.包括一个内核和一组不断丰富的 IoT 库</li><li>FreeRTOS 的构建突出可靠性和易用性</li><li><strong>开源和免费</strong>: 通过 MIT 许可证发布,可免费使用, 修改, 分发</li><li><strong>轻量级设计</strong>: 适用资源受限的嵌入式系统,不占同过多内存和处理器资源</li><li><strong>应用广泛</strong>: 工业自动化, 医疗设备, 消费电子产品, 汽车电子…</li><li><strong>多平台支持</strong>: 设计注重可移植性,可移植到不同硬件平台,支持多种处理器架构</li><li><strong>功能丰富</strong>: 提供了多任务调度, 任务通信, 同步等功能.适用复杂的嵌入式应用场景</li></ol><h3 id="0-2-特点"><a href="#0-2-特点" class="headerlink" title="0.2 特点"></a>0.2 特点</h3><ol><li><strong>任务调度</strong>: 通过任务调度器管理多个任务,支持不同优先级的任务,实现任务有序执行</li><li><strong>任务通信和同步</strong>: 提供了队列,信号量等机制,支持任务间的通信和同步,确保数据安全传递</li><li><strong>内存管理</strong>: 提供简单的内存管理机制,适用于嵌入式环境,有效利用有效的内存资源</li><li><strong>定时器和中断处理</strong>: 支持定时器功能,能够处理中断</li></ol><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1 基础"></a>1 基础</h2><h3 id="1-1-多任务处理"><a href="#1-1-多任务处理" class="headerlink" title="1.1 多任务处理"></a>1.1 多任务处理</h3><ol><li>多任务操作系统: 多个用户可以同时执行多个程序</li><li>多任务操作系统简化软件设计<ul><li>将复杂的程序分割为一组更小,更易于管理的任务</li><li>分割后,可以更简单的执行软件测试, 分解工作, 复用代码</li><li>复杂的时序和排序细节可以交由系统解决</li></ul></li><li><strong>多任务操作系统可以通过任务间快速切换制造并发执行的假象</strong></li></ol><h3 id="1-2-任务调度"><a href="#1-2-任务调度" class="headerlink" title="1.2 任务调度"></a>1.2 任务调度</h3><ol><li>一个处理器核心在某一时刻只能运行一个任务,在任务间快速切换模拟多任务同时执行</li><li><strong>任务调度器</strong>: 决定某一时刻要执行哪个任务.</li><li>内核可以在任务生命周期内多次挂起并稍后恢复一个任务</li><li><strong>调度策略</strong>: 任务调度器决定任何时间点执行哪个任务的算法</li><li>FreeRTOS 优先级数值越大,优先级越高</li><li><strong>FreeRTOS 默认使用固定优先级的抢占式任务调度策略,对同等优先级的任务执行时间片轮询调度</strong></li><li><strong>抢占式调度</strong>: 更高优先级的任务在任何时刻可以抢占正在执行的低优先级任务.提高实时性</li><li><strong>时间片轮询</strong>: 相同优先级任务轮流执行一个时间片,任务进入等待时,切换到下一个.公平分配 CPU 时间</li></ol><h3 id="1-3-任务状态"><a href="#1-3-任务状态" class="headerlink" title="1.3 任务状态"></a>1.3 任务状态</h3><ol><li><p>FreeRTOS 任务有四种状态</p><ul><li><p>运行态: 实际运行的状态.若只有一个内核,则任何时间都只有一个任务处于运行态</p></li><li><p>就绪态: 准备就绪但未执行的任务.因为有其他更高或同等优先级任务处于运行态</p></li><li><p>阻塞态: 正在等待延时或外部事件</p></li><li><p>挂起态: 类似暂停. <code>vTaskSuspend()</code> 进入挂起态, <code>vTaskResume()</code> 进入就绪态</p><p><img src="/2024/05/01/Embedded/FreeRTOS/FreeRTOS-status.png"></p></li></ul></li><li><p>只有就绪态可转变为运行态.想要运行就要先转变为就绪态</p></li></ol><h3 id="1-4-滴答"><a href="#1-4-滴答" class="headerlink" title="1.4 滴答"></a>1.4 滴答</h3><ol><li>FreeRTOS 一般将 Systick 作为时钟来源</li><li>休眠时,RTOS 任务需指定唤醒的时间.阻塞时,需指定等待的最长时间</li><li>FreeRTOS 实时内核通过滴答计数变量测量时间</li><li>定时器中断(RTOS 滴答中断)按严格的时间精度增加滴答数</li><li>实时内核可以按选择的定时器中断频率的分辨率测量时间</li><li>每次滴答数增加时,实时内核必须检查是否为解除阻塞或唤醒任务的时间</li><li>在滴答 ISR 期间唤醒或解除阻塞的任务优先级可能高于被中断任务的优先级</li></ol><h3 id="1-5-上下文切换"><a href="#1-5-上下文切换" class="headerlink" title="1.5 上下文切换"></a>1.5 上下文切换</h3><ol><li>上下文: 任务执行时,需要的处理器, 寄存器, ram, rom 资源</li><li>上下文切换: 在任务挂起时保存任务的上下文,任务恢复时操作系统内核恢复上下文</li><li>上下文切换时机: 任务切换时<ul><li>真正切换上下文的执行在 PendSV(系统异常) 的 ISR 处理</li><li>PendSV 可以手动触发,且可以在其他更高中断优先级的 ISR 中设置</li><li>FreeRTOS 会将 PendSV 设置为最低中断优先级,切面影响到其他 ISR</li></ul></li></ol><h3 id="1-6-空闲任务"><a href="#1-6-空闲任务" class="headerlink" title="1.6 空闲任务"></a>1.6 空闲任务</h3><ol><li>RTOS 调度器启动时,自动创建空闲任务,确保始终存在一个能够运行的任务</li><li>空闲任务以最低优先级创建,确保有更高优先级任务处于准备就绪状态时,空闲任务不使用 CPU 时间</li><li>空闲任务负责释放被删除任务的内存</li></ol><h2 id="2-FreeRTOS-移植"><a href="#2-FreeRTOS-移植" class="headerlink" title="2 FreeRTOS 移植"></a>2 FreeRTOS 移植</h2><h3 id="2-1-源码结构"><a href="#2-1-源码结构" class="headerlink" title="2.1 源码结构"></a>2.1 源码结构</h3><ol><li><p>获取源码: <a href="https://www.freertos.org/">官网下载</a></p></li><li><p>文件结构</p><blockquote><p>|– FreeRTOS: 内核</p><p>​    |– Demo: 例程</p><p>​    |– License: 证书</p><p>​    |– Source: 内核</p><p>​        |– include: 头文件</p><p>​        |– portable: 移植文件.编译器环境相关</p><p>​    |– Test: 测试</p><p>|– FreeRTOS-Plus: 组件.一般使用第三方的组件</p><p>|– tools: 工具</p></blockquote></li></ol><h3 id="2-2-HAL-库项目移植"><a href="#2-2-HAL-库项目移植" class="headerlink" title="2.2 HAL 库项目移植"></a>2.2 HAL 库项目移植</h3><ol><li><p>在根目录创建 FreeRTOS 目录,在其中创建 <code>source, portable</code> 目录</p><ul><li>source: 下载目录的 FreeRTOS&#x2F;Source 下的所有 .c 文件</li><li>portable<ul><li>FreeRTOS&#x2F;Source&#x2F;portable&#x2F;RVDS 的相关文件</li><li>FreeRTOS&#x2F;Source&#x2F;portable&#x2F;MemMang 的 <code>heap_4.c</code></li><li>FreeRTOS&#x2F;Source&#x2F;include 整个目录</li></ul></li><li>FreeRTOSConfig.h: 工程配置文件.可以在 DEMO 中寻找</li></ul></li><li><p>在 Keil 中添加路径…….</p></li><li><p>在系统配置文件 <code>FreeRTOSConfig.h</code> 中添加必须下面的3个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortPendSVHandlerPendSV_Handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vPortSVCHandlerSVC_Handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetSchedulerState 1</span><br></code></pre></td></tr></table></figure></li><li><p>在 <code>stm32f1xx_it.c</code> 文件中注释掉 <code>PendSV_Handler, SVC_Handler</code> 函数.否则会重复定义</p></li><li><p>配置时钟源: 在 <code>stm32f1xx_it.c</code> 文件包含 <code>FreeRTOS.h, task.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FreeRTOS.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task.h&quot;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">xPortSysTickHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) &#123;  <span class="hljs-comment">// 如果开启了任务调度器</span><br>        xPortSysTickHandler();  <span class="hljs-comment">// 启动 freeRTOS 的滴答 ISR</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>hal</code> 库的延时函数默认使用 <code>SysTick</code>.将 FreeRTOS 的时钟配置为 <code>SysTick</code> 后可能引发问题</p><ul><li>在中断调用 hal 库中提供的延时函数时,因为其优先级低,导致无法计数器无法累加,时间卡死</li><li>在 CubeMX 中选择 <code>Timebase Source</code> 默认为 <code>SysTick</code>, 改为其他未使用的定时器</li><li>在 NVIC 中找到 <code>Time base interrupt</code>,将其优先级改为1.因此可以正常使用延时</li></ul></li></ol><h3 id="2-3-寄存器项目移植"><a href="#2-3-寄存器项目移植" class="headerlink" title="2.3 寄存器项目移植"></a>2.3 寄存器项目移植</h3><ol><li><p>前置步骤与 hal 库一致,直到第 4 步,因为寄存器开发没有 <code>stm32f1xx_it.c</code> 文件</p></li><li><p>在某一个文件中实现滴答定时器的中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">xPortSysTickHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) &#123;  <span class="hljs-comment">// 如果开启了任务调度器</span><br>        xPortSysTickHandler();  <span class="hljs-comment">// 启动 freeRTOS 的滴答 ISR</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自己实现的延时函数不应再依赖 <code>SysTick</code>, 防止卡死</p></li></ol><h3 id="2-4-系统配置文件"><a href="#2-4-系统配置文件" class="headerlink" title="2.4 系统配置文件"></a>2.4 系统配置文件</h3><ol><li>在系统配置文件 <code>FreeRTOSConfig.h</code> 中有很多配置项.可在 <a href="https://www.freertos.org/zh-cn-cmn-s/Documentation/02-Kernel/03-Supported-devices/02-Customization">官方文档</a> 查看详细信息</li><li>主要分为 <code>config</code> 参数 和 <code>INCLUDE</code> 宏<ul><li><code>config</code>: 功能配置.如基本配置, 内存配置, 钩子配置, 中断配置…</li><li><code>INCLUDE</code>: 裁剪功能(使用条件编译实现.1 表示可用,0 表示禁用)</li></ul></li></ol><h3 id="2-5-FreeRTOS-数据类型"><a href="#2-5-FreeRTOS-数据类型" class="headerlink" title="2.5 FreeRTOS 数据类型"></a>2.5 FreeRTOS 数据类型</h3><ol><li><code>TickType_t</code>: 用于表示系统节拍计数器的值<ul><li><code>configUSE_16_BIT_TICKS</code> 为 <code>true</code> 时, <code>TickType_t</code> 是16bit.否则为 32bit</li><li>记录 FreeRTOS 中系统过去的节拍次数</li></ul></li><li><code>BaseType_t</code>: 架构中最有效, 自然的类型. 32位架构下被定义为 32位类型</li><li><code>UBaseType_t</code>: <code>BaseType_t</code> 的 <code>unsigned</code> 版</li><li><code>StackType_t</code>: 用于存储堆栈的类型</li></ol><h3 id="2-6-FreeRTOS-命名规范"><a href="#2-6-FreeRTOS-命名规范" class="headerlink" title="2.6 FreeRTOS 命名规范"></a>2.6 FreeRTOS 命名规范</h3><ol><li>变量名采用驼峰式大小写,一般不用缩写<ul><li><code>uint32_t</code> 类型变量用 <code>ul</code> 前缀,即 <code>unsigned long</code></li><li><code>uint16_t</code> 类型变量用 <code>us</code> 前缀,即 <code>unsigned short</code></li><li><code>uint8_t</code> 类型变量用 <code>uc</code> 前缀,即 <code>unsigned char</code></li><li>非 <code>stdint</code> 类型的变量用 <code>x</code> 前缀.如 <code>BaseType_t</code></li><li>非 <code>stdint</code> 类型的无符号变量用 <code>u</code> 前缀,如 <code>UBaseType_t</code></li><li><code>size_t</code> 类型变量用 <code>x</code> 前缀</li><li>枚举变量用 <code>e</code> 前缀</li><li>指针变量用 <code>p</code> 前缀</li></ul></li><li>函数使用驼峰式大小写,一般不用缩写<ul><li>文件作用域静态(私有)函数用 <code>prv</code> 前缀</li><li>API 函数以其返回类型为前缀.对于 <code>void</code> 用 <code>v</code> 前缀</li><li>API 函数名称用定义 API 函数文件为前缀</li><li>如 <code>vTaskDelay</code>: 返回类型 <code>void</code>,定义于 <code>task.c</code>, 作用为 <code>delay</code></li></ul></li><li>宏使用完整的单词拼写<ul><li>宏用定义宏的文件为前缀.如 <code>FreeRTOSConfig.h</code> 定义 <code>configUSE_PREEMPTION</code></li><li>除前缀外,宏全大写,并使用下划线分隔</li></ul></li></ol><h2 id="3-创建删除任务"><a href="#3-创建删除任务" class="headerlink" title="3 创建删除任务"></a>3 创建删除任务</h2><h3 id="3-1-创建删除任务-API"><a href="#3-1-创建删除任务-API" class="headerlink" title="3.1 创建删除任务 API"></a>3.1 创建删除任务 API</h3><ol><li><p>任务 API 函数</p><table><thead><tr><th>API 函数</th><th>描述</th></tr></thead><tbody><tr><td>xTaskCreate</td><td>动态方式创建任务</td></tr><tr><td>xTaskCreateStatic</td><td>静态方式创建任务</td></tr><tr><td>vTaskDelete</td><td>删除任务</td></tr></tbody></table><ul><li>动态创建任务: 任务的控制块和栈空间由 FreeRTOS 管理</li><li>静态创建任务: 任务的控制块和栈空间由用户分配提供</li></ul></li><li><p>动态创建任务函数声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskCreate</span> <span class="hljs-params">(</span><br><span class="hljs-params">    TaskFunction_t pxTaskCode,  <span class="hljs-comment">// 指向任务函数的指针</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> pcName,   <span class="hljs-comment">// 任务名,最大长度为 configMax_TASK_NAME_LEN</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> configSTACK_DEPTH_TYPE usStackDepth,  <span class="hljs-comment">// 任务堆栈大小,默认单位为4字节</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span> *<span class="hljs-type">const</span> pvParameters,  <span class="hljs-comment">// 传递给任务函数的参数</span></span><br><span class="hljs-params">    UBaseType_t uxPriority,    <span class="hljs-comment">// 任务优先级, 0 ~ configMAX_PRIORITIES - 1</span></span><br><span class="hljs-params">    TaskHandle_t *<span class="hljs-type">const</span> pxCreatedTask  <span class="hljs-comment">// 任务句柄,即任务的控制块</span></span><br><span class="hljs-params">)</span>;<br><span class="hljs-comment">// 返回值 pdPASS 表示创建成功. errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY 表示失败</span><br></code></pre></td></tr></table></figure></li><li><p>动态创建任务步骤</p><ul><li>将宏 <code>configSUPPORT_ALLOCATION</code> 配置为1</li><li>定义函数入口参数</li><li>编写任务函数</li><li><code>xTaskCreate</code> 创建的任务立刻进入就绪态,由任务调度器调度运行</li></ul></li><li><p>静态创建任务函数与动态的区别在于</p><ul><li>动态创建任务使用任务句柄作为参数</li><li>静态创建任务使用任务堆栈和任务控制块指针,返回任务句柄</li></ul></li><li><p>删除任务函数声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelete</span><span class="hljs-params">(TaskHandle_t xTaskToDelete)</span>;<br><span class="hljs-comment">// xTaskToDelete: 待删除任务的任务句柄</span><br><span class="hljs-comment">// 若传入 NULL: 删除任务自身(当前正在运行的任务)</span><br></code></pre></td></tr></table></figure><ul><li>被删除的任务将从就绪态任务列表, 阻塞态任务列表, 挂起态任务列表, 事件列表中移除</li><li>空闲任务负责释放被删除任务中系统分配的内存</li></ul></li></ol><h3 id="3-2-创建任务示例"><a href="#3-2-创建任务示例" class="headerlink" title="3.2 创建任务示例"></a>3.2 创建任务示例</h3><ol><li><p>目标: 使用 <code>xTaskCreate</code> 和 <code>vTaskDelete</code></p><ul><li><code>start_task</code>: 启动任务,用于创建其他任务</li><li><code>task1</code>: 让 LED1 每 500ms 闪烁一次</li><li><code>task2</code>: 让 LED2 每 500ms 闪烁一次</li><li><code>task3</code>: 判断 KEY1 是否按下,按下时删除 <code>task1</code></li></ul></li><li><p>创建 <code>task_test.h</code> 文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __TASK_TEST_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __TASK_TEST_H</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">freertos_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>创建 <code>task_test.c</code> 文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task_test.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FreeRTOS.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task.h&quot;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">start_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">task1</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">task2</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">task3</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">freertos_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">/* 1. 创建启动任务 */</span><br>    TaskHandle_t start_task_handler;<br>    xTaskCreate( (TaskFunction_t)start_task, <span class="hljs-string">&quot;start_task&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, &amp;start_task_handler);<br>    <span class="hljs-comment">/* 2. 启动调度器 */</span><br>    vTaskStartScheduler();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">start_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    taskENTER_CRITICAL();  <span class="hljs-comment">// 进入临界区.临界区的代码不会被打断</span><br>    <span class="hljs-comment">/* 1. 创建需要运行的任务 */</span><br>    <span class="hljs-type">static</span> TaskHandle_t task1_handler;<br>    <span class="hljs-type">static</span> TaskHandle_t task2_handler;<br>    <span class="hljs-type">static</span> TaskHandle_t task3_handler;<br>    xTaskCreate( (TaskFunction_t)task1, <span class="hljs-string">&quot;task1&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, &amp;task1_handler);<br>    xTaskCreate( (TaskFunction_t)task2, <span class="hljs-string">&quot;task2&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, &amp;task2_handler);<br>    xTaskCreate( (TaskFunction_t)task3, <span class="hljs-string">&quot;task3&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, &amp;task3_handler);<br>    <span class="hljs-comment">/* 2. 删除自身(启动任务),退出任务.因为启动任务只需执行一次 */</span><br>    vTaskDelete(<span class="hljs-literal">NULL</span>);<br>    taskEXIT_CRITICAL();  <span class="hljs-comment">// 退出临界区.与进入临界区成对出现</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">task1</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;task1 working...\n&quot;</span>);<br>        LED_Toggle(LED1_Pin);<br>        vTaskDelay(<span class="hljs-number">500</span>);  <span class="hljs-comment">// 该延时函数会让任务进入阻塞态</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">task2</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;task2 working...\n&quot;</span>);<br>        LED_Toggle(LED2_Pin);<br>        vTaskDelay(<span class="hljs-number">500</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">task3</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-type">uint8_t</span> key = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;task3 working...\n&quot;</span>);<br>        key = key_detect();<br>        <span class="hljs-keyword">if</span>(key == KEY1 &amp;&amp; task1_handler != <span class="hljs-literal">NULL</span>) &#123;<br>            vTaskDelete(task1_handler);<br>            task1_handler = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        vTaskDelay(<span class="hljs-number">500</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 <code>main.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task_test.h&quot;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    freertos_start();  <span class="hljs-comment">// 程序开启任务调度器后不会执行之后的代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-3-挂起和恢复"><a href="#3-3-挂起和恢复" class="headerlink" title="3.3 挂起和恢复"></a>3.3 挂起和恢复</h3><ol><li><p>挂起任务.类似暂停</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSuspend</span><span class="hljs-params">( TaskHandle_t xTaskToSuspend )</span>;<br><span class="hljs-comment">// xTaskToSuspend: 待挂起任务的任务句柄.为 NULL 表示挂起任务自身</span><br><span class="hljs-comment">// 需要将宏 INCLUDE_vTaskSuspend 配置为1</span><br></code></pre></td></tr></table></figure></li><li><p>恢复任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskResume</span><span class="hljs-params">( TaskHandle_t xTaskToResume )</span>;<br><span class="hljs-comment">// 需要将宏 INCLUDE_vTaskResume 配置为1</span><br><span class="hljs-comment">// 无论 suspend 多少次,只需 resume 一次.被恢复的任务重新进入就绪态</span><br></code></pre></td></tr></table></figure></li><li><p>在中断恢复被挂起的任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskResumeFromISR</span><span class="hljs-params">( TaskHandle_t xTaskToResume )</span>;<br><span class="hljs-comment">// 返回值: pdTRUE(pdFALSE) 表示任务恢复后需要(不需要)进行任务切换</span><br><span class="hljs-comment">// 需要将宏 INCLUDE_vTaskResume 和 INCLUDE_vTaskResumeFromISR 配置为1</span><br><span class="hljs-comment">// 在中断服务程序调用 Freertos 的 API 函数,要求中断优先级不高于 FreeRTOS 管理的最高中断优先级</span><br></code></pre></td></tr></table></figure></li><li><p>查看任务状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TRACE_FACILITY 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_STATS_FROMATTING_FUNCTIONS 1</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskList</span><span class="hljs-params">( <span class="hljs-type">char</span> *pcWriteBuffer )</span>;<br><span class="hljs-comment">// 输出格式形如:</span><br>名称   状态  优先级  堆栈使用  任务编号<br>task1   x      <span class="hljs-number">1</span>       <span class="hljs-number">79</span>       <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-中断管理"><a href="#3-4-中断管理" class="headerlink" title="3.4 中断管理"></a>3.4 中断管理</h3><ol><li><p>优先级配置</p><ul><li>STM32 通过优先级配置寄存器支持16级不同优先级中断.数字越小表示优先级越高(FreeRTOS 任务相反)</li><li>FreeRTOS 将 PendSV, SysTick 设为最低中断优先级(15),保证任务切换不会阻塞系统对其他中断的响应</li><li>FreeRTOS 通过 BASEPPRI 寄存器实现中断管理,屏蔽优先级低于某一阈值的中断</li><li>建议将所有的优先级指定为抢占优先级,方便 FreeRTOS 管理</li><li>在中断服务函数中调用 FreeRTOS 的 API 函数,必须使用 <code>From_ISR</code> 后缀的函数</li></ul></li><li><p>临界段代码</p><ul><li><p>临界区: 必须在不被打断的情况下完整运行的代码段.如对外设初始化有严格时序要求的代码</p></li><li><p>相关函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">taskENTER_CRITICAL();  <span class="hljs-comment">// 进入临界区</span><br>taskEXIT_CRITICAL();   <span class="hljs-comment">// 退出临界区</span><br>taskENTER_CRITICAL_FROM_ISR();<br>taskEXIT_CRITICAL_FROM_ISR();<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="3-5-时间片调度"><a href="#3-5-时间片调度" class="headerlink" title="3.5 时间片调度"></a>3.5 时间片调度</h3><ol><li>在 FreeRTOS 中,同等优先级的任务轮流分享相同的 CPU 时间.一个时间片的长度等同于 SysTick 中断的周期</li><li>延时函数<ul><li><code>vTaskDelay</code>: 相对延时.从执行该函数开始,直到延时完指定的参数</li><li><code>xTaskDelayUntil</code>: 绝对延时.将整个任务的运行周期视为整体.适合固定频率定期执行的任务</li></ul></li></ol><h2 id="4-消息队列"><a href="#4-消息队列" class="headerlink" title="4 消息队列"></a>4 消息队列</h2><ol><li><p>队列是任务间通信的主要形式,可用于任务之间以及中断和任务之间发送消息.特点有</p><ul><li>FIFO 顺序: 先进先出</li><li>线程安全: 队列操作时原子的</li><li>阻塞和非阻塞: 任务可通过阻塞和非阻塞的方式收发消息</li><li>优先级继承: 确保高优先级任务在队列操作期间不会被低优先级任务阻塞</li><li>可变长度项: 队列中的项可以是不同长度的数据块,而非固定大小</li></ul></li><li><p>队列 API</p><table><thead><tr><th>API 函数</th><th>描述</th></tr></thead><tbody><tr><td>xQueueCreate</td><td>动态方式创建队列</td></tr><tr><td>xQueueCreateStatic</td><td>静态方式创建队列</td></tr></tbody></table></li><li><p>向队列写入消息</p><table><thead><tr><th>API 函数</th><th>描述</th></tr></thead><tbody><tr><td>xQueueSend</td><td>向队列尾部写入消息</td></tr><tr><td>xQueueSendToFront</td><td>向队列头部写入消息</td></tr></tbody></table></li><li><p>从队列读取消息</p><table><thead><tr><th>API 函数</th><th>描述</th></tr></thead><tbody><tr><td>xQueueReceive</td><td>从队列头部读取消息,并删除消息</td></tr><tr><td>xQueuePeek</td><td>从队列头部读取消息,但不删除</td></tr></tbody></table></li></ol><h2 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5 信号量"></a>5 信号量</h2><ol><li><p>信号量是一种用于任务间同步和资源管理的机制.信号量可以是二值的(0 &#x2F; 1)或计数型(正整数)</p><ul><li>信号量的基础操作: 获取, 释放</li><li>管理对共享资源的访问,确保同一时刻只有一个任务可以访问共享资源</li><li>适用于对资源的互斥访问,控制任务的执行顺序.或限制同时访问某一资源的任务数量</li></ul></li><li><p>二值信号量: 主要用于共享资源的互斥访问 或 任务间同步</p><ul><li><p>0: 资源不可用. 1: 资源可用</p></li><li><p>二值信号量 API</p><table><thead><tr><th>API 函数</th><th>描述</th></tr></thead><tbody><tr><td>xSemaphoreCreateBinary</td><td>使用动态方式创建二值信号量</td></tr><tr><td>xSemaphoreGive</td><td>释放信号量</td></tr><tr><td>xSemaphoreTake</td><td>获取信号量</td></tr></tbody></table></li></ul></li><li><p>计数型信号量: 用于事件计数或资源数量计数</p><ul><li><p>计数型信号量 API</p><table><thead><tr><th>API 函数</th><th>描述</th></tr></thead><tbody><tr><td>xSemaphoreCreateCounting</td><td>使用动态方式创建计数型信号量</td></tr><tr><td>xSemaphoreGetCount</td><td>获取计数值</td></tr></tbody></table></li></ul></li><li><p>互斥信号量: 包含优先级继承机制的二值信号量,防止优先级翻转</p><ul><li>互斥信号量 API: <code>xSemaphoreCreateMutex</code> 动态创建互斥信号量</li></ul></li></ol><h2 id="6-事件标志组"><a href="#6-事件标志组" class="headerlink" title="6 事件标志组"></a>6 事件标志组</h2><ol><li>事件标志组是一个标志牌集合,每个标志位代表一种特定的状态或事件<ul><li>任务通过等待或设置这些标志位,实现任务之间的协同工作</li></ul></li><li>事件标志位可以规定将标志置1表示事件发生,0表示未发生<ul><li>事件标志位存储在单个无符号整数变量中.事件 0 存储于 bit0…</li></ul></li></ol><h2 id="7-任务通知"><a href="#7-任务通知" class="headerlink" title="7 任务通知"></a>7 任务通知</h2><ol><li>任务通知允许一个任务向其他任务发送简单的通知或信号,实现任务间的同步和协作<ul><li>任务通知通常替代二值信号量或事件标志组,提供更轻量级的任务间通信方式</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>FreeRTOS</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32</title>
    <link href="/2023/06/01/Embedded/STM32/"/>
    <url>/2023/06/01/Embedded/STM32/</url>
    
    <content type="html"><![CDATA[<h1 id="STM32"><a href="#STM32" class="headerlink" title="STM32"></a>STM32</h1><h2 id="0-开发板介绍"><a href="#0-开发板介绍" class="headerlink" title="0 开发板介绍"></a>0 开发板介绍</h2><h3 id="0-1-STM32-开发板"><a href="#0-1-STM32-开发板" class="headerlink" title="0.1 STM32 开发板"></a>0.1 STM32 开发板</h3><p><img src="/2023/06/01/Embedded/STM32/0-STM32F103C8T6-Board-Features.jpg"></p><ol><li>使用右侧 SWD 接口下载程序及供电</li><li>32.768KHz 晶振: 连接到 LSE(low-speed external clock signal),给 RTC 提供时钟.<br>如果无需使用掉电不丢失时间的功能,可去掉.由内部 40KHz 的 RC 时钟源给 RTC 提供时钟</li><li>8MHz 晶振: 连接到 HSE(high-speed external clock signal),给 SYSCLK 提供时钟.<br>由于芯片内部的 HSI RC 时钟源不够精准,<strong>通常采用外部独立时钟源来为芯片提供系统时钟</strong></li></ol><h3 id="0-2-开发板引脚图"><a href="#0-2-开发板引脚图" class="headerlink" title="0.2 开发板引脚图"></a>0.2 开发板引脚图</h3><p><img src="/2023/06/01/Embedded/STM32/0-STM32F103C8T6-Blue-Pill-Pin-Layout.gif"></p><h3 id="0-3-最小系统电路"><a href="#0-3-最小系统电路" class="headerlink" title="0.3 最小系统电路"></a>0.3 最小系统电路</h3><p><img src="/2023/06/01/Embedded/STM32/0-minimal-system-circuit.png"></p><ol><li>3V3 与 GND 间的 100nF 滤波电容: 保证供电电压的稳定</li><li><strong>晶振</strong>: 8MHz 晶振的典型电路.20pF 作为起振电容.接到芯片的5,6号脚.3,4号引脚预留接 32.768KHz 晶振</li><li><strong>复位</strong>: NRST 接到7号引脚,低电平复位<ul><li>刚上电时,电容充电,相当于短路,NRST 下拉至 GND(上电复位).充满电后短路,上拉至 3V3</li><li>之后,K1 断开时,NRST 拉至 3V3.K1 闭合时,电容放电,NRST 接地(手动复位)</li></ul></li><li><strong>启动配置</strong>: H1 起到开关的作用.实际中采用跳线帽的方式选择模式</li><li><strong>下载端口</strong>: SWDIO, SWCLK 分别接到芯片的34,37号引脚(PA13,14).正负极间同样可以加滤波电容</li></ol><h2 id="1-STM32"><a href="#1-STM32" class="headerlink" title="1 STM32"></a>1 STM32</h2><h3 id="1-1-STM32-命名规则"><a href="#1-1-STM32-命名规则" class="headerlink" title="1.1 STM32 命名规则"></a>1.1 STM32 命名规则</h3><p><img src="/2023/06/01/Embedded/STM32/1-STM32-naming.png"></p><h3 id="1-2-存储器和总线构架"><a href="#1-2-存储器和总线构架" class="headerlink" title="1.2 存储器和总线构架"></a>1.2 存储器和总线构架</h3><p><img src="/2023/06/01/Embedded/STM32/1-system-architecture.png"></p><h3 id="1-3-F103C8T6-引脚定义"><a href="#1-3-F103C8T6-引脚定义" class="headerlink" title="1.3 F103C8T6 引脚定义"></a>1.3 F103C8T6 引脚定义</h3><p><img src="/2023/06/01/Embedded/STM32/1-STM32F103C8T6-pin-define.png"></p><h3 id="1-4-片上资源-外设"><a href="#1-4-片上资源-外设" class="headerlink" title="1.4 片上资源(外设)"></a>1.4 片上资源(外设)</h3><table><thead><tr><th>英文缩写</th><th>名称</th><th>英文缩写</th><th>名称</th></tr></thead><tbody><tr><td>NVIC</td><td>嵌套向量中断控制器</td><td>CAN</td><td>CAN 通信</td></tr><tr><td>SysTick</td><td>系统滴答定时器</td><td>USB</td><td>USB 通信</td></tr><tr><td>RCC</td><td>复位和时钟控制</td><td>RTC</td><td>实时时钟</td></tr><tr><td>GPIO</td><td>通用 IO 口</td><td>CRC</td><td>CRC 校验</td></tr><tr><td>AFIO</td><td>复用 IO 口</td><td>PWR</td><td>电源控制</td></tr><tr><td>EXTI</td><td>外部中断</td><td>BKP</td><td>备份寄存器</td></tr><tr><td>TIM</td><td>定时器</td><td>IWDG</td><td>独立看门狗</td></tr><tr><td>ADC</td><td>模数转换器</td><td>WWDG</td><td>窗口看门狗</td></tr><tr><td>DMA</td><td>直接内存访问</td><td>DAC</td><td>数模转换器</td></tr><tr><td>USART</td><td>同步 &#x2F; 异步串口通信</td><td>SDIO</td><td>SD 卡接口</td></tr><tr><td>I2C</td><td>I2C 通信</td><td>FSMC</td><td>可变静态存储控制器</td></tr><tr><td>SPI</td><td>SPI 通信</td><td>USB OTG</td><td>USB 主机接口</td></tr></tbody></table><h2 id="2-工程建立"><a href="#2-工程建立" class="headerlink" title="2 工程建立"></a>2 工程建立</h2><h3 id="2-1-搭建开发环境"><a href="#2-1-搭建开发环境" class="headerlink" title="2.1 搭建开发环境"></a>2.1 搭建开发环境</h3><ol><li><p><strong>Keil5 MDK: IDE, 集成开发环境</strong></p><ul><li><p>运行 <code>MDK542a.exe</code> 文件,更改安装路径后,一路点击 <code>next</code> 即可</p></li><li><p>软件注册: 以管理员身份运行 Keil5 -&gt; <code>File</code> -&gt; <code>License Management</code> -&gt; 复制 CID</p><p><img src="/2023/06/01/Embedded/STM32/2-register-Keil.png"></p></li><li><p>运行 <code>keygen_new2032.exe</code> 文件 -&gt; 粘贴 <code>CID</code> -&gt; <code>Target</code> 选 <code>ARM</code> -&gt; 点击 <code>Generate</code> 生成序列码</p><p><img src="/2023/06/01/Embedded/STM32/2-keygen.png"></p></li><li><p>将序列码粘贴到 keil5 中的 <code>New License ID Code</code> 栏 -&gt; <code>ADD LIC</code></p></li></ul></li><li><p><strong>器件支持包: 对相应的 MCU 型号提供支持</strong></p><ul><li><p>离线安装: 下载后,运行相应的器件支持包文件即可(<code>Keil.STM32F1xx_DFP.2.2.0.pack</code>)</p></li><li><p>在线安装: 打开 Keil -&gt; <code>Pack Installer</code> -&gt; <code>Device</code> -&gt; <code>STMicroelectronics</code> -&gt; install 后缀 <code>DFP</code> 的文件</p><p><img src="/2023/06/01/Embedded/STM32/2-pack-installer.png"></p></li></ul></li><li><p><strong>STLink 驱动</strong>: Keil5 安装目录中自带(<code>Keil5\ARM\STLink\USBDriver\dpinst_amd64.exe</code>)</p></li><li><p><strong>JLink 驱动</strong>: 同样位于 Keil5 安装目录中(<code>Keil5\ARM\Segger\JLink.exe</code>)</p></li><li><p><strong>USB 转串口驱动</strong>: 运行 <code>CH341SER.EXE</code></p></li><li><p>STM32 开发方式</p><ul><li>基于寄存器: STM32 结构复杂,寄存器数量太多,不推荐</li><li>基于库函数: 使用 ST 官方提供的函数,间接配置寄存器(官方停止维护)</li><li>基于 HAL 库: 图形化界面配置 STM32(官方主推)</li></ul></li><li><p>基于库函数需要 STM32 库函数的文件(固件库)</p></li></ol><h3 id="2-2-寄存器开发"><a href="#2-2-寄存器开发" class="headerlink" title="2.2 寄存器开发"></a>2.2 寄存器开发</h3><ol><li><p>在 Keil5 中 -&gt; <code>Project</code> -&gt; <code>New uVision Project</code> -&gt; 设置工程文件名(project) -&gt; 选择芯片型号</p><ul><li><p>此时工程目录下将会有一个 <code>project.uvprojx</code> 文件.该文件为 keil 工程文件</p></li><li><p>配合使用 git 管理代码版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init<br></code></pre></td></tr></table></figure></li><li><p>创建 <code>.gitignore</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">.vscode/<br>DebugConfig/<br>Listings/<br>Objects/<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>添加固件库文件: 在工程目录中创建 Start 目录存放下列启动文件(STM32程序从启动文件开始执行)</strong></p><p><img src="/2023/06/01/Embedded/STM32/2-Start-directory.png"></p></li><li><p><strong>将文件添加到工程</strong></p><ul><li><p>将左侧的 <code>Source Group 1</code> 改名为 <code>Start</code> -&gt; 右击后选择 <code>Add Existing Files to Group</code> 添加文件</p><p><img src="/2023/06/01/Embedded/STM32/2-add-start-file.png"></p></li><li><p>启动文件需要根据型号选择(这里选择仅 <code>startup_stm32f10x_md.s</code>)</p></li></ul></li><li><p><strong>添加文件夹的头文件路径</strong>: <code>Options</code> -&gt; <code>C/C++</code> -&gt; 在 <code>Include Paths</code> 栏添加路径</p></li><li><p><strong>编写测试函数</strong>: 首先创建 User 目录用于存放用户代码</p><ul><li><p>创建 <code>main.c</code> 文件并添加到工程</p><ul><li><p>右键 <code>Target</code> -&gt; <code>Add Group</code> 并将名称改为 <code>User</code> -&gt; 右键 <code>Add New item...</code></p></li><li><p>选择 <code>C File</code> -&gt; 名称设为 <code>main</code> -&gt; 修改文件存放路径为 <code>User</code> 目录</p></li></ul></li><li><p>测试配置: 打开 <code>main</code> 文件在空白处右击,选择 insert <code>#include file stm32f10x.h</code> -&gt; 编写任意代码 -&gt; <code>Build</code></p></li><li><p>若编译没有错误说明工程建立正常.到此可以进行<strong>基于寄存器的开发</strong>.如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;  <span class="hljs-comment">/* 点亮 PC13 的 LED */</span><br>RCC-&gt;APB2ENR |= <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<span class="hljs-comment">/* 开启 APB2 的 GPIOC 时钟 */</span><br>GPIOC-&gt;CRH |= <span class="hljs-number">3</span> &lt;&lt; (<span class="hljs-number">4</span> * (<span class="hljs-number">13</span> - <span class="hljs-number">8</span>));<span class="hljs-comment">/* 指定 GPIO_Pin_13 为推挽输出.50MHz */</span><br>GPIOC-&gt;ODR &amp;= !(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">13</span>);<span class="hljs-comment">/* 指定 GPIO_Pin_13 引脚的电压为低 */</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>连接最小系统板时需要选择对应的调试方式(这里使用 STLink)</p><ul><li><p><code>Options</code> -&gt; <code>Debug</code> -&gt; Use 栏选择 <code>ST-Link Debugger</code> -&gt; <code>Settings</code> -&gt; <code>Flash Download</code> -&gt; 勾选 <code>Reset and Run</code></p><p><img src="/2023/06/01/Embedded/STM32/2-debug-config.png"></p></li></ul></li></ol><h3 id="2-3-标准库开发"><a href="#2-3-标准库开发" class="headerlink" title="2.3 标准库开发"></a>2.3 标准库开发</h3><ol><li><p>在工程新建 <code>Library</code> 目录,添加 <code>Libraries\STM32F10x_StdPeriph_Driver\src, inc</code> 目录下的所有文件(各23个)</p></li><li><p>将 <code>Project\STM32F10x_StdPeriph_Template</code> 目录下的三个文件添加到工程的 <code>User</code> 目录</p><p><img src="/2023/06/01/Embedded/STM32/2-User-directory.png"></p></li><li><p>添加全局宏定义</p><ul><li><p>打开 <code>&quot;stm32f10x.h&quot;</code> 文件,在文件末尾有条件编译语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_STDPERIPH_DRIVER</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x_conf.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>因此需要宏定义 <code>USE_STDPERIPH_DRIVER</code>: <code>Options</code> -&gt; 在 <code>C/C++ Define</code> 栏填 <code>USE_STDPERIPH_DRIVER</code></p></li></ul></li><li><p>需要再次完成 <strong>将文件添加到工程,添加文件夹的头文件路径</strong> 步骤</p></li><li><p>至此可以进行<strong>基于库函数的开发</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-comment">/* 配置 GPIOC.并设置为: 推挽输出,引脚选中13, 速率50MHz */</span><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);<br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOC, &amp;GPIO_InitStructure);<br>GPIO_ResetBits(GPIOC, GPIO_Pin_13);  <span class="hljs-comment">// 将 PC13 置为低电平</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>库函数调用逻辑: 复位中断函数才是程序的入口(在复位后执行).其职责为调用 <code>SystemInit, main</code> 函数</p><p><img src="/2023/06/01/Embedded/STM32/2-Engineering-architecture.png"></p></li></ol><h3 id="2-4-Keil5-使用"><a href="#2-4-Keil5-使用" class="headerlink" title="2.4 Keil5 使用"></a>2.4 Keil5 使用</h3><ol><li><strong>界面设置(Configuration)</strong><ul><li><code>Configuration</code> -&gt; <code>Color &amp; Fonts</code> -&gt; <code>C/C++ Editor files</code> -&gt; 设置字体及其大小</li><li><code>Configuration</code> -&gt; <code>Editor</code> -&gt; <code>Encoding</code> 改为 <code>UTF-8</code> 编码, <code>Tab Size</code> 改为4</li><li><code>Manage Project Items</code> -&gt; 可以调整左侧文件显示的顺序</li></ul></li><li>Keil 中直接写入汉字报错的解决方式<ul><li><code>Options</code> -&gt; <code>C/C++</code> -&gt; <code>Misc Controls</code> 栏填入 <code>--no-multibyte-chars</code></li></ul></li></ol><h3 id="2-5-串口下载"><a href="#2-5-串口下载" class="headerlink" title="2.5 串口下载"></a>2.5 串口下载</h3><ol><li><p>启动模式</p><table><thead><tr><th>BOOT1</th><th>BOOT 0</th><th>启动模式</th><th>说明</th></tr></thead><tbody><tr><td>X</td><td>0</td><td>主闪存存储器</td><td><strong>主闪存存储器被选为启动区域(主要使用方式)</strong></td></tr><tr><td>0</td><td>1</td><td>系统存储器</td><td>系统存储器被选为启动区域.运行 BootLoader(串口下载)</td></tr><tr><td>1</td><td>1</td><td>内置 SRAM</td><td>内置 SRAM 被选为启动区域(程序调试)</td></tr></tbody></table></li><li><p>FlyMcu 串口下载程序</p><ul><li><p>需要连接 USB转串口模块的 RX(PA9), TX(PA10), GND</p></li><li><p>需要工程生成的 HEX 文件(在 Keil 中 <code>Options for target</code> -&gt; <code>output</code> 勾选 <code>Creact HEX File</code>)</p><p><img src="/2023/06/01/Embedded/STM32/2-CreateHEX.png"></p></li><li><p><code>搜索串口</code> -&gt; bps 默认115200 -&gt; 选择下载的程序文件(.hex)</p></li><li><p>单片机引脚配置: 让STM32执行 <code>BootLoader</code> 程序</p><ul><li>将 Boot0 配置为1(插在右边), Boot1 配置为0(插在左边)</li><li>按下复位键,此时 STM32 将不断接收 USART1 的数据.刷新到主闪存</li></ul></li><li><p>点击<code>开始编程</code>.写入完成后,将 Boot0 配置为0(插在左边).按下复位键.程序开始执行</p><p><img src="/2023/06/01/Embedded/STM32/2-FlyMcu.png"></p></li></ul></li><li><p><strong>STM32 一键下载</strong>(需要搭建另外的电路)</p><ul><li>但是仍可以勾选<code>编程后执行</code>,反勾选<code>编程到FLASH时写选项字节</code></li><li>然后 boot0 选为1 -&gt; 按下复位键 -&gt; 下载程序.完成下载后程序会直接运行</li><li>原理为指定运行程序从 0800 0000 开始运行.复位其本质后仍执行 <code>BootLoader</code> 程序</li></ul></li><li><p>ST-LINK Utility(需连接 ST Link 下载)</p><p><img src="/2023/06/01/Embedded/STM32/2-ST-LINK-Utility.png"></p><ul><li><strong><code>Target</code> -&gt; <code>Option Bytes</code>(快捷键 Ctrl + B): 打开选项字节的设置页面</strong></li></ul></li></ol><h3 id="2-6-HAL-库开发"><a href="#2-6-HAL-库开发" class="headerlink" title="2.6 HAL 库开发"></a>2.6 HAL 库开发</h3><ol><li><p>CubeMX <a href="https://www.st.com/en/development-tools/stm32cubemx.html">官网下载</a></p><ul><li><p>运行 <code>SetupSTM32CubeMX-6.12.1-Win.exe</code> 安装 CubeMX</p></li><li><p>注意第一次需要使用管理员权限打开</p></li><li><p>安装支持包(在线安装): Help -&gt; Manage embedded software packages.选择对应版本下载</p><p><img src="/2023/06/01/Embedded/STM32/2-Cube-pack-manager.png"></p></li><li><p>创建项目: Access to MCU selector -&gt; 选择相应 MCU</p><p><img src="/2023/06/01/Embedded/STM32/2-Cube-pin.png"></p></li><li><p><strong>引脚配置</strong></p><ul><li><strong>RCC 选择 Crystal&#x2F;Ceramic Resonator</strong></li><li><strong>SYS 中 Debug 选择 Serial Wire</strong></li><li><strong>PC13 选择 GPIO_Output</strong></li></ul></li><li><p><strong>时钟配置: HCLK 设为72MHz</strong></p><p><img src="/2023/06/01/Embedded/STM32/2-Cube-clock.png"></p></li><li><p>项目配置</p><ul><li><p>需要指定项目名称, IDE 选择 <code>MDK-ARM</code></p></li><li><p>在 <code>Code Generator</code> 中勾选 <code>Generate peripheral initialization as a pair of &quot;.c/.h&quot; files per peripheral</code></p><p><img src="/2023/06/01/Embedded/STM32/2-Cube-project-config.png"></p></li></ul></li></ul></li></ol><h3 id="2-7-VSCode-插件"><a href="#2-7-VSCode-插件" class="headerlink" title="2.7 VSCode 插件"></a>2.7 VSCode 插件</h3><ol><li><p>VSCode <a href="https://code.visualstudio.com/">官网下载</a></p><ul><li><p>安装插件: <code>C/C++, Keil Assistant</code></p><p><img src="/2023/06/01/Embedded/STM32/2-VSCode-plug.png"></p></li><li><p>关联 Keil: 设置中搜索 keil, 在 <code>Keil Assistant.MDK: Uv4 Path</code> 栏指定 UV4 路径</p><p><img src="/2023/06/01/Embedded/STM32/2-Keil4-path.png"></p></li><li><p>在资源管理器中将会新增 keil 栏.可以进行编译下载(其本质仍是调用 Keil 的配置)</p><p><img src="/2023/06/01/Embedded/STM32/2-Keil.png"></p></li></ul></li></ol><h2 id="3-GPIO-输入输出"><a href="#3-GPIO-输入输出" class="headerlink" title="3 GPIO 输入输出"></a>3 GPIO 输入输出</h2><h3 id="3-1-GPIO-结构"><a href="#3-1-GPIO-结构" class="headerlink" title="3.1 GPIO 结构"></a>3.1 GPIO 结构</h3><ol><li><p>GPIO 基本结构</p><p><img src="/2023/06/01/Embedded/STM32/3-GPIO-struct.png"></p><ul><li>I&#x2F;O 引脚连接驱动器寄存器到 APB2</li><li>内核写入(读取)输出寄存器(输入寄存器),以此控制(读取) I&#x2F;O 引脚的高低电平</li></ul></li><li><p>IO 口的基本结构</p><p><img src="/2023/06/01/Embedded/STM32/3-IOpin-struct.png"></p></li><li><p>输入电路分析</p><ul><li><code>保护二极管</code>对输入电压进行限幅: 确保输入电压范围在 $V_{SS} \sim V_{DD}$</li><li><code>上拉电阻和下拉电阻</code>: 避免引脚悬空导致的输入数据不确定, 设定一个默认值<ul><li>上方闭合,下方断开: <strong>上拉输入模式,即默认高电平</strong></li><li>上方断开,下方闭合: <strong>下拉输入模式,即默认低电平</strong></li><li>开关均断开: <strong>浮空输入模式</strong></li></ul></li><li><code>施密特触发器</code>(图中翻译错误): 对输入电压整形,然后写入<code>输入数据寄存器</code><ul><li>输入电压大于某个上限,输出瞬间升为高电平;</li><li>输入电压小于某个下限,输出瞬间将为低电平;否则不变</li></ul></li><li>模拟输入, 复用功能输入<ul><li><strong>模拟输入</strong>需要连续量,因此在施密特触发器之前.连接到 ADC.此时 GPIO 失效</li><li><strong>复用功能输入</strong>(如串口的输入引脚)需要数字量,因此在施密特触发器之后</li></ul></li></ul></li><li><p>输出电路分析: 输出可由 <code>输出数据寄存器</code>(普通IO输出) 或 <code>片上外设</code>(<strong>复用功能输出</strong>) 控制</p><ul><li><code>位设置/清除寄存器</code>: 单独操作输出数据寄存器的某一位, 而不影响其他位<br>将需要置1的对应写1,其余写0,即可自动将相应位置置1,其他位不变</li><li><code>输出数据寄存器</code>: 输出整个寄存器的数据.只能整体写入,不能单独操作某一位</li><li><code>数据输出选择器</code>: 选择由输出数据寄存器或是复用功能输出</li><li><code>P-MOS, N-MOS</code>的作用: 输出控制<ul><li>当 P-MOS,N-MOS 均有效时为<strong>推挽输出</strong>, 高低电平均有驱动能力</li><li>当 P-MOS 无效, N-MOS 有效时为<strong>开漏输出</strong>,仅低电平具有驱动能力<ul><li>当数据寄存器为1时,N-MOS 断开,呈现出高阻态</li><li>当数据寄存器为0时,N-MOS 导通,输出低电平</li><li>开漏输出模式可以用于通信协议的驱动,如 I2C</li><li>开漏输出模式输出 5V 信号: 在 I&#x2F;O 口外接一个上拉电阻到 5V 电源正极</li></ul></li><li>当 P-MOS N-MOS 均无效时,输出关闭,端口电平由外部控制</li></ul></li></ul></li></ol><h3 id="3-2-标准库代码分析"><a href="#3-2-标准库代码分析" class="headerlink" title="3.2 标准库代码分析"></a>3.2 标准库代码分析</h3><ol><li><p>对 <code>stm32f10x_gpio.h, stm32f10x_gpio.c</code> 源码的分析</p></li><li><p><strong>头文件中的通用格式</strong>: 防止重复包含以及保证对 C++ 的兼容性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __STM32F10x_GPIO_H  <span class="hljs-comment">/* 防止头文件重复包含 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __STM32F10x_GPIO_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus  <span class="hljs-comment">/* 对 C++ 的兼容 */</span></span><br> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* 对 C++ 的兼容 */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __STM32F10x_GPIO_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>参数合理性判断</strong>: 对于后续编写的函数,需要判断传入参数是否为 GPIO.在调用函数前断言</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOB) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOC) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOD) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOE) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOF) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOG))</span><br><br><span class="hljs-comment">/* 分析: 断言参数 expr.若非零,则通过.否则断言失败,直接在编译时报错,并指出错误位置 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))</span><br></code></pre></td></tr></table></figure></li><li><p><strong>枚举定义</strong>: 初始化时,需要根据手册中的位组合确定模式时,提前对其定义.枚举非常多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 分析: 对于输出最大速率寄存器的组合,在这里直接定义为对应的值,方便使用 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>  GPIO_Speed_10MHz = <span class="hljs-number">1</span>,<span class="hljs-comment">/* MODE = 01 */</span><br>  GPIO_Speed_2MHz,<span class="hljs-comment">/* MODE = 10 */</span><br>  GPIO_Speed_50MHz<span class="hljs-comment">/* MODE = 11 */</span><br>&#125; GPIOSpeed_TypeDef;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-3-HAL-库"><a href="#3-3-HAL-库" class="headerlink" title="3.3 HAL 库"></a>3.3 HAL 库</h3><ol><li><p>使用 HAL 库使 led 闪烁</p><p><img src="/2023/06/01/Embedded/STM32/3-GPIO-HAL.png"></p></li></ol><h3 id="3-4-中断方式读取按键"><a href="#3-4-中断方式读取按键" class="headerlink" title="3.4 中断方式读取按键"></a>3.4 中断方式读取按键</h3><ol><li><p>按键操作定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 操作定义</span><br><span class="hljs-comment">** 短按: 按下时间 &lt; 1秒</span><br><span class="hljs-comment">** 长按: 按下时间 &gt; 1秒</span><br><span class="hljs-comment">** </span><br><span class="hljs-comment">** 按键事件</span><br><span class="hljs-comment">** 长按事件: 出现1次长按操作</span><br><span class="hljs-comment">** 单击事件: 1次短按后,间隔0.5秒内无操作</span><br><span class="hljs-comment">** 双击事件: 2次短按时间 &lt; 0.5秒.则这2次短按产生一次双击事件</span><br><span class="hljs-comment">** 特别的:   短按 + 0.5秒内长按不算双击.长按 + 0.5秒内短按也不算双击</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>实现思路</p></li></ol><h2 id="4-EXTI-外部中断"><a href="#4-EXTI-外部中断" class="headerlink" title="4 EXTI 外部中断"></a>4 EXTI 外部中断</h2><h3 id="4-1-中断"><a href="#4-1-中断" class="headerlink" title="4.1 中断"></a>4.1 中断</h3><ol><li><p>中断系统</p><ul><li>中断允许微控制器在执行主程序的同时,对发生的特定事件做出及时响应</li><li>在 STM32 中,中断用于处理外部事件,如按键输入,定时器溢出,串口数据接收等</li><li><strong>中断处理程序: 一段特殊的代码,用于处理中断事件</strong></li><li>当中断发生时,自动跳转到对应中断向量表项中存储的中断处理程序地址,并执行其中的代码</li></ul></li><li><p>中断向量表</p><ul><li><strong>中断处理程序的入口地址存储在中断向量表中</strong></li><li>中断向量表是一个存储中断处理程序地址的数组,每个中断都有一个对应的向量表项</li></ul></li><li><p><strong>中断优先级: 每个中断都有一个优先级,用于确定中断的相对重要性</strong></p><ul><li>较高优先级的中断将优先处理,而较低优先级的中断可能会被延迟处理</li><li><strong>中断嵌套: 即在一个中断处理程序中,可以允许更高优先级的中断打断当前正在执行的中断处理程序.以确保对于紧急事件的及时响应</strong></li></ul></li></ol><h3 id="4-2-NVIC"><a href="#4-2-NVIC" class="headerlink" title="4.2 NVIC"></a>4.2 NVIC</h3><p><img src="/2023/06/01/Embedded/STM32/4-NVIC.png"></p><ol><li><strong>NVIC(Nested Vectored Interrupt Controller, 嵌套向量中断控制器)是内核外设</strong><ul><li>中断通道可以将 EXTI, TIM, ADC, USART… 作为输入</li><li>只有一条输出通道,根据中断优先级分配先后顺序</li></ul></li><li>优先级分组: 由优先级寄存器的4位决定<ul><li>优先级寄存器分为高 n 位的抢占优先级和低 (4-n) 位的响应优先级</li><li><strong>抢占优先级可以中断嵌套,响应优先级则需要进行排队</strong></li></ul></li><li>优先级规则<ul><li>优先级数字越小,优先级越高.如果不设置优先级,默认为0</li><li>若抢占优先级和响应优先级都一样,则查找中断向量表,值小的先响应</li></ul></li></ol><h3 id="4-3-EXTI"><a href="#4-3-EXTI" class="headerlink" title="4.3 EXTI"></a>4.3 EXTI</h3><ol><li><p>EXTI 基本结构</p><p><img src="/2023/06/01/Embedded/STM32/4-EXTI.png"></p></li><li><p><strong>EXTI(Extern Interrupt, 外部中断)</strong></p><ul><li>EXTI 可以监测指定 GPIO 口的电平信号,当其指定的 GPIO 口产生电平变化时,EXTI 将立即向 NVIC 发出中断申请,经过 NVIC 裁决后即可中断 CPU 主程序,使 CPU 执行 EXTI 对应的中断程序</li><li>支持所有的 GPIO 口.但同 Pin 不能同时触发</li><li><strong>触发方式: 上升 &#x2F; 下降 &#x2F; 双边沿, 软件触发</strong></li><li>通道数: 16个 GPIO_Pin, PVD 输出, RTC 闹钟, USB 唤醒, 以太网唤醒</li></ul></li><li><p>响应方式</p><ul><li><strong>中断响应: 正常中断流程,申请中断</strong></li><li><strong>事件响应: 不申请中断,通向其他外设,触发其他外设的操作</strong></li></ul></li><li><p>判断代码是否成功进入中断的方法</p><ul><li>进入调试模式,在中断函数设置一个断点</li><li>选择全速运行代码,手动触发一个中断条件,使代码进入中断</li><li>如果代码运行到设置的断点处,说明进入了中断</li></ul></li></ol><h3 id="4-4-AFIO"><a href="#4-4-AFIO" class="headerlink" title="4.4 AFIO"></a>4.4 AFIO</h3><ol><li><p><strong>AFIO 功能: 引脚复用功能重映射, 中断引脚选择</strong></p></li><li><p>中断引脚选择: PA0~PG0 只能有一个通过 AFIO 的选择到达 EXTI</p><p><img src="/2023/06/01/Embedded/STM32/4-AFIO.png"></p></li><li><p>AFIO 引脚重映射(以 TIM2 的 CH1 为例)</p><ul><li><p>TIM2 的 CH1 原本位于 PA0.可以将其重映射到 PA15</p><p><img src="/2023/06/01/Embedded/STM32/4-AFIO-redefine.png"></p></li><li><p>因此,可以使用部分重映射1或完全重映射实现使用 PA15 作为 TIM2 的 CH1</p></li><li><p>需要注意的是,PA15 原本的功能是作为 JTAG 的调试功能,因此还需要将其关闭,作为普通 GPIO 引脚</p><p><img src="/2023/06/01/Embedded/STM32/4-JTAG-disable.png"></p></li></ul></li></ol><h3 id="4-5-HAL-库操作"><a href="#4-5-HAL-库操作" class="headerlink" title="4.5 HAL 库操作"></a>4.5 HAL 库操作</h3><ol><li><p>直接在引脚上选择 GPIO_EXTI</p><p><img src="/2023/06/01/Embedded/STM32/4-HAL-EXTI-pin.png"></p></li><li><p>在 GPIO 中选择其配置</p><p><img src="/2023/06/01/Embedded/STM32/4-HAL-EXTI-pin-config.png"></p></li><li><p>enable EXTI 中断线</p><p><img src="/2023/06/01/Embedded/STM32/4-NVIC-enable.png"></p></li><li><p>在 NVIC 中配置优先级(注意 hal_delay 的实现依赖于 SysTick 中断,因此若在中断使用 delay 需要 SysTick 优先级高于当前中断)</p><p><img src="/2023/06/01/Embedded/STM32/4-NVIC-priority.png"></p></li><li><p>生成的代码主要关注 <code>stm32f1xx_it.c</code> 文件,会增加一个中断处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* This function handles EXTI line1 interrupt. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">EXTI1_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  HAL_GPIO_EXTI_IRQHandler(key1_Pin);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>其底层会调用到一个弱实现的回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span> &#123;<br>  <span class="hljs-comment">/* EXTI line interrupt detected */</span><br>  <span class="hljs-keyword">if</span> (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != <span class="hljs-number">0x00u</span>) &#123;<br>    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);<br>    HAL_GPIO_EXTI_Callback(GPIO_Pin);<br>  &#125;<br>&#125;<br><br>__weak <span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_Callback</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span> &#123;<br>  UNUSED(GPIO_Pin);  <span class="hljs-comment">/* Prevent unused argument(s) compilation warning */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>因此可以通过重新实现回调函数来执行逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_Callback</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span> &#123;<br>  <span class="hljs-keyword">if</span> (GPIO_Pin == key1_Pin)<br>      <span class="hljs-comment">// 具体逻辑...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="5-TIM-定时器"><a href="#5-TIM-定时器" class="headerlink" title="5 TIM 定时器"></a>5 TIM 定时器</h2><h3 id="5-1-定时器"><a href="#5-1-定时器" class="headerlink" title="5.1 定时器"></a>5.1 定时器</h3><ol><li><p><strong>定时器: 对输入时钟计数,在计数值达到设定值时触发中断</strong></p><ul><li>基本定时功能: 每隔一段时间产生一个中断</li><li>定时器输出比较: 常用来产生 PWM 波形</li><li>定时器输入捕获: 测量方波频率</li><li>定时器编码器接口: 读取正交编码器的输出波形</li></ul></li><li><p>定时器类型</p><table><thead><tr><th><strong>类型</strong></th><th align="left"><strong>编号</strong></th><th><strong>总线</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>基本定时器</td><td align="left">TIM6 &amp; TIM7</td><td>APB1</td><td>定时中断, 主模式触发 DAC</td></tr><tr><td>通用定时器</td><td align="left">TIM2 ~ TIM5</td><td>APB1</td><td>拥有基本定时器全部功能. 额外具有: 内外时钟源选择,<br />输入捕获输出比较, 编码器接口, 主从触发模式等功能</td></tr><tr><td>高级定时器</td><td align="left">TIM1 &amp; TIM8</td><td>APB2</td><td>拥有通用定时器全部功能. 额外具有: 重复计数器,<br />死区生成, 互补输出, 刹车输入等功能</td></tr></tbody></table></li><li><p>基本定时器</p><p><img src="/2023/06/01/Embedded/STM32/5-basic-timer.png"></p><ul><li><strong>时基单元: 最基本的计数计时电路</strong><ul><li><code>PSC 预分频器</code>: 对 72MHz 的时钟进行预分频.实际分频系数 &#x3D; PSC + 1</li><li><code>CNT 计数器</code>: 对预分频后的时钟进行计数.每有一个上升沿,CNT ++</li><li><code>ARR 自动重装载寄存器</code>: 存储计数目标.<strong>当计数值 &#x3D;&#x3D; 重装值时,产生一个中断信号,并清零计数器</strong></li></ul></li><li><strong>主模式输出: 可以将定时器的更新事件映射到触发控制器(TRGO),TRGO 接到 DAC 的触发转换引脚</strong></li></ul></li><li><p>通用定时器</p><p><img src="/2023/06/01/Embedded/STM32/5-universal-timer.png"></p><ul><li><strong>通用计时器的时基单元: 通用定时器包含基本定时器的电路.时基单元是相似的</strong></li><li>内外时钟选择:<code>TIMx_ETR</code>引脚接一个外部方波时钟.经过<code>极性选择,边沿检测,预分频器,输入滤波</code>后分为两路<ul><li>向上进入<code>触发控制器</code>,作为时基单元的时钟</li><li>向下进入<code>TRGI</code>,用作触发输入.触发定时器的从模式</li></ul></li><li><code>ITR</code> 信号: 来自其他定时器从 <code>TRGO</code> 的输出</li><li><code>TIIF_ED</code>: 连接到输入捕获单元的 CH1 引脚</li><li><code>TI1FP1, TI2FP2</code>: 连接到输入滤波器和边沿检测器的后面</li><li><strong>主模式输出: TRGO 可将内部的事件映射到 TRGO 引脚</strong></li></ul></li><li><p>高级定时器</p><p><img src="/2023/06/01/Embedded/STM32/5-advanced-timer.png"></p><ul><li>高级定时器包含了通用定时器的电路.额外增加了下列内容<ul><li>申请中断的后面加入一个 <code>REP</code> 重复次数计数器,可以每个几个计数周期才发生一次更新事件&#x2F;中断</li><li><code>DTG</code> 寄存器: 死区生成电路.右侧输出引脚变为了两个,可以输出一对互补的 PWM 波</li><li><code>TIMxBKIN</code>: 若 <code>TIMxBKIN</code> 引脚产生刹车信号或内部时钟失效,将由控制电路自动切断电机输出</li></ul></li></ul></li></ol><h3 id="5-2-时基单元"><a href="#5-2-时基单元" class="headerlink" title="5.2 时基单元"></a>5.2 时基单元</h3><ol><li><p>预分频时序图</p><p><img src="/2023/06/01/Embedded/STM32/5-count-timing-sequence-1-2.png"></p><ul><li><p><code>预分频缓冲器(影子寄存器)</code>: 实际上起作用的寄存器.预分频控制寄存器修改后,为保证此计数周期内频率一致.<br>该修改并不立即生效,在本次计数结束后才生效.<code>自动加载寄存器, 捕获 / 比较寄存器</code>同样有影子寄存器</p></li><li><p>计数器计数频率公式<br>$$<br>\mathrm{CK_CNT} &#x3D; \frac{\mathrm{CK_PSC}}{\mathrm{(PSC +1)}}<br>$$</p></li></ul></li><li><p>计数器时序图</p><p><img src="/2023/06/01/Embedded/STM32/5-count-timing-sequence.png"></p><ul><li><strong>计数器溢出频率公式</strong><br>$$<br>\mathrm{freq} &#x3D; \frac{\mathrm{CK_CNT}}{\mathrm{(ARR + 1)}}<br>&#x3D; \frac{\mathrm{CK_PSC}}{\mathrm{(PSC +1)(ARR + 1)}}<br>$$</li></ul></li></ol><h3 id="5-3-RCC-时钟树"><a href="#5-3-RCC-时钟树" class="headerlink" title="5.3 RCC 时钟树"></a>5.3 RCC 时钟树</h3><p><img src="/2023/06/01/Embedded/STM32/5-RCC-clock-tree.png"></p><ol><li>RCC 产生和配置时钟,然后发送给各个外设的系统<ul><li><strong>时钟是所有外设运行的基础,需要最先配置</strong></li><li>左侧为时钟产生电路,右侧为时钟分配电路.中间的 <code>SYSCLK</code> 为系统时钟(72MHz)</li></ul></li><li><strong>程序在 <code>main</code> 函数之前会执行 <code>SystemInit</code> 函数,以配置时钟树</strong><ul><li>首先尝试以 线路1 按照 8MHz 频率运行,稳定后切换为 线路2</li><li>CSS 可以检测时钟运行是否正常.若出错会切换到内部时钟</li></ul></li></ol><h3 id="5-4-定时中断"><a href="#5-4-定时中断" class="headerlink" title="5.4 定时中断"></a>5.4 定时中断</h3><ol><li><p>定时中断基本结构</p><p><img src="/2023/06/01/Embedded/STM32/5-timer-interrupt-struct.png"></p></li><li><p>基本定时中断配置步骤</p><ul><li>开启 RCC 的 TIM 外设时钟</li><li>时基单元的时钟源选择(选择内部时钟模式). 配置时基单元</li><li>配置中断输出控制,允许更新中断输出到 NVIC. 配置 NVIC,打开定时器的中断通道</li></ul></li></ol><h3 id="5-5-输出比较"><a href="#5-5-输出比较" class="headerlink" title="5.5 输出比较"></a>5.5 输出比较</h3><ol><li><p><strong>OC(Output Compare, 输出比较)</strong></p><ul><li><strong>通过比较 CNT 和 CCR 寄存器值(CNT 计数自增,CCR 手动给定).</strong><br><strong>然后对输出电平 置1 &#x2F; 置0 &#x2F; 翻转,实现输出一定频率和占空比的 PWM 波形</strong></li><li>每个高级寄存器(前3个通道拥有死区生成和互补输出功能)和通用寄存器均拥有4个输出比较通道</li><li>CCR 被输入捕获和输出比较共用<ul><li>使用输入捕获时,CCR 作为捕获寄存器</li><li>使用输出比较时,CCR 作为比较寄存器</li></ul></li></ul></li><li><p><strong>PWM(Pulse Width Modulation 脉冲宽度调制)</strong></p><ul><li>在惯性系统中,可以通过对一系列脉冲的宽度进行调制,来等效地获得所需要的模拟参量</li><li>参数: 频率: $freq &#x3D; \frac{1}{T_S}$, 占空比: $duty &#x3D; \frac{T_{ON}}{T_S}$, 分辨率: 占空比变化步距(1%即可)<br>其中 $T_S$ 为周期(高低电平变化一次的时间), $T_{ON}$ 为周期中高电平的维持时间</li></ul></li><li><p>捕获 &#x2F; 比较通道</p><p><img src="/2023/06/01/Embedded/STM32/5-capture-channel.png"></p></li><li><p>输出比较模式(输出模式控制器)</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>冻结</td><td>CNT&#x3D;CCR 时,REF 保持为原状态.即维持为暂停时刻的状态不变</td></tr><tr><td>匹配时置有效电平</td><td>CNT&#x3D;CCR 时,REF 置有效电平</td></tr><tr><td>匹配时置无效电平</td><td>CNT&#x3D;CCR 时,REF 置无效电平</td></tr><tr><td>匹配时电平翻转</td><td>CNT&#x3D;CCR 时,REF 电平翻转</td></tr><tr><td>强制为无效电平</td><td>CNT 与 CCR 无效,REF 强制为无效电平</td></tr><tr><td>强制为有效电平</td><td>CNT 与 CCR 无效.REF 强制为有效电平</td></tr><tr><td><strong>PWM 模式1</strong></td><td><strong>向上计数: CNT &lt; CCR 时,REF 置有效电平;CNT ≥ CCR 时,REF 置无效电平</strong> <br />向下计数: CNT &gt; CCR 时,REF 置无效电平;CNT ≤ CCR 时,REF 置有效电平</td></tr><tr><td><strong>PWM 模式2</strong></td><td><strong>向上计数: CNT &lt; CCR 时,REF 置无效电平,CNT ≥ CCR 时,REF 置有效电平</strong> <br />向下计数: CNT &gt; CCR 时,REF 置有效电平,CNT ≤ CCR 时,REF 置无效电平</td></tr></tbody></table></li><li><p>高级定时器输出比较(相较于通用定时器可以输出互补电平信号和产生死区)</p><p><img src="/2023/06/01/Embedded/STM32/5-advanced-timer-output.png"></p><ul><li>输出 <code>OC1,OC1N</code> 分别接到外部推挽电路的控制极,2个推挽电路构成 H桥,3个推挽电路即可驱动三相无刷电机</li><li><code>死区生成器</code>: 在 MOS 管关闭时,进行一段延时,然后是另一个 MOS 管导通.防止因器件原因造成正负极短路</li></ul></li><li><p>PWM 基本结构</p><p><img src="/2023/06/01/Embedded/STM32/5-PWM-struct.png"></p><ul><li>图示中蓝线为 CNT(不断自增); 红线为 CCR(手动设置); 黄线为 ARR(手动设置).PWM 模式1</li><li>输出 PWM 波形不需要进行中断申请</li></ul></li><li><p><strong>PWM 参数计算</strong></p><ul><li><p>已知 $\mathrm{CK_PSC}$, PSC, ARR, CCR.计算频率, 占空比, 分辨率</p><ul><li><p>频率:     $\mathrm{freq} &#x3D; \frac{\mathrm{CK_PSC}}{\mathrm{(PSC + 1)}\mathrm{(ARR + 1)}}$</p></li><li><p>占空比: $\mathrm{Duty} &#x3D; \frac{\mathrm{CCR}}{\mathrm{(ARR + 1)}}$</p></li><li><p>分辨率: $\mathrm{Reso} &#x3D; \frac{1}{(\mathrm{ARR} + 1)}$</p></li></ul></li><li><p>已知 时钟频率, PWM 频率, 占空比, 分辨率时.计算 PSC, ARR, CCR</p><ul><li>$\mathrm{ARR+1} &#x3D; \frac{1}{\mathrm{Reso}}$</li><li>$\mathrm{CCR} &#x3D; \frac{\mathrm{Duty}}{\mathrm{Reso}}$ </li><li>$\mathrm{PSC + 1} &#x3D; \frac{\mathrm{Reso\cdot CK_{PSC}}}{\mathrm{freq}}$</li></ul></li><li><p><strong>确定 PSC, ARR, CCR 的方式</strong></p><ul><li>首先根据分辨率决定 ARR.如要求分辨率为 1% 时, (ARR + 1) &#x3D; 100.此后固定 ARR 的值,方便计算</li><li>此时 CRR 值即为占空比的百分数.如 CCR &#x3D; 50 时,占空比 duty &#x3D; 50%.代码中改变 CRR,即可调节占空比</li><li>最后确定 PSC 的值.代码中改变 PSC,即可调节频率</li></ul></li></ul></li></ol><h3 id="5-6-输入捕获"><a href="#5-6-输入捕获" class="headerlink" title="5.6 输入捕获"></a>5.6 输入捕获</h3><ol><li><p><strong>IC(Input Capture 输入捕获)</strong></p><ul><li>输入捕获模式下<ul><li>当通道输入引脚出现指定电平跳变时,当前 CNT 的值将被锁存到 CCR 中</li><li>可用于测量 PWM 波形的频率, 占空比, 脉冲间隔, 电平持续时间等参数</li></ul></li><li>每个高级定时器和通用定时器都拥有4个输入捕获通道<ul><li>可配置为 PWMI 模式,同时测量频率和占空比</li><li>可配合主从触发模式,实现硬件全自动测量</li></ul></li></ul></li><li><p><strong>频率测量方法</strong></p><ul><li><strong>测频法</strong>: 在闸门时间 T 内对上升沿计次 N,则频率 $f_x &#x3D; \frac{N}{T}$</li><li><strong>测周法</strong>: 两个上升沿内以标准频率 $f_c$ 计次 N,则频率 $f_x &#x3D; \frac{f_c}{N}$</li><li><strong>中界频率</strong>: 测频法与测周法误差相等的频率 $f_m &#x3D; \sqrt{\frac{f_c}{T}}$</li></ul></li><li><p>捕获比较通道框图</p><p><img src="/2023/06/01/Embedded/STM32/5-capture-channel-block.png"></p></li><li><p>主从触发模式</p><p><img src="/2023/06/01/Embedded/STM32/5-%E4%B8%BB%E4%BB%8E%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F.png"></p><ul><li><strong>主模式: 可将定时器内部的信号映射到 TRGO 引脚,触发其他外设</strong></li><li><strong>从模式: 接收其他外设或使用自身外设的信号.用以控制自身控制器的运行</strong></li><li>触发源选择: 指定 从模式的触发信号 得到 TRGI,然后触发选定的从模式</li></ul></li><li><p>输入捕获基本结构</p><p><img src="/2023/06/01/Embedded/STM32/5-capture-struct.png"></p><ul><li>从GPIO口输入方波信号,经过<code>滤波器, 边沿检测, 极性选择</code>得到 <code>TI1FP1</code>,最后连接到 <code>CCR1</code></li><li>当<code>TI1FP1</code>出现上升沿,不断自增的 <code>CNT</code> 转运到 <code>CCR1</code> 中</li><li>同时,触发源选择为 <code>TI1FP1</code>,从模式配置为 <code>Reset</code>.当 <code>TI1FP1</code> 出现上升沿,<code>CNT</code> 自动清零,再次自增</li></ul></li><li><p>PWMI 基本结构</p><p><img src="/2023/06/01/Embedded/STM32/5-PWMI-struct.png"></p><ul><li>PWMI 与 输入捕获的区别在于使用2个通道捕获同一 GPIO,可以同时测量周期和占空比</li><li>当上升沿来临,<code>TI1FP1</code> 触发,<code>CCR1</code> 捕获,清零 <code>CNT</code></li><li><code>TI1FP2</code>配置为下降沿触发.当下降沿来临,<code>TI1FP2</code> 触发,<code>CCR2</code> 捕获,不清零 <code>CNT</code></li><li>因而 <code>CCR2</code> 的值反映高电平维持时间,<code>CCR1</code> 的值反映周期的时间.占空比为 $\frac{CCR2}{CCR1}$</li></ul></li></ol><h3 id="5-7-编码器"><a href="#5-7-编码器" class="headerlink" title="5.7 编码器"></a>5.7 编码器</h3><ol><li><p>编码器接口(Encoder Interface)</p><ul><li>编码器接口可接收增量(正交)编码器的信号<ul><li>根据编码器旋转产生的正交信号脉冲</li><li>自动控制 CNT 自增或自减,从而指示 编码器的位置, 旋转方向, 旋转速度</li></ul></li><li>每个高级定时器和通用定时器都拥有1个编码器接口</li><li>编码器接口的两个输入引脚借用了输入捕获的通道1和通道2</li></ul></li><li><p>正交编码器</p><p><img src="/2023/06/01/Embedded/STM32/5-encoder.png"></p><ul><li>由于正转和反转输出的波形一致,故仅凭一项输出信号无法判断旋转方向.因此需要 A, B相</li><li>A相与B相 相位差90°.每当出现边沿变化时,判断另一相的状态,对照右侧表格,即可确定旋转方向</li></ul></li><li><p>编码器接口基本结构</p><p><img src="/2023/06/01/Embedded/STM32/5-encoder-struct.png"></p><ul><li><p>当编码器正转时,CNT++; 反转时,CNT–.结合固定的闸门时间,即可完成测速任务</p></li><li><p><code>TI1FP1, TI2FP2</code>来自 GPIO 端口输入.<strong>类似于一个外部时钟源,配置为编码器模式</strong></p><ul><li>因此此时 PSC 建议设为 0,不进行分频.ARR 设为 65535,最大</li></ul></li><li><p>配置 GPIO 为输入模式 -&gt; 配置时基单元 -&gt; 配置输入捕获单元 -&gt; 配置编码器接口(下行代码)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 编码器接口配置.并设置为: 定时器3, 选择编码器模式, TI1, TI2都计数, 不反相</span><br><span class="hljs-comment">** 注意此时参数的 Rising 和 Falling 不再代表上升沿和下降沿了,而是代表是否反相</span><br><span class="hljs-comment">** 此函数必须在输入捕获初始化之后进行,否则输入捕获的配置会覆盖此函数的部分配置 */</span><br>TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12,<br>                           TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="6-ADC"><a href="#6-ADC" class="headerlink" title="6 ADC"></a>6 ADC</h2><h3 id="6-1-ADC-功能"><a href="#6-1-ADC-功能" class="headerlink" title="6.1  ADC  功能"></a>6.1  ADC  功能</h3><ol><li><p><strong>ADC(Analog-Digital Converter, 模拟-数字转换器)</strong></p><ul><li>作用: 可将引脚上连续变化的模拟电压 转换为内存中存储的数字变量</li><li>18个输入通道: 可测量16个外部(GPIO)和2个内部信号源(温度传感器,内部参考电压)<ul><li>输入电压范围: 0 ~ 3.3V</li><li>分辨率为 12位: 即表示范围 $0 \sim 2^{12}-1$</li><li>1$\mu$s 转换时间: 即开始转换到产生结果耗时.对应频率为 1MHz</li></ul></li><li>STM32 增强功能: 规则组和注入组两个转换单元</li></ul></li><li><p>逐次逼近型 ADC 结构(<code>ADC0809</code> 内部结构图, 8位逐次逼近型)</p><p><img src="/2023/06/01/Embedded/STM32/6-approx-ADC.png"></p></li><li><p>ADC 框图</p><p><img src="/2023/06/01/Embedded/STM32/6-ADC-block.png"></p></li><li><p>ADC 基本结构</p><p><img src="/2023/06/01/Embedded/STM32/6-ADC-struct.png"></p><ul><li>配置 GPIO 为模拟输入模式 -&gt; 配置数据选择器 -&gt; 配置 ADC 转换器 -&gt; 开启 ADC</li></ul></li></ol><h3 id="6-2-ADC-模式"><a href="#6-2-ADC-模式" class="headerlink" title="6.2 ADC 模式"></a>6.2 ADC 模式</h3><ol><li><p><strong>规则组的转换模式</strong></p><ul><li>单次转换: 在一次转换结束后,转换结果存放在数据寄存器中,置 EOC 标志位,结束转换</li><li>连续转换: 在一次转换结束后,置 EOC 标志位,立即开始下一轮的转换</li><li>非扫描模式: 规则组的序列只有一个通道有效.即只处理一个通道的信号</li><li>扫描模式: 规则组的序列有效,一次转换多个通道的信号</li></ul></li><li><p>ADC 转换触发控制</p><p><img src="/2023/06/01/Embedded/STM32/6-ADC-external-trigger.png"></p></li><li><p>数据对齐: 对于一个 12bit ADC,其转换结果为 12bit.而数据寄存器为16bit,需进行数据对齐</p><ul><li><strong>右对齐: 有效数据右对齐,左边补0</strong></li><li>左对齐: 有效数据左对齐,右边补0</li></ul></li><li><p>转换时间(采样, 保持, 量化, 编码)</p><ul><li>ADC 的总转换时间: <code>T = 采样时间 + 12.5 * ADC 周期</code></li><li>采样时间可在程序中配置.量化编码因是12位 ADC,需要 12.5 个周期</li><li>例: 采样时间配置为1.5, ADC 频率为14MHz,则总转换时间为14个 ADC 周期,即 1us</li></ul></li></ol><h2 id="7-DMA"><a href="#7-DMA" class="headerlink" title="7 DMA"></a>7 DMA</h2><h3 id="7-1-DMA-功能"><a href="#7-1-DMA-功能" class="headerlink" title="7.1 DMA 功能"></a>7.1 DMA 功能</h3><ol><li><p><strong>DMA(Direct Memory Access, 直接存储器存取)</strong></p><ul><li>DMA 可以提供外设和存储器或者存储器和存储器之间的高速数据传输</li><li>本质上是从某个地址取出数据,转运到另一地址</li><li>作用: DMA 数据传输无须 CPU 干预,节省 CPU 的资源</li><li>12个独立可配置的通道: DMA1(7个通道), DMA2(5个通道)</li><li>每个通道都支持软件触发和特定的硬件触发</li></ul></li><li><p><strong>存储器映像</strong></p><table><thead><tr><th>类型</th><th>起始地址</th><th>存储器</th><th>用途</th></tr></thead><tbody><tr><td>ROM</td><td>0x0800 0000</td><td>程序存储器 Flash</td><td>存储编译后的 C 语言程序代码</td></tr><tr><td></td><td>0x1FFF F000</td><td>系统存储器</td><td>存储 BootLoader,用于串口下载</td></tr><tr><td></td><td>0x1FFF F800</td><td>选项字节</td><td>存储一些独立于程序代码的配置参数</td></tr><tr><td>RAM</td><td>0x2000 0000</td><td>运行内存 SRAM</td><td>存储运行过程中的临时变量</td></tr><tr><td></td><td>0x4000 0000</td><td>外设寄存器</td><td>存储各个外设的配置参数</td></tr><tr><td></td><td>0xE000 0000</td><td>内核外设寄存器</td><td>存储内核各个外设的配置参数</td></tr></tbody></table></li><li><p>DMA 框图</p><p><img src="/2023/06/01/Embedded/STM32/7-DMA-block.png"></p><ul><li>DMA 通过 <code>DMA 总线</code>主动访问各种存储器.DMA 总线是被分时复用的<ul><li><code>仲裁器</code>根据通道的优先级处理 DMA 通道的冲突</li><li><code>总线矩阵</code>也有仲裁器,当 CPU 和 DMA 访问同一目标时.保障 CPU 正常工作</li></ul></li><li>DMA 作为外设,也有寄存器.连接在 <code>AHB 总线</code>上,因此 CPU 可以访问,配置 DMA<ul><li>硬件可通过 DMA 请求线路向 DMA 发出硬件触发信号</li></ul></li></ul></li></ol><h3 id="7-2-DMA-转运"><a href="#7-2-DMA-转运" class="headerlink" title="7.2 DMA 转运"></a>7.2 DMA 转运</h3><ol><li><p><strong>DMA 基本结构</strong></p><p><img src="/2023/06/01/Embedded/STM32/7-DMA-struct.png"></p><ul><li>DMA 数据转运<ul><li>条件: DMA 使能, <code>传输计数器</code> &gt; 0, 触发源有触发信号</li><li>方向: 外设 -&gt; 存储器, 存储器 -&gt; 外设, Flash -&gt; SRAM</li><li>参数: 源端和目标的 <code>起始地址, 数据宽度, 地址是否自增</code></li></ul></li><li><strong>传输计数器</strong>: 在完成一次转运后会进行自减,当其值为0时结束转运,起始地址参数复位<ul><li><code>自动重装器</code>: 可以在传输计数器自减到0后,恢复传输计数器的值,再次自减.使得可以循环转运</li><li>DMA 转运完成后,必须先关闭 DMA,然后再次开启,才能给 <code>传输计数器</code> 写值</li></ul></li><li>触发方式: 由 <code>M2M</code> 控制<ul><li>软件触发: DMA 不断运行,直到 <code>传输计数器</code> 清零.此时不应开启 <code>自动重装器</code>,一般用于存储器间数据转运</li><li>硬件触发: 达到某种条件(如 ADC 转换完成,串口接收到数据,达到定时时间),触发 DMA 运行</li></ul></li></ul></li><li><p>DMA1 请求映像 </p><p><img src="/2023/06/01/Embedded/STM32/7-DMA1-request-map.png"></p><ul><li><strong>每个通道的硬件触发源不同.而软件触发都一样.需要根据触发选择 ADC 通道</strong></li><li>对于外设请求信号的选择: 由外设的 DMA 控制决定,开启就可以发出请求信号</li><li>外设请求信号经过 或门到硬件请求.一般只开启一个外设请求</li></ul></li><li><p>DMA 传输数据宽度</p><ul><li>源端宽度 &#x3D; 目标宽度: 正常传输</li><li>源端宽度 &gt; 目标宽度: 高位舍弃</li><li>源端宽度 &lt; 目标宽度: 高位补0</li></ul></li></ol><h2 id="8-USART-串口"><a href="#8-USART-串口" class="headerlink" title="8 USART 串口"></a>8 USART 串口</h2><h3 id="8-1-通信接口"><a href="#8-1-通信接口" class="headerlink" title="8.1 通信接口"></a>8.1 通信接口</h3><ol><li><p><strong>通信协议</strong></p><table><thead><tr><th>名称</th><th>引脚</th><th>双工</th><th>时钟</th><th>电平</th><th>设备</th></tr></thead><tbody><tr><td>USART</td><td>TX, RX</td><td>全双工</td><td>异步</td><td>单端</td><td>点对点</td></tr><tr><td>I2C</td><td>SCL, SDA</td><td>半双工</td><td>同步</td><td>单端</td><td>多设备</td></tr><tr><td>SPI</td><td>SCLK, MOSI, MISO, CS</td><td>全双工</td><td>同步</td><td>单端</td><td>多设备</td></tr><tr><td>CAN</td><td>CAN_H, CAN_L</td><td>半双工</td><td>异步</td><td>差分</td><td>多设备</td></tr><tr><td>USB</td><td>DP, DM</td><td>半双工</td><td>异步</td><td>差分</td><td>点对点</td></tr></tbody></table><ul><li>全双工: 通信双方能够同时进行双向通信.一般需要2根通信线</li><li>半双工: 通信双方无法同时输入 &#x2F; 输出数据</li><li>单工: 数据传输方向为单向</li><li>时钟: 确定数据的采集时机</li></ul></li><li><p>电平标准: 数据1&#x2F;0的表达方式(当电平信号不一致时,需要加入电平转换芯片)</p><table><thead><tr><th>电平标准</th><th>data: 1</th><th>data: 0</th></tr></thead><tbody><tr><td><strong>TTL</strong></td><td><strong>+3.3V 或 +5V</strong></td><td><strong>0V</strong></td></tr><tr><td>RS232 电平</td><td>-3 ~ -15V</td><td>+3 ~ +15</td></tr><tr><td>RS485 电平(差分信号)</td><td>+2 ~ +6V</td><td>-2 ~ -6V</td></tr></tbody></table></li><li><p>串口时序</p><p><img src="/2023/06/01/Embedded/STM32/8-uart-timing-sequence.png"></p></li><li><p>串口参数</p><ul><li><strong>波特率: 串口通信的速率.每秒传输码元的个数</strong></li><li>比特率: 每秒传输的比特数(bit&#x2F;s).二进制情况下,码元即是 bit,波特率等于比特率</li><li>起始位: 标志一个数据帧的开始,固定为低电平(空闲时为高电平)</li><li><strong>数据位: 数据帧的有效载荷.1为高电平,0为低电平.低位先行</strong></li><li>校验位: 用于数据验证(如奇校验表示连同校验位共有奇数个1,还有 CRC 校验)</li><li>停止位: 用于数据帧间隔.固定为高电平</li></ul></li></ol><h3 id="8-2-USART-外设"><a href="#8-2-USART-外设" class="headerlink" title="8.2 USART 外设"></a>8.2 USART 外设</h3><ol><li><p><strong>USART(Universal Synchronous&#x2F;Asynchronous Receiver&#x2F;Transmitter, 通用同步&#x2F;异步收发器)</strong></p><ul><li>STM32 内部集成 USART 外设<ul><li>可根据数据寄存器的一个字节数据自动生成数据帧时序.由 TX 引脚发送</li><li>可自动接收 RX 引脚的数据帧时序,拼接为一个字节数据,存放于数据寄存器</li><li>自带波特率发生器.最高达4.5Mbits&#x2F;s(本质是一个预分频器)</li></ul></li><li>可配置参数<ul><li>数据位长度(<strong>8</strong> &#x2F; 9). 停止位长度(0.5 &#x2F; <strong>1</strong> &#x2F; 1.5 &#x2F; 2)</li><li>校验位: <strong>无校验,</strong> 奇校验, 偶校验</li><li>支持同步模式, 硬件流控制, DMA, 智能卡, IrDA, LIN</li></ul></li><li>stm32f103 的 usart1 的引脚: tx - PA9, rx - PA10</li></ul></li><li><p>USART 框图</p><p><img src="/2023/06/01/Embedded/STM32/8-USART-block.png"></p><ul><li><code>TX</code> 引脚连接 <code>发送移位寄存器</code>,在<code>发送器控制</code>的控制下,将数据按位移出<ul><li>当 <code>TDR</code>(只写) 被写入数据时,先检查<code>移位寄存器</code>是否有数据正在移位</li><li>若无,则数据发送到<code>移位寄存器</code>,同时,置 <code>TXE 标志位</code>,可以再次向 <code>TDR</code> 写入数据</li><li>若有,则等待移位完成后,立即转移数据</li></ul></li><li><code>RX</code> 连接通向 <code>接收移位寄存器</code>,在<code>接收器控制</code>的控制下,将数据按位移出<ul><li><code>接收移位寄存器</code>按位读取 <code>RX</code> 引脚的信号</li><li>读取满1byte 后,将数据转移到 <code>RDR</code>.同时,置 <code>RXNE 标志位</code>.此时可从 <code>RDR</code>(只读)读出数据</li></ul></li></ul></li><li><p>USART 基本结构</p><p><img src="/2023/06/01/Embedded/STM32/8-USART-struct.png"></p><ul><li>APB的时钟信号到达波特率发生器进行分频</li><li>发送器 &#x2F; 接收器的波特率 &#x3D; $\mathrm{\frac{f_{PCLK}} { {16} \cdot {DIV} } }$. 由 <code>波特率寄存器 BRR</code> 中的 <code>DIV</code> 决定</li></ul></li></ol><h3 id="8-3-重定向-printf"><a href="#8-3-重定向-printf" class="headerlink" title="8.3 重定向 printf"></a>8.3 重定向 <code>printf</code></h3><ol><li><p>格式化打印: 对 <code>printf</code>函数的重定向</p></li><li><p>打开工程文件中的 <code>Options for target</code>,勾选 <code>Use MicroLIB</code>(Keil 为嵌入式平台准备的精简库)</p><p><img src="/2023/06/01/Embedded/STM32/8-UseMicroLib.png"></p></li><li><p><strong>由于<code>printf</code>函数底层调用<code>fput</code>函数不断打印,因此可以将 <code>printf</code> 函数重定向为向串口发送数据</strong></p></li><li><p>方法1: 重写的<code>fputc</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span> &#123;<br>serial_send_byte(ch);  <span class="hljs-comment">// 这是一个串口传输数据的函数,需要自行实现</span><br><span class="hljs-keyword">return</span> ch;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方法2: 对 <code>sprintf</code> 的封装(<code>sprintf</code> 函数: 将内容打印打印到字符串中)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">serial_printf</span><span class="hljs-params">(<span class="hljs-type">char</span> *format, ...)</span> &#123;<br><span class="hljs-type">char</span> <span class="hljs-built_in">string</span>[<span class="hljs-number">100</span>];               <span class="hljs-comment">// 定义字符数组</span><br>va_list arg;                    <span class="hljs-comment">// 定义可变参数列表数据类型的变量 arg</span><br>va_start(arg, format);          <span class="hljs-comment">// 从 format 开始,接收参数列表到 arg 变量</span><br><span class="hljs-built_in">vsprintf</span>(<span class="hljs-built_in">string</span>, format, arg);  <span class="hljs-comment">// 使用 vsprintf 打印格式化字符串和参数列表到字符数组中</span><br>va_end(arg);                    <span class="hljs-comment">// 结束变量 arg</span><br>serial_send_string(<span class="hljs-built_in">string</span>);     <span class="hljs-comment">// 串口发送字符数组的函数,需要自行实现</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="8-4-HAL-库"><a href="#8-4-HAL-库" class="headerlink" title="8.4 HAL 库"></a>8.4 HAL 库</h3><ol><li>配置 UART1</li></ol><p>   <img src="/2023/06/01/Embedded/STM32/8-USART-HAL.png"></p><ol start="2"><li><p>在 <code>stm32f1xx_hal_uart.h</code> 中有很多中断回调函数,以及功能实现函数</p><ul><li><p>收发函数(还有中断和 dma 版本)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_StatusTypeDef <span class="hljs-title function_">HAL_UART_Transmit</span><span class="hljs-params">(UART_HandleTypeDef *huart, </span><br><span class="hljs-params">                                    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *pData, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_UART_Receive</span><span class="hljs-params">(UART_HandleTypeDef *huart, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint8_t</span> *pData, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint32_t</span> Timeout)</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="9-I2C-通信"><a href="#9-I2C-通信" class="headerlink" title="9 I2C 通信"></a>9 I2C 通信</h2><h3 id="9-1-I2C-协议"><a href="#9-1-I2C-协议" class="headerlink" title="9.1 I2C 协议"></a>9.1 I2C 协议</h3><ol><li><p><strong>I2C(Inter IC BUS).由 Philips 公司开发的一种通用数据总线</strong></p><ul><li><strong>通信线: SCL(Serial Clock), SDA(Serial Data)</strong></li><li>属于同步通信,半双工通信.可以数据应答,支持总线挂载多设备</li><li>I2C 外设出厂会有一个地址(7位或10位)</li></ul></li><li><p>硬件电路</p><p><img src="/2023/06/01/Embedded/STM32/9-I2C-bus.png"></p><ul><li>SDA 和 SCL 的控制<ul><li>主机拥有对 SCL 线的完全控制权.也可控制空闲状态下的 SDA 线</li><li>从机只能读取 SCL 线,也不允许主动控制 SDA 线</li><li>仅在应答或主机要读取从机时才能获取 SDA 的控制权</li></ul></li><li>接线方式<ul><li>所有 I2C 设备的 SCL 连在一起,SDA 连在一起.均默认为高电平</li><li><strong>设备的 SCL 和 SDA 均要配置成开漏输出模式,禁止输出高电平</strong></li><li>SCL 和 SDA 各添加一个上拉电阻,阻值一般为4.7KΩ</li></ul></li></ul></li><li><p><strong>I2C 时序基本单元</strong></p><ul><li><p><strong>起始与终止</strong>: 始终由主机控制,从机无权发送该指令</p><ul><li><p>起始条件: 主机拉低 SDA 电平(下降沿,此时从机复位).然后拉低 SCL,占用 SCL</p></li><li><p>终止条件: 主机先放开 SCL,然后放开 SDA (上升沿).回到初始态</p></li><li><p><strong>除了起始和终止条件,每个时序单元的 SCL 以低电平开始,也以低电平结束</strong></p><p><img src="/2023/06/01/Embedded/STM32/9-I2C-start-end.png"></p></li></ul></li><li><p><strong>发送数据</strong></p><ul><li><p>起始状态后.SCL,SDA均为低电平.主机将数据置于 SDA 线(高位先行)</p></li><li><p>然后释放 SCL.从机在 SCL 高电平期间读取数据位,需要尽快读取,最好在上升沿时就立即读取</p></li><li><p>当 SCL 高电平时, SDA 不应发生变化,维持一段时间后,主机再次拉低 SCL.完成一位数据的传输</p></li><li><p>循环上述过程8次,即可传输一个字节的数据</p><p><img src="/2023/06/01/Embedded/STM32/9-I2C-send-byte.png"></p></li></ul></li><li><p><strong>接收数据</strong></p><ul><li><p>主机需要先释放 SDA.在 SCL 低电平期间,从机将数据置于 SDA 线(高位先行)</p></li><li><p>然后主机释放 SCL.由主机读取数据位</p></li><li><p><strong>SDA 总是在 SCL 低电平(下降沿)时被放置数据,在 SCL 高点平(上升沿)时被读取</strong></p><p><img src="/2023/06/01/Embedded/STM32/9-I2C-receive-byte.png"></p></li></ul></li><li><p><strong>主机发送应答</strong>: 主机接收完一个字节后,在下一个时钟发送一位数据.<strong>0为应答,1为非应答</strong></p></li><li><p><strong>接收从机应答</strong>: 主机发送完一个字节后,在下一个时钟接收一位数据.<strong>0为应答,1为非应答</strong></p><p><img src="/2023/06/01/Embedded/STM32/9-I2C-ack.png"></p></li></ul></li><li><p>指定地址写: 给指定设备(slave addr)的指定地址(reg addr)写入指定数据(data)</p><ul><li><p>起始条件 -&gt; 发送 1byte(前 7bit 为 slave addr, 后 1bit 表示读(1) &#x2F; <strong>写(0)</strong> ) -&gt; 从机应答0 -&gt; </p></li><li><p>发送 1byte 数据(reg addr) -&gt; 从机应答0 -&gt; </p></li><li><p>发送 1byte 数据(data) -&gt; 从机应答0 -&gt; 终止条件</p></li><li><p>后续字节: 传输真正的数据(寄存器的地址将会自增).当完成传输时,主机需要产生一个终止条件</p><p><img src="/2023/06/01/Embedded/STM32/9-I2C-write-reg.png"></p></li></ul></li><li><p>当前地址读: 对于指定设备(slave addr),读取从机当前地址指针的数据(data)</p><ul><li><p>起始条件 -&gt; 发送 1byte(前 7bit 为 slave addr, 后 1bit 表示<strong>读(1)</strong> &#x2F; 写(0) ) -&gt; 从机应答0 -&gt;</p></li><li><p>接收 1byte data(此时从机在 scl 低电平写入 sda,主机在 scl 高电平读取 sda) -&gt; 主机应答1 -&gt; 终止条件</p></li><li><p>当主机不想再接收数据时,需要在发送应答时给出非应答,此时从机将不再发送数据</p><p><img src="/2023/06/01/Embedded/STM32/9-I2C-read-reg.png"></p></li></ul></li><li><p>指定地址读: 给指定设备(slave addr)的指定地址(reg addr)读取数据(data)</p><ul><li><p>起始条件 -&gt; 发送 1byte(前 7bit 为 slave addr, 后 1bit 表示读(1) &#x2F; <strong>写(0)</strong> ) -&gt; 从机应答0 -&gt; </p></li><li><p>发送 1byte 数据(reg addr) -&gt; 从机应答0 -&gt; </p></li><li><p>重复起始条件 -&gt; 发送 1byte(前 7bit 为 slave addr, 后 1bit 表示<strong>读(1)</strong> &#x2F; 写(0) ) -&gt; 从机应答0 -&gt;</p></li><li><p>接收 1byte data(此时从机在 scl 低电平写入 sda,主机在 scl 高电平读取 sda) -&gt; 主机应答1 -&gt; 终止条件  </p><p><img src="/2023/06/01/Embedded/STM32/9-I2C-set-addr-read-reg.png"></p></li></ul></li></ol><h3 id="9-2-I2C-外设"><a href="#9-2-I2C-外设" class="headerlink" title="9.2 I2C 外设"></a>9.2 I2C 外设</h3><ol><li><p>STM32 内部集成了硬件 I2C 收发电路</p><ul><li>可以由硬件自动执行时钟生成,起始终止条件生成,应答位收发,数据收发等功能.减轻CPU的负担</li><li>支持 7bit &#x2F; 10bit 地址模式(若第一字节的前5位为11110,则表示10位地址)</li><li>支持不同的通讯速度,标准速度(高达100 kHz), 快速(高达400 kHz)</li><li>支持 DMA, 多主机模型, 兼容 SMBus(System Management Bus)协议</li></ul></li><li><p>I2C 基本结构图</p><p><img src="/2023/06/01/Embedded/STM32/9-I2C-struct.png"></p></li><li><p>硬件 I2C 波形</p><p><img src="/2023/06/01/Embedded/STM32/9-I2C-hardware-wave.png"></p></li></ol><h3 id="9-3-HAL-库"><a href="#9-3-HAL-库" class="headerlink" title="9.3 HAL 库"></a>9.3 HAL 库</h3><ol><li><p>I2C2 配置</p><p><img src="/2023/06/01/Embedded/STM32/9-I2C-hal.png"></p></li><li><p>在 <code>stm32f1xx_hal_i2c.h</code> 中有很多中断回调函数,以及功能实现函数</p><ul><li><p>收发函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Write</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> DevAddress,  <span class="hljs-comment">// 注意是 7bit地址 &lt;&lt; 1</span></span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> MemAddress,</span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> MemAddSize, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint8_t</span> *pData, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Read</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> DevAddress, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> MemAddress, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> MemAddSize, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint8_t</span> *pData, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint32_t</span> Timeout)</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="10-SPI-通信"><a href="#10-SPI-通信" class="headerlink" title="10 SPI 通信"></a>10 SPI 通信</h2><h3 id="10-1-SPI-协议"><a href="#10-1-SPI-协议" class="headerlink" title="10.1 SPI 协议"></a>10.1 SPI 协议</h3><ol><li><p><strong>SPI(Serial Peripheral Interface): 由Motorola公司开发的一种通用数据总线</strong></p><ul><li>通信线: SCK(Serial Clock), SS(Slave Select),<br>MOSI(Master Output Slave Input), MISO(Master Input Slave Output)</li><li>同步, 全双工.支持总线挂载多设备(一主多从)</li></ul></li><li><p>硬件电路</p><p><img src="/2023/06/01/Embedded/STM32/10-SPI-bus.jpg"></p><ul><li>所有 SPI 设备的 SCK, MOSI, MISO 分别连在一起<ul><li><strong>SCK: 时钟线</strong>.完全由主机掌控.由主机进行输出,从机得到输入</li><li><strong>MOSI: 主机输出从机输入</strong>.在主机上,表现为数据输出.在从机上,表现为数据输入</li><li><strong>MISO: 主机输入从机输出</strong>.在主机上,表现为数据输入.在从机上,表现为数据输出</li></ul></li><li><strong>主机另外引出多条 SS 控制线,分别接到各从机的 SS 引脚</strong><ul><li>当从机的 SS 高电平时,MISO 必须为高阻态,不允许从机输出,防止 MISO 数据冲突</li><li>SS 低电平有效,且只能同时选中一个从机.如需指定从机输入输出数据.则将对应的 SS 拉至低电平</li><li>输出的引脚需配置为推挽输出,保证高低电平均有强驱动能力.输入的引脚需配置为浮空或上拉输入</li></ul></li></ul></li><li><p>SPI 数据交换</p><p><img src="/2023/06/01/Embedded/STM32/10-SPI-swap-byte.png"></p><ul><li><code>波特率发生器</code>时钟上升沿时,所有移位寄存器向左移位,置于引脚</li><li><code>波特率发生器</code>时钟下降沿时,对引脚电平采样,置于移位寄存器的最低位</li><li>主机与从机的数据交换<ul><li>在一个周期内,从机由高位移出的数据传输到主机的低位,主机由高位移出的数据传输到从机的低位</li><li>循环8次后,从机的数据完整到达主机,主机的数据也完整达到从机,完成一次数据交换</li></ul></li><li>如果仅需主机发送数据,仍然需要执行数据交换,忽略接收到的数据即可</li><li>如果仅需接收从机数据,仍然需要执行数据交换,此时主机可使用任意数据交换(一般0x00或0xFF)</li></ul></li><li><p>SPI 基本时序</p><ul><li><p>起始条件: SS 从高电平切换到低电平</p></li><li><p>终止条件: SS 从低电平切换到高电平</p></li><li><p>可选择 上升&#x2F;下降沿 移位.可配置时钟相位提前半个时钟</p><ul><li><code>CPOL(Clock Polarity)</code><ul><li>CPOL&#x3D;0: SCK 空闲时为低电平</li><li>CPOL&#x3D;1: SCK 空闲时为高电平</li></ul></li><li><code>CPHA(Clock phase)</code><ul><li>CPHA&#x3D;0: SCK 奇数边沿时移入数据.偶数边沿移出数据(提前)</li><li>CPHA&#x3D;1: SCK 奇数边沿时移出数据.偶数边沿移入数据(正常)</li></ul></li></ul></li><li><p><strong>模式0 使用最多(CPOL&#x3D;0,CPHA&#x3D;0): 空闲时,SCK为低电平,上升沿采集数据</strong></p><p><img src="/2023/06/01/Embedded/STM32/10-SPI-mode0.jpg"></p></li></ul></li><li><p>SPI 通常使用指令码和读写数据的方式操作从机: 从机选择 -&gt; 发送指令 -&gt; 发送数据<br>向指定设备发送指令 0x02,然后写入数据</p><p><img src="/2023/06/01/Embedded/STM32/10-SPI-timing-sequence.jpg"></p></li></ol><h3 id="10-2-SPI-外设"><a href="#10-2-SPI-外设" class="headerlink" title="10.2 SPI 外设"></a>10.2 SPI 外设</h3><ol><li><p>STM32 内部集成了硬件 SPI 收发电路</p><ul><li>可配置 8 &#x2F; 16位数据帧, 高 &#x2F; 低位先行</li><li>时钟频率: PCLK &#x2F; (2, 4, 8, 16, 32, 64, 128, 256)</li><li>支持多主机模型(主&#x2F;从操作), 可精简为半双工&#x2F;单工通信, 支持 DMA, 兼容 I2S 协议</li></ul></li><li><p>SPI 基本结构</p><p><img src="/2023/06/01/Embedded/STM32/10-SPI-struct.png"></p></li></ol><h3 id="10-3-HAL-库"><a href="#10-3-HAL-库" class="headerlink" title="10.3 HAL 库"></a>10.3 HAL 库</h3><ol><li><p>SPI1 配置</p><p><img src="/2023/06/01/Embedded/STM32/10-SPI-hal.png"></p></li><li><p>spi 基础函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_StatusTypeDef <span class="hljs-title function_">HAL_SPI_TransmitReceive</span><span class="hljs-params">(SPI_HandleTypeDef *hspi, </span><br><span class="hljs-params">                                          <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *pTxData, </span><br><span class="hljs-params">                                          <span class="hljs-type">uint8_t</span> *pRxData,</span><br><span class="hljs-params">                                          <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                          <span class="hljs-type">uint32_t</span> Timeout)</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="11-RTC-实时时钟"><a href="#11-RTC-实时时钟" class="headerlink" title="11 RTC 实时时钟"></a>11 RTC 实时时钟</h2><h3 id="11-1-Unix-时间戳"><a href="#11-1-Unix-时间戳" class="headerlink" title="11.1 Unix 时间戳"></a>11.1 Unix 时间戳</h3><ol><li><p><strong>Unix 时间戳(Timestamp): 从 UTC &#x2F; GMT 的 <code>1970年1月1日00:00:00</code> 开始经过的秒数</strong></p><ul><li>秒计数器为 32 &#x2F; 64bit 的整型变量</li><li>各时区的秒计数器相同,但不同时区通过偏移得到当地时间</li></ul></li><li><p>GMT(Greenwich Mean Time): 格林尼治标准时间,将地球自转一周的时间等分为24小时</p></li><li><p>UTC(Universal Time Coordinated): 协调世界时,以原子钟为基础的时间计量系统</p></li><li><p>时间戳与时间的转换: C语言的 <code>&lt;time.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> tm* <span class="hljs-title function_">gmtime</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">time_t</span>*)</span>;     <span class="hljs-comment">// 秒计数器转换为日期时间</span><br><span class="hljs-keyword">struct</span> tm* <span class="hljs-title function_">localtime</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">time_t</span>*)</span>;  <span class="hljs-comment">// 秒计数器转换为当地时间</span><br><span class="hljs-type">time_t</span> <span class="hljs-title function_">mktime</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tm*)</span>;            <span class="hljs-comment">// 日期时间转换为秒计数器</span><br></code></pre></td></tr></table></figure><p><img src="/2023/06/01/Embedded/STM32/11-timestamp-convert.png"></p></li></ol><h3 id="11-2-BKP-备份寄存器"><a href="#11-2-BKP-备份寄存器" class="headerlink" title="11.2 BKP 备份寄存器"></a>11.2 BKP 备份寄存器</h3><ol><li><p>BKP 可用于存储用户应用程序数据</p><ul><li>当 VDD(2.0 ~ 3.6V)电源被切断时,仍由 VBAT(1.8 ~ 3.6V)维持供电</li><li>就算系统复位,电源复位,BKP 也不会复位</li><li>用户数据存储容量: 20字节(中&#x2F;小容量), 84字节(大容量&#x2F;互联型)</li></ul></li><li><p><strong>TAMPER 引脚产生的侵入事件会将所有备份寄存器内容清除</strong></p></li><li><p>RTC 引脚可以输出: RTC 校准时钟, RTC 闹钟脉冲, 秒脉冲</p></li><li><p>BPK 基本结构</p><p><img src="/2023/06/01/Embedded/STM32/11-BPK-struct.png"></p></li></ol><h3 id="11-3-RTC-实时时钟"><a href="#11-3-RTC-实时时钟" class="headerlink" title="11.3 RTC 实时时钟"></a>11.3 RTC 实时时钟</h3><ol><li><p><strong>RTC(Real Time Clock): 实时时钟,RTC是一个独立的定时器,可为系统提供时钟 &#x2F; 日历功能</strong></p><ul><li>RTC 和 时钟配置系统处于后备区域,系统复位时数据不清零</li><li>拥有32位可编程计数器,对应 Unix 时间戳的秒计数器</li><li>拥有20位可编程预分频器,适配不同频率的输入时钟.可选时钟源有<ul><li>HSE 时钟除以128(8MHz&#x2F;128)</li><li><strong>LSE 振荡器时钟(32.768KHZ)</strong></li><li>LSI 振荡器时钟(40KHz)</li></ul></li></ul></li><li><p>RTC 框图</p><p><img src="/2023/06/01/Embedded/STM32/11-RTC-block.png"></p></li><li><p>RTC 基本结构</p><p><img src="/2023/06/01/Embedded/STM32/11-RTC-struct.png"></p></li></ol><h2 id="12-PWR-电源控制"><a href="#12-PWR-电源控制" class="headerlink" title="12 PWR 电源控制"></a>12 PWR 电源控制</h2><h3 id="12-1-PWR"><a href="#12-1-PWR" class="headerlink" title="12.1 PWR"></a>12.1 PWR</h3><ol><li><p><strong>PWR(Power Control, 电源控制): 负责 STM32 内部的电源供电部分,可实现可编程电压检测器和低功耗模式</strong></p></li><li><p>电源框图</p><p><img src="/2023/06/01/Embedded/STM32/12-power-block.png"></p></li><li><p>上电复位和掉电复位</p><p><img src="/2023/06/01/Embedded/STM32/12-reset.png"></p></li><li><p><strong>可编程电压检测器(PVD): 监控 VDD 电源电压,当 VDD 上升&#x2F;下降到 PVD 阈值时,触发中断,执行紧急关闭任务</strong></p><p><img src="/2023/06/01/Embedded/STM32/12-PVD-threshold.png"></p></li></ol><h3 id="12-2-低功耗模式"><a href="#12-2-低功耗模式" class="headerlink" title="12.2 低功耗模式"></a>12.2 低功耗模式</h3><ol><li><p><strong>低功耗模式: 在系统空闲时,降低 STM32 的功耗,延长设备的使用时间</strong></p><p><img src="/2023/06/01/Embedded/STM32/12-low-power-mode.png"></p></li><li><p><strong>芯片在低功耗模式下无法直接下载程序: 下载程序步骤:按住复位键,点击下载程序,然后及时松开复位键</strong></p></li><li><p>修改芯片主频(修改文件 <code>Start/system_stm32f10x.c</code>)</p><ul><li>外部可见变量 <code>SystemCoreClock</code>: 系统主频的值</li><li>搜索 <code>SYSCLK_FREQ_xxMHz</code>,在此处进行的宏定义将会决定运行哪个设置系统时钟的函数</li></ul></li><li><p>进入睡眠模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">__WFI();  <span class="hljs-comment">// 进入睡眠模式,等待中断唤醒.一般置于主循环的最后一行</span><br>__WFE();  <span class="hljs-comment">// 进入睡眠模式,等待唤醒事件</span><br></code></pre></td></tr></table></figure></li><li><p>进入停机 &#x2F; 待机模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);      <span class="hljs-comment">// 停机和待机模式需开启 PWR 的时钟</span><br><br>PWR_EnterSTOPMode(PWR_Regulator_ON, PWR_STOPEntry_WFI);  <span class="hljs-comment">// 进入停止模式,并等待外部中断唤醒</span><br>PWR_EnterSTANDBYMode();  <span class="hljs-comment">// 进入待机模式,并等待指定的唤醒事件.唤醒后程序从头执行</span><br><br>SystemInit();  <span class="hljs-comment">// 从停止模式唤醒后,需重新配置时钟为 HSE(72MHz).而待机模式不需要</span><br></code></pre></td></tr></table></figure></li><li><p>设置闹钟或 PA0 上升沿唤醒待机模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">PWR_WakeUpPinCmd(ENABLE);  <span class="hljs-comment">// 使能 WakeUp 引脚(PA0)唤醒待机的功能(默认下拉低电平,高电平有效)</span><br>RTC_SetAlarm(RTC_GetCounter() + <span class="hljs-number">10</span>);  <span class="hljs-comment">// 设置 RTC 闹钟的值.为 10s 后</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="13-WDG-看门狗"><a href="#13-WDG-看门狗" class="headerlink" title="13 WDG 看门狗"></a>13 WDG 看门狗</h2><h3 id="13-1-看门狗功能"><a href="#13-1-看门狗功能" class="headerlink" title="13.1 看门狗功能"></a>13.1 看门狗功能</h3><ol><li><p><strong>看门狗(WDG, Watchdog)</strong></p><ul><li>监测程序的运行状态,当程序卡死时复位程序.保证安全性和可靠性</li><li><strong>看门狗本质是定时器,在指定的时间范围内,若未重置计数器,则硬件电路将产生复位信号</strong></li></ul></li><li><p><strong>独立看门狗(Independent WDG)</strong></p><p><img src="/2023/06/01/Embedded/STM32/13-independent-wdg.png"></p><ul><li><p>键寄存器 IWDG_KR: 控制寄存器,用于控制硬件电路的工作,避免干扰发生</p><table><thead><tr><th>写入键寄存器的值</th><th>作用</th></tr></thead><tbody><tr><td>0xCCCC</td><td>启用独立看门狗</td></tr><tr><td>0xAAAA</td><td>IWDG_RLR 中的值重新加载到计数器(喂狗)</td></tr><tr><td>0x5555</td><td>解除 IWDG_PR, IWDG_RLR 的写保护</td></tr><tr><td>0x5555之外的值</td><td>启用 IWDG_PR, IWDG_RLR 的写保护</td></tr></tbody></table></li><li><p>超时时间</p><p><img src="/2023/06/01/Embedded/STM32/13-wdg-timeout.png"></p><ul><li>超时时间: $T_{IWDG}$ &#x3D; 时钟周期 * PR 预分频系数 * (重装计数值 + 1)</li><li>其中,时钟周期&#x3D;1&#x2F;40KHz, PR 预分频系数只能取表中限定的值, 重装计数值12位(0~4095)</li></ul></li></ul></li><li><p><strong>窗口看门狗(Window WDG): 要求看门狗在精确计时窗口时作用(过早过晚均不行)</strong></p><p><img src="/2023/06/01/Embedded/STM32/13-wdg-block.png"></p></li><li><p>对比独立看门狗与窗口看门狗</p><table><thead><tr><th></th><th>独立看门狗</th><th>窗口看门狗</th></tr></thead><tbody><tr><td>复位时机</td><td>计数器减到0</td><td>计数器T[5:0] 减到0 &#x2F; 过早重装计数器</td></tr><tr><td>中断</td><td>&#x2F;</td><td>早期唤醒中断</td></tr><tr><td>时钟源</td><td>LSI(40KHz)</td><td>PCLK1(36MHz)</td></tr><tr><td>预分频系数</td><td>4, 8, 32, 64, 128, 256</td><td>1, 2, 4, 8</td></tr><tr><td>计数器</td><td>12位</td><td>6位</td></tr><tr><td>超时时间</td><td>0.1ms ~ 26214.4ms</td><td>113us ~ 58.25ms</td></tr><tr><td>喂狗方式</td><td>写入键寄存器,重装固定值 RLR</td><td>直接写入计数器</td></tr><tr><td>防误操作</td><td>键寄存器和写保护</td><td>&#x2F;</td></tr><tr><td>用途</td><td>独立工作,对时间精度要求较低</td><td>要求看门狗在精确计时窗口起作用</td></tr></tbody></table></li></ol><h3 id="13-2-看门狗代码"><a href="#13-2-看门狗代码" class="headerlink" title="13.2 看门狗代码"></a>13.2 看门狗代码</h3><ol><li><p>判断复位信号来源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) == SET) &#123;  <span class="hljs-comment">// 成立说明是独立看门狗复位</span><br><span class="hljs-comment">//if (RCC_GetFlagStatus(RCC_FLAG_WWDGRST) == SET) &#123;  // 成立说明是窗口看门狗复位</span><br>RCC_ClearFlag();  <span class="hljs-comment">// 标志位不会自动清除,进入后需要手动清除</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>操作独立看门狗</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* IWDG 初始化.LSI 会在设置看门狗后自动配置,无需手动开启 */</span><br>IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);  <span class="hljs-comment">// 独立看门狗写使能</span><br>IWDG_SetPrescaler(IWDG_Prescaler_16);  <span class="hljs-comment">// 设置预分频为16</span><br>IWDG_SetReload(<span class="hljs-number">2499</span>);  <span class="hljs-comment">// 设置重装值为2499,独立看门狗的超时时间为 1/40000 * 16 * 2500=1s</span><br>IWDG_ReloadCounter();  <span class="hljs-comment">// 重装计数器,初始化喂狗. 主循环中每1秒都需要喂狗,否则复位</span><br>IWDG_Enable();  <span class="hljs-comment">// 独立看门狗使能</span><br><span class="hljs-comment">/* 主循环中喂狗 */</span><br>IWDG_ReloadCounter();  <span class="hljs-comment">//重装计数器</span><br></code></pre></td></tr></table></figure></li><li><p>操作窗口看门狗</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* WWDG 初始化.以窗口时长 30~50ms 为例 */</span><br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);  <span class="hljs-comment">// 开启 WWDG 的时钟</span><br>WWDG_SetPrescaler(WWDG_Prescaler_8);  <span class="hljs-comment">// 设置预分频为8</span><br>WWDG_SetWindowValue(<span class="hljs-number">0x40</span> | <span class="hljs-number">21</span>);  <span class="hljs-comment">// 设置窗口时长 1/36,000,000 * 4096 * 8 * (54-21) = 30ms</span><br>WWDG_Enable(<span class="hljs-number">0x40</span> | <span class="hljs-number">54</span>);  <span class="hljs-comment">// 使能并第一次喂狗,超时时间为 1/36,000,000 * 4096 * 8 * (54+1) = 50ms</span><br><span class="hljs-comment">/* 主循环中喂狗 */</span><br>WWDG_SetCounter(<span class="hljs-number">0x40</span> | <span class="hljs-number">54</span>);  <span class="hljs-comment">//重装计数器</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="14-Flash-闪存"><a href="#14-Flash-闪存" class="headerlink" title="14 Flash 闪存"></a>14 Flash 闪存</h2><h3 id="14-1-Flash-功能"><a href="#14-1-Flash-功能" class="headerlink" title="14.1 Flash 功能"></a>14.1 Flash 功能</h3><ol><li><p>STM32F1 系列中容量产品 Flash 闪存模块组织</p><p><img src="/2023/06/01/Embedded/STM32/14-flash.png"></p></li><li><p><strong>读写 Flash 的用途</strong></p><ul><li><strong>利用程序存储器的剩余空间,保存用户数据(掉电不丢失)</strong></li><li><strong>通过在程序中编程(In-Application Programming),实现程序自我更新</strong></li></ul></li><li><p>下载程序方式</p><ul><li><strong>在线编程(In-Circuit Programming)</strong>: 更新程序存储器的全部内容<ul><li>通过 JTAG, SWD 协议(ST Link)或系统加载程序(Bootloader)下载程序</li></ul></li><li><strong>在程序中编程(In-Application Programming)</strong>: 使用微控制器支持的任意通信接口下载程序<ul><li>需要自己编写 Bootloader 程序(存储于程序更新时不覆盖的地方)</li><li>需要更新程序时,控制程序跳转到 Bootloader,接收通信数据(程序信息)</li><li>然后通过控制 Flash 读写,将程序信息存储于程序正常运行的地方</li></ul></li></ul></li><li><p>Flash 基本结构</p><p><img src="/2023/06/01/Embedded/STM32/14-Flash-struct.png"></p></li><li><p><strong>指针访问存储器</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// #define __IO volatile  // STM32对__IO的宏定义</span><br><span class="hljs-type">uint16_t</span> Data = *((__IO <span class="hljs-type">uint16_t</span> *)(<span class="hljs-number">0x08000000</span>));  <span class="hljs-comment">// 读取0x8000 0000地址的数据</span><br>* ((__IO <span class="hljs-type">uint16_t</span> *)(<span class="hljs-number">0x80000000</span>)) = <span class="hljs-number">0x1234</span>;  <span class="hljs-comment">// 给0x8000 0000地址写入数据.需要先解锁,执行相应流程</span><br></code></pre></td></tr></table></figure></li><li><p><strong>器件电子签名: 存放于闪存的系统存储区域,不可更改</strong></p><ul><li>读取方式: 使用指针直接读取指定地址下的存储器获得</li><li>闪存容量(单位kb)寄存器(16位)基地址: <code>0x1FFF F7E0</code></li><li>产品唯一身份标识寄存器(96位)基地址: <code>0x1FFF F7E8</code></li></ul></li></ol><h3 id="14-2-Flash-烧录"><a href="#14-2-Flash-烧录" class="headerlink" title="14.2 Flash 烧录"></a>14.2 Flash 烧录</h3><ol><li><p>读取芯片 ID</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">*((__IO <span class="hljs-type">uint16_t</span> *)(<span class="hljs-number">0x1FFFF7E0</span>));  <span class="hljs-comment">// 闪存容量寄存器的值</span><br>*((__IO <span class="hljs-type">uint32_t</span> *)(<span class="hljs-number">0x1FFFF7E8</span>));  <span class="hljs-comment">// 产品唯一身份标识寄存器的值,共96位</span><br>*((__IO <span class="hljs-type">uint32_t</span> *)(<span class="hljs-number">0x1FFFF7E8</span> + <span class="hljs-number">0x04</span>));<br>*((__IO <span class="hljs-type">uint32_t</span> *)(<span class="hljs-number">0x1FFFF7E8</span> + <span class="hljs-number">0x08</span>));<br></code></pre></td></tr></table></figure></li><li><p><strong>指定烧录程序是的起始地址</strong>: 打开工程选项 -&gt; Target</p><p><img src="/2023/06/01/Embedded/STM32/14-start-addr.png"></p></li><li><p><strong>程序占用空间大小查看</strong></p><ul><li><p>编译完成后会出现提示信息: <code>Program Size: Code=2784 RO-data=1788 RW-data=4 ZI-data=2660</code></p><ul><li><code>Code + RO=-data + Rw-data = 4576</code>: ROM 使用空间</li><li><code>Rw-data + ZI-data = 2664</code>:  RAM 使用空间</li></ul><table><thead><tr><th>数据类型</th><th>存储位置</th><th>说明</th></tr></thead><tbody><tr><td>Code</td><td>Flash</td><td>代码</td></tr><tr><td>RO-Data</td><td>Flash</td><td>只读数据.如 const 修饰</td></tr><tr><td>RW-Data</td><td>Flash &amp; SRAM</td><td>初值非0 可读可写的数据</td></tr><tr><td>ZI-Data</td><td>SRAM</td><td>初值为0 可读可写数据</td></tr></tbody></table></li><li><p>双击 <code>Target 1</code> 出现 <code>Project.map</code> 文件,拉到文件底部,可以直接查看程序占用空间情况</p><p><img src="/2023/06/01/Embedded/STM32/14-total-process-size.png"></p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 使用</title>
    <link href="/2022/02/01/Tool/Git/"/>
    <url>/2022/02/01/Tool/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-使用"><a href="#Git-使用" class="headerlink" title="Git 使用"></a>Git 使用</h1><h2 id="1-Git"><a href="#1-Git" class="headerlink" title="1 Git"></a>1 Git</h2><h3 id="1-1-Git-安装"><a href="#1-1-Git-安装" class="headerlink" title="1.1 Git 安装"></a>1.1 Git 安装</h3><ol><li><p>在 <a href="https://git-scm.com/download">git 官网</a> 下载对应系统的安装包</p></li><li><p>安装: 一直下一步安装即可</p></li><li><p>检查安装是否成功: 在命令行中输入 <code>git -v</code>.如果出现版本信息,则说明安装成功</p></li><li><p>在 Windows 中,还会自动安装 <code>Git Bash</code>(在文件夹中右键即可看到)</p></li></ol><h3 id="1-2-Git-基础"><a href="#1-2-Git-基础" class="headerlink" title="1.2 Git 基础"></a>1.2 Git 基础</h3><ol><li><p>git 的使用方式分为</p><ul><li>命令行(最基本,最常见)</li><li>图形化界面(GUI)</li><li>IDE 插件&#x2F;扩展</li></ul></li><li><p>初始化操作</p><ul><li><p><strong>git 的所有命令均以 <code>git</code> 开头,后面再接具体的命令.如: <code>git init</code> 表示初始化仓库</strong></p></li><li><p>git 安装后需要进行配置用户名和邮箱,以便查看代码提交者(只需设置一次)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;用户名&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;用户邮箱&quot;</span><br>git config --list  <span class="hljs-comment"># 检查配置是否成功</span><br></code></pre></td></tr></table></figure></li><li><p>如果用户名参数包含空格,则需要使用双引号包裹</p></li><li><p><code>--global</code> 表示全局配置,对所有仓库有效.如果省略则表示本地配置,只对本地仓库有效</p></li></ul></li><li><p>新建仓库</p><ul><li><p>仓库 &#x2F; 版本库(Repository, 简称 Reop): 是一个文件目录,其中的文件被 <code>git</code> 管理</p></li><li><p>对仓库中文件的 修改, 删除, 添加操作都将被 <code>git</code> 追踪</p></li><li><p><strong>本地创建仓库</strong>: 在 <code>Git Bash</code> 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure></li><li><p>此时 <code>git</code> 将会创建一个 <code>.git</code> 的隐藏目录.用于存放仓库的数据(不要自己更改)</p></li><li><p><strong>从服务器克隆仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> url<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-3-Git-概念"><a href="#1-3-Git-概念" class="headerlink" title="1.3 Git 概念"></a>1.3 Git 概念</h3><ol><li><p>工作区域</p><ul><li><p><strong>工作区(Working Directory)</strong>: 实际操作的目录</p></li><li><p><strong>暂存区(Staging Area&#x2F;Index)</strong>: 临时存储区域.保存即将提交到 <code>git</code> 仓库的修改内容</p></li><li><p><strong>本地仓库(Local Repository)</strong>: 存储代码和版本信息的主要位置.包含完整的项目历史和元数据</p><p><img src="/2022/02/01/Tool/Git/1-Git-workingArea.png"></p></li></ul></li><li><p>提交流程</p><ul><li><p>在对工作区的文件进行修改后,需要先提交到暂存区,然后将暂存区的修改提交到本地仓库</p></li><li><p>在上述过程中,可以使用 <code>git</code> 命令进行查看, 比较, 撤销修改</p></li><li><p><strong>添加: 从工作区 -&gt; 暂存区</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add<br></code></pre></td></tr></table></figure></li><li><p><strong>提交: 从暂存区 -&gt; 本地仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit<br></code></pre></td></tr></table></figure></li><li><p>在多次添加到暂存区后,到达需要增加版本的地步,就可以进行提交(push)</p></li></ul></li><li><p>文件状态</p><ul><li><p><strong>未跟踪(Untrack)</strong>: 新创建的,未被 <code>git</code> 管理的文件</p></li><li><p><strong>未修改(Unmodified)</strong>: 已经被 <code>git</code> 管理,但内容没有变化</p></li><li><p><strong>已修改(Modified)</strong>: 修改了文件,但未添加到暂存区</p></li><li><p><strong>已暂存(Staged)</strong>: 修改后,并添加到暂存区的文件</p><p><img src="/2022/02/01/Tool/Git/1-Git-fileState.png"></p></li></ul></li></ol><h3 id="1-4-提交"><a href="#1-4-提交" class="headerlink" title="1.4 提交"></a>1.4 提交</h3><ol><li><p>添加与提交</p><ul><li><strong><code>git status</code>: 展示目录中的文件的状态</strong></li><li><code>git add fileName</code>: 将指定的 <code>fileName</code> 文件添加到暂存区.还可以接收目录名参数</li><li><code>git commit -m &quot;提交信息备注&quot;</code>: 将暂存区中的修改提交到本地仓库(注意不会提交工作区的文件)</li><li><code>git log</code>: 查看提交记录.包含: 提交ID(唯一的16进制数), 作者, 时间, 备注信息</li></ul></li><li><p>版本穿梭</p><ul><li><p><strong><code>git reset --模式参数 版本号</code>: 穿梭到指定的版本</strong></p><p><img src="/2022/02/01/Tool/Git/1-Git-Reset.png"></p></li><li><p><code>soft</code>: 保留工作区和暂存区的内容</p><ul><li>当回退低版本时,高版本添加的文件将被保留到暂存区</li><li>此时对暂存区的这些文件进行修改,就可以再次执行提交</li></ul></li><li><p><code>hard</code>: 不保留工作区和暂存区的内容.这将导致高版本才添加的文件被删除(谨慎使用)</p></li><li><p><strong><code>mixed</code>: 默认参数.只保留工作区中的内容</strong></p><ul><li>当回退低版本时,高版本添加的文件将被保留到工作区,而非暂存区</li><li>在工作区中对内容进行修改后,再进行 添加, 提交 操作</li></ul></li><li><p>使用场景: 多次 <code>commit</code> 后,想要将其合并为一次 <code>commit</code>: 先回退,然后提交</p></li></ul></li></ol><h3 id="1-5-差异"><a href="#1-5-差异" class="headerlink" title="1.5 差异"></a>1.5 差异</h3><ol><li><p><strong>查看差异</strong>: 后续可以使用 IDE 更美观地查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff           <span class="hljs-comment"># 工作区 vs 暂存区</span><br>git diff HEAD      <span class="hljs-comment"># 工作区 + 暂存区 vs 本地仓库</span><br>git diff --cached  <span class="hljs-comment"># 暂存区 vs 本地仓库</span><br>git diff --staged  <span class="hljs-comment"># 暂存区 vs 本地仓库</span><br><br>git diff &lt;commit_hash&gt; &lt;commit_hash&gt;  <span class="hljs-comment"># 比较指定两次提交的差异</span><br>git diff HEAD~ HEAD                   <span class="hljs-comment"># 上一次提交 vs 本地仓库</span><br>git diff &lt;branch_hash&gt; &lt;branch_hash&gt;  <span class="hljs-comment"># 比较两个分支的差异</span><br></code></pre></td></tr></table></figure><p><img src="/2022/02/01/Tool/Git/1-Git-diff.png"></p></li><li><p><strong>删除文件</strong>: 删除工作区和暂存区中的指定文件.但版本库不变</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> fileName<br></code></pre></td></tr></table></figure></li><li><p><strong>忽略文件</strong>: 通过 <code>.gitignore</code> 文件来指定忽略特定的文件</p><p><img src="/2022/02/01/Tool/Git/1-Gitignore.png"></p><ul><li>新建一个 <code>.gitignore</code> 文件,在其中存储想要被忽略的文件名</li><li>会从上往下逐行匹配,每行表示一个忽略模式</li></ul></li><li><p><strong><code>.gitignore</code> 匹配规则: 使用标准的 Blob 模式匹配</strong></p><ul><li>文件可以使用通配符.如 <code>*.log</code> 表示忽略所有后缀为 log 的文件</li><li>文件夹需要以 <code>/</code> 结尾</li><li>以 <code>#</code> 开头的行表示注释</li></ul></li></ol><h3 id="1-6-分支"><a href="#1-6-分支" class="headerlink" title="1.6 分支"></a>1.6 分支</h3><ol><li><p>分支(Branch): 代码的不同版本</p><ul><li><strong><code>git branch</code>: 查看分支</strong>.其中 <code>*</code> 表示当前所处的分支</li><li><strong><code>git branch name</code>: 创建新分支</strong>.创建新分支后并不会自动切换分支</li><li><strong><code>git switch name</code>: 切换分支</strong>.同时工作区的文件会被自动替换为目标分支的状态</li><li><strong><code>git merge name</code>: 将 <code>name</code> 分支合并到当前分支</strong>.该指令会执行一次提交,因此需要输入提交信息</li><li><code>git log --graph --oneline --decorate --all</code>: 查看分支图</li><li><code>git branch -d name</code>: 删除指定的已合并分支</li></ul></li><li><p>合并冲突</p><ul><li><strong>当合并分支时,出现同一文件被不同分支修改时,会出现冲突,需要手动解决冲突</strong></li><li>此时,使用 <code>git status</code> 命令查看冲突文件的列表.<code>git diff</code> 可以查看冲突的具体内容</li></ul></li><li><p>变基(Rebase): </p><ul><li><strong><code>git rebase main</code>: 将当前分支变基到 <code>main</code> 分支</strong><ul><li>每个分支都有一个 <code>head</code> 指针,指向当前分支的最新提交记录</li><li>当执行变基时,将寻找两个分支的共同的祖先节点</li><li>然后将当前分支的祖先节点之后的提交移植到目标分支的后面</li></ul></li><li>变基使得分支始终保持简单的线性结构.但破坏了原分支的提交记录.不要在公共分支 <code>rebase</code></li><li>分支合并不会破坏提交记录,方便回溯.但产生了额外的节点</li></ul></li><li><p>分支的最佳实践</p><ul><li><p>保证 <code>master</code> 分支中的代码是可发布的.不允许直接修改,只能合并,每当合并时生成一个版本号</p></li><li><p>首先在主分支中分离出自己的分支进行开发测试,先在本地进行提交</p></li><li><p>然后发起推送请求(PR).经过 Review 之后,将该分支合并到主分支中</p><p><img src="/2022/02/01/Tool/Git/1-Git-GitHubFlow.png"></p></li></ul></li></ol><h3 id="1-7-关联-github-仓库"><a href="#1-7-关联-github-仓库" class="headerlink" title="1.7 关联 github 仓库"></a>1.7 关联 github 仓库</h3><ol><li><p>要关联本地仓库与远程仓库,首先需要设置 SSH 密钥</p><ul><li><p>检查主机是否已经存在 ssh key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~/.ssh  # 切换到.ssh目录<br>ls         # 如果有 id_rsa(私钥) id_rsa.pub(公钥) 文件,说明已经有 ssh key<br></code></pre></td></tr></table></figure></li><li><p>如果没有 ssh key.则需要先生成(如果有 ssh key.则直接获取)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -b 4096  # 生成 rsa 密钥,大小为 4096<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在 GitHub 账号中添加公钥</p><ul><li><p>回到 GitHub,点击头像 -&gt; <code>Settings</code> -&gt; <code>SSH and GPG keys</code> -&gt; <code>New SSH key</code></p><p><img src="/2022/02/01/Tool/Git/1-Git-github-sshkey.png"></p></li><li><p>将 <code>id_rsa.pub</code> 文件中的内容复制到 Key 中即可</p></li><li><p>验证设置是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br><span class="hljs-meta prompt_"># </span><span class="language-bash">成功将显示: Hi Fxs21! You<span class="hljs-string">&#x27;ve successfully authenticated...</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>完成 SSH 的设置后,可以直接使用 SSH 进行 <code>git clone</code> 操作</p></li><li><p>本地仓库和远程仓库是不同的仓库.想要将两者的文件同步.需要 <code>git pull, git push</code> 指令</p><p><img src="/2022/02/01/Tool/Git/1-Git-push.png"></p></li><li><p>此时,完成了关联本地仓库与远程仓库的准备工作.先在 github 上创建一个新仓库.然后进行操作</p><ul><li><code>git remote add &lt;shortname&gt; &lt;url&gt;</code>: 将本地仓库关联到远程仓库.同时创建了远程库的别名</li><li><code>git remote -v</code>: 查看当前仓库对应的远程仓库的别名和地址(默认别名 <code>shortname == origin</code>)</li><li><code>git branch -M main</code>: 指定分支名为 <code>main</code></li><li><strong><code>git push -u origin main</code>: 将本地的 main 分支与远程仓库 <code>origin</code> 的 <code>main</code> 分支关联.并推送</strong></li><li><strong><code>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code>: 拉取远程仓库中的分支.默认为 <code>origin</code> 的 <code>main</code> 分支</strong></li></ul></li></ol><h2 id="2-GitHub-Pages"><a href="#2-GitHub-Pages" class="headerlink" title="2 GitHub Pages"></a>2 GitHub Pages</h2><h3 id="2-1-创建-github-仓库"><a href="#2-1-创建-github-仓库" class="headerlink" title="2.1 创建 github 仓库"></a>2.1 创建 github 仓库</h3><ol><li><p><a href="https://github.com/">github</a>: 代码托管平台</p></li><li><p>创建仓库: 名称格式为 <code>username.github.io</code></p><p><img src="/2022/02/01/Tool/Git/1-Git-githubCreateRepo.png"></p></li><li><p>在 <code>settings</code> 中找到 <code>Pages</code>.此时 <code>Source</code> 为空.因此需要上传静态页面</p></li></ol><h3 id="2-2-克隆仓库到本地"><a href="#2-2-克隆仓库到本地" class="headerlink" title="2.2 克隆仓库到本地"></a>2.2 克隆仓库到本地</h3><ol><li><p>下载 <code>github desktop</code>,并与 github 账号关联.然后将创建的仓库克隆到本地</p><p><img src="/2022/02/01/Tool/Git/2-Git-githubDesktop.png"></p></li><li><p>将需要上传的文件全部复制到本地仓库路径中(需要填写描述信息 Summary)</p><p><img src="/2022/02/01/Tool/Git/2-Git-githubDesktop-file.png"></p></li><li><p>然后点击上方的 <code>Publish branch</code>.将本地仓库上传到 <code>github</code></p></li></ol><h3 id="2-3-公网访问项目"><a href="#2-3-公网访问项目" class="headerlink" title="2.3 公网访问项目"></a>2.3 公网访问项目</h3><ol><li><p>此时再次进入 github. 在 <code>settings</code> 中找到 <code>Pages</code>.此时 <code>Source</code> 就有了 <code>master</code> 分支</p><p><img src="/2022/02/01/Tool/Git/2-Git-githubSource.png"></p></li><li><p>显示 Your site is live at <a href="https://fxs21.github.io/">https://fxs21.github.io/</a>: 表示成功部署可以在网页中打开</p><p><img src="/2022/02/01/Tool/Git/2-Git-shark.png"></p></li></ol><h3 id="2-4-开源项目的结构"><a href="#2-4-开源项目的结构" class="headerlink" title="2.4 开源项目的结构"></a>2.4 开源项目的结构</h3><ol><li><p>开源项目: jQuery 为例</p><p><img src="/2022/02/01/Tool/Git/2-Git-jQuery.png"></p></li></ol><h2 id="3-IDE-集成-Git"><a href="#3-IDE-集成-Git" class="headerlink" title="3 IDE 集成 Git"></a>3 IDE 集成 Git</h2><h3 id="3-1-配置-Git"><a href="#3-1-配置-Git" class="headerlink" title="3.1 配置 Git"></a>3.1 配置 Git</h3><ol><li><p>以 Pycharm 为例.需要先配置 Git</p><ul><li><p>需要给 Pycharm 指出 Git 的安装目录.显示出版本信息表示配置成功</p></li><li><p><kbd>设置</kbd> -&gt; <kbd>版本控制</kbd> -&gt; <kbd>Git</kbd> -&gt; 选择 Git 可执行文件路径为 <code>Git\cmd\git.exe</code></p><p><img src="/2022/02/01/Tool/Git/3-Git-PycharmSet.png"></p></li></ul></li><li><p>初始化 git: 点击左下角的 <kbd>Git</kbd> -&gt; <kbd>创建 Git 仓库...</kbd>.选择创建仓库的目录后确认即可</p></li><li><p>git 界面</p><p><img src="/2022/02/01/Tool/Git/3-Git-Pycharm.png"></p></li></ol><h3 id="3-2-Git-操作"><a href="#3-2-Git-操作" class="headerlink" title="3.2 Git 操作"></a>3.2 Git 操作</h3><ol><li><p>对现有的 Git 仓库进行操作</p><ul><li><strong>获取网络上的 Git 仓库</strong>: 在编辑器右键 -&gt; <kbd>Git</kbd> -&gt; <kbd>克隆...</kbd>.填写 <code>URL</code> 和 <code>本地目录</code>即可</li><li><strong>新建分支</strong>: 点击左上角的 <kbd>VCS 微件</kbd> -&gt; <kbd>新建分支</kbd>.输入新分支的名称,进行创建</li><li><strong>提交修改</strong>: 在新分支修改文件后,IDE 将会检测到修改<br>点击左侧的 <kbd>提交</kbd>.选择需要进行版本管理的文件.在下方的<kbd>提交消息</kbd>中添加更改信息即可<br>点击<kbd>提交消息</kbd>的右下角的设置,勾选<kbd>格式化代码</kbd>将会根据代码样式自动编辑文件</li><li><strong>修正</strong>: 如果忘记添加某些需要提交的文件,可以勾选<kbd>修正</kbd>再次提交</li><li><strong>推送到远程仓库</strong>: <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>K</kbd> 打开推送对话框.即可推送提交</li></ul></li><li><p>查看项目历史记录</p><ul><li>点击左下的 <kbd>Git</kbd>.可以看到 git 分支.提交记录可以进行筛选,右键可以对其进行多种操作</li><li>工具栏右侧可以看到相关信息.双击提交文件树中的文件可以查看具体差异</li><li><kbd>与本地比较</kbd> 也可以对比文件的差异.其中绿色表示无差异,蓝色表示存在差异</li></ul></li><li><p>功能分支工作流</p><ul><li><p>完成分支工作后准备推送到远程.需要检查是否与 Main 分支中已提交的内容产生冲突</p><p><img src="/2022/02/01/Tool/Git/3-Git-Branch01.png"></p></li><li><p>签出 <code>Main</code> 分支: 点击左上角的 <kbd>VCS 微件</kbd> -&gt; 选中<kbd>Main</kbd> -&gt; <kbd>签出</kbd></p></li><li><p>更新 <code>Main</code> 分支: <kbd>Ctrl</kbd><kbd>T</kbd>打开<code>更新项目</code>对话框进行更新.此时 Main 分支可能已经作出更改:</p><p><img src="/2022/02/01/Tool/Git/3-Git-Branch02.png"></p></li><li><p><strong>变基</strong>: 将提交放在他人的修改之后可能更加合适,此时就需要进行变基<br>点击左上角的 <kbd>VCS 微件</kbd> -&gt; 选中<kbd>feature</kbd> -&gt; <kbd>签出并变基到 Main</kbd></p><p><img src="/2022/02/01/Tool/Git/3-Git-Branch03.png"></p></li><li><p><strong>更新到远程仓库</strong>: 右键<code>HEAD</code>,选择<kbd>推送</kbd>.此时由于本地的<code>feature</code>分支 变基后与远程冲突<br>因此,需要使用<kbd>强制推送</kbd>(慎重使用)</p></li></ul></li></ol><h3 id="3-3-设置-GitHub-账号"><a href="#3-3-设置-GitHub-账号" class="headerlink" title="3.3 设置 GitHub 账号"></a>3.3 设置 GitHub 账号</h3><ol><li><p><kbd>文件</kbd> -&gt; <kbd>设置</kbd> -&gt; <kbd>版本控制</kbd> -&gt; <kbd>GitHub</kbd> -&gt; <kbd>添加账号</kbd></p><p><img src="/2022/02/01/Tool/Git/3-Git-github.png"></p></li><li><p>分享到 Github: <kbd>Git</kbd> -&gt; <kbd>GitHub</kbd> -&gt; <kbd>在 GitHub 上共享项目</kbd></p></li><li><p><code>clone</code>: 在首页 -&gt; <kbd>从VCS获取</kbd> -&gt; <kbd>仓库URL</kbd></p><p><img src="/2022/02/01/Tool/Git/3-Git-clone.png"></p></li><li><p><code>push</code>: 默认使用 HTTPS.因此需要修改为 SSH.别名也需要修改,否则会冲突</p><p><img src="/2022/02/01/Tool/Git/3-Git-push-1.png"></p></li><li><p><code>pull</code>: 注意在修改代码之前,应该保证代码是最新版本.因此需要先进行 <code>pull</code></p><p><img src="/2022/02/01/Tool/Git/3-Git-pull.png"></p></li></ol><h2 id="4-hexo"><a href="#4-hexo" class="headerlink" title="4 hexo"></a>4 hexo</h2><h3 id="4-1-安装-hexo"><a href="#4-1-安装-hexo" class="headerlink" title="4.1 安装 hexo"></a>4.1 安装 <a href="https://hexo.io/zh-cn/">hexo</a></h3><ol><li><p><code>git</code> 配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;fxs&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;yshuang68@163.com&quot;</span><br>git config --list<br></code></pre></td></tr></table></figure></li><li><p>安装 NodeJS: <a href="https://nodejs.org/en">官网下载</a>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">node -v  # 验证安装<br>npm config set prefix &quot;D:\code\npm_path&quot;  # 配置 npm 的全局安装路径<br></code></pre></td></tr></table></figure></li><li><p>安装 <code>hexo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g  <span class="hljs-comment"># 安装 hexo</span><br>hexo -v                  <span class="hljs-comment"># 验证安装</span><br></code></pre></td></tr></table></figure></li><li><p>初始化 <code>hexo</code>(新建一个空目录,然后使用 <code>git bash</code> 打开)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init  <span class="hljs-comment"># 从 github 拉取代码</span><br>git init   <span class="hljs-comment"># 初始化 git 仓库</span><br></code></pre></td></tr></table></figure></li><li><p><code>hexo</code> 的 hello world</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s<br></code></pre></td></tr></table></figure><ul><li><p>打开网址 <a href="http://localhost:4000/.%E8%83%BD%E7%9C%8B%E5%88%B0">http://localhost:4000/.能看到</a> hello world 网页表示配置成功</p><p><img src="/2022/02/01/Tool/Git/4-hexo-hello-world.png"></p></li></ul></li></ol><h3 id="4-2-hexo-部署"><a href="#4-2-hexo-部署" class="headerlink" title="4.2 hexo 部署"></a>4.2 hexo 部署</h3><ol><li><p>配置 SSH 免密登录</p><ul><li><p>先检查是否已经生成过密钥(<code>PowerShell </code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls ~\.ssh\id_rsa.pub  # 查看是否已经生成过密钥<br>cat ~\.ssh\id_rsa.pub # 查看生成的密钥(复制输出的内容.以 ssh-rsa AAA... 开头)  <br></code></pre></td></tr></table></figure></li><li><p>若没有生成过则生成密钥(默认保存路径为 <code>C:\Users\你的用户名\.ssh\id_rsa</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -b 4096<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在 GitHub 上添加公钥(参考 [1.7章](# 1.7 关联 github 仓库))</p></li><li><p>安装部署插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li><li><p>配置 hexo 上传的地址(打开 <code>_config.yml</code> 文件,在最后添加内容.<strong>注意这里的配置决定了仓库地址</strong>)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">&#x27;git&#x27;</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:Fxs21/Fxs21.github.io.git</span><br></code></pre></td></tr></table></figure></li><li><p>使用 hexo 命令将代码部署到远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl <span class="hljs-comment"># 清除文件</span><br>hexo g  <span class="hljs-comment"># 生成静态文件.路径为 ./public/</span><br>hexo d  <span class="hljs-comment"># 上传到服务器</span><br></code></pre></td></tr></table></figure></li><li><p>对于调试不需要生成静态文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo cl &amp;&amp; hexo s<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-3-hexo-配置"><a href="#4-3-hexo-配置" class="headerlink" title="4.3 hexo 配置"></a>4.3 hexo 配置</h3><ol><li><p><strong>更换主题</strong>: 在 <a href="https://hexo.io/themes/">Themes | Hexo</a> 选择合适的主题.这里以 <code>Fluid</code> 为例,根据 <a href="https://github.com/fluid-dev/hexo-theme-fluid">参考文档</a> 安装</p><ul><li><p>安装 <code>Fluid</code> 主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure></li><li><p>在博客目录下创建 <code>_config.fluid.yml</code> 文件</p></li><li><p>将 <code>./node_modules/hexo-theme-fluid/_config.yml</code> 的内容复制到 <code>_config.fluid.yml</code> 文件</p></li><li><p>更改默认的主题: 打开 <code>_config.yml</code> 文件,修改 <code>theme, language</code> 项</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>     <span class="hljs-comment"># 指定主题</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CH</span>  <span class="hljs-comment"># 指定语言</span><br></code></pre></td></tr></table></figure></li><li><p>创建关于页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about<br></code></pre></td></tr></table></figure></li><li><p>在 <code>./source/about/index.md</code> 文件中添加一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">layout: about<br></code></pre></td></tr></table></figure></li></ul></li><li><p>工作目录(初始化之后的目录)</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br><span class="hljs-string">|   ├── _drafts</span><br><span class="hljs-string">|   └── _posts</span><br>└── themes<br></code></pre></td></tr></table></figure><ul><li><strong><code>_config.yml</code>: 网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 文件.可以在此配置大部分的参数</strong></li><li><code>package.json</code>: 应用程序的信息. <a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> 渲染引擎 已默认安装</li><li><code>scaffolds</code>: 模板文件夹.新建文章时根据此文件创建</li><li><strong><code>source</code>: 存放用户资源</strong><ul><li>除 <code>_posts</code> 文件夹之外,开头命名为 <code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略</li><li>Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹,而其他文件会被拷贝过去</li></ul></li><li><code>themes</code>: 主题文件夹.Hexo 会根据主题来生成静态页面</li></ul></li><li><p><strong>站点配置</strong>: Hexo 博客目录下的 <code>_config.yml</code> 文件</p><ul><li><p>站点名称</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Shuang</span> <span class="hljs-string">blog</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">&#x27;Shuang blog&#x27;</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;Shuang blog&#x27;</span><br><span class="hljs-attr">keywords:</span> <span class="hljs-string">Shuang</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">Shuang</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">&#x27;Asia/Shuanghai&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>资源文件夹</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ul><li>启用后,资源图片将会被自动解析为其对应文章的路径</li><li>例如: <code>image.jpg</code> 位置为 <code>/2020/01/02/foo/image.jpg</code>.这表示它是 <code>/2020/01/02/foo/</code> 文章的一张资源图片</li><li><code>![](image.jpg)</code> 将会被解析为 <code>&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt;</code></li></ul></li></ul></li></ol><h3 id="4-4-Fluid-主题"><a href="#4-4-Fluid-主题" class="headerlink" title="4.4 Fluid  主题"></a>4.4 <a href="https://hexo.fluid-dev.com/docs/start/">Fluid </a> 主题</h3><ol><li><p>配置文件的修改</p><ul><li><strong>主题配置</strong>: <code>theme/fluid/_config.yml</code> 或者 <code>_config.fluid.yml</code> 文件</li></ul></li><li><p>Fluid 主题默认总体概览</p><p><img src="/2022/02/01/Tool/Git/4-fluid-appearance.png"></p></li><li><p>主题字体</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 主题字体配置</span><br><span class="hljs-attr">font:</span><br>  <span class="hljs-attr">font_size:</span> <span class="hljs-string">16px</span><br>  <span class="hljs-attr">font_family:</span> <span class="hljs-string">consolas</span>  <span class="hljs-comment"># 使用 consolas 字体</span><br>  <span class="hljs-attr">letter_spacing:</span> <span class="hljs-number">0.</span><span class="hljs-string">02em</span><br>  <span class="hljs-attr">code_font_size:</span> <span class="hljs-number">85</span><span class="hljs-string">%</span><br></code></pre></td></tr></table></figure></li><li><p>导航栏左侧标题(默认为 <code>Fluid</code>)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">blog_title:</span> <span class="hljs-string">&quot;windsand&quot;</span>  <span class="hljs-comment"># 将会以文本的形式显示</span><br></code></pre></td></tr></table></figure></li><li><p>首页背景图以及 slogan 文本</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">index:</span><br>  <span class="hljs-comment"># 首页 Banner 头图,可以是相对路径或绝对路径,以下相同</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/train.png</span>  <span class="hljs-comment"># 首页背景图.注意要自己存放图片资源到路径</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">100</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br>  <span class="hljs-comment"># 首页副标题的独立设置</span><br>  <span class="hljs-attr">slogan:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">text:</span> <span class="hljs-string">&quot;人生如逆旅,我亦是行人&quot;</span>  <span class="hljs-comment"># 首页 slogan</span><br></code></pre></td></tr></table></figure></li><li><p>文章页背景图(归档页, 分类页, 标签页, 关于页, 自定义页, 404 页, 友链页 同理)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/train.png</span>  <span class="hljs-comment"># 与上面的首页背景图配置方法相同</span><br></code></pre></td></tr></table></figure></li><li><p>文章内数学公式</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">math:</span><br>  <span class="hljs-comment"># 开启后文章默认可用,自定义页面如需使用,需在 Front-matter 中指定 math: true</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>   <br>  <span class="hljs-comment"># 开启后,只有在文章 Front-matter 里指定 math: true 才会在文章页启动公式转换</span><br>  <span class="hljs-comment"># 以便在页面不包含公式时提高加载速度</span><br>  <span class="hljs-attr">specific:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="4-5-文章属性"><a href="#4-5-文章属性" class="headerlink" title="4.5 文章属性"></a>4.5 文章属性</h3><ol><li><p>以本文为例,在 <code>front-matter</code> 中编写内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">typora-root-url:</span> <span class="hljs-string">./Git</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Git</span> <span class="hljs-string">使用</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Git</span>, <span class="hljs-string">工具箱</span>, <span class="hljs-string">笔记</span>, <span class="hljs-string">Code</span>]<br><span class="hljs-attr">categories:</span> <span class="hljs-string">工具箱</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">&quot;Git 的使用方式介绍; GitHub Pages 页面的配置方法; 在 IDE 中使用 Git; hexo 的安装使用; typora 的配置; MarkDown 语法.&quot;</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/Git.svg</span><br><span class="hljs-attr">math:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><img src="/2022/02/01/Tool/Git/4-Hexo-front-matter.png"></p></li><li><p><code>typora-root-url</code>: typora 中图片的根目录</p></li><li><p><code>title</code>: 文章的标题.将会在主页中显示</p></li><li><p><code>tags</code>: 文章的标签.将会在主页中显示,点击可以跳转.一篇文章可以有多个 tag</p></li><li><p><code>categories</code>: 文章的类别.分类下面可以有多篇文章</p></li><li><p><code>excerpt</code>: 文章的摘要</p></li><li><p><code>index_img</code>: 文章封面图的路径.本示例的路径为 <code>./source/img/Git.svg</code></p></li></ol><h2 id="5-typora"><a href="#5-typora" class="headerlink" title="5 typora"></a>5 typora</h2><h3 id="5-1-typora-配置"><a href="#5-1-typora-配置" class="headerlink" title="5.1 typora 配置"></a>5.1 typora 配置</h3><ol><li><p>为了与 hexo 部署兼容(主要是图片存放路径)</p><ul><li><p>文件 -&gt; 偏好设置 -&gt; 图像 -&gt; 插入图片时 -&gt; 复制到指定路径 <code>./$&#123;filename&#125;</code></p><p><img src="/2022/02/01/Tool/Git/5-typora-image-setting.png"></p></li><li><p>格式 -&gt; 图像 -&gt; 设置图片根目录 -&gt; 将 <code>./$&#123;filename&#125;</code> 目录设置为根目录</p></li></ul></li><li><p>图片命令不要包含中文或空格.否则可能显示异常</p></li><li><p>为了更好的结构化管理,图片命名时前缀加上图片所在的章节</p></li></ol><h3 id="5-2-MarkDown-语法"><a href="#5-2-MarkDown-语法" class="headerlink" title="5.2 MarkDown 语法"></a>5.2 MarkDown 语法</h3>]]></content>
    
    
    <categories>
      
      <category>工具箱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Code</tag>
      
      <tag>Git</tag>
      
      <tag>工具箱</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 使用</title>
    <link href="/2022/01/01/Tool/Linux/"/>
    <url>/2022/01/01/Tool/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-使用"><a href="#Linux-使用" class="headerlink" title="Linux 使用"></a>Linux 使用</h1><h2 id="0-导论"><a href="#0-导论" class="headerlink" title="0 导论"></a>0 导论</h2><h3 id="0-1-准备环境"><a href="#0-1-准备环境" class="headerlink" title="0.1 准备环境"></a>0.1 准备环境</h3><ol><li>Linux 学习环境搭建目标: 在 Windows 中,首先创建一个虚拟机,然后安装 <code>CentOS</code>(现推荐安装 [wsl](# 0.3 wsl))</li><li>安装 <code>Vmware</code><ul><li>先在 BIOS 中开启 <code>虚拟化设备支持</code></li><li>安装只需一直下一步即可</li></ul></li><li>安装 <code>CentOS</code><ul><li>将界面修改为中文: 在快捷方式的目标栏添加 <code> --locale zh_CN</code></li></ul></li><li>如果遇到打开虚拟机就蓝屏: 在 Windows 功能中打开 <code>虚拟机监控程序平台, 虚拟机平台</code></li><li><strong>网络连接模式</strong><ul><li>桥接模式: 虚拟系统可和外部系统通讯,但容易造成 IP 冲突</li><li>NAT 模式: 网络地址转化模式.可和外部系统通讯,而不造成 IP 冲突</li><li>主机模式: 独立的系统.不进行通讯</li></ul></li><li>虚拟机功能<ul><li>克隆: 直接复制文件,系统也是文件,复制文件即可克隆系统</li><li>快照: 保存快照后,可以在快照管理回到之前的状态</li><li>删除和迁移: 与克隆类似,直接操作文件</li></ul></li></ol><h3 id="0-2-远程登陆"><a href="#0-2-远程登陆" class="headerlink" title="0.2 远程登陆"></a>0.2 远程登陆</h3><ol><li><p>Xshell &amp; Xftp 安装(Xshell 用于执行指令.Xftp 用于文件传输)</p></li><li><p>Linux 终端输入 <code>ifconfig</code> 查询 ip 地址(inet 后面即为 ip 地址)</p></li><li><p>Windows 中命令行输入 <code>ping ip</code>,检查是否联通</p></li><li><p>进入 Xshell -&gt; 新建会话 -&gt; 主机输入 Linux 的 ip -&gt; 完成</p></li><li><p>双击左侧主机名 -&gt; 接收并保存 -&gt; 输入用户名和密码.即可登录</p></li></ol><h3 id="0-3-wsl"><a href="#0-3-wsl" class="headerlink" title="0.3 wsl"></a>0.3 wsl</h3><ol><li><p>先在 BIOS 中开启 <code>虚拟化设备支持</code>(任务管理器中显示 <code>虚拟化已开启</code> 即可)</p><p><img src="/2022/01/01/Tool/Linux/0-Virtualization.png"></p></li><li><p>win + R 输入 control 进入控制面板 -&gt; 程序和功能 -&gt; 启用或关闭 Windows 功能.<br>开启 <code>Virtual Machine Platform</code> 和 <code>适用于 Linux 的 Windos 子系统</code>(完成该步骤后需要重启电脑)</p><p><img src="/2022/01/01/Tool/Linux/0-Windows-feature.png"></p></li><li><p>打开终端,执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">wsl --update   # 安装 linux 子系统<br>wsl --version  # 检查版本信息<br>wsl --list --online         # 列出可以在线安装的版本 <br>wsl --install Ubuntu-24.04  # 安装 Ubuntu 24.04.然后根据提示新建用户<br></code></pre></td></tr></table></figure></li><li><p>更新所有软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update     # 拉取可更新软件列表<br>sudo apt upgrade -y # 更新所有软件<br>sudo apt install neofetch htop  # 安装 neofetch<br>neofetch  # 运行 neofetch.显示系统信息<br>htop      # 交互式界面显示系统资源使用情况<br></code></pre></td></tr></table></figure></li></ol><h2 id="1-Linux-基础"><a href="#1-Linux-基础" class="headerlink" title="1 Linux 基础"></a>1 Linux 基础</h2><h3 id="1-1-Linux-目录结构"><a href="#1-1-Linux-目录结构" class="headerlink" title="1.1 Linux 目录结构"></a>1.1 Linux 目录结构</h3><ol><li><p><strong>Linux 一切皆文件</strong></p><p><img src="/2022/01/01/Tool/Linux/1-Linux-Struct.jpg"></p></li><li><p><code>/</code>: 根目录,包含整个文件系统</p><ul><li><code>/bin</code>: 二进制文件目录.包含一些常用的命令和工具.如 ls, cp, mv…</li><li><code>/sbin</code>: 系统二进制文件目录.包含一些系统管理命令和工具.如 shutdown, reboot…</li><li><code>/boot</code>: 启动目录.包含启动 Linux 系统所需的文件,如内核文件和引导程序</li><li><strong><code>/dev</code>: 设备目录.包含系统中的设备文件.如 硬盘, 光驱, 键盘…</strong></li><li><code>/etc</code>: 配置文件目录.包含系统和应用程序的配置文件.如网络配置, 用户配置…</li><li><strong><code>/home</code>: 用户主目录.包含系统中所有用户的主目录</strong></li><li><code>/lib</code>: 库文件目录.包含系统和应用程序所需的共享库文件</li><li><code>/media</code>: 挂载目录.包含可移动设备的挂载点,如 U盘, 光盘…</li><li><strong><code>/mnt</code>: 挂载目录.包含临时挂载的文件系统</strong></li><li><strong><code>/opt</code>: 可选目录.包含第三方应用程序的安装目录</strong></li><li><code>/proc</code>: 进程目录.包含系统和进程的信息.如 内存使用, CPU使用…</li><li><code>/root</code>: root 用户主目录</li><li><code>/tmp</code>: 临时目录.包含系统和应用程序的临时文件</li><li><code>/usr</code>: 用户程序目录.包含系统和用户安装的应用程序和文件</li><li><code>/var</code>: 可变目录.包含系统和应用程序的可变数据.如日志文件, 缓存文件…</li></ul></li></ol><h3 id="1-2-vim"><a href="#1-2-vim" class="headerlink" title="1.2 vim"></a>1.2 vim</h3><ol><li><p>vim 键盘图</p><p><img src="/2022/01/01/Tool/Linux/1-vi-vim-cheat-sheet-sch.gif"></p></li><li><p>vim 的工作模式: 命令模式, 输入模式, 命令行模式</p><p><img src="/2022/01/01/Tool/Linux/1-vim-vi-workmodel.png"></p></li><li><p>命令模式: 当启动 vi&#x2F;vim 时,默认为命令模式</p><ul><li><kbd>x</kbd>: 删除当前光标所在处的字符</li><li><kbd>G</kbd>: 定位到最后一行, <kbd>gg</kbd> 则定位到首行</li><li><strong><kbd>yy</kbd>: 复制当前行,在前面加一个数字可以选定行数,如 5yy</strong></li><li><strong><kbd>dd</kbd>: 剪切当前行,在前面加一个数字可以选定行数,如 3dd</strong></li><li><strong><kbd>p</kbd>: 粘贴复制的内容</strong></li><li><kbd>u</kbd>: 撤销操作</li><li><kbd>Ctrl</kbd><kbd>r</kbd>: 重做上一次的撤销</li><li>定位到指定行: 输入行数然后 <kbd>Shif</kbd><kbd>g</kbd></li></ul></li><li><p>插入模式: 可以直接输入文本</p><ul><li><strong><kbd>ESC</kbd>: 进入命令行模式</strong></li><li><kbd>Page Up</kbd> &#x2F; <kbd>Page Down</kbd>: 上下翻页</li></ul></li><li><p>命令行模式: 保存或退出文件,设置编辑环境</p><ul><li><strong><kbd>:w</kbd>: 保存文件</strong></li><li><strong><kbd>:q</kbd>: 退出编辑器</strong></li><li><kbd>:q!</kbd>: 强制退出,且不保存</li><li><kbd>:set nu</kbd>: 显示行号.<kbd>:set nonu</kbd>: 隐藏行号. <kbd>:整数</kbd>:跳转到某行</li><li><strong><kbd>/text</kbd>: 查找文本信息.此时输入<kbd>n</kbd>查找下一个.<kbd>N</kbd>查找下一个</strong></li><li><kbd>?text</kbd>: 向上查找文本信息</li></ul></li></ol><h2 id="2-Linux-命令"><a href="#2-Linux-命令" class="headerlink" title="2. Linux 命令"></a>2. Linux 命令</h2><h3 id="2-1-基础命令"><a href="#2-1-基础命令" class="headerlink" title="2.1 基础命令"></a>2.1 基础命令</h3><ol><li><p>命令格式</p><ul><li><p>linux 的命令格式为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">命令名称 [-命令选项] [命令参数]<br></code></pre></td></tr></table></figure></li><li><p>命令名称实际上也可以是 Shell 脚本</p></li><li><p>命令选项</p><ul><li>长格式: 如 <code>man --help</code></li><li>短格式: 如 <code>man -h</code></li></ul></li><li><p>命令参数: 如文件, 目录, 用户等资源</p></li></ul></li><li><p>开关机</p><ul><li><code>shutdown -h now</code>: 立即关机</li><li><strong><code>shutdown -h 1</code>: 1分钟后关机.这也是 <code>shutdown</code> 的默认形式</strong></li><li><code>shutdown -r now</code>: 立即重启</li><li><code>halt</code>: 立即关机</li><li><strong><code>reboot</code>: 立即重启</strong></li><li><strong><code>sync</code>: 把内存里的数据同步到磁盘(建议在关机前先执行该指令)</strong></li></ul></li><li><p>登录 Linux(一般仅使用普通用户登录)</p><ul><li><code>su -username</code>: 切换登陆用户</li><li><code>logout</code>: 注销用户</li><li><strong>在登陆后可使用 <code>su -root</code> 切换到 root 用户.然后使用 <code>logout</code> 可以切换回普通用户</strong></li></ul></li><li><p>用户管理(要想使用 Linux 系统资源,需要向管理员申请账号)</p><ul><li><strong><code>useradd 用户名</code>: 添加用户.且登陆后将默认进入 <code>/home/username</code> 目录</strong></li><li><code>passwd 用户名</code>: 指定 &#x2F; 修改密码</li><li><code>userdel 用户名</code>: 删除用户,但保留目录</li><li><code>id 用户名</code>: 查询用户信息</li><li><code>whoami</code>: 查看当前登录用户</li></ul></li><li><p>用户组(对具有相似权限的用户分组管理)</p><ul><li><strong><code>groupadd 组名</code>: 创建用户组(若创建用户时未指定组,默认创建同名组)</strong></li><li><code>groupdel 组名</code>: 删除用户组</li><li><code>groupmod -n 新名称 原名称</code>: 更改用户组名</li><li><code>usermod -g 组名 用户名</code>: 修改用户的组别</li><li><code>gpasswd -d 组名 用户组</code>: 从组中删除用户</li></ul></li><li><p>帮助指令</p><ul><li><code>man [指令或配置文件]</code>: 获取帮助信息.如 <code>man ls</code></li><li><code>help 指令</code>: 获得 shell 内置命令的帮助信息.如 <code>help cd</code></li></ul></li></ol><h3 id="2-2-文件目录"><a href="#2-2-文件目录" class="headerlink" title="2.2 文件目录"></a>2.2 文件目录</h3><ol><li>路径切换<ul><li><strong><code>pwd</code>: 显示当前目录的绝对路径</strong></li><li><strong><code>ls [目录/文件]</code>: 展示文件和目录</strong><ul><li><code>-a</code>: 显示所有文件和目录(包括隐藏文件,即以 <code>.</code> 开头的文件)</li><li><code>-l</code>: 以列表形式显示</li></ul></li><li><strong><code>cd</code>: 切换到指定目录</strong><ul><li><code>cd ~</code>: 回到家目录</li><li><code>cd ..</code>: 回到上一级目录</li><li><code>cd -</code>: 返回上一次目录</li></ul></li></ul></li><li>目录与文件<ul><li><strong><code>touch 文件名</code>: 创建空文件</strong></li><li><strong><code>mkdir 目录名</code>: 创建目录(默认只能创建一级目录)</strong><ul><li><code>mkdir -p 目录名1/目录名2</code>: 创建多级目录</li></ul></li><li><strong><code>rmdir 要删除的空目录名</code>: 删除空目录</strong></li><li><strong><code>rm 要删除的文件或目录</code>: 删除文件或目录</strong><ul><li><code>-r</code>: 递归删除整个文件夹</li><li><code>-f</code>: 强制删除不提示</li></ul></li><li><strong><code>cp 待拷贝文件或目录 目标目录</code>: 将文件复制到指定目录</strong><ul><li><code>-r</code>: 递归复制整个文件夹</li><li><code>\cp</code>: 直接覆盖同名文件,不进行提示</li></ul></li><li><strong><code>mv 原文件 目标目录</code>: 移动文件或目录(如果位于同一目录,则作用为重命名)</strong></li></ul></li><li>文件信息<ul><li><code>diff 文件名</code>: 比较文件的差异.(<code>-c</code>: 查看具体信息)</li><li><strong><code>cat 文件名</code>: 查看文件内容.不能修改.(<code>-n</code>: 显示行号)</strong></li><li><code>more 文件名</code>: 分批显示.<kbd>Space</kbd>向下翻页,<kbd>Enter</kbd>显示下一行,<kbd>Q</kbd>直接离开</li><li><code>less 文件名</code>: 分屏查看文件内容</li><li><strong><code>echo</code>: 输出内容到控制台(如 echo $PATH)</strong></li><li><code>tail -f 文件名</code>: 实时追踪文件的所有更新</li></ul></li><li><strong>指令 <code>&gt;</code> 和 <code>&gt;&gt;</code>: 重定向和追加</strong><ul><li><code>cat 文件1 &gt; 文件2</code>: 将文件1内容覆盖到文件2</li><li><code>echo &quot;内容&quot; &gt;&gt; 文件名</code>: 将内容追加到文件中</li></ul></li><li><strong><code>ln -s [源文件或目录] [软链接名]</code>: 创建软链接</strong></li><li><strong><code>history</code>: 查看 &#x2F; 执行历史指令</strong></li></ol><h3 id="2-3-时间日期"><a href="#2-3-时间日期" class="headerlink" title="2.3 时间日期"></a>2.3 时间日期</h3><ol><li><strong><code>date</code>: 显示当前日期</strong><ul><li><code>date</code>: 显示当前日期</li><li><code>date + %Y</code>: 显示当前年份</li><li><code>date + %m</code>: 显示当前月份</li><li><code>date + %d</code>: 显示当前天数</li><li><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code>: 显示年月日时分秒</li></ul></li><li>date 设置时间(如: <code>date -s &quot;2021-06-18 08:00:00&quot;</code>)</li><li><strong><code>cal</code>: 显示本月日历</strong><ul><li><code>cal 2025</code>: 显示 2025年日历</li></ul></li></ol><h3 id="2-4-查找"><a href="#2-4-查找" class="headerlink" title="2.4 查找"></a>2.4 查找</h3><ol><li><p><strong><code>find</code>: 从指定目录向下递归遍历各个子目录,将满足条件的文件 &#x2F; 目录显示在终端</strong></p><ul><li><p>基本语法: <code>find [搜索范围] [选项]</code></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-name&lt;查询方式&gt;</td><td>按指定文件名 查找模式</td></tr><tr><td>-user&lt;用户名&gt;</td><td>查找属于指定用户名所有文件</td></tr><tr><td>-size&lt;文件大小&gt;</td><td>按照指定文件大小查找文件(+n 大于, -n 小于, n 等于)</td></tr></tbody></table></li><li><p>查找示例</p><ul><li>查找 <code>/home</code> 目录的 <code>hello.txt</code> 文件: <code>find /home -name hello.txt</code></li><li>查找 <code>/opt</code> 目录中拥有者为 <code>nobody</code> 的文件: <code>find /opt -user nobody</code></li><li>查找整个系统中大于 200M 的文件: <code>find / -size +200M</code></li></ul></li></ul></li><li><p><strong><code>locate</code>: 事先建立系统中所有文件名称及路径的 <code>locate</code> 数据库</strong></p><ul><li>第一次运行时,必须先使用 <code>updatedb</code> 指令创建 <code>locate</code> 数据库</li><li>查询速度快,需及时更新 <code>locate</code> 时刻</li></ul></li><li><p><strong><code>which</code>: 查看某个指令所属目录</strong></p></li><li><p><strong><code>grep</code>: 过滤查找(常和 | 结合使用)</strong></p><ul><li><code>grep [选项] 查找内容 源文件</code></li><li><code>-n</code>: 显示匹配行及行号</li><li><code>-i</code>: 忽略大小</li><li><code>-r</code>: 递归查找</li><li><code>-v</code>: 反向过滤</li></ul></li></ol><h3 id="2-5-压缩和解压"><a href="#2-5-压缩和解压" class="headerlink" title="2.5 压缩和解压"></a>2.5 压缩和解压</h3><ol><li><p><strong><code>gzip 文件名</code>: 压缩为 *.gz 文件</strong></p></li><li><p><strong><code>gunzip 文件名</code>: 解压 *.gz 解压文件</strong></p></li><li><p><strong><code>zip</code>: 压缩目录 &#x2F; 文件</strong></p><ul><li><code>zip [选项] *.zip 将要压缩的内容</code>: 压缩文件和目录</li><li><code>-r</code>: 递归压缩,即压缩整个目录</li></ul></li><li><p><strong><code>unzip</code>: 解压文件</strong></p><ul><li><p><code>unzip [选项] *.zip</code>: 解压文件</p></li><li><p><code>-d&lt;目录&gt;</code>: 指定存放目录.默认为当前目录</p></li></ul></li><li><p><strong><code>tar</code>: 打包指令</strong></p><ul><li><code>tar [选项] *.tar.gz 打包的内容</code>: 打包目录.文件名后缀 <code>.tar.gz</code></li></ul><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>产生 <code>.tar</code> 打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后文件名</td></tr><tr><td>-z</td><td>打包同时压缩</td></tr><tr><td>-x</td><td>解包 <code>.tar</code> 文件</td></tr></tbody></table></li></ol><h3 id="2-6-运行级别"><a href="#2-6-运行级别" class="headerlink" title="2.6 运行级别"></a>2.6 运行级别</h3><ol><li>运行级别一般为 3 或 5<ul><li>0: 系统停机状态,即关机状态</li><li>1: 单用户模式,只有 root 用户可以登录.用于系统维护和修复</li><li>2: 多用户模式,没有 NFS 服务.但可以使用网络</li><li>3: <strong>多用户模式,完全启动系统.可以使用所有服务</strong></li><li>4: 保留,未使用</li><li>5: <strong>多用户模式,与运行级别3相同.但是在此级别下启动X Window系统,即图形界面</strong></li><li>6: 系统重启级别</li></ul></li><li>运行级别指令<ul><li><code>init 1</code>: 切换到运行级别1</li><li><code>runlevel</code>: 查看当前运行级别</li></ul></li></ol><h2 id="3-权限管理"><a href="#3-权限管理" class="headerlink" title="3 权限管理"></a>3 权限管理</h2><h3 id="3-1-组"><a href="#3-1-组" class="headerlink" title="3.1 组"></a>3.1 组</h3><ol><li><strong>Linux 每个用户都属于某个组.每个文件有 所有者, 所在组, 其他组</strong></li><li>所有者: 文件的创建者自然成为文件的所有者<ul><li><code>ls -ahl</code>: 查看文件&#x2F;目录所有者</li><li><code>chown 用户名 文件名</code>: 修改文件&#x2F;目录所有者</li><li><strong><code>chown 用户名:组名 文件名</code>: 修改所有者以及所在组</strong><ul><li><code>-R</code>: 将目录的子目录和文件进行递归修改</li></ul></li></ul></li><li>所在组: 文件 &#x2F; 目录的所在组 为 所有者的所在组<ul><li><code>chgrp 组名 文件名</code>: 修改文件&#x2F;目录所在组</li></ul></li><li>其他组: 除所有者和所在组之外的用户</li></ol><h3 id="3-2-文件权限"><a href="#3-2-文件权限" class="headerlink" title="3.2 文件权限"></a>3.2 文件权限</h3><ol><li><p><strong>文件所属分为拥有者(owner), 所属群组(group), 其他人(other).</strong><br><strong>而三种身份各有 读(read), 写(write), 执行(execute)权限</strong></p></li><li><p>考虑 <code>ls -l</code> 命令,显示的信息形如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc<br></code></pre></td></tr></table></figure><ul><li>从左到右分别为: 文件权限, 链接数, 文件拥有者, 文件所属用户组, 文件大小(Bytes), 最后被修改的时间, 文件名</li></ul></li><li><p>文件权限共 9位.其含义为</p><ul><li><strong>第 0 位: 文件类型(d ,-, l, c, b)</strong><ul><li><code>d</code>: 目录.相当于文件夹</li><li><code>-</code>: 普通文件</li><li><code>l</code>: 链接.相当于快捷方式</li><li><code>c</code>: 字符设备.如鼠标键盘</li><li><code>b</code>: 块设备.如硬盘</li></ul></li><li><strong>1 ~ 3位: 文件所有者的权限.如 rwx 表示可读可写可执行</strong></li><li><strong>4 ~ 6位: 所在组用户的权限.如 rw- 表示可读可写,但不能执行</strong></li><li><strong>7 ~ 9位: 其他用户对该文件的权限.如 r– 表示仅能读</strong></li></ul></li><li><p><strong>目录权限表示方式</strong></p><ul><li><code>r</code>: 可读.可以查看文件 或 可用 <code>ls</code> 查看目录内容</li><li><code>w</code>: 可写.可创建, 删除, 重命名, 移动其中的文件或目录</li><li><code>x</code>: 可执行.可以执行文件 或 可进入该目录(成为工作目录)</li><li><code>-</code>: 对应位置如果出现 <code>-</code>,表示没有该类型权限</li><li><code>rwx</code> 还可以用数字形式表示(<code>r = 4, w = 2, x = 1</code>).如 rwx &#x3D; 4 + 2 +1 &#x3D; 7</li></ul></li><li><p><strong><code>chmod</code>: 修改文件或目录的权限</strong></p><ul><li><code>u</code>: 所有者, <code>g</code>: 所在组, <code>o</code>: 其他人, <code>a</code>: 所有人. 使用 <code>+, -, =</code>赋予权限</li><li><code>chmod u=rwx,g=rx,o=x 文件名</code>: 对文件设置权限</li><li><code>chmod o+w 文件名</code>: 对其他组增加 w 可写权限</li><li><code>chmod a-x 文件名</code>: 对所有人取消 x 可执行权限</li><li><code>chmod 751 文件名</code>: 与 <code>chmod u=rwx,g=rx,o=x 文件名</code> 等价</li></ul></li></ol><h3 id="3-3-定时任务"><a href="#3-3-定时任务" class="headerlink" title="3.3 定时任务"></a>3.3 定时任务</h3><ol><li><p>任务调度: 系统在某个时间执行的特定命令或程序</p><ul><li>系统工作.需要周期性的执行,如病毒扫描</li><li>用户工作.如对 mysql 数据库的备份</li></ul></li><li><p><code>crond</code> 定时任务</p><ul><li>基础语法: <code>crontab [选项]</code><ul><li><code>-e</code>: 编辑 <code>crontab</code> 任务</li><li><code>-l</code>: 查询 <code>crontab</code> 任务</li><li><code>-r</code>: 删除当前用户的所有 <code>crontab</code> 任务</li></ul></li><li>示例: <code>*/1**** ls -l /etc &gt; /tmp/to.txt</code> 将会每分钟都执行一次</li></ul></li><li><p>时间规则</p><ul><li><p>5个占位符的含义</p><table><thead><tr><th>序号</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>1</td><td>每小时的分钟数</td><td>0 ~ 59</td></tr><tr><td>2</td><td>每天的小时数</td><td>0 ~ 23</td></tr><tr><td>3</td><td>每月的天数</td><td>1 ~ 31</td></tr><tr><td>4</td><td>每天的月份</td><td>1 ~ 12</td></tr><tr><td>5</td><td>每周星期数</td><td>0 ~ 7(0和7均为星期天)</td></tr></tbody></table></li><li><p>特殊符号</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>通配符,表示任意时间</td></tr><tr><td>,</td><td>分隔不连续的时间.如 <code>08,17***</code> 表示每天的8时0分,17时0分</td></tr><tr><td>-</td><td>连续的时间范围.如 <code>05**1-6</code> 表示周一到周六的5时0分</td></tr><tr><td>*&#x2F;n</td><td>每次的间隔时间.如 <code>*/10****</code> 表示每次间隔10分钟</td></tr></tbody></table></li></ul></li></ol><h3 id="3-4-进程"><a href="#3-4-进程" class="headerlink" title="3.4 进程"></a>3.4 进程</h3><ol><li><p>进程</p><ul><li>Linux 中每个执行的程序都是一个进程.每个进程都会分配一个ID号(pid)</li><li>每个进程可以以前台或后台的形式存在</li><li>一般系统服务均以后台进程形式存在,且常驻于系统,直到关机才结束</li></ul></li><li><p><strong><code>ps</code>: 查看当前系统中正在执行的进程</strong></p><ul><li><code>ps -a</code>: 显示当前终端的所有进程信息</li><li><code>ps -u</code>: 以用户的格式显示进程信息</li><li><code>ps -x</code>: 显示后台进程运行的参数</li></ul></li><li><p>父子进程</p><ul><li><strong><code>ps -ef</code>: 全格式显示当前所有进程</strong></li><li>显示的 ppid 指出该进程的父进程</li><li>搭配 <code>| grep</code> 可以进行过滤</li></ul></li><li><p>终止进程</p><ul><li><strong><code>kill [选项] 进程号</code>: 通过进程号终止进程</strong></li><li><code>killall 进程名称</code>: 通过进程名称终止进程,同时会终止其所有子进程</li></ul></li><li><p><code>pstree</code>: 查看进程树</p><ul><li><code>-p</code>: 显示进程的 pid</li><li><code>-u</code>: 显示进程的用户</li></ul></li><li><p>服务(service): 其本质仍然是进程.通常会监听某个端口,等待其他程序的请求</p><ul><li><code>service 服务名 [start | stop | restart | reload | status]</code></li><li>CentOS7.0后,很多服务不再使用 <code>service</code> 指令管理,而使用 <code>systemctl</code></li><li><code>systemctl [start | stop | restart | status] 服务名</code></li><li><code>systemctl</code> 管理的服务在 <code>/user/lib/systemd/system</code> 查看</li></ul></li></ol><h2 id="4-开发环境"><a href="#4-开发环境" class="headerlink" title="4 开发环境"></a>4 开发环境</h2><h3 id="4-1-包管理"><a href="#4-1-包管理" class="headerlink" title="4.1 包管理"></a>4.1 包管理</h3><ol><li>rpm(RedHat Package Manager)<ul><li><strong>rpm 用于互联网下载包的打包,安装.生成 <code>.RPM</code> 的文件</strong></li><li>Linux 的分发版均有采用,成为行业标准</li></ul></li><li>查询软件包<ul><li><code>rpm -qa</code>: 查询所有安装的 rpm 软件包</li><li><code>rpm -qa | grep firefox</code>: 查询具体的某个软件包</li><li><code>rpm -qi firefox</code>: 查询软件包的具体信息</li></ul></li><li>安装与删除软件包<ul><li><code>rpm -ivh rpm包的全路径名称</code>: 安装软件包需要有全路径</li><li><code>rpm -e firefox</code>: 删除软件包</li></ul></li><li>yum: Shell 前端软件包管理器<ul><li>yum 基于 rpm 包管理.能从指定服务器自动下载 rpm 包并安装</li><li>yum 将会自动处理依赖性关系,并一次安装所有依赖的软件包</li></ul></li><li>yum 指令<ul><li><code>yum list | grep firefox</code>: 查询 yum 服务器中的相关软件包信息</li><li><code>yum install firefox</code>: 下载安装软件包及依赖</li></ul></li></ol><h3 id="4-2-JavaEE"><a href="#4-2-JavaEE" class="headerlink" title="4.2 JavaEE"></a>4.2 JavaEE</h3><ol><li><p>JDK8</p><ul><li><p>创建目录: <code>mkdir /opt/jdk</code>(一般安装的软件置于 opt 目录下)</p></li><li><p>将安装包通过 xftp 上传到刚才创建的目录</p></li><li><p>解压安装包: <code>tar -zxvf jdk-8u261-linux-x64.tar.gz</code></p></li><li><p>创建目录: <code>mkdir /usr/local/java</code></p></li><li><p>移动整个解压后的目录: <code>mv /opt/jdk/jdk1.8.0_261 /usr/local/java</code></p></li><li><p>配置环境变量: <code>vim /etc/profile</code>.在最下方添加两行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export JAVA_HOME=/usr/local/java/jdk1.8.0_261<br>export PATH=$JAVA_HOME/bin:$PATH<br></code></pre></td></tr></table></figure></li><li><p>使环境变量生效: <code>source /etc/profile</code></p></li><li><p>测试安装: 编写 <code>Hello, world</code> 程序,编译运行</p></li></ul></li><li><p>tomcat8</p><ul><li>同样将安装文件上传并解压缩到 <code>/opt/tomcat</code> 目录</li><li>进入解压后的 <code>bin</code> 目录,启动 tomcat: <code>./startup.sh</code></li><li>开放端口 8080<ul><li><code>firewall-cmd --permanent add-port=8080/tcp</code></li><li><code>firewall-cmd --reload</code></li></ul></li><li>测试安装: 访问 <a href="http://linuxip:8080/">http://linuxip:8080</a><ul><li><code>cd ../webapps/ROOT/</code>: 在默认访问目录中增加 HTML 文件</li><li><code>vim test.html</code>: 编写 HTML 代码</li><li>然后访问 <a href="http://linuxip:8080/test.html">http://linuxip:8080/test.html</a> 将能正常打开页面</li></ul></li></ul></li></ol><h3 id="4-3-Ubuntu"><a href="#4-3-Ubuntu" class="headerlink" title="4.3 Ubuntu"></a>4.3 Ubuntu</h3><ol><li><p><strong>Ubuntu: 一个以桌面应用为主的开源 GNU&#x2F;Linux 操作系统</strong></p><ul><li>基于 GNU&#x2F;Linux.支持 x86, amd64, ppc 架构.由 Canonical 打造</li><li>Python 开发者一般选择 Ubuntu 作为生产平台</li><li>下载桌面版: <a href="https://cn.ubuntu.com/download">Ubuntu系统下载 | Ubuntu</a></li></ul></li><li><p>中文支持</p><ul><li>Ubuntu 默认只有英文.需要安装中文语言包(需要联网)</li><li>打开 Language Support 菜单 -&gt; Language Support 选项卡 -&gt; Install</li><li>选中 Chinese(Simplified) -&gt; Apply Changes 提交.此时系统将会自动下载</li><li>默认显示中文需要将 <code>汉语(中国)</code> 拖动到第一位</li></ul></li><li><p>root 权限</p><ul><li><strong>Ubuntu 安装后只有普通用户权限.若需要 root 权限,应在命名前加上 <code>sudo</code></strong></li><li>当使用 <code>su root</code> 切换到 root 用户时,因还未设置密码,将会抛出 <code>error</code></li><li>设置 root 用户的密码并使用<ul><li><code>sudo password</code>: 给 root 用户设置密码</li><li><code>su root</code>: 切换到 root 用户</li><li>提示符 <code>$</code> 表示一般用户.<code>#</code> 表示 root 用户</li><li><code>exit</code>: 退出 root 用户</li></ul></li></ul></li><li><p>python</p><ul><li>Ubuntu 默认安装 python 的开发环境</li><li><code>python3</code> 将会展示版本信息</li></ul></li><li><p><strong>apt(Advanced Packaging Tool): 安装包管理工具</strong></p><ul><li><p>在 Ubuntu 中,可以使用 <code>apt</code> 命令进行软件包的安装, 删除, 清理…</p></li><li><p><code>/etc/apt/sources.list</code> 文件中存放着 apt 服务器的地址</p></li><li><p>apt 通过指令完成软件的安装, 更新, 卸载</p></li><li><p>镜像网站: 因为服务器位于美国,连接缓慢,由镜像网站获取其资源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update            # 更新源<br>sudo apt-get install &lt;package&gt; # 安装 package<br>sudo apt-get remove &lt;package&gt;  # 删除 package<br><br>sudo apt-cache search &lt;package&gt; # 搜索软件包<br>sudo apt-cache show &lt;package&gt;   # 获取包的相关信息<br>sudo apt-get install &lt;package&gt; --reinstall # 重新安装包<br><br>sudo apt-get -f install               # 修复安装<br>sudo apt-get remove &lt;package&gt; --purge # 删除包,包括配置文件<br>sudo apt-get build-dep &lt;package&gt;      # 安装相关编译环境<br><br>sudo apt-get upgrade               # 更新已安装的包<br>sudo apt-get dist-upgrade          # 升级系统<br>sudo apt-cache depends &lt;package&gt;   # 查看该包所依赖的包<br>sudo apt-cache rdepends &lt;package&gt;  # 查看该包被哪些包依赖<br>sudo apt-get source package        # 下载软件包的源代码 *<br></code></pre></td></tr></table></figure></li></ul></li><li><p>修改 apt 更新源</p><ul><li><p>备份文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cp /ect/apt/sources.list /etc/apt/sources.list.backup # Ubuntu 24.04 前<br>sudo cp /etc/apt/sources.list.d/ubuntu.sources /etc/apt/sources.list.d/ubuntu.sources.backup # Ubuntu 24.04 后<br></code></pre></td></tr></table></figure></li><li><p>使用 root 用户,清空源文件中的所有内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;&#x27; &gt; source.list<br></code></pre></td></tr></table></figure></li><li><p>将需要的<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">镜像地址(清华源)</a>拷贝到 <code>source.list</code> 文件中</p></li></ul></li><li><p>远程登录</p><ul><li><p>SSH(Secure Shell): 建立于应用层和传输层基础上的安全协议</p></li><li><p>与 CentOS 不同,Ubuntu 默认没有安装 SSHD 服务</p></li><li><p>安装 SSH</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install openssh-server<br></code></pre></td></tr></table></figure></li><li><p>启动 SSH</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service sshd restart<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Linux 登录到 Ubuntu</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh 目标主机的用户名@目标主机IP地址 # 登录<br>logout # 退出<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-Shell"><a href="#5-Shell" class="headerlink" title="5 Shell"></a>5 Shell</h2><h3 id="5-1-Shell-概念"><a href="#5-1-Shell-概念" class="headerlink" title="5.1 Shell 概念"></a>5.1 Shell 概念</h3><ol><li><p><strong>Shell: 命令行解释器.为用户提供一个向 Linux 内核发送请求以便运行程序的界面系统级程序</strong></p><ul><li>运维工程师对服务器集群进行管理时,需要编写 Shell 程序进行服务器管理</li><li>JavaEE, Python程序员需要编写 Shell 维护程序和服务器</li><li>大数据程序员需要编写 Shell 程序管理集群</li></ul></li><li><p>Shell 脚本</p><ul><li><p>文件内容需要以 <code>#!/bin/bash</code> 开头,一般后缀为 <code>.sh</code></p></li><li><p>文件本身需要有可执行权限.赋予权限: <code>chmod u+x hello.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>echo &quot;Hello,world!&quot;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>执行脚本</p><ul><li><code>脚本的绝对路径或相对路径</code>: 即可执行(需要有 <code>+x</code> 权限)</li><li><code>sh 脚本路径</code>: 这样执行无需 <code>+x</code> 执行权限</li></ul></li><li><p>注释</p><ul><li>单行注释: <code># content</code></li><li>多行注释: <code>:&lt;&lt;! content !</code></li></ul></li></ol><h3 id="5-2-变量"><a href="#5-2-变量" class="headerlink" title="5.2 变量"></a>5.2 变量</h3><ol><li>系统变量<ul><li>如: <code>$HOME, $PWD, $SHELL, $USER</code>.可使用 <code>echo $HOME</code> 打印当前用户的家目录</li><li>显示当前 Shell 的所有系统变量</li></ul></li><li>自定义变量<ul><li>语法: <code>变量名=value</code>.注意语句中不要加入空格.变量名的命名限制与C相同</li><li>销毁变量: <code>unset 变量名</code>.Shell 编程变量名一般大写</li><li>声明静态变量: <code>readonly 变量名</code>.不能使用 <code>unset</code> 销毁</li><li>打印变量: <code>echo $变量名</code>.注意需要加上 <code>$</code> 符号</li></ul></li><li>将命令的返回值赋给变量<ul><li>A&#x3D;`date`: 将 date 作为一个命令执行,然后将结果赋值给变量 A</li><li><code>A=$(date)</code>: 与上述写法等价.变量 A 将会存储当前时间信息</li></ul></li><li>环境变量<ul><li><code>export 变量名=值</code>: 将 Shell 变量输出为环境变量 &#x2F; 全局变量</li><li><code>export 配置文件</code>: 使修改后的配置信息立即生效</li><li><code>echo $变量</code>: 查询环境变量的值</li></ul></li><li>位置参数<ul><li><code>$0</code>: 表示命令本身,<code>$1 ~ $9</code>表示第1 ~ 9个参数.对于超过10的,要用 <code>&#123;&#125;</code> 包裹</li><li><code>$*</code>: 表示所有的参数.且将所有参数当作整体处理</li><li><code>$@</code>: 表示所有的参数.但将每个参数分开处理</li><li><code>$#</code>: 获取命令行中所有参数的个数</li></ul></li><li>预定义变量: Shell 已定义的变量,可以直接在 Shell 脚本中使用<ul><li><code>$$</code>: 当前进程的进程号 pid</li><li><code>$!</code>: 后台运行的最后一个进程的进程号 pid</li><li><code>#?</code>: 最后一次执行的命令的返回状态.0表示正确执行</li></ul></li><li>运算<ul><li>语法: <code>$((运算式))</code> 或 <code>$[运算式]</code></li></ul></li></ol><h3 id="5-3-控制流"><a href="#5-3-控制流" class="headerlink" title="5.3 控制流"></a>5.3 控制流</h3><ol><li><p>条件表达式: <code>[ condition ]</code>.注意两端的空格,非空返回 true</p></li><li><p>分支语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ condition1 ]<br>then<br>code block1<br>elif [ condition2 ]<br>then<br>code block2<br>fi<br></code></pre></td></tr></table></figure></li><li><p>case</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $变量名 in<br>&quot;value1&quot;)<br>code block1<br>;;<br>&quot;value2&quot;)<br>code block2<br>*)<br>code block<br>esac<br></code></pre></td></tr></table></figure></li><li><p>for</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for 变量名 in value1 value2...<br>do<br>code block<br>done<br></code></pre></td></tr></table></figure></li><li><p>while</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">while [ condition ]<br>do<br>code block<br>done<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-4-函数"><a href="#5-4-函数" class="headerlink" title="5.4 函数"></a>5.4 函数</h3><ol><li><p>读取控制台输入</p><ul><li>基础语法: <code>read 选项 参数</code></li><li>选项: <code>-p</code> 指定读取值时的提示符. <code>-t</code> 指定等待的秒数</li><li>参数: 指定存储输入值的变量名</li></ul></li><li><p>系统函数</p><ul><li><code>basename</code>: 返回完整路径最后一个 <code>/</code> 后的内容,常用于获取文件名</li><li><code>basename [pathname] [suffix]</code></li><li><code>dirname</code>: 返回完整路径最后一个 <code>/</code> 前的内容,常用于获取路径</li></ul></li><li><p>自定义函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ function ] funname[()]<br>&#123;<br>Action;<br>[return int;]<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具箱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Code</tag>
      
      <tag>工具箱</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法分析 - C 语言描述</title>
    <link href="/2021/12/01/Computer/Data-Structures/"/>
    <url>/2021/12/01/Computer/Data-Structures/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法分析"><a href="#数据结构与算法分析" class="headerlink" title="数据结构与算法分析"></a>数据结构与算法分析</h1><h2 id="0-算法分析"><a href="#0-算法分析" class="headerlink" title="0 算法分析"></a>0 算法分析</h2><h3 id="0-1-基础概念"><a href="#0-1-基础概念" class="headerlink" title="0.1 基础概念"></a>0.1 基础概念</h3><ol><li>概念<ul><li>数据结构: 组织大量数据的方法</li><li>算法分析: 对算法运行时间的评估</li><li><strong>算法(algorithm)</strong>: 为求解一个问题所需遵循的,被清楚指定的简单指令集合</li><li>当某种算法被给定时,则需要确定该算法所需的时间和空间等资源量</li></ul></li><li><strong>抽象数据类型(Abstract Data Type,ADT)</strong>: 是一些操作的集合,是数学上的抽象<ul><li>例如表,集合,图以及它们的操作可看作抽象数据类型</li><li>例如集合ADT,可以有 并(union), 交(intersection), 补(complement), 求大小(size)等操作</li><li>基本思路: 只在程序中编写一次,其他地方需要运行 ADT 上的操作时,可通过调用函数实现</li></ul></li><li>定义: 建立无穷大量之间的相对级别<ul><li>$\mathrm{if} \quad \exists c,n_0\in N_+,N\geq n_0\quad\mathrm{s.t.} T(N)\leq cf(N), \mathrm{then} \quad T(N)&#x3D;O(f(N))$</li><li>$\mathrm{if} \quad \exists c,n_0\in N_+,N\geq n_0  \quad  \mathrm{s.t.} T(N)\geq cg(N),\mathrm{then} \quad T(N)&#x3D;\Omega(g(N))$</li><li>$T(N)&#x3D;O(h(N))  \quad and\quad T(N)&#x3D;\Omega(h(N)) \iff T(N)&#x3D;\Theta(h(N))$</li><li>$T(N)&#x3D;O(p(N)) \quad and \quad T(N)\neq \Theta(p(N)), \mathrm{then} \quad T(N)&#x3D;o(f(N))$</li></ul></li><li>简要说明<ul><li>$O$: 高阶无穷大</li><li>$\Omega$: 低阶无穷大</li><li>$\Theta$: 同阶无穷大</li><li>$o$: 严格的高阶无穷大</li></ul></li><li><strong>一般采用大$O$记法</strong>.例如 $T(N)&#x3D;2N^2+N&#x3D;O(N^2)$<ul><li>不要将常数或低阶项放入大$O$,直接忽略即可</li><li>典型的增长率(递增排列): $C, \mathrm{log}N, \mathrm{log}^2N, N, N\mathrm{log}N, N^2, N^3, 2^N$</li><li>可以使用洛必达法则确定两个函数的相对级别</li></ul></li></ol><h3 id="0-2-计算方式"><a href="#0-2-计算方式" class="headerlink" title="0.2 计算方式"></a>0.2 计算方式</h3><ol><li>为在正式的框架中分析算法,需要一个计算模型<ul><li>假定一个标准计算机,它顺序执行指令.拥有简单的指令系统(如加减乘除,赋值等)</li><li>特别地,该模型机执行任意一条简单指令都恰好花费一个时间单元</li><li>该模型机具有无限内存</li></ul></li><li>待分析的问题<ul><li>最重要的资源一般为运行时间</li><li>在这里分析对运行时间的影响因素有: 使用的算法, 对该算法的输入(主要方面)</li><li>考虑两个函数<ul><li>$T_{avg}(N)$: 输入为 N 时算法所花费的平均时间</li><li>$T_{worst}(N)$: 输入为 N 时算法在最坏情况下花费的时间</li><li><strong>主要考虑 $T_{worst}(N)$.因为它为所有的输入提供了一个运行时间上界</strong></li></ul></li><li>当两个程序花费的时间大致相同时,判断运行速度的方法是将其编码并运行</li><li>为简化分析,系数,低阶项,常数项直接抛弃.只计算其上界: 大$O$</li></ul></li></ol><h3 id="0-3-运行时间计算"><a href="#0-3-运行时间计算" class="headerlink" title="0.3 运行时间计算"></a>0.3 运行时间计算</h3><ol><li><p>分析案例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 计算 1~n 的立方和 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> partialSum = <span class="hljs-number">0</span>;<span class="hljs-comment">// 声明不计时间,赋值计1个时间单元</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i &lt;= n, i++) &#123;<span class="hljs-comment">// 初始化赋值计1次,判断循环条件计n+1次,自增计n次</span><br>        partialSum += i * i * i;<span class="hljs-comment">// 乘法2次,加法1次,赋值1次.重复n次,共计4n个时间单元</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> partialSum;<span class="hljs-comment">// 返回计1个时间单元</span><br>&#125;  <span class="hljs-comment">// 本算法共计6n+4个时间单元,即 O(N)</span><br></code></pre></td></tr></table></figure></li><li><p>一般法则</p><ul><li><code>for</code>: 运行时间最多为循环语句的运行时间乘以迭代次数</li><li>嵌套 <code>for</code>: 由里向外分析循环.嵌套循环内部一条语句总运行时间为: 该语句运行时间乘以<code>for</code>循环大小的乘积</li><li>顺序语句: 对各语句的运行时间求和(事实上,只需考虑运行时间最长的语句)</li><li><code>if/else</code>: 判断语句运行时间加上分支语句中最长的运行时间</li><li><strong>分析的基本策略为从内部向外扩展.如果有函数调用,则应该首先分析</strong></li></ul></li><li><p>考虑 Fibonacci 数列递归求和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-1</span>) + fib(n<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>运行时间为: $T(N)&#x3D;T(N-1)+T(N-2)\quad (n\geq2)$.这是一个指数级增长</li><li>运行效率低下的原因为: 进行了大量的重复计算,且计算结果被抛弃</li><li>改进: 用一个数组将计算结果存储起来,将可以大大提高运行效率</li></ul></li><li><p>最大子序列和问题的四种算法</p></li></ol><ul><li><p>问题: 给定整数 $A_1,A_2,\dots,A_n$, 求  $\sum\limits^j_{k&#x3D;i}A_k$ 的最大值(假定数组中均为负数,则最大子序列和为0)</p></li><li><p>穷举所有的可能 $\Theta(n^3)$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumN3</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i; j&lt;n; j++) &#123;<br>            <span class="hljs-type">int</span> thisSum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i; k&lt;=j; k++) &#123;<br>                thisSum += a[k];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(thisSum &gt; maxSum)<br>                maxSum = thisSum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分析可知,最内层的 for 冗余,将其去掉 $O(N^2)$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumN2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-type">int</span> thisSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i; j&lt;n; j++) &#123;<br>            thisSum += a[j];<br>            <span class="hljs-keyword">if</span>(thisSum &gt; maxSum)<br>                maxSum = thisSum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>递归 $O(N\mathrm{logN})$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumNlogN</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left == right) <span class="hljs-comment">// 参数为数组,左边界,右边界</span><br>        <span class="hljs-keyword">return</span> a[left] &gt; <span class="hljs-number">0</span> ? a[left] : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> center = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> maxLeftSum, maxRightSum;<br>    maxLeftSum = maxSubseqSumNlogN(a, left, center);  <span class="hljs-comment">// 递归调用</span><br>    maxRightSum = maxSubseqSumNlogN(a, center + <span class="hljs-number">1</span>, right);<br><br>    <span class="hljs-type">int</span> maxLeftBrdSum,  maxRightBrdSum,     leftBrdSum,     rightBrdSum;<br>    maxLeftBrdSum = <span class="hljs-number">0</span>;  maxRightBrdSum = <span class="hljs-number">0</span>; leftBrdSum = <span class="hljs-number">0</span>; rightBrdSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=center; i&gt;=left; i--) &#123;  <span class="hljs-comment">// 计算中值到左边界的最大和</span><br>        leftBrdSum += a[i];<br>        <span class="hljs-keyword">if</span>(leftBrdSum &gt; maxLeftBrdSum)<br>            maxLeftBrdSum = leftBrdSum;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=center+<span class="hljs-number">1</span>; i&lt;=right; i++) &#123;  <span class="hljs-comment">// 计算中值到右边界的最大和</span><br>        rightBrdSum += a[i];<br>        <span class="hljs-keyword">if</span>(rightBrdSum &gt; maxRightBrdSum)<br>            maxRightBrdSum = rightBrdSum;<br>    &#125;<br>    <span class="hljs-comment">// 返回三者的最大值</span><br>    <span class="hljs-keyword">if</span> (maxLeftSum &gt;= maxRightSum)<br>        <span class="hljs-keyword">return</span> maxLeftSum &gt;= maxLeftBrdSum + maxRightBrdSum ? maxLeftSum : maxLeftBrdSum + maxRightBrdSum;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> maxRightSum &gt;= maxLeftBrdSum + maxRightBrdSum ? maxRightSum : maxLeftBrdSum + maxRightBrdSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>线性算法 $O(N)$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumN</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> thisSum, maxSum;<br>    thisSum = <span class="hljs-number">0</span>; maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++) &#123;<br>        thisSum += a[j];<br>        <span class="hljs-keyword">if</span>(thisSum &gt; maxSum)<br>            maxSum = thisSum;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(thisSum &lt; <span class="hljs-number">0</span>)<br>            thisSum = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行代码(将上述代码置于一个文件下即可运行)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">-2</span>&#125;;<br>    <span class="hljs-type">int</span> arrLength = <span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(N^3)   = %d\n&quot;</span>,maxSubseqSumN3(a, arrLength));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(N^2)   = %d\n&quot;</span>,maxSubseqSumN2(a, arrLength));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(NlogN) = %d\n&quot;</span>,maxSubseqSumNlogN(a, <span class="hljs-number">0</span>, arrLength - <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(N)     = %d\n&quot;</span>,maxSubseqSumN(a, arrLength));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li><p>运行时间中的对数</p><ul><li><p>对数经常出现的场景有</p><ul><li>若算法利用 $O(1)$ ,即在常数时间里将问题的规模削减一部分(如50%).则该算法为 $O(\mathrm{log}N)$</li><li>若算法利用 $O(1)$ ,即在常数时间里将问题的规模消减一个常数(如 -1).则该算法为 $O(N)$</li></ul></li><li><p>考虑到仅仅是将 N 个数据读入耗费的时间即为 $\Theta(N)$ .当谈及$O(\mathrm{log}N)$ 时均假定数据已读入</p></li></ul></li><li><p>下面三个算法均为 $O(\mathrm{log}N)$</p><ul><li><p>二分查找(给定整数$X$,已排序数组 $A_0,A_1,\dots,A_{n-1}$ ,求满足$A_i&#x3D;X$的下标 $i$)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">float</span> elementType;<br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> elementType arr[], elementType x, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> low, mid, high;<br>    low = <span class="hljs-number">0</span>; high =n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>        mid = (low+high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(arr[mid] &lt; x)<br>            low = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; x)<br>            high = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>欧几里得算法(计算最大公因数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> m,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rem;<br>    <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>) &#123;<br>        rem = m % n;<br>        m = n;<br>        n = rem;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>幂运算</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">int</span> x,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == n)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> == n % <span class="hljs-number">2</span> ? <span class="hljs-built_in">pow</span>(x * x, n / <span class="hljs-number">2</span>) : <span class="hljs-built_in">pow</span>(x * x, n / <span class="hljs-number">2</span>) * x;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1 线性表"></a>1 线性表</h2><h3 id="1-1-单链表"><a href="#1-1-单链表" class="headerlink" title="1.1 单链表"></a>1.1 单链表</h3><ol><li><p>表: 形如 $a_1, a_2,\dots ,a_n$ 的有限序列.其中 $a_i$ 为数据元素 </p><ul><li>其大小为 n (当 n&#x3D;&#x3D;0 称为空表,empty list)</li><li>表的操作: 创建空表(makeEmpty), 插入元素(Insert), 删除元素(Delete), 查找元素(find), 打印表(printList)</li><li>由于数组对于插入和删除元素的运行太慢,一般不用简单数组实现表</li></ul></li><li><p>链表: 由一系列的无需在内存中相连的结构组成</p><ul><li>每个结构含有表元素以及指向该元素后继元结构的指针(next 指针)</li><li>最后一个元素的 next 指针 指向 NULL</li><li><strong>预留一个标志节点作为表头(head).其位置为0</strong></li></ul></li><li><p>链表接口(具体实现见 <code>single_linked_list</code>.不考虑数组实现方式)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SINGLE_LINKED_LIST_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SINGLE_LINKED_LIST_H</span><br><br><span class="hljs-comment">/*********************************************************/</span><br><span class="hljs-comment">/* node:        结构体类型名,链表结点</span><br><span class="hljs-comment">** ptr2node:    结构体指针,指向链表结点的指针</span><br><span class="hljs-comment">** list:        结构体指针,一般将头结点声明为 list 类型</span><br><span class="hljs-comment">** position:    结构体指针,一般将其它结点声明为 position 类型</span><br><span class="hljs-comment">** elementType: 元素类型名 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr2node</span>;</span><br><span class="hljs-keyword">typedef</span> ptr2node <span class="hljs-built_in">list</span>;<br><span class="hljs-keyword">typedef</span> ptr2node position;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    elementType element;<br>    position next;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(elementType x, elementType y)</span>;<br><br><span class="hljs-comment">/*********************************************************/</span><br><span class="hljs-comment">/* 链表相关函数.除了创建空链表,其它函数都需要参数 list l,以指明操作对象 */</span><br><span class="hljs-comment">/********** 1.创建与销毁 **********/</span><br><span class="hljs-built_in">list</span> <span class="hljs-title function_">makeList</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">clearList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deleteList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><br><span class="hljs-comment">/********** 2.获取长度 **********/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmptyList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isLast</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, position p)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">lenList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><br><span class="hljs-comment">/********** 3.增删改查 **********/</span><br>position <span class="hljs-title function_">findPosition</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x)</span>;<br>position <span class="hljs-title function_">findPrevious</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">findIndex</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x, compare func)</span>;<br>elementType *<span class="hljs-title function_">findElem</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, <span class="hljs-type">int</span> index)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x, position p)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* SINGLE_LINKED_LIST_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p>常见错误</p><ul><li>未初始化指针: 如果不知道应将指针初始化为什么,则将其初始化为 NULL</li><li><code>malloc</code> 函数的使用<ul><li>声明一个结构体指针是并不创建该结构.仅留出足够容纳结构的空间</li><li>若只需要一个结构体指针沿着表前进(例: <code>printList</code> 函数中的 <code>tmp</code>),则不需要使用 <code>malloc</code></li><li>当空间不再需要时.应使用 <code>free</code> 函数回收</li><li>若链表未执行过删除操作,则 <code>malloc</code> 调用次数应等于表的大小.若有表头,调用次数会多一次</li></ul></li></ul></li></ol><h3 id="1-2-链表使用"><a href="#1-2-链表使用" class="headerlink" title="1.2 链表使用"></a>1.2 链表使用</h3><ol><li><p>双链表: 在数据结构中增加一个域,使其指向前一个单元</p><ul><li><p>增加空间需求.因为需要额外存储一个指针</p></li><li><p>使得插入和删除的开销增加一倍.因为需要对增加的指针进行定位</p></li><li><p>简化删除操作.因为不再需要定位前驱元</p></li></ul></li><li><p>循环链表: 令最后一个单元指向第一个单元(可以存在表头,令最后一个单元指向表头)</p></li><li><p><strong>桶排序(bucket sort)</strong></p><ul><li>问题: 存在 $n$ 个整数 $a_i(0\leq x_i\leq M-1,1\leq i\leq n)$ 需要排序</li><li>预留一个大小为 $M$ 的 count 数组.即 count 有 $M$ 个单元(桶).初始情况下 count 内元素为空</li><li>当 $a_i$ 被读入时,$\mathrm{count}[a_i]$ 自增1;所有的输入被读入后,扫描数组 count,打印排好序的表</li><li>该算法的时间花费为 $O(M+N)$</li></ul></li><li><p><strong>基数排序(radix sort)是桶式排序的推广</strong></p><ul><li><p>考虑当桶的数量远大于数的个数时.桶排序便不再适合</p></li><li><p>若存在 $n$ 个整数 $a_i(0\leq x_i\leq n^p-1,1\leq i\leq n)$ 需要排序.进行多次桶式排序</p></li><li><p>第一步以最低位进行桶式排序,依次按位数桶式排序,直到最高位完成进行桶式排序</p></li><li><p>该算法的时间花费为 $O(p(n+b))$.其中 p 为趟数,n 为元素个数,b 为桶数</p></li><li><p>例: 对 0~9 的立方进行基数排序</p><ul><li>原始数组: [0, 1, 512, 343, 64, 125, 216, 27, 8, 729]</li><li>第一次排序结果: [0, 1, 512 ,343, 64, 125, 216, 27, 8, 729]</li><li>第二次排序结果: [8, 1, 0], [216, 512], [729,27,125],  [343], [64]</li><li>第三次排序结果: [64,27,8,1,0], [125], [216], [343], [512], [729]</li></ul></li></ul></li></ol><h3 id="1-3-栈"><a href="#1-3-栈" class="headerlink" title="1.3 栈"></a>1.3 栈</h3><ol><li><p>栈(stack): 限制插入和删除只能在一个位置(栈顶, top)进行的表</p><ul><li>栈的基本操作有: 入栈(push),出栈(pop)</li><li>栈的特点: 后进先出(LIFO),且只有栈顶元素可访问</li><li>栈的链表实现及其操作不涉及栈的大小,因此均为常数时间开销.缺点在于需要承担 <code>malloc,free</code> 的开销</li><li>当栈采用头插法进行入栈,则头节点的后继元即为栈顶,因此出栈只需删除头节点的后继元</li></ul></li><li><p>栈接口(具体实现见 <code>stack</code>.不考虑数组实现方式)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STACK_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr2node</span>;</span><br><span class="hljs-keyword">typedef</span> ptr2node <span class="hljs-built_in">stack</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    elementType element;<br>    ptr2node next;<br>&#125;;<br><br><span class="hljs-built_in">stack</span> <span class="hljs-title function_">makeStack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deleteStack</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s, elementType x)</span>;<br>elementType <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* STACK_H */</span></span><br></code></pre></td></tr></table></figure></li></ol><h3 id="1-4-队列"><a href="#1-4-队列" class="headerlink" title="1.4 队列"></a>1.4 队列</h3><ol><li><p>队列(queue): 限制插入(队尾, rear)和删除(队头, front)只能在两端分别进行的表</p><ul><li>队列的基本操作有入队(enqueue),出队(dequeue)</li><li>队列的特点: 先进先出(FIFO);只有队头元素可访问</li></ul></li><li><p>队列的链表实现的注意事项</p><ul><li>队列需要指向队头(front)和队尾(rear)的两个指针</li><li>当进行入队操作时,采用尾插法,且需要将 rear 指针向后移动一位</li><li>当进行出队操作时,需要先判断队列是否为空(front &#x3D;&#x3D; rear),然后删除 front 指针的后继元</li></ul></li><li><p>队列接口(具体实现见 <code>queue</code>.不考虑数组实现方式)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> QUEUE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUEUE_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr2node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    elementType element;<br>    ptr2node next;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ptr2node front;<br>    ptr2node rear;<br>&#125; *<span class="hljs-built_in">queue</span>;<br><br><span class="hljs-built_in">queue</span> <span class="hljs-title function_">makeQueue</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deleteQueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q, elementType e)</span>;<br>elementType <span class="hljs-title function_">dequeue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* QUEUE_H */</span></span><br></code></pre></td></tr></table></figure></li></ol><h2 id="2-树"><a href="#2-树" class="headerlink" title="2 树"></a>2 树</h2><h3 id="2-1-树的实现"><a href="#2-1-树的实现" class="headerlink" title="2.1 树的实现"></a>2.1 树的实现</h3><ol><li><p>树的递归定义: 一棵<strong>树</strong>是一些节点的集合(可以是空集).若非空,则一棵树由称为<strong>根</strong>(root)的节点 r,以及0个或多个非空的(子)树 $T_1,T_2,\dots,T_k$ 组成,这些<strong>子树</strong>中的每一颗的根都被来自根 r 的一条有向边所连接</p><ul><li><strong>叶</strong>(leaf): 没有子节点的节点</li><li><strong>兄弟</strong>(sibling): 具有相同父节点的节点</li><li><strong>路径</strong>(path): 从节点 $n_1$ 到 $n_k$ 的路径为 $n_1, n_2,\dots,n_k$ 的一个序列.且对于 $1\leq i&lt;k$,有 $n_i$ 是 $n_{i+1}$ 的父节点</li><li><strong>路径的长</strong>(length): 路径上 边的条数,即 $k-1$.每一节点到自身的路径长为0</li><li><strong>深度</strong>(depth): 对于任意节点 $n_i$,其深度为从根到 $n_i$ 的唯一路径的长</li></ul></li><li><p>树的实现</p><ul><li><p>在每一个节点除数据外,还需要的两个指针指向它的第一子节点(向下)及下一个兄弟节点(向右)</p></li><li><p>树的节点声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">prtToNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> &#123;</span><br>    elementType element;<br>    prtToNode firstChild;<br>    prtToNode nextSibling;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>树的遍历</p><ul><li><p>树经常用于操作系统中的目录结构</p><ul><li>例如 Unix 系统中的文件 <code>/usr/mark/book/ch1.r</code></li><li>第一个 &#x2F; 后的每个 &#x2F; 都表示一条边</li></ul></li><li><p>考虑以下述格式打印目录中的所有文件: 深度为 $d_i$ 的文件的名称前有 $d_i$ 个 <kbd>tab</kbd> 进行缩进,然后打印</p></li><li><p>实现思路: 以递归的方式打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">listDir</span><span class="hljs-params">(directoryOrFile d, <span class="hljs-type">int</span> depth)</span> &#123;<br>    <span class="hljs-keyword">if</span>(d is a legitimate entry) &#123;<br>        printName(d, depth);<br>        <span class="hljs-keyword">if</span>(d is a directory) &#123;<br>            <span class="hljs-keyword">for</span> each child, c, of d<br>                <span class="hljs-title function_">listDir</span><span class="hljs-params">(c, depth + <span class="hljs-number">1</span>)</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">listDirectory</span><span class="hljs-params">(directoryOrFile d)</span> &#123;<br>    listDir(d, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>算法核心函数 <code>listDir</code>: 参数为目录树的引用.如果是目录,则递归的处理子节点,文件名则被缩进后打印</li><li>驱动函数 <code>listDirectory</code>: 考虑到 <code>listDir</code> 的参数 <code>depth</code> 为内部递归变量.<br>因此需要驱动函数(这里赋值为0)</li></ul></li></ul></li></ol><h3 id="2-2-二叉树"><a href="#2-2-二叉树" class="headerlink" title="2.2 二叉树"></a>2.2 二叉树</h3><ol><li><p><strong>二叉树</strong>: 每个节点的子节点都不超过2个的树</p><ul><li>平均二叉树的深度通常比节点数 N 小得多,平均深度为 $O(\sqrt N)$</li><li><strong>二叉查找树</strong>(binary search tree)的平均深度为 $O(\log N)$.但在最坏的情况下可以为 N-1</li></ul></li><li><p>二叉树的实现</p><ul><li><p>由于二叉树最多有两个子节点,因此可以直接用指针指向它们</p></li><li><p>二叉树的节点声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">ptrToNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ptrToNode</span> <span class="hljs-title">tree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> &#123;</span><br>    elementType element;<br>    tree left;<br>    tree right;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="2-3-二叉查找树"><a href="#2-3-二叉查找树" class="headerlink" title="2.3 二叉查找树"></a>2.3 二叉查找树</h3><ol><li><p>二叉树经常用于查找.给树中的每个节点指定一个关键字值(假定为整数,且唯一)</p></li><li><p><strong>二叉查找树</strong>: 对于树中的每个节点 X,其左子树所有关键字值小于X关键字值,右子树所有关键字值大于X关键字值</p><ul><li>考虑到树的递归定义,对二叉查找树的操作通常采用递归处理</li><li>考虑到所有的元素都是有序的,因此假定运算符 <code>&lt;, =, &gt;</code> 均可用于这些元素</li></ul></li><li><p>二叉查找树的声明(<code>searchTree.h</code>文件中)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SEARCH_TREE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEARCH_TREE_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">position</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">searchTree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> &#123;</span><br>    elementType element;<br>    searchTree left;<br>    searchTree right;<br>&#125;<br><br>searchTree <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">(searchTree t)</span>;  <span class="hljs-comment">// 创建空树</span><br>position <span class="hljs-title function_">find</span><span class="hljs-params">(elementType x, searchTree t)</span>;  <span class="hljs-comment">// 查找元素位置</span><br>position <span class="hljs-title function_">findMin</span><span class="hljs-params">(searchTree t)</span>;  <span class="hljs-comment">// 查找最小值位置</span><br>position <span class="hljs-title function_">findMax</span><span class="hljs-params">(searchTree t)</span>;  <span class="hljs-comment">// 查找最大值位置</span><br>searchTree <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, searchTree t)</span>;  <span class="hljs-comment">// 插入元素</span><br>searchTree <span class="hljs-title function_">delete</span><span class="hljs-params">(elementType x, searchTree t)</span>;  <span class="hljs-comment">// 删除元素</span><br>elementType <span class="hljs-title function_">retrieve</span><span class="hljs-params">(position p)</span>;  <span class="hljs-comment">// 检索位置信息</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* SEARCH_TREE_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p>源文件 <code>searchTree.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c">searchTree <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">(searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t != <span class="hljs-literal">NULL</span>) &#123;<br>        makeEmpty(t-&gt;left);<br>        makeEmpty(t-&gt;right);<br>        <span class="hljs-built_in">free</span>(t);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>position <span class="hljs-title function_">find</span><span class="hljs-params">(elementType x, searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(x &lt; t-&gt;element)<br>        <span class="hljs-keyword">return</span> find(x, t-&gt;left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t-&gt;element)<br>        <span class="hljs-keyword">return</span> find(x, t-&gt;right);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> t;<br>&#125;<br><br>position <span class="hljs-title function_">findMin</span><span class="hljs-params">(searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;left == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> t;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> findMin(t-&gt;left);<br>&#125;<br><br>position <span class="hljs-title function_">findMax</span><span class="hljs-params">(searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t != <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">while</span>(t-&gt;right != <span class="hljs-literal">NULL</span>)<br>            t = t-&gt;right;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br>searchTree <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>) &#123;<br>        t = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> treeNode));<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">NULL</span>)<br>            fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            t-&gt;element = x;<br>            t-&gt;left = t-&gt;right = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; t-&gt;element)<br>        t-&gt;left = insert(x, t-&gt;left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t-&gt;element)<br>        t-&gt;right = insert(x, t-&gt;right);<br>    <span class="hljs-comment">/* else x已经在树中,不在执行任何操作 */</span><br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br>searchTree <span class="hljs-title function_">delete</span><span class="hljs-params">(elementType x, searchTree t)</span> &#123;<br>    position tmp;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)  <span class="hljs-comment">/* 空树 */</span><br>        Error(<span class="hljs-string">&quot;Element not found&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; t-&gt;element)  <span class="hljs-comment">/* 向左 */</span><br>        t-&gt;left = delete(x, t-&gt;left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t-&gt;element)  <span class="hljs-comment">/* 向右 */</span><br>        t-&gt;right = delete(x, t-&gt;right);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;left &amp;&amp; t-&gt;right) &#123; <span class="hljs-comment">/* 2个子节点 */</span><br>        tmp = findMin(t-&gt;right);<br>        t-&gt;element = tmp-&gt;element;<br>        t-&gt;right = delete(t-&gt;element, t-&gt;right);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        tmp = t;<br>        <span class="hljs-keyword">if</span>(t-&gt;left == <span class="hljs-literal">NULL</span>)<br>            t = t-&gt;right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;right == <span class="hljs-literal">NULL</span>)<br>            t = t-&gt;left;<br>        <span class="hljs-built_in">free</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-AVL-树"><a href="#2-4-AVL-树" class="headerlink" title="2.4 AVL 树"></a>2.4 AVL 树</h3><ol><li><strong>AVL树</strong>(Adelson-Velskii Landis): 带有平衡条件(需易保持)的二叉查找树.且保证树的深度为$O(\log N)$<ul><li>AVL 树要求每个节点的左子树和右子树的高度最多差1(空树的高度定义为-1)</li><li>AVL 树的高度最多为$1.44\log (N+2)-1.328$. 因此可以保证除插入外的操作(删除为惰性)均为 $O(\log N)$</li></ul></li><li><strong>旋转</strong>: AVL 树的插入操作可能会破坏平衡条件,因此隐含着困难.但总是可以经过修正使得性质恢复<ul><li>插入后,只有插入点到根节点路径上的节点的平衡可能被改变.沿着此路径向上找到一个破坏了 AVL 条件的节点,调整该节点重新平衡该树,将会使得整棵树满足 AVL 条件</li><li>设需要重新平衡的节点为 $\alpha$.导致不平衡出现的插入位置共有4种情况<ol><li>左子节点的左子树</li><li>左子节点的右子树</li><li>右子节点的左子树</li><li>右子节点的右子树</li></ol></li><li>情形1,4 与 情形2,3 为关于 $\alpha$节点的对称.分别通过单旋转和双旋转进行处理</li></ul></li></ol><h2 id="3-散列"><a href="#3-散列" class="headerlink" title="3 散列"></a>3 散列</h2><h3 id="3-1-散列函数"><a href="#3-1-散列函数" class="headerlink" title="3.1 散列函数"></a>3.1 散列函数</h3><ol><li><p>散列表(hash table)ADT: 仅支持二叉查找树所允许的一部分操作,其实现常称为<strong>散列</strong>(hashing)</p><ul><li>散列以常数平均时间执行 插入,删除,查找,但需要元素间任何排序信息的操作不会得到有效支持</li><li>理想的散列表数据结构是一个含有<strong>关键字</strong>的具有固定大小的数组</li><li>关键字的典型是带有信息的字符串,而表的大小记为 Table-Size</li></ul></li><li><p><strong>映射函数</strong>(hash function): 将关键字映射到 [0, Table-Size) 区间中的某个数,且放到适当的单元中</p><ul><li>理想的映射函数应运算简单,且保证不同的关键字映射到不同的单元</li><li>实际上不可能,因为关键字是无穷的,而单元的数量是有限的</li><li>因此要找一个散列函数,能在单元间均匀的分配关键字</li><li><strong>冲突</strong>(collision): 两个关键字散列到同一个值</li></ul></li><li><p>散列函数</p><ul><li><p>若输入的关键字为整数,一般采用返回 <code>key mod tableSize</code>.保证表的大小为素数时效果较好</p></li><li><p>若输入的关键字为字符串</p><ol><li><p>可以将字符串中的字符的 ASCII 码值之和作为关键字(简单,但当表很大时将会分配不均)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index;<br>index <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">int</span> tableSize)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashVal = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*key != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        hashVal += *key++;<br>    <span class="hljs-keyword">return</span> hashVal % tableSize;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>考虑计算 $\mathrm{\sum\limits_{i&#x3D;0}^{keySize&#x3D;1}key[keySize-i-1]}\cdot 32^i$(根据 Horner 法则计算 32 的多项式函数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">index <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">int</span> tableSize)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashVal = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*key != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        hashVal = (hashVal &lt;&lt; <span class="hljs-number">5</span>) + *key++;<br>    <span class="hljs-keyword">return</span> hashVal % tableSize;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如计算 $h_k &#x3D; k_1 + 32k_2 + 32^2k_3$ 的方式为 $h_k &#x3D; ((k_3) \times 32 + k_2) \times 32+k_1$ </li><li>关键行中的 <code>&lt;&lt; 5</code> 即为乘以32, 且其中的加法还可以使用按位异或 <code>^</code> 代替</li><li>该算法的优点在于极其简单,当允许溢出时速度很也快</li><li>如果关键字特别长,不仅时间花费大,而且前面的字符还会被移出.此时通常不采用全部字符</li></ul></li></ol></li></ul></li></ol><h3 id="3-2-消除冲突"><a href="#3-2-消除冲突" class="headerlink" title="3.2 消除冲突"></a>3.2 消除冲突</h3><ol><li><p>当一个元素被插入处已存在另一个元素(即不同关键字的散列值相同),此时将产生冲突</p><ul><li>解决冲突的方式有: 分离链接法(separate chaining), 开放定址法(open addressing)</li></ul></li><li><p>分离链接法: 将散列到同一个值的所有元素保存到一个表中</p><ul><li><p>示例: 关键字为前10个数的平方(0, 1, 4, 9, 16, 25, 36, 49, 64, 81).散列函数为 $hash(x) &#x3D; x \space mod \space 10$</p></li><li><p>则分离链接散列表形如</p><p><img src="/2021/12/01/Computer/Data-Structures/3-Detach-link-hash-tables.png"></p></li><li><p>插入操作: 遍历相应的表以检查该元素是否以处于适当的位置.如果是新元素,则将其插入到表的前端&#x2F;末尾</p></li><li><p>分离链接散列表的的实现</p><ul><li><p>头文件 <code>hashSeq.h</code> 中(其中 listNode 的结构与链表相同)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HASH_SEQ_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HASH_SEQ_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTbl</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">position</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTbl</span> *<span class="hljs-title">hashTable</span>;</span><br><br>hashTable <span class="hljs-title function_">initializeTable</span><span class="hljs-params">(<span class="hljs-type">int</span> tableSize)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">destroyTable</span><span class="hljs-params">(hashTable h)</span>;<br>position <span class="hljs-title function_">find</span><span class="hljs-params">(elementType key, hashTable h)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType key, hashTable h)</span>;<br>elementType <span class="hljs-title function_">retrieve</span><span class="hljs-params">(position p)</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br>    elementType element;<br>    position next;<br>&#125;<br><span class="hljs-keyword">typedef</span> position <span class="hljs-built_in">list</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTbl</span> &#123;</span><br>    <span class="hljs-type">int</span> tableSize;<br>    <span class="hljs-built_in">list</span> *theLists;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>源文件 <code>hashSeq.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">hashTable <span class="hljs-title function_">initializeTable</span><span class="hljs-params">(<span class="hljs-type">int</span> tableSize)</span> &#123;<br>    hashTable h;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>(tableSize &lt; minTableSize) &#123;<br>        error(<span class="hljs-string">&quot;Table size too small&quot;</span>);<br>        retrun <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>    h = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> hashTbl));<br>    <span class="hljs-keyword">if</span>(h == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    h-&gt;tableSize = nextPrime(tableSize);<br>    <br>    h-&gt;theLists = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">list</span>) * h-&gt;tableSize);<br>    <span class="hljs-keyword">if</span>(h-&gt;theLists == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; h-&gt;tableSize; i++) &#123;<br>        h-&gt;theLists[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> listNode));<br>        <span class="hljs-keyword">if</span>(h-&gt;theLists[i] == <span class="hljs-literal">NULL</span>)<br>            fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            h-&gt;theLists[i]-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType key, hashTable h)</span> &#123;<br>    position pos, newCell;<br>    <span class="hljs-built_in">list</span> l;<br>    pos = find(key, h);<br>    <span class="hljs-keyword">if</span>(pos == <span class="hljs-literal">NULL</span>) &#123;<br>        newCell = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> listNode));<br>        <span class="hljs-keyword">if</span>(newCell == <span class="hljs-literal">NULL</span>)<br>            fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            l = h-&gt;thelists[hash(key, h-&gt;tableSize)];<br>            newCell-&gt;next = l-&gt;next;<br>            newCell-&gt;element = key;<br>            l-&gt;next = newCell;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>开放定址法: 当冲突发生时,尝试选择另外的单元,知道找出空的单元为止</p><ul><li>考虑单元 $h_0(X),h_1(X),h_2(X), \cdots,$相继试选.其中 $h_i(X) &#x3D; (hash(x)+F(i))\mod \mathrm{tableSize}$</li><li>函数 $F$ 是冲突解决方法,且 $F(0) &#x3D; 0$ </li><li>开放地址法需要将所有数据置于表内,因此散列表较大.但省去了给新单元分配地址的时间</li></ul></li></ol><h3 id="3-3-再散列"><a href="#3-3-再散列" class="headerlink" title="3.3 再散列"></a>3.3 再散列</h3><ol><li><p><strong>再散列</strong>(rehashing): 对于开放定址法,如果表的元素太满,则操作时间消耗增长,且插入可能失败.此时可以建立另外一个约两倍大的表(同时使用一个相关的新散列函数),扫描整个原始散列表,计算每个元素的新散列值并将其插入到新表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">hashTable <span class="hljs-title function_">rehash</span><span class="hljs-params">(hashTable h)</span> &#123;<br>    <span class="hljs-type">int</span> i, oldSize;<br>    cell *oldCell;<br>    oldCells = h-&gt;theCells;<br>    oldSize = h-&gt;tableSize;<br>    h = initializeTable(<span class="hljs-number">2</span> * oldSize);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; oldSize; i++) &#123;<br>        <span class="hljs-keyword">if</span>(oldCells[i].info == legitimate)<br>            insert(oldCells[i].element, h);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(oldCells);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-优先队列"><a href="#4-优先队列" class="headerlink" title="4 优先队列"></a>4 优先队列</h2><h3 id="4-1-优先队列"><a href="#4-1-优先队列" class="headerlink" title="4.1 优先队列"></a>4.1 优先队列</h3><ol><li><strong>优先队列</strong>(priority queue): 是允许至少插入(入队)和删除最小(出队:找出,返回,删除优先队列中的最小元素)的数据结构</li><li>优先队列的简单实现方式<ul><li>使用简单链表: 在表头进行插入$O(1)$,遍历链表以实现删除最小元$O(n)$</li><li>始终让表保持排序状态: 进行顺序插入$O(n)$和删除操作$O(1)$</li><li>二叉查找树: 对插入和删除操作均为 $O(\log n)$</li></ul></li></ol><h3 id="4-2-二叉堆"><a href="#4-2-二叉堆" class="headerlink" title="4.2 二叉堆"></a>4.2 二叉堆</h3><ol><li><p>二叉堆(binary heap) 具有两个性质: 结构性和堆序性.因此堆的操作需要堆的所有性质都被满足才终止</p></li><li><p>结构性质: <strong>堆</strong>(heap): 一颗被完全填满的二叉树(完全二叉树, complete binary tree),底层可以例外(从左到右填入)</p><ul><li>高为 h 的完全二叉树节点数为: $[2^h, 2^{h+1})$.因而完全二叉树的高是 $\lfloor \log N \rfloor$</li><li>完全二叉树可以用数组进行表示,而不需要指针</li><li>考虑位置为 i 的元素,其左子节点位于 2i,右子节点位于左子节点后的 2i+1,父节点位于 $\lfloor i&#x2F;2 \rfloor$ </li><li>堆数据结构将由 一个数组(无论关键为什么类型),一个代表最大值的整数,当前堆大小的整数 组成</li></ul></li><li><p>堆序性质: 使操作快速执行</p><ul><li>考虑需要找出最小元,因此最小元应该在根上</li><li>将任意子树也视为一个堆,则任意节点应小于其所有后裔</li><li><strong>堆序性质</strong>: 在一个堆中,对于任意节点 X, X父节点的关键字小于X的关键字(根节点除外)</li></ul></li><li><p>优先队列的声明(<code>binaryHeap.h</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BIN_HEAP_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIN_HEAP_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapStruct</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapStruct</span> *<span class="hljs-title">priorityQueue</span>;</span><br><br>priorityQueue <span class="hljs-title function_">initialize</span><span class="hljs-params">(<span class="hljs-type">int</span> maxElements)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, priorityQueue h)</span>;<br>elementType <span class="hljs-title function_">deleteMin</span><span class="hljs-params">(priorityQueue h)</span>;<br>elementType <span class="hljs-title function_">findMin</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">(priorityQueue h)</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapStruct</span> &#123;</span><br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> size;<br>    elementType *elements;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>优先队列的操作(<code>binaryHeap.c</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">priorityQueue <span class="hljs-title function_">initialize</span><span class="hljs-params">(<span class="hljs-type">int</span> maxElements)</span> &#123;<br>    priorityQueue h;<br>    <span class="hljs-keyword">if</span>( maxElements &lt; minPQSize )<br>        error(<span class="hljs-string">&quot;Priority queue size is too small&quot;</span>);<br>    h = <span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>( <span class="hljs-keyword">struct</span> heapStruct ) );<br>    <span class="hljs-keyword">if</span>(h == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    h-&gt;elements = <span class="hljs-built_in">malloc</span>( ( maxElements + <span class="hljs-number">1</span> ) * <span class="hljs-keyword">sizeof</span>(elementsType) );<br>    <span class="hljs-keyword">if</span>( h-&gt;elements == <span class="hljs-literal">NULL</span> )<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    h-&gt;capacity = maxElements;<br>    h-&gt;size = <span class="hljs-number">0</span>;<br>    h-&gt;elements[<span class="hljs-number">0</span>] = minData;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, priorityQueue h)</span> &#123;<br>    <span class="hljs-keyword">if</span>(isFull(h)) &#123;<br>        error(<span class="hljs-string">&quot;Priority queue is full&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = ++h-&gt;size; h-&gt;elements[ i / <span class="hljs-number">2</span> ] &gt; x; i /= <span class="hljs-number">2</span>)<br>        h-&gt;elements[ i ] = h-&gt;elements[ i / <span class="hljs-number">2</span> ];<br>    h-&gt;elements[i] = x;<br>&#125;<br><br>elementType <span class="hljs-title function_">deleteMin</span><span class="hljs-params">(priorityQueue h)</span> &#123;<br>    <span class="hljs-type">int</span> child;<br>    elementType minElement, lastElement;<br>    <span class="hljs-keyword">if</span>( isEmpty(h) ) &#123;<br>        error(<span class="hljs-string">&quot;Priority queue is full&quot;</span>);<br>        <span class="hljs-keyword">return</span> h-&gt;elements[<span class="hljs-number">0</span>];<br>    &#125;<br>    minElement = h-&gt;elements[<span class="hljs-number">1</span>];<br>    lastElement = h-&gt;elements[h-&gt;size--];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i * <span class="hljs-number">2</span> &lt;=  h-&gt;size; i = child) &#123;<br>        child = i * <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(child != h-&gt;size &amp;&amp; h-&gt;elements[child+<span class="hljs-number">1</span>] &lt; h-&gt;elements[child])<br>            child++;<br>        <span class="hljs-keyword">if</span>(lastElement &gt; h-&gt;elements[child])<br>            h-&gt;elements[i] = h-&gt;elements[child];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    h-&gt;elements[i] = lastElement;<br>    <span class="hljs-keyword">return</span> minElement;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-排序"><a href="#5-排序" class="headerlink" title="5 排序"></a>5 排序</h2><ol><li>排序算法接受的参数为: 数组首地址, 及一个表示数组元素个数的整数</li><li>基于比较的排序: 假定对于元素而言,运算符 <code>&lt;, &gt;</code> 是存在的</li><li>逆序(inversion): 与线性代数中的关于排列的逆序数定义类似<ul><li>n 个互异数的数组的平均逆序数为 $\frac{n(n-1)}4$</li><li>通过交换相邻元素进行排序的任何算法平均需要 $\Omega(N^2)$</li><li>排序算法通过删除逆序进行,为了有效运行,必须每次删除不止一个逆序</li></ul></li><li>间接排序(indirect sorting): 由于交换结构的操作是昂贵的,因而可以创建数组(其元素为指向结构的指针).通过比较指针指向的关键字,并在必要时交换指针来进行排序</li><li>排序的一般下界<ul><li>任何只用到比较的算法在最坏的情况下需要 $\Omega(N\log N)$ 次比较,因而归并排序和堆排序最优</li><li>任何只用到比较的算法在平均的情况下需要 $\Omega(N\log N)$ 次比较,因而快速排序是最优的</li></ul></li></ol><h3 id="5-1-插入排序"><a href="#5-1-插入排序" class="headerlink" title="5.1 插入排序"></a>5.1 插入排序</h3><ol><li><p>插入排序(insert sort)</p><ul><li><p>将数组假想为两部分: 前面的为已排序数组,后面的为待排序数组</p></li><li><p>初始状态为已排序数组只有第一个元素,剩余为待排序数组</p></li><li><p>遍历待排序数组,将每个未排序元素插入到已排序数组中恰当的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    elementType tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>; p &lt; n; ++p) &#123;<br>        tmp = arr[p];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = p; j&gt;<span class="hljs-number">0</span> &amp;&amp; arr[j<span class="hljs-number">-1</span>] &gt; tmp; --j)<br>            arr[j] = arr[j<span class="hljs-number">-1</span>];<br>        arr[j] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>时间复杂度: $O(N^2)$</p><ul><li>当输入数据为逆序时,达到此上界</li><li>当输入数据已排序时,运行时间为 $O(N)$</li><li><strong>对于几乎已经排序的数据(逆序数 I 较小),插入排序很快,其时间为 $O(I+N)$</strong></li></ul></li></ol><h3 id="5-2-希尔排序"><a href="#5-2-希尔排序" class="headerlink" title="5.2 希尔排序"></a>5.2 希尔排序</h3><ol><li><p>希尔排序(缩小增量排序, diminishing increment sort): 先将整个待排序的序列分割为若干子序列分别进行直接插入排序,待整个序列中的记录基本有序时,在对全体进行直接插入排序</p><ul><li><p>增量序列: $h_1, h_2, \dots,h_t$,其中 $h_1 &#x3D; 1$</p></li><li><p>$h_k$-排序数组: $\forall i,arr[i] \leq arr[i+h_k]$</p></li><li><p>希尔增量通常取 $h_t &#x3D; \lfloor n&#x2F;2 \rfloor, h_k &#x3D; \lfloor h_{k+1}&#x2F;2 \rfloor$ </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    elementType tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> increment = n/<span class="hljs-number">2</span>; increment &gt; <span class="hljs-number">0</span>; increment /= <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = increment; i &lt; n; ++i) &#123;<br>            tmp = arr[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &gt;= increment; j -= increment)<br>                <span class="hljs-keyword">if</span>(tmp &lt; arr[j - increment])<br>                    a[j] = a[j - increment];<br>            <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">break</span>;<br>                arr[j] = tmp;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>时间复杂度(希尔排序算法简单,但分析极其困难)</p><ul><li>希尔增量下的希尔排序的最坏情形运行时间 $\Theta(N^2)$</li><li>Hibbard 增量: 形如 $1, 3, 7, \dots , 2^k-1$.最坏情形运行时间 $\Theta(N^\frac32)$</li></ul></li></ol><h3 id="5-3-堆排序"><a href="#5-3-堆排序" class="headerlink" title="5.3 堆排序"></a>5.3 堆排序</h3><ol><li><p>堆排序(heap sort): 考虑建立二叉堆 $O(N)$,执行 N 次 <code>deleteMin</code> $O(N\log N)$.按照顺序,最小的元素将会先离开堆,将这些元素记录到第二个数组即可得到排序数组</p></li><li><p>上述算法需要额外的数组空间,可以每次在 <code>deleteMin</code> 操作后,将最后空出来的单元用于存放元素.此时得到的将是逆序的排序数组,因而可以构建具有 <code>deleteMax</code> 操作的二叉堆</p></li><li><p>堆排序是非常稳定的算法: 平均使用的比较只比最坏情形略少</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> leftChild(i) (2 * (i) + 1)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">percDown</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> child;<br>    <span class="hljs-keyword">for</span>(elementType tmp = arr[i]; leftChild(i) &lt; n; i = child) &#123;<br>        <span class="hljs-keyword">if</span>(child != n - <span class="hljs-number">1</span> &amp;&amp; arr[child + <span class="hljs-number">1</span>] &gt; arr[child])<br>            child++;<br>        <span class="hljs-keyword">if</span>(tmp &lt; a[child])<br>            arr[i] = arr[child];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    arr[i] = tmp;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        percDown(arr, i, n);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>        swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[i]);<br>        percDown(arr, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-4-归并排序"><a href="#5-4-归并排序" class="headerlink" title="5.4 归并排序"></a>5.4 归并排序</h3><ol><li><p>考虑合并2个已排序的数组: 设定2个指针分别指向数组的起始位置.比较2个指针指向的元素,将较小的元素放入输出数组,并移动指针.重复这一过程,直到某一指针到达末尾</p></li><li><p>归并排序(merge sort): 以分治递归的形式合并已排序数组 $O(N\log N)$.使用的比较次数几乎最优</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mSort</span><span class="hljs-params">(elementType arr[], elementType tmpArr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> center;<br>    <span class="hljs-keyword">if</span>(left &lt; right) &#123;<br>        center = (left + right) / <span class="hljs-number">2</span>;<br>        mSort(arr, tmpArr, left, center);<br>        mSort(arr, tmpArr, center + <span class="hljs-number">1</span>, right);<br>        merge(arr, tmpArr, left, center + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mergeSord</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    elementType *tmpArr = <span class="hljs-built_in">malloc</span>( n * <span class="hljs-keyword">sizeof</span>(elementType) );<br>    <span class="hljs-keyword">if</span>(tmpArr != <span class="hljs-literal">NULL</span>) &#123;<br>        mSort(arr, tmpArr, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">free</span>(tmpArr);<br>    &#125; <span class="hljs-keyword">else</span><br>        fatalError(<span class="hljs-string">&quot;No space for tmp array!&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(elementType arr[], elementType tmpArr[], <span class="hljs-type">int</span> lpos, <span class="hljs-type">int</span> rpos, <span class="hljs-type">int</span> rightEnd)</span> &#123;<br>    <span class="hljs-type">int</span> leftEnd = rpos - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> tmpPos = lpos;<br>    <span class="hljs-type">int</span> numElements = rightEnd - lpos + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(lpos &lt;= leftEnd &amp;&amp; rpos &lt;= rightEnd)<br>        <span class="hljs-keyword">if</span>(arr[lpos] &lt;= arr[rpos])<br>            tmpArr[tmpPos++] = arr[lpos++];<br>    <span class="hljs-keyword">else</span><br>            tmpArr[tmpPos++] = arr[rpos++];<br>    <span class="hljs-keyword">while</span>(lpos &lt;= leftEnd)<br>        tmpArr[tmpPos++] = arr[lpos++];<br>    <span class="hljs-keyword">while</span>(rpos &lt;= rightEnd)<br>        tmpArr[tmpPos++] = arr[rpos++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numElements; ++i, --rightEnd) &#123;<br>        arr[rightEnd] = tmpArr[rightEnd];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-5-快速排序"><a href="#5-5-快速排序" class="headerlink" title="5.5 快速排序"></a>5.5 快速排序</h3><ol><li><p>快速排序(quick sort): 实践中最快的已知排序算法,平均运行时间 $O(N\log N)$</p><ul><li>若 S 中元素个数为 0 或 1,则直接返回</li><li>选取 S 中的任意元素 v,其称为基准(pivot)</li><li>分区并排序: 将 $S-{v}$ 分为两个不相交集合: $S_1 &#x3D;{x\in S-{v}|x\leq v},S_2 &#x3D;{x\in S-{v}|x\geq v} $ </li><li>递归地将小于基准元素的子数列和大于基准值元素的子数组排序</li></ul></li><li><p>选取基准</p><ul><li>错误的方式: 选取第一个元素作为基准.若输入是预排序或反序的,将会产生劣质的分割</li><li>安全的方式: 随机选取基准.但考虑到生成随机数是昂贵的,因而无法减少算法其余部分的平均运行时间</li><li>数中值分割法: 基准的最好选择是数组的中值,但这很难算出.因而可以考虑三个元素(左侧,中心,右侧位置)的中值作为基准.消除了预排序输入的坏情形,并减少约 5% 的时间</li></ul></li><li><p>分割策略</p><ul><li>将基准元与最后的元素进行交换,使得基准元离开要被分割的数据段</li><li>设置双指针 i, j. 初始时刻分别指向数组的第一个元素和倒数第二个元素(因为最后一个元素为基准)</li><li>当 i &lt; j 时,将 i 右移,直到遇到大于基准元的数.同理,将 j 左移,直到遇到小于基准元的数</li><li>若停止后的仍满足 i &lt; j,则将 i, j 指向的两个元素互换.重复该过程,直到 i, j 彼此交错</li><li>当 i, j 交错后,将基准元与 i 所指向的元素互换,即可完成分割</li></ul></li><li><p>对于小数组(n &lt; 20),快速排序不如插入排序好</p><ul><li>由于快速排序是递归的,因此小数组排序的情况经常发生</li><li>对小数组不进行递归排序,而进行插入排序将会节约15%的时间.截至范围可选择 n&#x3D;10</li></ul></li><li><p>快速排序的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    qSort(arr, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>&#125;<br><br>elementType <span class="hljs-title function_">median3</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> center = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(arr[left] &gt; arr[center])<br>        swap(&amp;arr[left], &amp;arr[center]);<br>    <span class="hljs-keyword">if</span>(arr[left] &gt; arr[right])<br>        swap(&amp;arr[left], &amp;arr[right]);<br>    <span class="hljs-keyword">if</span>(arr[center] &gt; arr[right])<br>        swap(&amp;arr[center], &amp;arr[right]);<br>    swap(&amp;arr[center], &amp;arr[right - <span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> arr[right - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">qSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    elementType pivot;<br>    <span class="hljs-keyword">if</span>(left + cutOff &lt;= right) &#123;<br>        pivot = median3(arr, left, right);<br>        <span class="hljs-type">int</span> i = left;<br>        <span class="hljs-type">int</span> j = right - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(;;) &#123;<br>            <span class="hljs-keyword">while</span>(arr[++i] &lt; pivot) &#123;&#125;<br>            <span class="hljs-keyword">while</span>(arr[--j] &lt; pivot) &#123;&#125;<br>            <span class="hljs-keyword">if</span>(i &lt; j)<br>                swap(&amp;arr[i], &amp;arr[j]);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        swap(&amp;arr[i], &amp;arr[right - <span class="hljs-number">1</span>]);<br>        qSort(arr, left, i - <span class="hljs-number">1</span>);<br>        qSort(arr, i + <span class="hljs-number">1</span>, right);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        insertSort(arr + left, right - left + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-图论算法"><a href="#6-图论算法" class="headerlink" title="6 图论算法"></a>6 图论算法</h2><h3 id="6-1-图的定义"><a href="#6-1-图的定义" class="headerlink" title="6.1 图的定义"></a>6.1 图的定义</h3><ol><li>图(graph): 由顶点(vertex)的集合 V,边(edge)的集合 E 组成<ul><li>每条边都是点对(v, w), 其中 $v,w\in V$</li><li>若点对是有序的,则图是有向(directed)的,称为有向图(digraph)</li><li>顶点 v, w 邻接等价于当 $(v,w)\in E$</li><li>边可以有第三种成分: 权(weight) 或 值(cost)</li></ul></li><li>图中的路径(path)<ul><li>路径是顶点序列: $w_1, w_2, \dots, w_N \space\space \mathrm{s.t.}(w_i,w_{i+1})\in E,1\leq i&lt;E$ </li><li>路径的长(length): 边的数量,即 N-1</li><li>环(loop): 从一个顶点到自身的边</li><li>简单路径: 所有的顶点都互异,但第一个和最后一个顶点可以相同</li></ul></li><li>图中的圈(cycle)<ul><li>有向图中的圈: 满足 $w_1 &#x3D; w_N$ 且长至少为1的一条路径</li><li>无向图中的圈则额外要求边是互异的</li></ul></li><li>连通(connected)<ul><li>在无向图中从每一个顶点到每个其他顶点都存在一条路径</li><li>在有向图中,这种性质称为强连通(strongly connected)</li><li>若有向图不是强连通的,但其基础图(underlying graph, 即去掉弧的方向)是连通的,则称为弱连通(weakly connected)</li><li>完全图(complete graph): 每个顶点间都存在一条边</li></ul></li><li>图的表示(有向图)<ul><li>使用一个二维数组,即**邻接矩阵(adjacent matrix)**表示<ul><li>对于每条边(u, v),置 <code>A[u][v] = 1</code>.其他元素为0</li><li>若该边有一个权,则可置 <code>A[u][v]</code> 等于该权.使用很大&#x2F;小的数表示不存在的边</li><li>若图是稀疏的(sparse), 该方法所需求的空间 $\Theta(|V|^2)$ 过大了</li></ul></li><li><strong>邻接表(adjacent list)</strong>: 对每一个顶点,使用一个表存放所有的邻接点<ul><li>空间需求为 $O(|E|+|V|)$</li><li>邻接表是图的标准表示方法</li></ul></li><li>考虑到实际中顶点都有名字,因此需要使用散列表建立名字到数字的映射<ul><li>散列表中对每个顶点存储一个名字和一个内部编号( 1 ~ |V| 之间)</li></ul></li></ul></li></ol><h3 id="6-2-最短路径算法"><a href="#6-2-最短路径算法" class="headerlink" title="6.2 最短路径算法"></a>6.2 最短路径算法</h3><ol><li><p>输入一个赋权图: 与每条边 $(v_i, v_j)$ 联系的是穿越该弧的代价 $c_{i,j}$</p><ul><li>赋权路径长(weighted path length): $v_1v_2\dots v_N$ 路径的值为 $\sum\limits^{N-1}<em>{i&#x3D;1}c</em>{i,j}$</li></ul></li><li><p>单源最短路径问题: 给定赋权图 $G&#x3D;(V,E)$ 和特定顶点 s 作为输入,找出 s 到 G 每个点的最短赋权路径</p></li><li><p>无权最短路径</p><ul><li><p>广度优先搜索(breadth-first search): 按层处理顶点,距离最近的先辈赋值,最远的最后赋值</p></li><li><p>显然顶点s到自身距离为0,然后考察与s邻接的点,其距离为1.然后考察邻接的邻接,直到完成所有点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unWeigted</span><span class="hljs-params">(table t)</span> &#123;<br>    vertex v, w;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> currDist = <span class="hljs-number">0</span>; currDist &lt; numVetex; ++currDist)<br>        <span class="hljs-keyword">for</span> each vertex v<br>            <span class="hljs-title function_">if</span><span class="hljs-params">(!t[v].known &amp;&amp; t[v].dist == currDist)</span> &#123;<br>                t[v].known = True;<br>                <span class="hljs-keyword">for</span> each w adjacent to v<br>                    <span class="hljs-title function_">if</span><span class="hljs-params">(t[w].dist == infinity)</span> &#123;<br>                        t[w].dist = currDist + <span class="hljs-number">1</span>;<br>                        t[w].path = v;<br>                    &#125;<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Dijkstra 算法: 考虑赋权图的单源最短路径问题.仍借鉴无权时的思路</p><ul><li>顶点 s 到自身的距离为0,将其标记为已知,因为此时多了一个已知点,则可以获得其到达邻接点的距离</li><li>选取距离最小的点(贪心法,greedy algorithm)标记为已知,则有可以更新其到达邻接点的距离</li><li>重复该过程,直到获得到达目标点的最短距离</li><li>对于没有负值边的图,该算法总能完成.一旦出现负值边,则可能出现错误的答案</li></ul></li></ol><h2 id="7-算法设计技巧"><a href="#7-算法设计技巧" class="headerlink" title="7 算法设计技巧"></a>7 算法设计技巧</h2><h3 id="7-1-贪婪算法"><a href="#7-1-贪婪算法" class="headerlink" title="7.1 贪婪算法"></a>7.1 贪婪算法</h3><ol><li>贪婪算法分阶段工作.在每一个阶段,认为所作的决定是最好的,而不考虑将来的后果(即局部最优)<ul><li>当算法终止时,若局部最优就是全局最优,则算法正确.否则将得到一个次优解(suboptimal solution)</li><li>若不要求绝对最佳答案,也可通过简单的贪婪算法生成近似答案</li></ul></li><li>Huffman 编码<ul><li>ASCII 编码有约100个可打印字符和控制字符组成,需要 $\lceil \log 128\rceil&#x3D;7$ 位表示,可添加第8位作为校验位<ul><li>现实中,许多文件都含有大量的数字,空格和换行,而 q, x 很少</li><li>采用非等长编码,使经常出现的字符代码较短,可以节约磁盘空间</li></ul></li><li>对于代表字符的二进制代码,可以用二叉树来表示<ul><li>只在树叶上有数据.且每个字符从根节点开始,用0指示向左分支,用1指示向右分支</li><li>若字符 $c_i$ 在深度 $d_i$ 处,且出现 $f_i$ 次.则该字符代码的值(cost)为 $\sum d_i f_i$</li></ul></li></ul></li><li>Huffman 算法<ul><li>假设字符数量为 C.算法开始时存在 C 棵单节点树(每个字符一颗)</li><li>任意选取有最小权(树的权等于其树叶频率的和)的两棵树,任意形成以这两棵树为子树的新树</li><li>将这样的过程进行 C-1 次.即可得到最优 Huffman 编码树</li></ul></li></ol><h3 id="7-2-分治算法"><a href="#7-2-分治算法" class="headerlink" title="7.2 分治算法"></a>7.2 分治算法</h3><ol><li>分治(divide and conquer)算法<ul><li>分: 递归解决较小的问题(基本情况除外)</li><li>治: 从子问题的解 构建原问题的解</li></ul></li><li>最近点问题: 找出平面上点列中最近(欧几里得距离)的一对点<ul><li>暴力算法: 计算每个点对之间的距离,找出最小值 $O(N^2)$</li><li>分治算法思路<ul><li>将平面上的点分为两半,最近点对存在三种可能: 均在左, 均在右, 一个在左一个在右</li><li>记不同情况的最近点对的最小距离为: 左侧点集 $d_l$,右侧点集 $d_r$,两侧点间的距离 $d_c$</li><li>对于 $d_l, d_r$,可以递归的进行计算.关键在于如何计算 $d_c$</li></ul></li><li>$d_c$ 的计算<ul><li>令 $\delta &#x3D; \min(d_l, d_r)$.如果 $d_c$ 对 $\delta$ 有改进,则只需计算 $d_c$</li><li>若 $d_c$ 是这样的距离,则定义 $d_c$ 的两个点必然在分割线的 $\delta$ 邻域内(一个带状区域).限制考察点的数量</li><li>对于均匀分布的点集,则平均有 $O(\sqrt N)$ 个点位于邻域内,此时可采用暴力求解 $O(N)$</li></ul></li></ul></li><li>选择问题: 找出含有 N 个元素的表 S 中的第 k 个最小的元素(对于中位数 $k &#x3D; \lceil N&#x2F;2 \rceil$ 特别关注)<ul><li>通过对元素的快速排序,此问题以 $O(N\log N)$ 的最坏情形时间解决</li><li>五分化中项的中项 选择快速排序的基准<ul><li>将 N 个元素分为 $\lfloor N&#x2F;5 \rfloor$ 组,每5个元素一组,最多忽略4个元素</li><li>找出每组的中项,得到 $\lfloor N&#x2F;5 \rfloor$ 个中项的表 M,找出 M 的中项并返回</li></ul></li><li>使用五分化中项的中项的快速选择算法的运行时间为 $O(N)$.但实践中该算法并不实用</li></ul></li></ol><h3 id="7-3-动态规划"><a href="#7-3-动态规划" class="headerlink" title="7.3 动态规划"></a>7.3 动态规划</h3><ol><li><p>动态规划(dynamic programming)</p><ul><li>数学递归公式均可直接翻译为递归算法,但现实中编译器往往不发正确对待递归算法,而导致低效</li><li>当这种情况发生时,便需要给编译器提供帮助.改写为非递归的算法,并将子问题的答案记录在一个表内</li></ul></li><li><p>使用表代替递归</p><ul><li><p>计算 Fibonacci 数的自然递归效率非常低,是指数级别的</p></li><li><p>使用一个表将中间的计算结果存储起来,则可避免大量的冗余计算,下面计算 $c_n &#x3D; \frac2n\sum\limits_{i&#x3D;0}^{n-1}c_i+n,\space c_0 &#x3D; 1$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">double</span> *c = <span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>( <span class="hljs-type">double</span> ) * ( n + <span class="hljs-number">1</span> ) );<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    c[<span class="hljs-number">0</span>] = <span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j)<br>            sum += c[j];<br>        c[i] = <span class="hljs-number">2.0</span> * sum / i + i;<br>    &#125;<br>    <span class="hljs-type">int</span> answer = c[n];<br>    <span class="hljs-built_in">free</span>(c);<br>    <span class="hljs-keyword">return</span> answer;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>Code</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言进阶</title>
    <link href="/2021/10/01/Computer/C-Language-Advanced/"/>
    <url>/2021/10/01/Computer/C-Language-Advanced/</url>
    
    <content type="html"><![CDATA[<h1 id="C-语言进阶"><a href="#C-语言进阶" class="headerlink" title="C 语言进阶"></a>C 语言进阶</h1><h2 id="0-开发环境"><a href="#0-开发环境" class="headerlink" title="0 开发环境"></a>0 开发环境</h2><h3 id="0-1-Windows-环境"><a href="#0-1-Windows-环境" class="headerlink" title="0.1 Windows 环境"></a>0.1 Windows 环境</h3><ol><li><p>下载安装 <a href="https://www.mingw-w64.org/downloads/#mingw-w64-builds">MinGW</a></p><ul><li><p>将 <code>x86_64-15.1.0-release-win32-seh-ucrt-rt_v12-rev0.7z</code> 解压得到 <code>mingw64</code> 目录</p></li><li><p>配置环境变量: 在系统 <code>path</code> 中添加 <code>mingw64</code> 路径. 如: <code>D:\code\mingw64\bin</code></p></li><li><p>检查安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc --version<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>运行</strong>: 在 VS Code 中编写代码,然后点击右上角运行 -&gt; <code>C/C++:gcc.exe 生成和调试活动文件</code>.进行编译运行</p></li><li><p><strong>多文件编译</strong>(<code>tasks.json</code> 文件配置): 编译快捷键 <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>B</kbd> </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppbuild&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C/C++: gcc.exe 生成活动文件&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;D:/code/mingw64/bin/gcc.exe&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// gcc 绝对路径</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;-fdiagnostics-color=always&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 启用彩色诊断信息</span><br>                <span class="hljs-string">&quot;-g&quot;</span><span class="hljs-punctuation">,</span>                          <span class="hljs-comment">// 生成调试信息.用于 GDB 调试</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/*.c&quot;</span><span class="hljs-punctuation">,</span>      <span class="hljs-comment">// 编译所有 .c 文件</span><br>                <span class="hljs-string">&quot;-o&quot;</span><span class="hljs-punctuation">,</span>                          <span class="hljs-comment">// 指定输出文件名</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/main.exe&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 生成的可执行文件名称</span><br>                <span class="hljs-string">&quot;-Wall&quot;</span><span class="hljs-punctuation">,</span>     <span class="hljs-comment">// 开启所有警告</span><br>                <span class="hljs-string">&quot;-Wextra&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-comment">// 启用额外警告</span><br>                <span class="hljs-string">&quot;-Werror&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-comment">// 警告视为错误</span><br>                <span class="hljs-string">&quot;-pedantic&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 严格遵循标准</span><br>                <span class="hljs-string">&quot;-std=c17&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 使用 C17 标准</span><br>                <span class="hljs-string">&quot;-O0&quot;</span><span class="hljs-punctuation">,</span>       <span class="hljs-comment">// 优化级别 0.不优化,调试时使用</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;fileDirname&#125;&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;$gcc&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;isDefault&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;detail&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;调试器生成的任务。&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>调试</strong>(<code>launch.json</code> 文件配置): 运行和调试 -&gt; 创建 <code>launch.json</code> 文件 -&gt; C++(GDB&#x2F;LLDB)<br> -&gt; 添加配置 -&gt; C&#x2F;C++: (gdb) 启动</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(gdb) 调试 C 程序&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/main.exe&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;environment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;externalConsole&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 需要输入时改为 true</span><br>            <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;D:/code/mingw64/bin/gdb.exe&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// gdb 绝对路径</span><br>            <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;启用漂亮打印&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;反汇编风格为 Intel&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C/C++: gcc.exe 生成活动文件&quot;</span>  <span class="hljs-comment">// 调试前自动编译</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><code>clangd</code> 插件</p><ul><li><p>需要下载安装包含 <code>clangd</code> 可执行文件的 LLVM&#x2F;Clang 工具链(直接使用 VS Code 提示安装)</p></li><li><p>解决标准库标红(在项目根目录下创建 <code>.clangd</code> 文件)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">CompileFlags:<br>  Add: [<br>    --target=x86_64-w64-mingw32,<br>    -isystem, D:/code/mingw64/x86_64-w64-mingw32/include,<br>    -isystem, D:/code/mingw64/include,<br>  ]<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>CMake</code> 使用</p><ul><li><p><a href="https://cmake.org/download/">下载安装 <code>CMake</code></a> &amp; 验证安装是否成功(在 VS Code 中安装 <code>CMake, CMake Tools, Code Runner</code> 插件)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake --version<br></code></pre></td></tr></table></figure></li><li><p>手动构建方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir build &amp;&amp; cd build  # 创建并进入 build 目录<br>cmake ..                 # 编译上级目录的 CMakeList.txt<br>make                     # 构建项目<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.20 之后改为</span><br>cmake -B build           # 创建 build 目录,编译 CMakeList.txt<br>cmake -build build       # 构建项目<br></code></pre></td></tr></table></figure></li><li><p>在 VS Code 中配置 <code>CMake</code> 路径<br><kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>P</kbd> -&gt; <code>Preferences: Open Settings (JSON)</code> 在 <code>setting.json</code> 文件中添加内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;cmake.cmakePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;D:/code/cmake/bin/cmake.exe&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// cmake 绝对路径</span><br><span class="hljs-attr">&quot;cmake.generator&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MinGW Makefiles&quot;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure></li><li><p><code>CmakeLists.txt</code> 文件(在项目根目录下创建)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.20</span>)<br><br><span class="hljs-comment"># 项目设置</span><br><span class="hljs-keyword">project</span>(VscodeProjectTest LANGUAGES C)<br><br><span class="hljs-comment"># 严格编译器设置</span><br><span class="hljs-keyword">set</span>(CMAKE_C_STANDARD <span class="hljs-number">17</span>)          <span class="hljs-comment"># 使用 C17 标准</span><br><span class="hljs-keyword">set</span>(CMAKE_C_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>) <span class="hljs-comment"># 强制要求编译器必须严格支持指定的 C 语言标准</span><br><span class="hljs-keyword">set</span>(CMAKE_C_EXTENSIONS <span class="hljs-keyword">OFF</span>)       <span class="hljs-comment"># 禁用编译器扩展(模拟-pedantic)</span><br><br><span class="hljs-comment"># 启用编译数据库生成.配合 clangd</span><br><span class="hljs-keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-comment"># 强制启用所有警告</span><br><span class="hljs-keyword">add_compile_options</span>(<br>    -Wall     <span class="hljs-comment"># 开启所有警告</span><br>    -Wextra   <span class="hljs-comment"># 启用额外警告</span><br>    -Werror   <span class="hljs-comment"># 将警告视为错误</span><br>    -pedantic <span class="hljs-comment"># 严格遵循标准</span><br>)<br><br><span class="hljs-comment"># 根据构建类型设置优化级别</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">NOT</span> CMAKE_BUILD_TYPE)<br>  <span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE <span class="hljs-string">&quot;Debug&quot;</span>) <span class="hljs-comment"># 默认 Debug 模式(自动包含-g)</span><br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># 显式包含当前目录(确保头文件能找到)</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)<br><br><span class="hljs-comment"># 添加可执行文件(推荐显式列出文件)</span><br><span class="hljs-keyword">add_executable</span>(<br>    <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span><br>    main.c<br>)<br></code></pre></td></tr></table></figure></li><li><p>使用 CMake 编译出的文件路径为: <code>./build/xxx.exe</code>.因此调试需要修改 <code>launch.json</code> 文件配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/build/VscodeProjectTest.exe&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>至此,可以 <code>CMake Tools</code> 插件可以利用 CMake 构建, 运行项目,且可以使用 gdb 调试</p></li></ul></li></ol><h3 id="0-2-Linux-环境"><a href="#0-2-Linux-环境" class="headerlink" title="0.2 Linux 环境"></a>0.2 Linux 环境</h3><ol><li><p>在 Linux(发行版为 windows 的 wsl, Ubuntu 24.04) 使用 C 语言开发</p></li><li><p>在 Linux 安装必要的工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install build-essential gdb gcc g++ make<br></code></pre></td></tr></table></figure></li><li><p>Windows 远程连接到 Linux(需要先确保 Linux 服务器已开启 SSH 服务)</p><ul><li><p>在 PowerShell 中生成密钥(默认保存路径为 <code>C:\Users\你的用户名\.ssh\id_rsa</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -b 4096<br></code></pre></td></tr></table></figure></li><li><p>查看生成的密钥(复制输出的内容.以 <code>ssh-rsa AAA...</code> 开头)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat ~\.ssh\id_rsa.pub<br></code></pre></td></tr></table></figure></li><li><p>在 Linux 上添加公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p ~/.ssh  # 如果目录不存在则创建<br>echo &quot;Windows 中输出的公钥内容&quot; &gt;&gt; ~/.ssh/authorized_keys<br>chmod 600 ~/.ssh/authorized_keys  # 设置权限<br></code></pre></td></tr></table></figure></li><li><p>在 PowerShell 中测试 ssh 连接(若能够直接连接而无需密码,表示配置正确)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh username@linux_server_ip # 格式为 用户名@ip地址<br>logout                       # 退出 ssh<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在 VS Code 安装 <code>remote</code> 扩展</p><ul><li><p>按 <kbd>F1</kbd> 或 <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>P</kbd> -&gt; <code>Remote-SSH: Connect to Host...</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh username@linux_server_ip<br></code></pre></td></tr></table></figure></li><li><p>VS Code 会提示选择 SSH 配置文件(默认是 <code>C:\Users\你的用户名\.ssh\config</code>),确认保存</p></li><li><p>ssh 连接 <code>config</code> 文件的含义(非必需项,仅了解含义)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host mylinux  # 自定义别名<br>    HostName linux_server_ip<br>    User username<br>    IdentityFile ~/.ssh/id_rsa<br>    Port 22  # 默认端口，如果修改过请调整<br></code></pre></td></tr></table></figure></li></ul></li><li><p>配置 VS Code 编译, 调试设置(相较于 Windows 生成的可执行文件, Linux 无需 <code>.exe</code> 后缀)</p><ul><li><p>相较于 Windows 的 <code>tasks.json</code> 文件修改内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gcc&quot;</span> <span class="hljs-comment">// gcc 绝对路径</span><br></code></pre></td></tr></table></figure></li><li><p>相较于 Windows 的 <code>launch.json</code> 文件修改内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;miDebuggerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gdb&quot;</span> <span class="hljs-comment">// gdb 绝对路径</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>CMake</code> 使用(相较于 Windows 的 <code>CMakeLists.txt</code> 文件添加内容, 指定 gcc, g++ 路径)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(CMAKE_C_COMPILER <span class="hljs-string">&quot;/usr/bin/gcc&quot;</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_COMPILER <span class="hljs-string">&quot;/usr/bin/g++&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li><p>若想要使用 CMake 构建项目, gdb 进行调试,则 <code>task.json</code> 改为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake-configure&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;-B&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;-DCMAKE_BUILD_TYPE=Debug&quot;</span> <span class="hljs-comment">// Debug 模式方便调试</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;owner&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;fileLocation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-string">&quot;relative&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>                <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;pattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;regexp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^(.*):(\\d+):\\s+(.*)$&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;file&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;line&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake-build&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;--build&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;--parallel&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;owner&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cpp&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;fileLocation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-string">&quot;relative&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span><br>                <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;pattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;regexp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^(.*):(\\d+):(\\d+):\\s+(warning|error|fatal error):\\s+(.*)$&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;file&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;line&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;column&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;severity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Full Build&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;dependsOrder&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sequence&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;dependsOn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;cmake-configure&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;cmake-build&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;isDefault&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><code>launch.json</code> 改为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;GDB Debug&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/build/VscodeProjectTest&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 替换为你的可执行文件名</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;environment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;externalConsole&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gdb&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Enable pretty-printing for gdb&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Set disassembly flavor to Intel&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Full Build&quot;</span>  <span class="hljs-comment">// 调试前自动构建</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>clangd</code> 插件(VS Code 中需安装插件)</p><ul><li><p>下载, 验证安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install clangd<br>clangd --version<br></code></pre></td></tr></table></figure></li><li><p>在 <code>setting.json</code> 中添加配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;clangd.path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/clangd&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;clangd.arguments&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;--background-index&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;--clang-tidy&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;--completion-style=detailed&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;--header-insertion=never&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;C_Cpp.intelliSenseEngine&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;disabled&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 禁用微软引擎</span><br>  <span class="hljs-attr">&quot;C_Cpp.codeFolding&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;disabled&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-comment">// 避免冲突</span><br>  <span class="hljs-attr">&quot;editor.semanticHighlighting.enabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><code>clangd</code> 依赖 <code>compile_commands.json</code> 来获取项目的编译信息.CMake 生成该文件位于 <code>build</code> 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s build/compile_commands.json .  # 创建软连接供 clangd 使用<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>clang-format</code> 格式化代码(VS Code 快捷键 <kbd>Shift</kbd><kbd>Alt</kbd><kbd>F</kbd>)</p><ul><li><p>安装 <code>clang-format</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install clang-format<br></code></pre></td></tr></table></figure></li><li><p>在项目根目录新建 <code>.clang-format</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">BasedOnStyle: Google  # 使用 Google 风格<br>IndentWidth: 4        # 覆盖为 4 空格缩进<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-3-GCC-编译器"><a href="#0-3-GCC-编译器" class="headerlink" title="0.3 GCC 编译器"></a>0.3 GCC 编译器</h3><ol><li><p>GCC(GNU Compiler Collection): gcc &#x2F; g++ 分别是 GNU 的 C &#x2F; C++ 编译器</p></li><li><p>gcc &#x2F; g++ 在执行编译工作的步骤</p><ul><li>预处理器 cpp: 预处理,生成 <code>.i</code> 的文件</li></ul><ul><li>编译器 egcs: 将预处理后的文件转换成汇编语言, 生成 <code>.s</code> 文件</li><li>汇编器 as: 有汇编变为目标代码(机器代码)生成 <code>.o</code> 的文件</li><li>链接器 ld: 连接目标代码, 生成可执行程序</li></ul></li><li><p>查看版本信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc --version<br></code></pre></td></tr></table></figure></li><li><p>gcc 编译选项(gcc 会按照后缀名进行编译.对于 C 程序,应当保持后缀名为 <code>.c</code>)</p><ul><li><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -E hello.c &gt; hello.i  # 只激活预处理,不生成文件.但可以重定向到一个输出文件<br>gcc -S hello.i -o hello.s # 只激活预处理和编译.将文件编译成汇编代码<br>gcc -c hello.s -o hello.o # 只激活预处理, 编译, 汇编.生成 obj 文件<br>gcc hello.o -o hello      # 完整地编译文件(默认生成的可以执行文件名为 a.out)<br></code></pre></td></tr></table></figure></li><li><p>调试, 优化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -g hello.c -o hello  # 生成可供 gdb 调试可执行文件<br>gcc -O2 hello.c -o hello # 优化级别2<br></code></pre></td></tr></table></figure></li><li><p>标准, 警告</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -Wall hello.c    # 打印 gcc 的警告信息<br>gcc -w hello.c       # 关闭 gcc 的警告信息<br>gcc -std=c11 hello.c # 使用 C11 标准<br></code></pre></td></tr></table></figure></li><li><p>编译时定义宏</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -D宏名 hello.c<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-4-GDB-调试器"><a href="#0-4-GDB-调试器" class="headerlink" title="0.4 GDB 调试器"></a>0.4 GDB 调试器</h3><ol><li><p>GDB(GNU Project Debugger) 功能</p><ul><li>指定参数</li><li>设置断点</li><li>分析 crash 现场</li><li>直接修改程序,观测结果</li></ul></li><li><p>下载, 验证安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install gbd<br>gdb --version<br></code></pre></td></tr></table></figure></li><li><p>启动 gdb(注意: 在 gcc 编译时需要加上 <code>-g</code> 选项才能生成可供调试的可执行文件)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gdb filename       # 从头运行程序并调试<br>gdb filename core  # 调试 crash 的程序<br>gdb -p 进程号      # 调试运行中的程序<br></code></pre></td></tr></table></figure></li><li><p>gdb 命令(<kbd>Enter</kbd> 表示重复上一命令)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">run         # 运行<br>start       # 单步执行.停在第一行<br>quit(q)     # 退出<br>list(l)     # 查看代码<br>break(b)    # 设置断点,行数<br>delete(d)   # 删除断点<br>next(n)     # 单步执行,逐过程<br>step(s)     # 单步执行,逐语句<br>finish      # 结束当前函数,跳出<br>continue(c) # 继续运行<br>display     # 追踪变量<br>undisplay   # 取消追踪<br>watch       # 观察点修改时进行打印<br><br>print(p) # 查看变量<br>set var  # 设置变量<br>info(i)  # 查看信息<br>x 0x...  # 查看内存信息<br>!clear   # 清屏<br>thread   # 线程<br>disass   # 汇编<br></code></pre></td></tr></table></figure></li></ol><h2 id="1-库函数"><a href="#1-库函数" class="headerlink" title="1  库函数"></a>1  库函数</h2><h3 id="1-1-字符类别测试"><a href="#1-1-字符类别测试" class="headerlink" title="1.1 字符类别测试"></a>1.1 字符类别测试</h3><ol><li><p>下列函数声明于 <code>&lt;ctype.h&gt;</code></p></li><li><p>下面这些函数参数类型均为 <code>int</code>,其值必须为 <code>EOF</code> 或可用 <code>unsigned char</code> 类型表示的字符</p></li><li><p>函数的返回值类型也为 <code>int</code>.若满足指定的条件,返回非零值(真).否则返回0(假)</p><table><thead><tr><th>函数</th><th>假定的判断</th></tr></thead><tbody><tr><td>isalnum(c)</td><td>小写字母或数字</td></tr><tr><td>isalpha(c)</td><td>字母</td></tr><tr><td>iscntrl(c)</td><td>控制字符</td></tr><tr><td>isdigit(c)</td><td>十进制数</td></tr><tr><td>isgraph(c)</td><td>除空格外的可打印字符</td></tr><tr><td>islower(c)</td><td>小写字母</td></tr><tr><td>isprint(c)</td><td>包括空格的可打印字符</td></tr><tr><td>ispunct(c)</td><td>除空格,字母,数字外的可打印字符</td></tr><tr><td>isspace(c)</td><td>空格&#x2F;换页符&#x2F;换行符&#x2F;回车符&#x2F;横(纵)向制表符</td></tr><tr><td>isupper(c)</td><td>大写字母</td></tr><tr><td>isxdigit(c)</td><td>十六进制数</td></tr></tbody></table></li><li><p>在7位 ASCII 字符集中</p><ul><li>可打印字符为 0x20(‘ ‘) ~ 0x7E(‘-‘)</li><li>控制字符为 0(NUL) ~ 0x1F(US), 再加上0x7F(DEL)</li></ul></li><li><p>字符的大小写转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">tolower</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 当 c 为大写字母时才会进行转换.否则返回 c 自身</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">toupper</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-2-字符串函数"><a href="#1-2-字符串函数" class="headerlink" title="1.2 字符串函数"></a>1.2 字符串函数</h3><ol><li><p>下列函数声明于 <code>&lt;string.h&gt;</code>.其中有2组字符串函数.分别以 <code>str, mem</code> 开头</p></li><li><p>比较函数将参数作为 <code>unsigned char</code> 类型的数组处理</p><ul><li><code>s, t</code> 类型为 <code>char *</code></li><li><code>cs, ct</code> 类型为 <code>const char *</code></li><li><code>n</code> 类型为 <code>size_t</code></li><li><code>c</code>类型为 <code>int</code>(会被转换为<code>char</code>)</li></ul><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><strong>char *strcpy(s, ct);</strong></td><td>将 ct 复制到 s 中(包括<code>&#39;\0&#39;</code>),返回 s</td></tr><tr><td>char *strncpy(s, ct, n);</td><td>复制过程最大数目被限制为 n.若 ct 不足 n 个,用<code>&#39;\0&#39;</code>填充</td></tr><tr><td><strong>char *strcat(s, ct);</strong></td><td>将 ct 连接到 s 的尾部,返回 s</td></tr><tr><td>char *strncat(s, ct, n);</td><td>连接过程最大数目被限制为 n. 并以 <code>&#39;\0&#39;</code> 结束</td></tr><tr><td><strong>int strcmp(cs, ct);</strong></td><td>比较 cs 和 ct</td></tr><tr><td>int strncmp(cs, ct, n);</td><td>比较过程最大数目被限制为n</td></tr><tr><td>char *strchr(cs, c);</td><td>在 cs 中查找字符 c.若不存在返回<code>NULL</code></td></tr><tr><td>char *strrchr(cs, c);</td><td>将查找的方向反向</td></tr><tr><td>size_t strspn(cs, ct);</td><td>计算 cs 中包含 ct 前缀长度</td></tr><tr><td>size_t strcspn(cs, ct);</td><td>计算 cs 中不包含 ct 前缀长度</td></tr><tr><td>char *strpbrk(cs, ct);</td><td>在 cs 中查找 ct 包含的任意字符.若不存在返回<code>NULL</code></td></tr><tr><td><strong>char *strstr(cs, ct);</strong></td><td>在cs中查找ct.返回指向第一次出现的位置的指针</td></tr><tr><td><strong>size_t strlen(cs);</strong></td><td>计算 cs 的长度</td></tr><tr><td>char *strerror(n);</td><td>返回一个指向 与错误编号n对应的错误信息字符串 的指针</td></tr><tr><td>char *strtok(s, ct);</td><td>在 s 中搜索由 ct 中字符界定的记号</td></tr></tbody></table></li><li><p>由 <code>mem</code> 开头的函数按字符数组的方式操作对象</p><ul><li><code>s, t</code> 类型为 <code>void *</code> </li><li><code>cs, ct</code> 类型为 <code>const void *</code></li><li><code>n</code> 类型为 <code>size_t</code></li><li><code>c</code> 类型为 <code>int</code>(将会被转换为 <code>unsigned char</code>)</li></ul><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><strong>void *memcpy(s, ct, n);</strong></td><td>将 ct 的 n 个字符复制到 s 中,返回 s</td></tr><tr><td>void *memmove(s, ct, n);</td><td>将复制过程扩展为 对象重叠时仍可正确执行</td></tr><tr><td>int memcmp(cs, ct, n);</td><td>与 <code>strcmp</code> 相似</td></tr><tr><td>void *memchr(cs, c, n);</td><td>在 cs 中查找字符 c.若不存在返回<code>NULL</code></td></tr><tr><td><strong>void *memset(s, c, n);</strong></td><td>将 s 的前 n 个对象替换为 c,返回s</td></tr></tbody></table></li></ol><h3 id="1-3-标准输入输出"><a href="#1-3-标准输入输出" class="headerlink" title="1.3 标准输入输出"></a>1.3 标准输入输出</h3><ol><li><p><code>getchar</code></p><ul><li>函数原型: <code>int getchar(void)</code></li><li>作用: 从标准输入一次读入一个字符</li><li>机制: 每次被调用时返回下一个输入字符.如果遇到文件结尾,返回EOF(在<code>stdio.h</code>中定义)</li></ul></li><li><p><code>putchar</code></p><ul><li>函数原型: <code>int putchar(int)</code></li><li>作用: 将字符送到标准输出上,默认为屏幕</li><li>机制: 若无错误发生,返回输出的字符.若发生错误,返回 EOF</li></ul></li><li><p><code>perror</code>: 打印错误信息(函数定义于 <code>stdio.h</code>)</p><ul><li><code>errno</code>(外部变量,在<code>errno.h</code>中定义)用于保存错误代码</li><li>函数原型: <code>void perror(char const *message);</code></li><li>作用: 打印出 <code>message</code> 指向的字符串,加上一个 空格和分号.然后打印一条解释 <code>errno</code> 当前错误的信息</li></ul></li><li><p><code>printf</code></p><ul><li><p>函数原型: <code>int printf(const char *format, ...)</code></p></li><li><p>作用: 将字符串进行格式化转换,然后进行标准化输出.等价于 <code>fprintf(stdout, ...)</code></p></li><li><p>机制: 按照 <code>format</code> 参数说明的格式进行转换,写入标准输出流.返回值为实际写入的字数.出错返回一个负值</p></li><li><p>格式串的组成</p><ul><li><p>普通字符: 被复制到输出流</p></li><li><p>转换说明: 决定下一后续参数的转换和打印.以<code>%</code>开头,转换字符结束.中间还可包含:</p><ol><li><code>标志(出现顺序不限)</code>: 用于修改转换说明<ul><li><code>-</code>: 指定被转换的参数在其字段左对齐</li><li><code>+</code>: 指定在输出的数前面加上 <code>正负号</code></li><li><code>空格</code>: 若第一个字符不是<code>正负号</code>, 则在其前面加上一个空格</li><li><code>0</code>: 对于数值转换,当输出长度小于字段宽度时,用0填充</li><li><code>#</code>: 指定另一种输出形式<ul><li>若为<code>o</code>转换,则第一个数字为0</li><li>若为 <code>e/E/f/g/G</code>转换,指定输出总是包括一个小数点</li><li><code>g/G</code> 转换还将保留尾部无意义的0</li></ul></li></ul></li><li><code>数值</code>: 用于指定最小字段宽度<ul><li>若参数字符数小于该数值,则在参数左边填充一些字符(通常为空格)</li><li>若指定左对齐,则在参数右边填充</li><li>若设置了0填充,则填充字符为0</li></ul></li><li><code>.</code>: 用于分隔字段宽度和精度</li><li><code>数值</code>: 用于指定精度<ul><li>若对象为字符串,则指定打印的字符最大个数</li><li>若为<code>e/E/f</code>转换,则指定打印的小数点后的位数</li><li>若为<code>g/G</code>转换,则指定打印的有效数字位数</li><li>若对象为整型数,则指定打印的数字位数(必要时进行0填充)</li></ul></li><li><code>h/l/L</code>: 长度修饰符,用于将参数指定为某种类型<ul><li><code>h</code>: 指定为 short&#x2F;unsigned short 类型</li><li><code>l</code>: 指定为 long&#x2F;unsigned long 类型</li><li><code>L</code>: 指定为 long double 类型</li></ul></li><li>宽度和精度均可用 <code>*</code> 进行指定.此时该值将通过转换下一参数(int 类型)得到</li></ol></li><li><p><code>printf</code> 转换字符(若<code>%</code>后的字符不是转换字符,则为未定义行为)</p><table><thead><tr><th>转换字符</th><th>参数类型 &amp; 转换结果</th></tr></thead><tbody><tr><td>d, i</td><td>int. 有符号十进制表示</td></tr><tr><td>o</td><td>unsigned int. 无符号八进制表示(无前导0)</td></tr><tr><td>x, X</td><td>unsigned int. 无符号十六进制表示(无前导0x&#x2F;0X),区分大小写</td></tr><tr><td>u</td><td>int. 无符号十进制表示</td></tr><tr><td>c</td><td>int. 转换为 unsigned char 类型后为1个字符</td></tr><tr><td>s</td><td>char *. 打印字符串的字符.直到 <code>&#39;\0&#39;</code> 或 达到被精度指定的字符数</td></tr><tr><td>f</td><td>double. 形式为: [-]mmm.ddd 的十进制表示<br />d 的数目由精度指定,默认为6. 当精度为0时不打印小数点</td></tr><tr><td>e, E</td><td>double. 形式为: <code>$[-]m.dddddd \quad e/E\pm xx$</code> 的十进制表示<br />d 的数目由精度指定,默认为6. 当精度为0时不打印小数点</td></tr><tr><td>g, G</td><td>double. 当指数小于-4或大于精度时,采用 %e&#x2F;%E 的格式<br />否则采用 %f 的格式. 尾部的0与小数点不打印</td></tr><tr><td>p</td><td>void *. 打印指针值</td></tr><tr><td>n</td><td>int *. 到目前为止,printf 输出的字符数目被写到相应的参数<br />不进行参数转换</td></tr><tr><td>%</td><td>不进行参数转化.打印 <code>%</code></td></tr></tbody></table></li></ul></li></ul></li><li><p><code>scanf</code></p><ul><li><p>函数原型: <code>int scanf(const char *format, ...)</code></p></li><li><p>作用: 从标准输入读取输入,根据<code>format</code>进行转换,并将转换后的值 赋给后续的各个参数,而这些参数必须是指针. 等价于 <code>scanf(stdout, ...)</code></p></li><li><p>机制: 当 <code>format</code> 用完时,函数返回实际被转换并赋值的输入项的数目.若到达文件的末尾或在转换输入前出错,则返回 <code>EOF</code></p></li><li><p>格式串的组成</p><ul><li><p>空格和制表符</p></li><li><p>普通字符(除%),将与标准输入流的下一个空白字符进行匹配</p></li><li><p>转换说明: 决定下一个输入字符的转换方式.以<code>%</code>开头,转换字符结束.中间还可包含:</p><ol><li><code>*</code>: 赋值屏蔽字符.跳过对应的输入字段,不进行赋值</li><li><code>某个数值</code>: 指定最大字段宽度的数</li><li><code>h/l/L</code>: 指定目标字段宽度(类似 <code>printf</code> )</li></ol></li><li><p><code>scanf</code> 转换字符</p><table><thead><tr><th>转换字符</th><th>参数类型 &amp; 输入数据</th></tr></thead><tbody><tr><td>d</td><td>int *. 十进制整型数</td></tr><tr><td>i</td><td>int *. 整型数,可以为八进制(0开头)或十六进制(0x&#x2F;0X开头)</td></tr><tr><td>o</td><td>int *. 八进制整型数</td></tr><tr><td>u</td><td>unsigned int *. 无符号十进制整型数</td></tr><tr><td>x</td><td>int *. 十六进制整型数</td></tr><tr><td>c</td><td>char *. 根据字段宽度的大小(默认为1)将读取的字符保存到指定的数组中,不增加<code>&#39;\0&#39;</code><br />此时,读取输入将不会跳过空白符.若要读取下一非空白字符,可使用%1s</td></tr><tr><td>s</td><td>char *. 由非空白符组成的字符串(不包含引号).自动在数组末尾增加 <code>&#39;\0&#39;</code></td></tr><tr><td>e &#x2F; f &#x2F; g</td><td>float *. 浮点数的输入格式为: <code>$\pm$</code>(可选), 数字串(可能有小数), 指数字段(可选)</td></tr><tr><td>p</td><td>void *. 指针值</td></tr><tr><td>n</td><td>int *. 到目前为止,将 sacnf 读取的字符数目被写到相应的参数<br />不读取输入字符.不增加已转换的项目计数</td></tr><tr><td>[…]</td><td>char *.与方括号中的字符集合 匹配的输入字符中 最长的非空字符串<br /><code>[]...]</code> 表示集合中包含字符<code>]</code>. 自动在数组末尾增加 <code>&#39;\0&#39;</code></td></tr><tr><td>[^…]</td><td>char *.与方括号中的字符集合 <strong>不匹配</strong>的输入字符中 最长的非空字符串<br /><code>[^]...]</code> 表示集合中<strong>不包含</strong>字符<code>]</code>. 自动在数组末尾增加 <code>&#39;\0&#39;</code></td></tr><tr><td>%</td><td>表示 <code>%</code>,不进行赋值</td></tr></tbody></table></li></ul></li></ul></li></ol><h3 id="1-4-整型函数"><a href="#1-4-整型函数" class="headerlink" title="1.4 整型函数"></a>1.4 整型函数</h3><ol><li><p>算术(下列整型函数均声明于 <code>&lt;stdlib.h&gt;</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">abs</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">labs</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">int</span> value)</span>;<br><span class="hljs-type">div_t</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> numerator, <span class="hljs-type">int</span> denominator)</span>;<br><span class="hljs-type">ldiv_t</span> <span class="hljs-title function_">ldiv</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">int</span> numerator, <span class="hljs-type">long</span> <span class="hljs-type">int</span> denominator)</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>abs</code> 函数返回参数的绝对值, <code>labs</code> 函数处理的对象为 <code>long int</code> 类型</p></li><li><p><code>div</code> 函数进行带余整数除法,返回一个 <code>div_t</code> 的结构.包含两个字段:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> quot; <span class="hljs-comment">// 商</span><br><span class="hljs-type">int</span> rem;  <span class="hljs-comment">// 余数</span><br></code></pre></td></tr></table></figure></li><li><p><code>ldiv</code> 函数处理的对象为 <code>long int</code> 类型,而返回 <code>ldiv_t</code> 结构</p></li></ul></li><li><p>随机数</p><ul><li><p>用于产生伪随机数的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">rand</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">srand</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seed)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>rand</code> 返回一个范围在 0~RAND_MAX(至少为32767) 的伪随机数</p></li><li><p>可以用对 <code>rand</code> 返回值取模,然后加上一个偏移量的方式获取一个固定区间的随机数</p></li><li><p><code>srand</code> 函数可以设置随机数种子.根据参数对随机数发生器初始化</p></li><li><p>可以用时间作为随机数产生器的种子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">srand( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) time(<span class="hljs-number">0</span>) );<br></code></pre></td></tr></table></figure></li></ul></li><li><p>字符串转换</p><ul><li><p>字符串转换函数将 字符串转换为数值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">atoi</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>)</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">atol</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>)</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strtol</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">char</span> **unused, <span class="hljs-type">int</span> base)</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strtoul</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">char</span> **unused, <span class="hljs-type">int</span> base)</span>; <br><span class="hljs-type">double</span> <span class="hljs-title function_">atof</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">strtod</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">char</span> **unused)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>atoi,atol</code> 函数进行基数为10的转换</li><li><code>strtol,strtoul</code> 函数允许指定基数,还允许访问字符串的剩余部分</li><li>如果参数 <code>string</code> 中包含了前导空白字符 以及非法缀尾字符,将会被忽略</li><li>参数 <code>base</code> 的取值范围为 2<del>36,此时字母 A</del>Z 分别表示 10~35</li><li>特别的,当 <code>base</code> 的值为0时,表示接受 程序中任何可书写的整型字面值</li></ul></li><li><p><code>strol</code> 函数示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">x = strol(<span class="hljs-string">&quot;   590bear&quot;</span>, next, <span class="hljs-number">12</span>);<br></code></pre></td></tr></table></figure><ul><li>该指令的返回值为 9947,由于 e 在基数为12时非法,转换终止</li><li><code>next</code> 是一个指向指针的指针,指向的内容为: 指向字母 e 的指针</li></ul></li><li><p>如果参数 <code>string</code> 中不包含任何一个合法数值,返回0</p></li><li><p>如果被转换的值无法表示,函数将在 <code>errno</code> 中存储值 <code>ERANGE</code>.并返回下表中的一个值</p><table><thead><tr><th>函数</th><th>返回值</th></tr></thead><tbody><tr><td>strol</td><td>若值过大且为负,返回 <code>LONG_MIN</code>. 若值过大且为正,返回 <code>LONG_MAX</code></td></tr><tr><td>stroul</td><td>若值过大,返回 <code>ULONG_MAX</code></td></tr></tbody></table></li></ul></li></ol><h3 id="1-5-浮点型函数"><a href="#1-5-浮点型函数" class="headerlink" title="1.5 浮点型函数"></a>1.5 浮点型函数</h3><ul><li>下列函数声明于 <code>&lt;math.h&gt;</code>.绝大多数的参数和返回值类型为 <code>double</code></li><li>若函数的参数不在定义域内,出现<code>定义域错误</code>.函数返回一个由编译器提供的错误值,并置 <code>errno</code> 值为 <code>EDOM</code></li><li>若函数的结果值过大&#x2F;小,超出 <code>double</code> 的范围,出现返回错误.<ul><li>若过大,函数返回 <code>HUGE_VAL</code>(在<code>math.h</code>中定义)</li><li>若过小,函数返回 0,事实上也是范围错误</li></ul></li></ul><ol><li><p>三角函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 参数为弧度制的角度值 */</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">sin</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">cos</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">tan</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><br><span class="hljs-comment">/* 返回值为弧度制的角度值 */</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">asin</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">acos</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">atan</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span>;<br><br><span class="hljs-comment">/* 返回值为 y/x 的反正切值,利用参数的符号决定象限 */</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">atan2</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br></code></pre></td></tr></table></figure></li><li><p>双曲函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 参数为弧度制的角度值 */</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">sinh</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">cosh</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">tanh</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br></code></pre></td></tr></table></figure></li><li><p>对数和指数函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">exp</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">log</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">log10</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>exp</code> 返回 $e^x$</li><li><code>log</code> 返回 $\mathrm{ln}x$</li><li><code>log10</code> 返回 $\mathrm{log}_{10} x$</li><li>利用换底公式 $\mathrm{log}_b x&#x3D;\frac{\mathrm{ln} x}{\mathrm{ln} b}$ 计算任意底数的对数</li></ul></li><li><p>浮点表示形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">frexp</span><span class="hljs-params">(<span class="hljs-type">double</span> value, <span class="hljs-type">int</span> *exponent)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">ldexp</span><span class="hljs-params">(<span class="hljs-type">double</span> fraction, <span class="hljs-type">int</span> exponent)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">modf</span><span class="hljs-params">(<span class="hljs-type">double</span> value, <span class="hljs-type">double</span> *ipart)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>frexp</code> 函数返回值 <code>fraction</code>,取值范围为 [0.5, 1).满足 $\mathrm{fraction}\cdot2^\mathrm{exponent} &#x3D; \mathrm{value}$</li><li><code>ldexp</code> 函数相对地返回 <code>value</code>: $\mathrm{value}&#x3D;\mathrm{fraction}\cdot2^\mathrm{exponent}$</li><li><code>modf</code> 函数将浮点值分成整数和小数两部分,它们拥有与原值相同的符号</li></ul></li><li><p>幂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">pow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>pow</code> 函数返回 $x^y$. 计算时可能会用到对数</li><li><code>sqrt</code> 函数返回 $\sqrt{x}$</li></ul></li><li><p>底数,顶数,绝对值,余数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">floor</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">ceil</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">fabs</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">fmod</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>floor</code> 函数返回不大于参数的最大整数值,即向下取整</li><li><code>ceil</code> 函数返回不小于参数的最小整数值,即向上取整</li><li><code>fabs</code> 函数返回参数的绝对值</li><li><code>fmod</code> 函数返回 x&#x2F;y 的余数,符号与 x 相同</li></ul></li></ol><h3 id="1-6-日期和时间函数"><a href="#1-6-日期和时间函数" class="headerlink" title="1.6 日期和时间函数"></a>1.6 日期和时间函数</h3><ol><li><p>处理器时间(下列时间&#x2F;日期函数均声明于 <code>&lt;time.h&gt;</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">clock_t</span> <span class="hljs-title function_">clock</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>clock</code> 函数返回程序开始起处理去所消耗的时间,可能是个近似值</li><li>若需要精确时间,可在<code>main</code>函数开始调用一次<code>clock</code>,随后的调用进行减法来获取时间</li><li>若时间值过大,或机器无法获得时间,返回 -1</li><li><code>clock</code> 函数返回的数字由编译器定义,一般为处理器时钟滴答的次数</li><li>若需要将返回值换算成秒,应将其除以 <code>CLOCKS_PER_SEC</code></li></ul></li><li><p>当天时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">time_t</span> <span class="hljs-title function_">time</span><span class="hljs-params">(<span class="hljs-type">time_t</span> *returned_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>若参数为非NULL指针,则时间值将通过这个指针存储</li><li>若时间值太大,或机器无法提供日期和时间,返回 -1</li><li>标准并未规定时间的编码方式,因此不应使用字面值常量</li></ul></li><li><p>日期和时间的转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">ctime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> <span class="hljs-type">const</span> *time_value)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">difftime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> time1, <span class="hljs-type">time_t</span> time2)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>ctime</code> 函数的参数为 指向 <code>time_t</code> 的指针,返回一个指向字符串的指针<ul><li>返回的字符串格式为: <code>Sun Jul 4 04:02:48 1976\n\0</code></li><li>字符串内部的空格是固定的</li></ul></li><li><code>difftime</code> 函数计算 <code>time2 - time1</code> 的值,并将结果转换为秒</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> tm *<span class="hljs-title function_">gmtime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> <span class="hljs-type">const</span> *time_value)</span>;<br><span class="hljs-keyword">struct</span> tm *<span class="hljs-title function_">localtime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> <span class="hljs-type">const</span> *time_value)</span>;<br></code></pre></td></tr></table></figure></li><li><p>将一个 <code>time_t</code> 的值转换为一个 <code>tm</code> 结构,可以方便地访问各组成部分</p><ul><li><p><code>gmtime</code> 函数转换为世界协调时间</p></li><li><p><code>localtime</code> 函数转换为当地时间</p></li><li><p><code>tm</code> 结构的字段</p><table><thead><tr><th>类型 &amp; 名称</th><th>范围</th><th>含义</th></tr></thead><tbody><tr><td><code>int tm_sec</code></td><td>0~61</td><td>分之后的秒数</td></tr><tr><td><code>int tm_min</code></td><td>0~59</td><td>小时后的分数</td></tr><tr><td><code>int tm_hour</code></td><td>0~23</td><td>午夜后的小时数</td></tr><tr><td><code>int tm_mday</code></td><td>1~31</td><td>当月的日期</td></tr><tr><td><code>int tm_mon</code></td><td>0~11</td><td>1月后的月数</td></tr><tr><td><code>int tm_year</code></td><td>0~?</td><td>1900年后的年数</td></tr><tr><td><code>int tm_wday</code></td><td>0~6</td><td>星期天之后的天数</td></tr><tr><td><code>int tm_yday</code></td><td>0~365</td><td>1月1日后的天数</td></tr><tr><td><code>int tm_isdat</code></td><td></td><td>夏令时标志</td></tr></tbody></table></li></ul></li><li><p>将 <code>tm</code> 结构转换为字符串格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">asctime</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tm <span class="hljs-type">const</span> *tm_ptr)</span>;<br><span class="hljs-type">size_t</span> <span class="hljs-title function_">strftime</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">size_t</span> maxsize, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *format, <span class="hljs-keyword">struct</span> tm <span class="hljs-type">const</span> *tm_str)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>asctime</code> 转换为字符串的格式与 <code>ctime</code> 一致</p><ul><li><p><code>strftime</code> 格式化的非常灵活</p></li><li><p>若转换的结果字符串长度小于 <code>maxsize</code>,则该字符串将被复制到 <code>string</code> 中</p></li><li><p><code>strftime</code> 的返回值为字符串的长度.若返回的是 -1,则 <code>string</code> 内容未定义</p></li><li><p><code>strftime</code> 格式代码</p><table><thead><tr><th>代码</th><th>被…替代</th></tr></thead><tbody><tr><td>%%</td><td><code>%</code></td></tr><tr><td>%a(%A)</td><td>星期中的某天,用当地的简写(全写)表示</td></tr><tr><td>%b(%B)</td><td>月份,用当地的简写(全写)表示</td></tr><tr><td>%c</td><td>日期和时间,使用 <code>%x %X</code></td></tr><tr><td>%d</td><td>月份中的某天(01~31)</td></tr><tr><td>%H</td><td>小时,24小时制(00~23)</td></tr><tr><td>%I</td><td>小时,12小时制(00~12)</td></tr><tr><td>%J</td><td>一年中的某天(001~366)</td></tr><tr><td>%m</td><td>月份(01~12)</td></tr><tr><td>%M</td><td>分钟(00~59)</td></tr><tr><td>%P</td><td>AM&#x2F;PM</td></tr><tr><td>%S</td><td>秒(00~61)</td></tr><tr><td>%U(%W)</td><td>一年中的第几个星期(00~53),以星期日&#x2F;星期一为第一天</td></tr><tr><td>%w</td><td>一星期的第几天,星期日为 0</td></tr><tr><td>%x(%X)</td><td>日期&#x2F;时间,本地格式</td></tr><tr><td>%y(%Y)</td><td>当前世纪的年份(00~99)&#x2F;年份的全写(如2023)</td></tr><tr><td>%z</td><td>时区的简写,无法判断时为空</td></tr></tbody></table></li></ul></li><li><p>将 <code>tm</code> 结构转化为 <code>time_t</code> 值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">time_t</span> <span class="hljs-title function_">mktime</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tm *tm_ptr)</span>;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-7-排序和查找"><a href="#1-7-排序和查找" class="headerlink" title="1.7 排序和查找"></a>1.7 排序和查找</h3><ol><li><p>排序 <code>&lt;stdlib.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">qsort</span><span class="hljs-params">(<span class="hljs-type">void</span> *base, <span class="hljs-type">size_t</span> n_elements, <span class="hljs-type">size_t</span> el_size, \</span><br><span class="hljs-params">           <span class="hljs-type">int</span> (*compare)(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *) )</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>qsort</code> 函数是类型无关的,对任意数据类型的,固定长度的数组进行升序排序</p></li><li><p><code>base</code> 参数: 指向待排序的数组</p></li><li><p><code>n_elements</code> 参数: 指定数组中的元素数目</p></li><li><p><code>el_size</code> 参数: 指定每个元素的长度(单位为 字符)</p></li><li><p><code>compare</code> 是一个函数指针,对需要排序的元素类型进行比较.在排序时,调用该函数进行大小比较</p></li><li><p>比较函数接受2个参数,指向待比较的值.返回一个整数,表示参数的大小关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">// 定义一个结构,根据 key 排序</span><br> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>     <span class="hljs-type">char</span> key[<span class="hljs-number">10</span>];<br>     <span class="hljs-type">int</span> otherData;<br> &#125; Record;<br><br><span class="hljs-comment">// 比较函数,直接返回 strcmp 的计算结果</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">recordCompare</span><span class="hljs-params">(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *a, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *b)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>( (Record *)a-&gt;key, (Record *)b-&gt;key );<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Record <span class="hljs-built_in">array</span>[<span class="hljs-number">50</span>];<br>    qsort(<span class="hljs-built_in">array</span>, <span class="hljs-number">50</span>, <span class="hljs-keyword">sizeof</span>(Record), recordCompare);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>二分查找 <code>&lt;stdlib.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">bsearch</span><span class="hljs-params">(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *key, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *base, <span class="hljs-type">size_t</span> n_elements,\</span><br><span class="hljs-params">             <span class="hljs-type">size_t</span> el_size, <span class="hljs-type">int</span> (*compare)(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *) )</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>key</code> 参数: 待查找的值,必须和目标数组元素的类型相同</p></li><li><p><code>base</code> 参数: 指向目标数组</p></li><li><p><code>n_elements</code> 参数: 数组的元素数目</p></li><li><p><code>el_size</code> 参数: 每个元素的长度(以字符为单位)</p></li><li><p><code>compare</code> 参数: 指向比较参数.与 <code>qsort</code> 函数相同</p></li><li><p><code>bsearch</code> 函数: 返回一个指针,指向查找到的数组元素.若不存在,返回 <code>NULL</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">// 定义一个结构,根据 key 排序</span><br> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>     <span class="hljs-type">char</span> key[<span class="hljs-number">10</span>];<br>     <span class="hljs-type">int</span> otherData;<br> &#125; Record;<br><br><span class="hljs-comment">// 比较函数,直接返回 strcmp 的计算结果</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">recordCompare</span><span class="hljs-params">(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *a, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *b)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>( (Record *)a-&gt;key, (Record *)b-&gt;key );<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Record <span class="hljs-built_in">array</span>[<span class="hljs-number">50</span>];<br>    Record key; <span class="hljs-comment">// 待查找的对象</span><br>    Record *ans;<br>    <br>    <span class="hljs-built_in">strcpy</span>(key.key, <span class="hljs-string">&quot;value&quot;</span>); <span class="hljs-comment">// 比较函数中用到的 key 字段必须填充</span><br>    qsort(<span class="hljs-built_in">array</span>, <span class="hljs-number">50</span>, <span class="hljs-keyword">sizeof</span>(Record), recordCompare); <span class="hljs-comment">// 注意: 二分查找需要先排序</span><br>    ans = bsearch(&amp;key, <span class="hljs-built_in">array</span>, <span class="hljs-number">50</span>, <span class="hljs-keyword">sizeof</span>(Record, recordCompare));<br>    <span class="hljs-comment">/* 现在 ans指向查找到的目标 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-8-信号"><a href="#1-8-信号" class="headerlink" title="1.8 信号"></a>1.8 信号</h3><ol><li><p>信号</p><ul><li>程序中绝大部分事件由其本身引发.但对于外部中断等事件,程序需要预备对这类时间作出反应</li><li><strong>信号表示一种事件,可能会异步发生.程序可设置一个信号处理函数,当信号发生,就调用它</strong></li><li>下面的函数位于 <code>&lt;signal.h&gt;</code></li></ul></li><li><p>信号名</p><table><thead><tr><th>信号</th><th>含义</th></tr></thead><tbody><tr><td>SIGABRT</td><td>程序请求异常终止</td></tr><tr><td>SIGFPE</td><td>发生一个算术错误</td></tr><tr><td>SIGILL</td><td>检测到非法指令</td></tr><tr><td>SIGSEGV</td><td>检测到对内存的非法访问</td></tr><tr><td>SIGINT</td><td>收到一个交互性注意信号</td></tr><tr><td>SIGTERM</td><td>收到一个终止程序的请求</td></tr></tbody></table><ul><li><code>SIGABRT</code> 是由 <code>abort</code> 函数引发的信号,用于终止程序</li><li><code>SIGILL</code> 提示 CPU 试图执行一条非法指令</li><li><code>SIGINT</code> 和 <code>SIGTERM</code> 是异步的,由程序外部产生</li></ul></li><li><p>处理信号</p><ul><li><p>显式的引发一个信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">raise</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span>;<br></code></pre></td></tr></table></figure></li><li><p>当一个信号发生时,程序可以有3种反应: 缺省方式(终止程序); 将其忽略; 设置信号处理函数对其反应</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*signal(<span class="hljs-type">int</span> sig, <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">int</span>))) (<span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><ul><li><code>signal</code> 是一个函数.返回一个函数指针,指向一个参数为 <code>int</code> 的无返回值函数</li><li><code>sig</code> 参数是<code>信号名</code>中列举的信号之一</li><li><code>handler</code> 参数是希望为该信号设置的处理函数,是一个函数指针,指向一个参数为 <code>int</code> 的无返回值函数</li><li>当信号发生时,信号的代码作为参数传递给 <code>handler</code> 指向的信号处理函数</li><li><code>signal</code> 返回一个指向该信号以前的处理函数的指针</li><li><code>signal.h</code> 定义了宏 <code>SIG_DFL, SIG_IGN</code>,可作为 <code>handler</code> 参数的值.分别表示缺省处理&#x2F;忽略信号</li></ul></li></ul></li><li><p>信号处理函数</p><ul><li>当一个已设置的信号处理函数的信号发生时,系统恢复对该信号的缺省行为(防止处理函数内部再次发生该信号而引起无限循环),然后,信号处理函数被调用,信号代码作为参数传入</li><li>信号处理函数可能执行的工作非常有限.对于异步信号,不应调用除 <code>signal.h</code> 以外的库函数</li><li>信号处理函数仅能向一个类型为 <code>volatile sig_atomic_t</code> 的静态变量赋值,其他静态数据可能无法访问</li><li>从一个信号处理函数返回,将导致执行流从信号发生的地点恢复执行(除了<code>SIGFPE</code>,无法完成计算)</li><li>若希望将来再次捕获同类型信号,需要在处理函数返回前,调用 <code>signal</code> 函数进行设置</li></ul></li></ol><h3 id="1-9-非本地跳转"><a href="#1-9-非本地跳转" class="headerlink" title="1.9 非本地跳转"></a>1.9 非本地跳转</h3><ol><li><p>类似于 <code>goto</code> 语句,但作用域并非局限于函数作用域</p></li><li><p>需要包含头文件 <code>&lt;setjump.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">setjump</span><span class="hljs-params">(jmp_buf state)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">longjump</span><span class="hljs-params">(jmp_buf state, <span class="hljs-type">int</span> value)</span>;<br></code></pre></td></tr></table></figure><ul><li>调用方式: 声明一个 <code>jmp_buf</code> 变量,使用 <code>setjump</code> 函数进行初始化,返回值为0</li><li><code>setjump</code> 会将程序信息保存到缓冲区.调用 <code>sejump</code> 时所处的函数成为 <code>顶层函数</code></li><li>在<code>顶层函数</code>或其他被它调用的函数处 调用 <code>longjump</code> 时,被保存的程序信息将会恢复.跳回 <code>顶层函数</code></li><li>当 <code>setjump</code> 函数第一次被调用返回0.当 <code>setjump</code> 作为 <code>longjump</code> 的执行结果时,返回 <code>value</code></li></ul></li></ol><h3 id="1-10-执行环境"><a href="#1-10-执行环境" class="headerlink" title="1.10 执行环境"></a>1.10 执行环境</h3><ol><li><p>终止执行 <code>&lt;stdlib.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">atexit</span><span class="hljs-params">(<span class="hljs-type">void</span> (func)(<span class="hljs-type">void</span>))</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>abort</code> 函数用于不正常地终止一个正在执行的程序.它将引发 <code>SIGABRT</code>,可为它设置信号处理函数</li><li><code>atexit</code> 函数可将一些函数注册为 <code>退出函数</code>.当程序要正常终止时,退出函数将被调用</li><li><strong><code>exit</code> 函数用于正常终止程序.当它被调用时,所有被 <code>atexit</code> 注册为退出函数按被注册顺序逆序依次调用.然后所有用于流的缓冲区被刷新,所有打开的文件被关闭,用<code>tempfile</code>函数创建的文件被删除.退出状态返回给宿主环境.程序停止执行</strong></li><li><code>exit</code> 函数的<code>status</code> 参数将会返回给操作系统</li><li><code>exit</code> 函数没有返回值: 当 <code>exit</code> 结束时,程序已经消失,它已无处可返</li></ul></li><li><p><strong>断言: 声明某事应该为真</strong> <code>&lt;assert.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">assert</span><span class="hljs-params">(<span class="hljs-type">int</span> expression)</span>; <span class="hljs-comment">// 实际上这是不是函数,而是一个宏</span><br><span class="hljs-comment">/* expression 若为假,向标准错误打印一条诊断信息并终止程序.若为真,程序继续执行 */</span><br></code></pre></td></tr></table></figure></li><li><p>断言一般用于程序调试.当程序被完整地测试完毕,可在包含头文件 <code>aseert.h</code> 之前增加:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDEBUG</span><br><span class="hljs-comment">/* 定义了 NDEBUG 之后,预处理将丢弃所有的断言,而不必在源文件中实际将其删除 */</span><br></code></pre></td></tr></table></figure></li><li><p>执行系统命令 <code>&lt;stdlib.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">system</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *command)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>system</code> 函数将字符串参数传递给宿主操作系统</li><li><code>system</code> 函数可用 <code>NULL</code> 参数进行调用,用于询问命令处理器是否存在.若存在,返回一个非零值</li></ul></li></ol><h2 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2 内存管理"></a>2 内存管理</h2><h3 id="2-1-C-语言内存布局"><a href="#2-1-C-语言内存布局" class="headerlink" title="2.1 C 语言内存布局"></a>2.1 C 语言内存布局</h3><ol><li><p>C 程序在运行时,内存分为以下几个主要区域(Segments)</p><table><thead><tr><th align="left"><strong>内存区域</strong></th><th align="left"><strong>存储内容</strong></th><th align="left"><strong>特点</strong></th></tr></thead><tbody><tr><td align="left"><strong>代码段(Text)</strong></td><td align="left">存放编译后的机器指令(二进制代码)</td><td align="left">只读.程序运行时不可修改</td></tr><tr><td align="left"><strong>数据段(Data)</strong></td><td align="left"><strong>已初始化全局变量 &amp; 静态变量</strong></td><td align="left">程序启动时分配.生命周期直到程序结束</td></tr><tr><td align="left"><strong>BSS 段(BSS)</strong></td><td align="left"><strong>未初始化全局变量 &amp; 静态变量</strong></td><td align="left">程序启动时清零.生命周期直到程序结束</td></tr><tr><td align="left"><strong>堆(Heap)</strong></td><td align="left">动态分配(<code>malloc, calloc, realloc, free</code>)</td><td align="left">手动管理.增长方向从低地址向高地址</td></tr><tr><td align="left"><strong>栈(Stack)</strong></td><td align="left">局部变量,函数参数,返回地址等</td><td align="left">自动管理(函数调用时入栈,返回时出栈).<br />增长方向从高地址向低地址,大小有限</td></tr></tbody></table></li><li><p>内存布局图示(Linux 64bit)</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss">高地址<br>┌─────────────────────┐<br>│        Stack        │ ← 由高地址向低地址增长<br>├─────────────────────┤<br>│          ↓          │<br>│          ↑          │<br>├─────────────────────┤<br>│        Heap         │ ← 由低地址向高地址增长<br>├─────────────────────┤<br>│        BSS          │ (未初始化全局变量)<br>├─────────────────────┤<br>│        Data         │ (已初始化全局变量)<br>├─────────────────────┤<br>│        <span class="hljs-selector-tag">Text</span>         │ (程序指令)<br>低地址<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-动态内存分配"><a href="#2-2-动态内存分配" class="headerlink" title="2.2  动态内存分配"></a>2.2  动态内存分配</h3><ol><li><p>需要使用到 <code>&lt;stdlib.h&gt;</code> 头文件中的库函数</p><ul><li><code>malloc</code>:   申请动态空间内存</li><li><code>free</code>:       释放动态空间内存</li><li><code>calloc</code>:   申请并初始化一系列内存</li><li><code>realloc</code>:  重新分配内存空间</li></ul></li><li><p><code>malloc</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;              <span class="hljs-comment">// malloc 函数原型</span><br><span class="hljs-type">int</span> *ptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));  <span class="hljs-comment">// 申请内存而不初始化</span><br></code></pre></td></tr></table></figure><ul><li><code>malloc</code> 向系统申请分配 <code>size</code> 个字节的内存空间,返回一个指向该空间的指针</li><li>申请的内存空间不会被初始化</li><li>调用成功返回一个申请的内存空间指针,类型为 <code>void *</code></li><li>调用失败返回 <code>NULL</code>.若设置 <code>size = 0</code>,同样返回 <code>NULL</code></li></ul></li><li><p><code>calloc</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> nmemb, <span class="hljs-type">size_t</span> size)</span>;   <span class="hljs-comment">// calloc 函数原型</span><br><span class="hljs-type">int</span> *ptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">8</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));  <span class="hljs-comment">// 申请内存并初始化为0</span><br></code></pre></td></tr></table></figure><ul><li><code>calloc</code> 在内存中动态的申请 <code>nmemb</code> 个长度为 <code>size</code> 的连续内存空间,并全部初始化为0</li><li>如果调用成功,返回指向申请内存的指针</li><li>调用失败返回 <code>NULL</code>.参数为 0 时也会返回 <code>NULL</code></li></ul></li><li><p><code>realloc</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size)</span>;                <span class="hljs-comment">// realloc 函数原型</span><br><span class="hljs-type">int</span> *ptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">realloc</span>(ptr, count * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));  <span class="hljs-comment">// 重新分配内存</span><br></code></pre></td></tr></table></figure><ul><li>可以增大或减小已分配内存的大小</li><li>其实现通常为新分配内存,然后复制内容,最后释放原内存.注意新内存仍不会初始化</li><li><code>ptr</code> 指向先前分配的内存空间.当参数 <code>ptr==NULL</code> 时,等同于调用 <code>malloc</code></li></ul></li><li><p><code>free</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span>;  <span class="hljs-comment">// free 函数原型</span><br><span class="hljs-built_in">free</span>(ptr);             <span class="hljs-comment">// 释放空间</span><br></code></pre></td></tr></table></figure><ul><li><code>free</code> 释放的内存空间必须是由 <code>malloc, calloc, realloc</code> 函数申请.否则会导致未定义行为</li><li>若参数 <code>ptr==NULL</code>,则不执行任何操作.多次对同一指针调用 <code>free</code>,将导致未定义行为</li><li><code>free</code> 函数不改变参数 <code>ptr</code> 的值.为避免悬空指针,释放空间后需将指针的值置为 <code>NULL</code></li></ul></li></ol><h3 id="2-3-动态内存管理"><a href="#2-3-动态内存管理" class="headerlink" title="2.3 动态内存管理"></a>2.3 动态内存管理</h3><ol><li><p>内存泄漏</p><ul><li>C 语言不具备垃圾回收机制,需要手动释放内存</li><li><code>malloc</code> 和 <code>free</code> 应该成对编写</li></ul></li><li><p>申请任意尺寸的内存空间</p><ul><li><p><code>malloc</code> 可以申请任意尺寸的内存空间.得到的空间是连续的,经常使用数组索引</p></li><li><p>初始化申请的内存空间有专门的库函数,声明于 <code>&lt;string.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">memset</span>(ptr, <span class="hljs-number">0</span>, num * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></table></figure><ul><li><code>memset</code>: 使用一个常量字节填充内存空间</li><li><code>memcpy</code>: 复制内存空间</li><li><code>memmove</code>: 复制内存空间</li><li><code>memcmp</code>: 比较内存空间</li><li><code>memchr</code>: 在内存空间中搜索一个字符</li></ul></li><li><p>与字符串处理函数相似,且开头的 <code>mem</code> 即表示内存</p></li></ul></li><li><p>内存池</p><ul><li>频繁使用 <code>malloc</code> 和 <code>free</code> 手动分配和释放内存很容易产生大量的内存碎片</li><li>调用 <code>malloc</code> 函数向操作系统申请堆内存经历了从应用层切入系统内核层的过程.造成时间浪费</li><li>内存池: 让程序额外维护一个缓存区域.当一块内存将要释放时,不调用 <code>free</code>,而将其放入内存池,下次需要分配内存空间时直接从内存池中获取</li></ul></li><li><p>内存池的维护方式</p><ul><li>当用户申请一个内存块时,先在内存池中查找是否有合适的内存块<ul><li>若有: 则直接从内存池中取出使用</li><li>若无: 调用 <code>malloc</code> 函数申请</li></ul></li><li>当用户释放一个内存块时,先检查内存池是否已满<ul><li>不满: 则将指向内存块的指针存放到内存池</li><li>已满: 调用 <code>free</code> 函数释放</li></ul></li></ul></li><li><p>内存池实现思路</p><ul><li>使用单链表维护一个简单的内存池<ul><li>将没用到的内存空间地址用单链表记录</li><li>需要使用时从单链表获取</li></ul></li></ul></li></ol><h2 id="3-文件-IO"><a href="#3-文件-IO" class="headerlink" title="3 文件 IO"></a>3 文件 IO</h2><h3 id="3-1-打开和关闭文件"><a href="#3-1-打开和关闭文件" class="headerlink" title="3.1 打开和关闭文件"></a>3.1 打开和关闭文件</h3><ol><li><p><code>fopen</code>: 打开一个文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *<span class="hljs-title function_">fopen</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode )</span>;  <span class="hljs-comment">// fopen 函数原型</span><br><span class="hljs-comment">/* filename: 指定将要打开的文件路径以及文件名</span><br><span class="hljs-comment">** mode: 指定文件的打开模式 */</span><br></code></pre></td></tr></table></figure><ul><li><p>调用成功返回一个指向 <code>FILE</code> 结构的文件指针.通过该指针对文件进行操作.失败返回 <code>NULL</code></p></li><li><p>打开模式</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>“r”</td><td>只读模式打开;  从文件头读取;  该文本文件必须存在</td></tr><tr><td>“w”</td><td>只写模式打开;  从文件头写入;  文本不存在时则先创建;  重新写入内容会覆盖所有内容</td></tr><tr><td>“a”</td><td>追加模式打开;  从文件末追加;  文本不存在时则先创建</td></tr><tr><td>“r+”</td><td>读写模式打开;  从文件头读写;  该文本文件必须存在; 只覆盖重写入内容,原有内容保留</td></tr><tr><td>“w+”</td><td>读写模式打开;  从文件头读写;  文本不存在时则先创建; 重新写入内容会覆盖所有内容</td></tr><tr><td>“a+”</td><td>读和追加模式打开;  读从头开始,写从末尾追加;  文本不存在时则先创建</td></tr><tr><td>b</td><td>可与以上6种模式结合(如 “rb, “r+b”); 含义相同,但操作对象为二进制文件</td></tr></tbody></table></li></ul></li><li><p><code>fclose</code> 函数: 关闭一个文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fclose</span><span class="hljs-params">( FILE *fp )</span>;  <span class="hljs-comment">// fclose 函数原型</span><br><span class="hljs-comment">/* fp: 使用 fopen 获取的文件指针</span><br><span class="hljs-comment">** 调用成功返回0,失败返回 EOF</span><br><span class="hljs-comment">** 调用 fopen 后系统才会将缓冲区的数据写入文件,并释放该文件的相关资源*/</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-2-顺序读写文件"><a href="#3-2-顺序读写文件" class="headerlink" title="3.2 顺序读写文件"></a>3.2 顺序读写文件</h3><ol><li><p>读取单个字符(下列函数均声明于 <code>&lt;stdio.h&gt;</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fgetc, getc 函数: 从文件流中读取下一个字符,并推进文件的位置指示器 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fgetc</span><span class="hljs-params">(FILE *stream)</span>;  <span class="hljs-comment">// 函数原型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getc</span><span class="hljs-params">(FILE *stream)</span>;   <span class="hljs-comment">// 通常实现为宏</span><br><span class="hljs-comment">/* stream: 指向一个待读取的文件流 */</span><br></code></pre></td></tr></table></figure></li><li><p>写入单个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fputc, putc 函数: 向文件流写入单个字符 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *stream)</span>;  <span class="hljs-comment">// 函数原型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *stream)</span>;   <span class="hljs-comment">// 通常实现为宏</span><br><span class="hljs-comment">/* c: 待写入的字符</span><br><span class="hljs-comment">** stream: 指向一个待写入的文件流</span><br><span class="hljs-comment">** 返回值: 遇到错误或文件结束时返回 EOF.否则返回已写入的字符本身 */</span><br></code></pre></td></tr></table></figure></li><li><p>读取字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fgets 函数: 从指定的文件中读取字符串 */</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> size, FILE *stream)</span>;<br><span class="hljs-comment">/* s: 指向存放读取得到字符串的位置</span><br><span class="hljs-comment">** size: 指定读取的字符数(包括自动添加的 &#x27;\0&#x27;).想读取10个字符,应令 size = 11</span><br><span class="hljs-comment">** stream: 指定一个待操作的数据流</span><br><span class="hljs-comment">** 返回值: 调用成功,返回 s 指向的地址.若发生错误,返回 NULL</span><br><span class="hljs-comment">** 当遇到换行符 &#x27;\n&#x27; 就会停止本次字符串的读取</span><br><span class="hljs-comment">** 注意 gets 函数不安全,已被 C99 弃用并从 C11 除名 */</span><br></code></pre></td></tr></table></figure></li><li><p>写入字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fputs 函数: 将字符串写入到指定的文件中,结尾的 &#x27;\0&#x27; 不会被写入 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, FILE *stream)</span>;<br><span class="hljs-comment">/* s: 指向存放待写入字符串的位置</span><br><span class="hljs-comment">** stream: 指定一个待操作的数据流 */</span><br><br><span class="hljs-comment">/* puts 函数: 将字符串写入 stdout 并自动追加换行符.方便打印消息 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">puts</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;<br></code></pre></td></tr></table></figure></li><li><p>格式化读写文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fscanf 函数: f 表示 file,对文件进行读取 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fscanf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br><br><span class="hljs-comment">/* fprintf 函数: f 表示 file,对文件进行写入 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br></code></pre></td></tr></table></figure></li><li><p>二进制读写文件</p><ul><li><code>fopen</code> 函数可以指定文件的打开模式(文本, 二进制).但后续对文件的操作并不一定是对应的形式</li><li>无论以哪种模式打开文件,都不能决定写入数据的形式.它们只是影响换行符的表现形式.</li><li>真正决定数据写入模式的是 相关的文件读写函数</li></ul></li><li><p><code>fread</code> 函数: 从指定文件中读取指定尺寸的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">fread</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span>;<br><span class="hljs-comment">/* ptr:指向存放数据的内存块地址</span><br><span class="hljs-comment">** size:待读取的每个元素的尺寸 </span><br><span class="hljs-comment">** nmemb:指定待读取的元素个数</span><br><span class="hljs-comment">** stream:指向一个待读取的文件流</span><br><span class="hljs-comment">** 返回值:   调用成功返回实际读取到的元素个数,即 nmemb</span><br><span class="hljs-comment">** 如果返回值小于 nmemb,说明读取到文件末尾或发生错误 */</span><br></code></pre></td></tr></table></figure></li><li><p><code>fwrite</code> 函数: 将指定数据写入到指定文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">fwrite</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span>;<br><span class="hljs-comment">/* ptr:指向存放数据的内存块地址</span><br><span class="hljs-comment">** size:待写入的每个元素的尺寸</span><br><span class="hljs-comment">** nmemb:指定待写入的元素个数</span><br><span class="hljs-comment">** stream:指向一个待写入的文件流 */</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-3-随机读写文件"><a href="#3-3-随机读写文件" class="headerlink" title="3.3 随机读写文件"></a>3.3 随机读写文件</h3><ol><li><p>系统为每个打开的文件设置了一个位置指示器,用于表示当前的读写位置</p></li><li><p><code>ftell</code> 函数: 返回当前的读写位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">ftell</span><span class="hljs-params">(FILE *stream)</span>;<br><span class="hljs-comment">/* stream: 指定待操作的文件流</span><br><span class="hljs-comment">** 返回值: 指定文件的当前读写位置</span><br><span class="hljs-comment">** 如果将文件看作一个数组,那么 ftell 的返回值就是&quot;数组&quot;的下标 */</span><br></code></pre></td></tr></table></figure></li><li><p><code>fseek</code> 函数: 设置文件位置指示器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">long</span> <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> whence)</span>;<br><span class="hljs-comment">/* stream: 指定待操作的文件流</span><br><span class="hljs-comment">** offset: 指定偏移的字节数量</span><br><span class="hljs-comment">** whence: 指定开始偏移的位置 */</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>whence 的值</th><th>描述</th></tr></thead><tbody><tr><td>SEEK_SET</td><td>文件开头</td></tr><tr><td>SEEK_CUR</td><td>当前位置</td></tr><tr><td>SEEK_END</td><td>文件末尾</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">fseek(fp, <span class="hljs-number">100</span>, SEEK_SET);<span class="hljs-comment">// 定位到文件的第100字节位置</span><br>fseek(fp, <span class="hljs-number">-5</span>, SEEK_END);<span class="hljs-comment">// 定位到文件的倒数第5个字节位置</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>fseek</code> 需要考虑可移植性</p><ul><li>不同操作系统对换行符的处理不同,导致定位会出现误差</li><li>对于二进制模式打开的文件, <code>fseek</code> 在某些操作系统中可能不支持 SEEK_END</li><li>对于文本模式打开的文件, <code>whence</code> 参数只有取 SEEK_SET 才有意义.传递给 offset 的参数值要么为 0,要么是上一次对同一文件调用 <code>ftell</code> 函数获得的返回值</li></ul></li></ol><h3 id="3-4-标准流"><a href="#3-4-标准流" class="headerlink" title="3.4 标准流"></a>3.4 标准流</h3><ol><li><p>标准 输入 &#x2F; 输出 &#x2F; 错误输出</p><ul><li><p>当一个程序被执行时, C 语言自动为其打开3个面向终端的文件流(在 <code>&lt;stdio.h&gt;</code> 中声明)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stdin</span>;   <span class="hljs-comment">// 标准输入(standard input)</span><br><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stdout</span>;  <span class="hljs-comment">// 标准输出(standard output)</span><br><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stderr</span>;  <span class="hljs-comment">// 标准错误输出(standard error output)</span><br></code></pre></td></tr></table></figure></li><li><p>C 语言对应提供3种文件指针: <code>stdin, stdout, stderr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 若打开文件失败,则输出 &quot;打开文件失败\n&quot;,并退出 */</span><br>FILE *fp;<br><span class="hljs-keyword">if</span>((fp = open(<span class="hljs-string">&quot;nonexistent.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>)) == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;打开文件失败\n&quot;</span>, <span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT FALLURE);<br>&#125;<br>fclose(fp);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>错误处理</p><ul><li><p>每个流对象内部都有2个指示器</p><ul><li><p><strong>文件结束指示器</strong>: 遇到文件末尾时被设置</p></li><li><p><strong>错误指示器</strong>: 当读写文件出错时被设置</p></li><li><p>使用 <code>feof, ferror</code> 函数检查这两个指示器是否被设置(置1)</p></li><li><p>使用 <code>clearerr</code> 函数可以人为清除文件末尾指示器和错误指示器的状态</p></li><li><p><code>ferror</code> 函数只能检测是否出错,并不能提供出现错误的原因</p></li><li><p>大多数系统函数在出错时会将错误原因记录在 <code>errno</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开文件失败: %d\n&quot;</span>, errno);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>各种错误原因都有对应的错误码记录在 <code>errno</code> 中,但仅打印 <code>errno</code> 的值很不直观</p></li><li><p>C 语言将各种错误码对应信息打包在 <code>perror</code> 函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">perror</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;<br><span class="hljs-comment">/* s: 指定在错误信息前输出的自定义内容.然后自动添加一个冒号 */</span><br></code></pre></td></tr></table></figure></li><li><p>如果只想要系统返回错误信息的本体.可使用 <code>stderror</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> errnum)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>errnum</code>: 指定的 <code>errno</code> 值</li><li>返回值: 错误码对应的错误信息</li></ul></li></ul></li></ol><h3 id="3-5-I-O缓冲区"><a href="#3-5-I-O缓冲区" class="headerlink" title="3.5 I&#x2F;O缓冲区"></a>3.5 I&#x2F;O缓冲区</h3><ol><li><p>对于写入操作,程序会先将数据写入缓冲区,直到缓冲区被写满或文件关闭时才一次性写入设备中</p></li><li><p>对于读取操作,如果数据已经在缓冲区中,则立即返回给程序.否则,系统会将一大块数据从设备读入缓冲区</p></li><li><p>如果需要立即将数据写入设备中,可使用 <code>fflush</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fflush</span><span class="hljs-params">(FILE *stream)</span>;<br></code></pre></td></tr></table></figure></li><li><p>标准 I&#x2F;O 提供三种类型的缓冲模式</p><ul><li>按块缓存(全缓存): 在缓冲区填满后才进行实际的设备读写</li><li>按行缓存: 接受到换行符之前,数据缓存在缓冲区</li><li>不缓存: 允许直接读写设备上的数据</li></ul></li><li><p>可以通过 <code>setvbuf</code> 函数自定义缓存的模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">setvbuf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> mode, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>stream</code>: 待操作的文件流</p></li><li><p><code>buf</code>: 指定一个用户分配的缓冲区.设置为 <code>NULL</code> 时,由函数自动分配</p></li><li><p><code>mode</code>: 缓存模式</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>_IOFBF</td><td>按块缓存</td></tr><tr><td>_IOLBF</td><td>按行缓存</td></tr><tr><td>_IONBF</td><td>不缓存</td></tr></tbody></table></li><li><p><code>size</code>: 缓冲区的实际尺寸</p></li></ul></li></ol><h2 id="4-架构设计"><a href="#4-架构设计" class="headerlink" title="4 架构设计"></a>4 架构设计</h2><h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><ol><li><p>封装: 隐藏实现细节,仅暴露必要接口</p></li><li><p>实现方式: 使用 <code>struct</code> 存储数据,使用头文件(<code>.h</code>)声明公共接口,而源文件(<code>.c</code>)隐藏私有实现</p></li><li><p><code>person.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> <span class="hljs-title">Person</span>;</span>  <span class="hljs-comment">// 不透明指针(不完整类型)</span><br><br><span class="hljs-comment">// 构造函数 / 析构函数</span><br>Person* <span class="hljs-title function_">person_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">person_destroy</span><span class="hljs-params">(Person *p)</span>;<br><br><span class="hljs-comment">// 公共方法(接口)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_name</span><span class="hljs-params">(Person *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">person_get_name</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_age</span><span class="hljs-params">(Person *p, <span class="hljs-type">int</span> age)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">person_get_age</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">person_greet</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>person.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span></span><br><br><span class="hljs-comment">// 完整定义 Person(仅在此文件可见)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">// 实现构造函数</span><br>Person* <span class="hljs-title function_">person_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age)</span> &#123;<br>    Person *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Person));<br>    p-&gt;name = strdup(name);<br>    p-&gt;age = age;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_destroy</span><span class="hljs-params">(Person *p)</span> &#123;<br>    <span class="hljs-built_in">free</span>(p-&gt;name);<br>    <span class="hljs-built_in">free</span>(p);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_greet</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, I&#x27;m %s, age %d!\n&quot;</span>, p-&gt;name, p-&gt;age);<br>&#125;<br><br><span class="hljs-comment">// 其他方法实现</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_name</span><span class="hljs-params">(Person *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span> &#123;<br>    <span class="hljs-built_in">free</span>(p-&gt;name);<br>    p-&gt;name = strdup(name);<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">person_get_name</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span> &#123;<br>    <span class="hljs-keyword">return</span> p-&gt;name;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_age</span><span class="hljs-params">(Person *p, <span class="hljs-type">int</span> age)</span> &#123;<br>    p-&gt;age = age;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">person_get_age</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span> &#123;<br>    <span class="hljs-keyword">return</span> p-&gt;age;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;student.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    Person *p = person_create(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>);<br>    person_greet(p);  <span class="hljs-comment">// 输出: Hello, I&#x27;m Alice, age 25!</span><br>    person_set_age(p, <span class="hljs-number">10</span>);<br>    person_set_name(p, <span class="hljs-string">&quot;Bob&quot;</span>);<br>    person_greet(p);  <span class="hljs-comment">// 输出: Hello, I&#x27;m Bob, age 10!</span><br>    person_destroy(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-2-继承"><a href="#4-2-继承" class="headerlink" title="4.2 继承"></a>4.2 继承</h3><ol><li><p>继承: 子类继承父类的属性和方法</p></li><li><p>实现方式: 结构体嵌套(父结构体作为子结构体的第一个成员),通过类型转换模拟继承</p></li><li><p><code>student.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">Student</span>;</span><br><br>Student* <span class="hljs-title function_">student_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *university)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">student_destroy</span><span class="hljs-params">(Student *s)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">student_study</span><span class="hljs-params">(<span class="hljs-type">const</span> Student *s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *subject)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>student.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;student.h&quot;</span></span><br><br><span class="hljs-comment">// Student 的私有定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> &#123;</span><br>    Person *base;  <span class="hljs-comment">// 通过指针持有 Person(避免不完整类型问题)</span><br>    <span class="hljs-type">char</span> *university;<br>&#125;;<br><br>Student* <span class="hljs-title function_">student_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *university)</span> &#123;<br>    Student *s = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Student));<br>    s-&gt;base = person_create(name, age);  <span class="hljs-comment">// 调用 Person 的构造函数</span><br>    s-&gt;university = strdup(university);<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">student_study</span><span class="hljs-params">(<span class="hljs-type">const</span> Student *s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *subject)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s is studying %s at %s.\n&quot;</span>,<br>           person_get_name(s-&gt;base), subject, s-&gt;university);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">student_destroy</span><span class="hljs-params">(Student *s)</span> &#123;<br>    person_destroy(s-&gt;base);  <span class="hljs-comment">// 调用 Person 的析构函数</span><br>    <span class="hljs-built_in">free</span>(s-&gt;university);<br>    <span class="hljs-built_in">free</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;student.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// 创建 Student 对象(完全隐藏 Person 的细节)</span><br>    Student *s = student_create(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Stanford&quot;</span>);<br><br>    <span class="hljs-comment">// 只能通过公共接口访问数据</span><br>    student_study(s, <span class="hljs-string">&quot;Computer Science&quot;</span>);<br><br>    <span class="hljs-comment">// 释放资源</span><br>    student_destroy(s);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-3-多态"><a href="#4-3-多态" class="headerlink" title="4.3 多态"></a>4.3 多态</h3><ol><li><p>多态: 同一接口,不同实现</p></li><li><p>实现: 使用 <strong>函数指针</strong> 实现动态绑定.类似 C++ 的虚函数表(vtable)</p></li><li><p><code>shape.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Shape</span> <span class="hljs-title">Shape</span>;</span><br><br><span class="hljs-comment">// 定义虚函数表(模拟 C++ 的 vtable)</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">void</span> (*draw)(<span class="hljs-type">const</span> Shape *);<br>    <span class="hljs-type">double</span> (*area)(<span class="hljs-type">const</span> Shape *);<br>&#125; ShapeVTable;<br><br><span class="hljs-comment">// 基类结构体(对外不透明)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Shape</span> &#123;</span><br>    <span class="hljs-type">const</span> ShapeVTable *vtable; <span class="hljs-comment">// 每个对象绑定自己的虚表</span><br>&#125;;<br><br><span class="hljs-comment">// 公共接口(多态方法)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">shape_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">shape_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>shape.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><br><span class="hljs-comment">// 多态方法: 通过虚表调用具体实现</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">shape_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    shape-&gt;vtable-&gt;draw(shape);<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">shape_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-keyword">return</span> shape-&gt;vtable-&gt;area(shape);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>circle.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> <span class="hljs-title">Circle</span>;</span><br>Circle *<span class="hljs-title function_">circle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>circle.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;circle.h&quot;</span></span><br><br><span class="hljs-comment">// Circle 的私有定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> &#123;</span><br>    Shape base;  <span class="hljs-comment">// 继承 Shape(必须放在首位！)</span><br>    <span class="hljs-type">double</span> radius;<br>&#125;;<br><br><span class="hljs-comment">// Circle 的 draw 实现</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">circle_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Circle *circle = (<span class="hljs-type">const</span> Circle *)shape; <span class="hljs-comment">// 向下转型</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;○ Circle (radius=%.2f)\n&quot;</span>, circle-&gt;radius);<br>&#125;<br><br><span class="hljs-comment">// Circle 的 area 实现</span><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">circle_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Circle *circle = (<span class="hljs-type">const</span> Circle *)shape;<br>    <span class="hljs-keyword">return</span> M_PI * circle-&gt;radius * circle-&gt;radius;<br>&#125;<br><br><span class="hljs-comment">// Circle 的虚表</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> ShapeVTable circle_vtable = &#123;<br>    .draw = circle_draw,<br>    .area = circle_area<br>&#125;;<br><br><span class="hljs-comment">// 构造函数</span><br>Circle *<span class="hljs-title function_">circle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br>    Circle *circle = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Circle));<br>    circle-&gt;base.vtable = &amp;circle_vtable; <span class="hljs-comment">// 绑定虚表</span><br>    circle-&gt;radius = radius;<br>    <span class="hljs-keyword">return</span> circle;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>rectangle.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span> <span class="hljs-title">Rectangle</span>;</span><br>Rectangle *<span class="hljs-title function_">rectangle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>rectangle.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rectangle.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span> &#123;</span><br>    Shape base;  <span class="hljs-comment">// 继承 Shape</span><br>    <span class="hljs-type">double</span> width, height;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rectangle_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Rectangle *rect = (<span class="hljs-type">const</span> Rectangle *)shape;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;□ Rectangle (%.2f x %.2f)\n&quot;</span>, rect-&gt;width, rect-&gt;height);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">rectangle_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Rectangle *rect = (<span class="hljs-type">const</span> Rectangle *)shape;<br>    <span class="hljs-keyword">return</span> rect-&gt;width * rect-&gt;height;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> ShapeVTable rectangle_vtable = &#123;<br>    .draw = rectangle_draw,<br>    .area = rectangle_area<br>&#125;;<br><br>Rectangle *<span class="hljs-title function_">rectangle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height)</span> &#123;<br>    Rectangle *rect = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Rectangle));<br>    rect-&gt;base.vtable = &amp;rectangle_vtable;<br>    rect-&gt;width = width;<br>    rect-&gt;height = height;<br>    <span class="hljs-keyword">return</span> rect;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;circle.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rectangle.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// 创建不同子类对象，但用基类指针存储</span><br>    Shape *shapes[] = &#123;<br>            (Shape *)circle_create(<span class="hljs-number">3.0</span>),<br>            (Shape *)rectangle_create(<span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>),<br>    &#125;;<br><br>    <span class="hljs-comment">// 多态调用</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>        shape_draw(shapes[i]);  <span class="hljs-comment">// 调用实际类型的 draw()</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Area: %.2f\n\n&quot;</span>, shape_area(shapes[i]));<br>    &#125;<br><br>    <span class="hljs-comment">// 释放内存(实际项目应更严谨)</span><br>    <span class="hljs-built_in">free</span>(shapes[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">free</span>(shapes[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-4-重载"><a href="#4-4-重载" class="headerlink" title="4.4 重载"></a>4.4 重载</h3><ol><li>重载</li></ol><h3 id="4-2-solid"><a href="#4-2-solid" class="headerlink" title="4.2 solid"></a>4.2 solid</h3><ol><li><strong>单一职责原则(Single Responsibility Principle): 一个类应该只负责一项职责</strong><ul><li>避免”上帝类”(承担过多功能的类),将功能拆分到多个类中</li><li>每个类只关注自己的核心职责,降低修改带来的风险</li></ul></li><li><strong>开闭原则(Open Closed Principle): 软件实体(类, 模块, 函数等)应对扩展开放,对修改关闭</strong><ul><li>通过抽象(接口, 继承)实现新功能,而不是直接修改现有代码</li><li>减少对已有代码的影响,提高稳定性</li></ul></li><li><strong>里氏替换原则(Liskov Substitution Principle): 子类必须能够替换其父类,且不影响程序的正确性</strong><ul><li>子类不应破坏父类的行为契约(如方法参数, 返回值, 异常等)</li><li>避免滥用继承,确保 “is-a” 关系合理</li></ul></li><li><strong>接口隔离原则(Interface Segregation Principle): 客户端不应被迫依赖它不需要的接口</strong><ul><li>将庞大的接口拆分为更小,更具体的接口</li><li>减少 “胖接口” 导致的冗余依赖</li></ul></li><li><strong>依赖倒置原则(Dependence Inversion Principle): 高层模块不应依赖低层模块二者都应依赖抽象</strong><ul><li>通过抽象(接口)解耦,避免直接依赖具体实现</li><li>依赖注入(DI)是实现 DIP 的常见方式</li></ul></li></ol><h3 id="4-3-设计模式"><a href="#4-3-设计模式" class="headerlink" title="4.3 设计模式"></a>4.3 设计模式</h3><ol><li>观测者模式: 通知链</li><li>工厂方法: socket</li><li>模板方法: 内核调度器</li><li>策略模式: 内存压缩算法</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C 语言</tag>
      
      <tag>计算机</tag>
      
      <tag>Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言基础</title>
    <link href="/2021/09/01/Computer/C-Language-Basic/"/>
    <url>/2021/09/01/Computer/C-Language-Basic/</url>
    
    <content type="html"><![CDATA[<h2 id="0-编译链接"><a href="#0-编译链接" class="headerlink" title="0 编译链接"></a>0 编译链接</h2><h3 id="0-1-源代码处理"><a href="#0-1-源代码处理" class="headerlink" title="0.1 源代码处理"></a>0.1 源代码处理</h3><ol><li><strong>预处理(Preprocessing)</strong>: 对源代码(source code file)进行文本替换(宏定义, 条件编译, 文件包含)<ul><li>删除所有注释 <code>//, /* */</code></li><li>展开所有宏定义 <code>#define</code></li><li>处理所有的条件编译指令 <code>#if, #ifdef, #endif...</code></li><li>添加行号和文件名标识</li><li>保留所有的 <code>#pragma</code> 编译器指令,留给编译器</li></ul></li><li><strong>编译(Compilation)</strong>: 将经过预处理之后的程序转换成特定汇编代码(assembly code).生成文本文<ul><li><strong>词法分析</strong>: 将代码的字符序列转化为一系列 token(如关键字, 标识符, 特殊符号…)</li><li><strong>语法分析</strong>: 生成以表达式为节点的语法树</li><li><strong>语义分析</strong>: 进行静态语义分析(如类型转换).此时语法树有了类型</li></ul></li><li><strong>汇编(Assemble)</strong>: 将汇编代码转换成机器码(machine code),生成的文件称目标文件(二进制格式)</li><li><strong>链接(Linking)</strong>: 将多个目标文件以及所需的库文件(.so等)链接成最终的可执行文件(executable file)<ul><li><strong>符号解析</strong>: 链接器扫描所有目标文件收集所有符号,为每个符号引用找到对应的定义</li><li><strong>地址空间分配</strong>: 将目标文件的段信息进行合并</li><li><strong>重定位</strong>: 程序中调用的函数, 全局变量在编译并未确定其地址.此时修正它们的地址</li></ul></li></ol><h3 id="0-2-宏定义"><a href="#0-2-宏定义" class="headerlink" title="0.2 宏定义"></a>0.2 宏定义</h3><ol><li><p>程序扩展 <code>#define</code> 的步骤</p><ul><li>调用宏时,对参数进行检查.如果包含了 <code>#define</code>  定义的符号,将其替换(双引号中的除外)</li><li>替换文本被插入到程序原来的位置.对于带参数的宏,参数名会被值替换</li><li>再次对结果文本进行扫描.如果还有由 <code>#define</code> 定义的符号,重复上述步骤</li></ul></li><li><p>编译器预定义宏</p><table><thead><tr><th>符号</th><th>示例值</th><th>含义</th></tr></thead><tbody><tr><td><code>__FILE__</code></td><td>“name.c”</td><td>进行编译的源文件名</td></tr><tr><td><code>__LINE__</code></td><td>25</td><td>文件当前行号</td></tr><tr><td><code>__DATE__</code></td><td>“Aug 24 2023”</td><td>文件被编译的日期</td></tr><tr><td><code>__TIME__</code></td><td>“18:04:30”</td><td>文件被编译的时间</td></tr><tr><td><code>__STDC__</code></td><td>1</td><td>若编译器遵循 ANSI C,其值为1.否则未定义</td></tr></tbody></table></li><li><p><strong>无参宏定义</strong>: <code>#define name stuff</code> </p><ul><li><p>作用: 在该指令后面内容中,每当 <code>name</code> 出现,预处理器将其替换为 <code>stuff</code> </p></li><li><p>若 <code>stuff</code> 很长,可以将其分为几行,在行尾加上 <code>\</code> 表示下一行是上一行的延续</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG_PRINT print(<span class="hljs-string">&quot;File %s line %d: x=%d, y=%d, z=%d&quot;</span> \</span><br><span class="hljs-meta">__FILE__, __LINE__, x, y, z)</span><br>x *= <span class="hljs-number">2</span>; y += x; z = x * y;<br>DEBUG_PRINT; <span class="hljs-comment">// 将打印出 文件名, 行号, x, y, z的值</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>含参数宏定义</strong>: <code>#dedine name(parameter-list) stuff</code> </p><ul><li><p>其中参数列表 <code>parameter-list</code> 是由逗号分隔的符号列表,可能会出现在 <code>stuff</code> 中</p></li><li><p>作用: 在该指令后面内容中,每当 <code>name(parameter-list)</code> 出现,预处理器将其替换为 <code>stuff</code>,且每个参数均对应地被替换.注意在参数上加上括号,避免参数与操作符的相互作用而产生不可预料的后果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(x) ((x) * (x))</span><br>SQUARE(<span class="hljs-number">5</span>); <span class="hljs-comment">// 将被预处理器替换为 ((5) * (5))</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>可变参数宏定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHOWLIST(...) printf(__VA_ARGS__)</span><br>SHOWLIST(Clang, <span class="hljs-number">520</span>, pi); <span class="hljs-comment">// 输出为 Clang, 520, pi</span><br></code></pre></td></tr></table></figure><ul><li><code>...</code> 表示可变参数.可变参数允许空参数</li><li><code>__VA_ARGS__</code> 在预处理中被实际的参数集替换</li></ul></li><li><p><code>#</code>: <strong>记号字符串化运算符</strong></p><ul><li><p>带参数的宏定义中,<code>#</code> 运算符后面应该跟一个参数</p></li><li><p><code>#argument</code> 会被预处理器翻译为字符串 <code>&quot;argument&quot;</code> </p></li><li><p>多个空白字符将被替换为一个空格</p></li><li><p><code>&quot;</code>将被替换为<code>\&quot;</code>,<code>\</code>将被替换为<code>\\</code>.即<code>&quot;</code> 和<code>\</code>被自动转义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT(FORMAT, VALUE) printf(<span class="hljs-string">&quot;The value of &quot;</span> #VALUE <span class="hljs-string">&quot; is &quot;</span> FORMAT <span class="hljs-string">&quot;\n&quot;</span>, VALUE)</span><br> <br>PRINT(<span class="hljs-string">&quot;%d&quot;</span>, x+<span class="hljs-number">3</span>);<br><span class="hljs-comment">/* 上面将会被替换为 printf(&quot;The value of x+3 is %d\n&quot;, x+3); */</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>##</code>: <strong>标记粘贴运算符</strong>: 将两侧的符号连接为一个符号.可用于宏定义中从分离的文本片段创建标识符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADD_TO_SUM(sum_number, value)\</span><br><span class="hljs-meta">   sum ## sum_number += value</span><br> <br>ADD_TO_SUM(<span class="hljs-number">5</span>,<span class="hljs-number">25</span>);<br><span class="hljs-comment">/* 上面将被替换为 sum5 += 25; */</span><br></code></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li><p><strong>宏定义中的空格不能忽视</strong></p></li><li><p><strong><code>#define</code> 定义的符号可以嵌套,但不能递归</strong></p></li><li><p>预处理在编译之前,因此编译器不会对宏定义进行语法检查</p></li><li><p>预处理器搜索 <code>#define</code> 定义的符号时不检查字符串常量的内容</p></li><li><p><strong>利用 C 语言 <code>临近字符串自动连接</code> 的特性, 可将宏参数插入字符串常量</strong></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT(FORMAT, VALUE)\</span><br><span class="hljs-meta">   printf(<span class="hljs-string">&quot;The value is &quot;</span> FORMAT <span class="hljs-string">&quot;\n&quot;</span>, VALUE)</span><br><br>PRINT(<span class="hljs-string">&quot;%d&quot;</span>, x+<span class="hljs-number">3</span>);<br><span class="hljs-comment">/* 上面将会被替换为 printf(&quot;The value is &quot; &quot;%d&quot; &quot;\n&quot;, x+3); */</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>宏不是语句.因此不需要分号</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> assert(e) ((void)(e) || _assert_error(__FILE__,__LINE__))</span><br></code></pre></td></tr></table></figure><ul><li><code>e</code>: 一个表达式. 当 <code>e==0</code> 时, <code>_assert_error(__FILE__,__LINE__)</code> 函数将被调用</li><li>由于 <code>||</code> 顺序求值.当  <code>e!=0</code>,右侧不会被计算</li></ul></li><li><p><strong>宏不是类型定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 宏常用于多个不同变量的类型在一处说明.修改变量类型时仅需修改宏定义.提高可移植性 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOOTYPE struct foo</span><br>FOOTYPE a,b;<br><br><span class="hljs-comment">/* 类型定义更加通用 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> <span class="hljs-title">FOOTYPE</span>;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>宏不是函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> abs(x) (((x) &gt;= 0) ? (x) : -(x))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(a,b) ((a) &gt; (b)) ? (a) : (b)</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>宏定义只会被机械地替换.括号是为了保证不会因运算优先级出错</strong></p></li><li><p>在带参数的宏定义中,若一个操作数在多处用到,则会被求值多次</p><ul><li>例如 <code>max</code> 中,若 <code>a[i] &gt; b</code>,则 <code>max(a[i++], b)</code> 被展开为<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">((a[i++]) &gt; (b)) ? (a[i++]) : (b)  <span class="hljs-comment">// 使得 i 自增2次</span><br></code></pre></td></tr></table></figure></li><li>解决方法: 确保宏中的参数没有副作用 或 使用函数的方法实现</li></ul></li><li><p>如果宏参数在定义中出现的次数超过1次,且具有副作用.则使用时可能出现危险</p></li><li><p>带副作用的操作符和函数:</p><ul><li><code>++, --</code> 运算符</li><li><code>getchar()</code> 函数</li></ul></li></ul></li><li><p>宏相对于函数的区别</p><ul><li><p>函数调用有压栈,弹栈的额外开销</p></li><li><p>命名约定: 使用宏的语法和函数完全一致,为进行区别.<strong>宏名一般全大写</strong></p></li><li><p>函数只需出现在代码的某一处.而每个宏出现的地方都会被替换,导致代码变长</p></li><li><p><strong>函数声明时需要指出参数的类型,宏不用</strong></p></li><li><p><strong>函数无法传递将 <code>类型</code> 作为函数参数传递,宏可以</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MALLOC(n, type) ( (type *)malloc( (n) * sizeof(type) ) )</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-3-条件编译"><a href="#0-3-条件编译" class="headerlink" title="0.3 条件编译"></a>0.3 条件编译</h3><ol><li><p><strong>预处理指令</strong></p><table><thead><tr><th align="left">指令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">#define</td><td align="left">定义宏</td></tr><tr><td align="left">#include</td><td align="left">包含一个源代码文件</td></tr><tr><td align="left">#undef</td><td align="left">取消已定义的宏</td></tr><tr><td align="left">#ifdef</td><td align="left">如果宏已经定义返回真</td></tr><tr><td align="left">#ifndef</td><td align="left">如果宏没有定义返回真</td></tr><tr><td align="left">#if</td><td align="left">如果给定条件为真,则编译下面代码</td></tr><tr><td align="left">#else</td><td align="left">#if 的替代方案</td></tr><tr><td align="left">#elif</td><td align="left">如果 #if 的条件不为真,且当前条件为真.则编译下面代码</td></tr><tr><td align="left">#endif</td><td align="left">结束一个 <code>#if……#else</code> 条件编译块</td></tr><tr><td align="left">#error</td><td align="left">当遇到标准错误时,输出错误消息</td></tr><tr><td align="left">#pragma</td><td align="left">使用标准化方法,向编译器发布特殊的命令到编译器中</td></tr></tbody></table></li><li><p>条件编译(<strong>条件编译的常量表达式 一般为字面值 ,或是一个由 <code>#define</code> 定义的符号.必须在程序执行前确定该值</strong>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> constant-expression    <span class="hljs-comment">// 常量表达式,由预处理器进行求值</span></span><br>    statements             <span class="hljs-comment">// constant-expression 为真(非零),则 statements 被编译.否则删除</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> constant-expression  <span class="hljs-comment">// #elif 子句出现的次数不限</span></span><br>    other statements1      <span class="hljs-comment">// #elif 后面的语句,只有前面的所有常量表达式全为假时,才会被编译</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    other statements2      <span class="hljs-comment">// #else 后面的语句,只有前面的所有常量表达式全为假时,才会被编译</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>检查是否被定义的指令</strong>(<code>defined</code> 的作用在于可以使用 <code>&amp;&amp;, ||</code> 逻辑运算符对多个符号进行判断)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span>     defined(symbol)   <span class="hljs-comment">// 如果定义了符号 symbol ...</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  symbol            <span class="hljs-comment">// 如果定义了符号 symbol ...</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span>     !defined(symbol)  <span class="hljs-comment">// 如果未定义符号 symbol ...</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> symbol            <span class="hljs-comment">// 如果未定义符号 symbol ...</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>指令嵌套</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined( OS_UNIX )</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OPTION1</span><br>        unix_version_of_option1();<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* OPTION1 */</span></span><br>            <br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OPTION2</span><br>        unix_version_of_option2();<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* OPTION2 */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined( OS_MSDOS )</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OPTION2</span><br>        msdos_version_of_option2();<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* OPTION2 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* defined( OS_UNIX ) */</span></span><br></code></pre></td></tr></table></figure><ul><li><code>#endif</code> 语句后加上一条注释标签,帮助阅读</li><li>上述代码的用意为: 在不同的操作系统中根据选项决定使用不同的方案</li></ul></li></ol><h3 id="0-4-文件包含"><a href="#0-4-文件包含" class="headerlink" title="0.4 文件包含"></a>0.4 文件包含</h3><ol><li><p>头文件(约定后缀为 <code>.h</code>)中通常会包含以下内容</p><ul><li><p>明示常量, 宏函数, 函数声明, 结构体模板定义, 类型定义</p></li><li><p>在头文件中声明外部变量,可实现与其他文件共享变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> status = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 该变量声明于源代码文件中(.c),且具有文件作用域</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> status; <span class="hljs-comment">// 该语句声明于头文件中(.h).则包含了该头文件的代码均可访问 status 变量</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>#include</code> 指令</strong></p><ul><li>预处理器将会删除此指令,然后用包含的文件内容取代</li><li>当头文件被包含时,位于头文件内的所有内容都要被编译</li><li>每个头文件仅需包含一组函数 &#x2F; 数据的声明</li></ul></li><li><p><strong>包含库函数的头文件: <code>#include &lt;filename&gt;</code></strong></p><ul><li><code>filename</code> 并不存在限制.但约定标准库文件以 <code>.h</code> 结尾</li></ul></li><li><p><strong>包含本地文件: <code>#include &quot;filename&quot;</code></strong></p><ul><li>处理方式: 先在源文件的当前位置查找,若没有,则用查找函数库头文件的方式查找</li></ul></li><li><p>避免文件重复包含</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __HEADER_NAME_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __HEADER_NAME_H__ 1</span><br><span class="hljs-comment">/* All the stuff that you want in the header file */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li><strong>使用条件编译可以避免多重包含</strong></li><li>当第一次包含该文件时, <code>#define __HEADER_NAME_H__ 1</code> 被执行,再次包含时将被忽略</li><li>定义可以省略<code>1</code>. 即: <code>#define __HEADER_NAME_H__ </code>.该符号被定义为一个空字符,也是被定义的</li></ul></li><li><p><strong><code>#error</code>: 生成错误信息</strong></p><ul><li><p>语法: <code>#error text of error message</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span>defined(OPTION_A)</span><br><span class="hljs-comment">/* stuff needed for option A */</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span>defined(OPTION_B)</span><br><span class="hljs-comment">/* stuff needed for option B */</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span>defined(OPTION_C)</span><br><span class="hljs-comment">/* stuff needed for option C */</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">error</span> NO option selected!</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>#line</code> 指令</p><ul><li>语法: <code>#line number &quot;string&quot;</code></li><li>作用: 通知编译器 <code>number</code> 是下一行输入的行号.<code>&quot;string&quot;</code> 为可选部分.表示将其作为当前文件的名字</li><li><strong><code>#line</code> 将会修改 <code>__LINE__</code> 和 <code>__FILE__</code> 的值</strong></li><li>常用于将其他语言代码转化为 C代码的程序</li></ul></li><li><p>无效指令</p><ul><li>语法: 以 <code>#</code> 开头,但后面没有内容的行</li><li>处理方式: 被预处理器简单地删除</li><li>用法: 凸显某一行<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">#<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>#<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-5-词法分析"><a href="#0-5-词法分析" class="headerlink" title="0.5 词法分析"></a>0.5 词法分析</h3><ol><li><p><code>token</code> 指程序的一个基本组成单元</p></li><li><p>词法分析器: 编译器中负责将程序分解为一个一个符号的部分</p><ul><li>符号之间的空白(空格符,制表符,换行符)将会被忽略</li></ul></li><li><p>词法分析的贪心法</p><ul><li>C 语言分为单字符符号和多字符符号</li><li><strong>编译器在读取符号时的规则为: 每一个符号应包含尽可能多的字符</strong></li><li>编译器将程序分解为符号的方法: 从左往右读入字符,如果该字符可能成为一个符号,那么再读入下一个字符.判断已读入的2个字符是否可能组成一个符号,如果可能继续读入,重复步骤,直到不可能组成一个有意义的符号</li><li>除了字符串和字符常量,符号的中间不能嵌入空白(空格符,制表符,换行符)</li></ul></li></ol><h3 id="0-6-链接"><a href="#0-6-链接" class="headerlink" title="0.6 链接"></a>0.6 链接</h3><ol><li><p>编译与链接</p><ul><li><strong>C 程序可由多个部分分别编译组成,连接器可以将其合并成一个整体</strong></li><li>编译器一般只处理一个文件,因此无法检测出需要了解多个文件才能察觉的错误</li><li>连接器在许多系统独立于 C 语言实现,因而如果错误与 C 语言相关,连接器是无法察觉的</li></ul></li><li><p>链接器</p><ul><li><strong><code>分别编译</code>是 C 语言的一个重要思想: 多个源程序分别编译,在恰当的时候整合</strong></li><li>连接器并不需要理解 C 语言.它理解机器语言和内存布局.而编译器将源程序翻译给连接器</li><li>连接器读入目标模块,同时生成载入模块<ul><li>对于目标模块的每个外部对象,连接器需要检查载入模块中是否有同名的外部对象</li><li>没有,则将该外部对象添加到载入模块</li><li>若有,则处理命名冲突</li></ul></li><li>除了外部对象,目标模块还可能包含对其他模块中外部对象的引用<ul><li>如调用了 <code>printf</code> 函数的程序,包含一个对 <code>printf</code> 函数的引用</li><li>该引用指向一个位于某个库文件中的外部对象</li></ul></li></ul></li><li><p>声明与定义</p><ul><li>当 <code>int a;</code> 语句声明于函数外部.a 定义为一个外部整型变量.且会为 a 分配存储空间,将其初始化为0</li><li>声明 <code>extern int a;</code> 时,并非是对 a 的定义(但仍是外部变量).连接器认为这是对外部变量 a 的引用,而非定义</li><li><strong>每个外部对象必须在程序的某个地方定义</strong></li></ul></li><li><p>形参, 实参, 返回值</p><ul><li><strong>任何一个 C 函数都有返回类型: <code>void</code> 或函数生成结果的类型</strong><ul><li>若函数在调用它的文件中,第一次调用之前进行了声明或定义.则其返回值类型是非常明确的</li><li><strong>若函数在被声明或定义之前被调用,则返回类型默认为 <code>int</code></strong></li><li>若需要调用另一文件中的函数,则应在调用它的文件中对其进行声明</li></ul></li><li>形参和实参的匹配<ul><li><strong>ANSI C 允许声明时指定函数的类型</strong></li><li>函数声明中可以省略参数类型的说明,而函数定义中不能省略</li></ul></li></ul></li></ol><h2 id="1-数据"><a href="#1-数据" class="headerlink" title="1 数据"></a>1 数据</h2><h3 id="1-1-基本数据类型"><a href="#1-1-基本数据类型" class="headerlink" title="1.1 基本数据类型"></a>1.1 基本数据类型</h3><ol><li><p><strong>C 语言中的所有类型,要么是对象类型,要么是函数类型</strong></p><ul><li><strong>对象</strong>: 可以在其中表示值的一块存储区域(注意并非面向对象的对象)</li><li><strong>函数</strong>: 并非对象,且其类型由 返回值类型, 参数的数量, 类型 共同决定</li></ul></li><li><p>C 语言的5种基本数据类型</p><ul><li>整型(<code>short, int, long, long long</code>)</li><li>浮点型(<code>float, double, long double</code>)</li><li>字符型(<code>char</code>)</li><li>布尔型(<code>_Bool</code>)</li><li>枚举(<code>enum</code>)</li></ul></li><li><p><strong>C 语言并未给定 int 的具体尺寸为多少字节,只需满足: <code>short &lt;= int &lt;= long &lt;= long int</code></strong><br><strong>因此需要 sizeof 运算符获取数据类型或表达式的尺寸</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">sizeof</span>(type_name);<br><span class="hljs-keyword">sizeof</span>(object);<br><span class="hljs-keyword">sizeof</span> object;<br></code></pre></td></tr></table></figure></li><li><p>ANSI C规定的整型的最小范围</p><table><thead><tr><th align="left">类型</th><th align="left">最小值</th><th>最大值</th></tr></thead><tbody><tr><td align="left">char</td><td align="left">0</td><td>127</td></tr><tr><td align="left">signed char</td><td align="left">-127</td><td>127</td></tr><tr><td align="left">unsigned char</td><td align="left">0</td><td>255</td></tr><tr><td align="left">short</td><td align="left">-32767</td><td>32767</td></tr><tr><td align="left">unsigned short</td><td align="left">0</td><td>65535</td></tr><tr><td align="left">int</td><td align="left">-32767</td><td>32767</td></tr><tr><td align="left">unsigned int</td><td align="left">0</td><td>65535</td></tr><tr><td align="left">long</td><td align="left">-2147483647</td><td>2147483647</td></tr><tr><td align="left">unsigned long</td><td align="left">0</td><td>4294967259</td></tr></tbody></table></li><li><p><strong><code>&lt;limits.h&gt;</code> 中说明了不同整数 &#x2F; 浮点数类型的特点</strong></p><table><thead><tr><th align="center"></th><th align="center">signed</th><th align="center">signed</th><th align="center">unsigned</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">最小值</td><td align="center">最大值</td><td align="center">最大值</td></tr><tr><td align="center">字符</td><td align="center">SCHAR_MIN</td><td align="center">SCHAR_MAX</td><td align="center">USCHAR_MAX</td></tr><tr><td align="center">短整型</td><td align="center">SHRT_MIN</td><td align="center">SHRT_MAX</td><td align="center">USHRT_MAX</td></tr><tr><td align="center">整型</td><td align="center">INT_MIN</td><td align="center">INT_MAX</td><td align="center">UINT_MAX</td></tr><tr><td align="center">长整型</td><td align="center">LONG_MIN</td><td align="center">LONG_MAX</td><td align="center">ULONG_MAX</td></tr><tr><td align="center">单精度</td><td align="center">FLT_MIN</td><td align="center">FLT_MAX</td><td align="center">&#x2F;</td></tr><tr><td align="center">双精度</td><td align="center">DBL_MIN</td><td align="center">DBL_MAX</td><td align="center">&#x2F;</td></tr><tr><td align="center">扩展精度</td><td align="center">LDBL_MIN</td><td align="center">LDBL_MAX</td><td align="center">&#x2F;</td></tr></tbody></table></li><li><p><strong>默认的 <code>char</code> 并未规定是否有符号</strong></p><ul><li>使用 <code>char</code> 型变量时最好将其范围限制在 [0, 127]</li><li>当明确声明了 <code>char</code> 是否有符号后,才对其进行算数运算</li></ul></li><li><p>整型字面值</p><ul><li><p><strong>默认情况下的十进制字面值将被指定为最短的能容纳该值的类型</strong></p></li><li><p><strong>在字面值加上后缀可以指定其整型的类型</strong></p><ul><li><p>l &#x2F; L: long</p></li><li><p>u &#x2F; U: unsigned</p></li><li><p>上面的 u &#x2F; l 可以进行组合</p></li></ul></li><li><p>八进制表示方法: 在数值前加上 <code>0</code></p></li><li><p>十六进制表示方法: 在数值前加上 <code>0x</code></p></li><li><p><strong>字符常量: 单引号下的单个字符(也可以是转义字符或三字母词)</strong></p></li></ul></li><li><p>枚举类型: 其值为符号常量,而非字面值</p><ul><li><strong>枚举类型的变量其本质上是整型</strong></li><li>枚举声明中的符号名会被当作整型常量处理(从0开始,后面的值比前面大1)</li></ul></li><li><p>浮点类型</p><ul><li><strong>浮点数字面值在默认情况下为 <code>double</code> 类型.后缀为 l&#x2F;L 可指定其为 <code>float</code></strong></li><li>所有浮点类型必须可以容纳 $10^{-37}\sim 10^{37}$ 间的任意值</li></ul></li></ol><h3 id="1-2-变量"><a href="#1-2-变量" class="headerlink" title="1.2 变量"></a>1.2 变量</h3><ol><li><p>变量和常量是程序处理的两种基本数据类型</p><ul><li>通常待处理的数据会被置于内存中</li><li>存放数据的位置即是一个地址,CPU 可以通过地址找到该数据</li></ul></li><li><p><strong>变量命名规则</strong></p><ul><li>只能由英文字母(<code>_</code> 也视为字母)和数字组成</li><li>英文字母开头</li><li>区分大小写</li><li>不能使用关键字</li></ul></li><li><p><strong>ANSI C 有32个关键字</strong></p><table><thead><tr><th>auto</th><th>break</th><th>case</th><th>char</th><th>const</th><th>continue</th><th>default</th><th>do</th></tr></thead><tbody><tr><td>double</td><td>else</td><td>enum</td><td>extern</td><td>float</td><td>for</td><td>goto</td><td>if</td></tr><tr><td>int</td><td>long</td><td>register</td><td>return</td><td>short</td><td>signed</td><td>sizeof</td><td>static</td></tr><tr><td>struct</td><td>switch</td><td>typedef</td><td>union</td><td>unsigned</td><td>void</td><td>volatile</td><td>while</td></tr></tbody></table><ul><li>C99 标准新增5个关键字: <code>inline, restrict, _Bool, _Complex, _Imaginary</code></li><li>C11 标准新增7个关键字: <code>_Alignas, _Alignof, _Atomic, _Static_assert, _Noreturn, _Thread_local, _Generic</code></li></ul></li><li><p>局部变量</p><ul><li><code>for</code> 语句中的初始化语句定义的是局部变量,仅适用于复合语句内部</li><li><strong>一个函数定义的变量无法在另一个函数中访问</strong></li><li>C 语言允许随处定义变量</li></ul></li><li><p>全局变量</p><ul><li><strong>定义于函数之外的即为全局变量.会自动初始化为 0</strong></li><li>函数内部存在同名全局变量和局部变量时,会屏蔽掉全局变量</li></ul></li><li><p>减少全局变量的使用</p><ul><li>全局在程序退出是才会被释放.导致占用更多内存</li><li>使用全局变量将导致: 命名空间污染, 耦合性提高</li></ul></li><li><p>C 语言的变量有用两种生存期: 静态存储期和自动存储期</p><ul><li><strong>静态存储期:</strong> 程序执行时一直占据存储空间,程序关闭才释放.如: 具有文件作用域的变量,函数名</li><li><strong>自动存储期</strong>: 代码块结束时自动释放存储空间.如: 具有代码块作用域的变量</li></ul></li><li><p>寄存器变量</p><ul><li>寄存器存在于 CPU 内部,CPU 对寄存器的读取和存储几乎没有延时</li><li><code>register</code> 关键字: 声明寄存器变量(实际很少用到)</li><li><code>register</code> 在编译器看来只是一个建议,编译器会考虑是否将其放入寄存器</li></ul></li><li><p>静态局部变量</p><ul><li><strong><code>static</code> 关键字: 用于声明局部变量时,将局部变量设为静态存储期,与全局变量一致</strong></li><li><strong>静态局部变量仅会被初始化一次</strong></li><li><strong>静态局部变量仍为局部变量,无法在别的函数中直接访问</strong></li></ul></li></ol><h3 id="1-3-常量"><a href="#1-3-常量" class="headerlink" title="1.3 常量"></a>1.3 常量</h3><ol><li><p>基本数据类型中的数据类型可作为常量.常用的还有字符串常量和符号常量</p><ul><li><p><strong>字符串常量: C 语言没有单独的字符串类型,采取字符数组的方式定义字符串</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> 变量名[字符数量];<br><span class="hljs-type">char</span> name[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br><span class="hljs-type">char</span> name[] = <span class="hljs-string">&quot;ys&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><p>C 语言约定用转义字符 <code>&#39;\0&#39;</code> (空字符)表示字符串的结束位置当系统读取到该转义字符时,说明字符串结束</p></li><li><p>以数组形式初始化时,需要给结尾的 <code>&#39;\0&#39;</code> 留出位置</p></li><li><p>使用字符串常量初始化并赋值时,编译器会自动在末尾补上 <code>&#39;\0&#39;</code></p></li></ul></li><li><p><strong>符号常量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> 标识符 常量</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> YEAR 2023</span><br></code></pre></td></tr></table></figure></li><li><p>转义字符</p><table><thead><tr><th>转义字符</th><th>含义</th><th>转义字符</th><th>含义</th></tr></thead><tbody><tr><td><code>\a</code></td><td>响铃(BEL)</td><td><code>\\</code></td><td>\</td></tr><tr><td><code>\b</code></td><td>退格(BS)</td><td><code>\&#39;</code></td><td>‘</td></tr><tr><td><code>\f</code></td><td>换页(FF)</td><td><code>\&quot;</code></td><td>“</td></tr><tr><td><code>\n</code></td><td>换行(LF)</td><td><code>\?</code></td><td>?</td></tr><tr><td><code>\r</code></td><td>回车(CR)</td><td><code>\0</code></td><td>NULL</td></tr><tr><td><code>\t</code></td><td>水平制表(HT)</td><td><code>\ddd</code></td><td>八进制值</td></tr><tr><td><code>\v</code></td><td>垂直制表(VT)</td><td><code>\xhh</code></td><td>十六进制值</td></tr></tbody></table></li></ul></li><li><p><strong><code>const</code> 关键字用来声明常量.常量与变量的区别仅在于其值是只读的</strong></p><ul><li><code>int const a;</code> 与 <code>const int a;</code> 声明方式变量时的效果完全相同</li><li>由于常量的值不可修改.因此声明时一般要进行初始化</li><li>作为形参的常量在函数被调用时会得到实参的值</li></ul></li><li><p><code>const</code> 与指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-type">const</span> *pci;      <span class="hljs-comment">// pci 指向一个整型常量</span><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> pci;      <span class="hljs-comment">// pci 指向一个整型变量,指向不可修改</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *<span class="hljs-type">const</span> pci <span class="hljs-comment">// pci 指向一个整型常量,且指向不可修改</span><br></code></pre></td></tr></table></figure></li><li><p><code>const</code> 与 <code>#define</code></p><ul><li><code>const</code> 只能使用于可以出现变量的地方</li><li><code>#define</code> 可以创建名字常量.只要字面值可以出现的地方均可使用</li></ul></li><li><p>变量初始化</p><ul><li>在程序链接时,静态变量存储位置被指定<ul><li><strong>因此若静态变量未显式地初始化,则会被初始化为0.且初始化只会进行一次</strong></li></ul></li><li>自动变量在链接时其存储位置无法判断.因此自动变量没有缺省的初始值.对其初始化会包含一条隐式的赋值语句<ul><li>对自动变量的初始化 相比于赋值语句效率不会提高(除非声明为 <code>const</code> 变量)</li><li>隐式的赋值语句会使得自动变量每次执行到它们的时候都会重新初始化</li><li>由于初始化在运行时执行,因此可以用任何表达式作为初始值</li><li><strong>若自动变量创建而未初始化时,则其值没有意义</strong></li></ul></li></ul></li></ol><h3 id="1-4-运算符"><a href="#1-4-运算符" class="headerlink" title="1.4 运算符"></a>1.4 运算符</h3><table><thead><tr><th>优先级</th><th>运算符</th><th>结合律</th></tr></thead><tbody><tr><td>0</td><td>强制分组: <code>()</code></td><td>—&gt;</td></tr><tr><td>1</td><td>后缀运算符: <code>[]  ()  .  -&gt;</code></td><td>—&gt;</td></tr><tr><td>2</td><td>一元运算符: <code>++ -- ! ~ +  - * &amp; (type) sizeof _Alignof</code></td><td><strong>&lt;—</strong></td></tr><tr><td>3</td><td>乘除法运算符: <code>*  /  %</code></td><td>—&gt;</td></tr><tr><td>4</td><td>加减法运算符: <code>+  -</code></td><td>—&gt;</td></tr><tr><td>5</td><td>移位运算符: <code>&lt;&lt;  &gt;&gt;</code></td><td>—&gt;</td></tr><tr><td>6</td><td>关系运算符: <code>&lt;  &lt;=  &gt;  &gt;=</code></td><td>—&gt;</td></tr><tr><td>7</td><td>相等运算符: <code>==  !=</code></td><td>—&gt;</td></tr><tr><td>8</td><td>位运算符 AND: <code>&amp;</code></td><td>—&gt;</td></tr><tr><td>9</td><td>位运算符 XOR: <code>^</code></td><td>—&gt;</td></tr><tr><td>10</td><td>位运算符 OR: &#96;</td><td>&#96;</td></tr><tr><td>11</td><td>逻辑运算符 AND: <code>&amp;&amp;</code></td><td>—&gt;</td></tr><tr><td>12</td><td>逻辑运算符 OR: &#96;</td><td></td></tr><tr><td>13</td><td>条件运算符: <code>? :</code></td><td><strong>&lt;—</strong></td></tr><tr><td>14</td><td>赋值运算符: &#96;&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &amp;&#x3D; ^&#x3D;</td><td>&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D;&#96;</td></tr><tr><td>15</td><td>逗号运算符: <code>,</code></td><td>—&gt;</td></tr></tbody></table><ol><li><p>单目运算符</p><ul><li><strong>单目运算符的优先级仅低于后缀运算符</strong></li><li>结合顺序为从右到左.即 <code>*p++</code> 会被认为是 <code>*(p++)</code></li></ul></li><li><p>双目运算符</p><ul><li><p>算术  –&gt;  移位  –&gt;  关系  –&gt;  位  –&gt;  逻辑(<strong>算移关位逻</strong>)</p></li><li><p>关系运算符中: 比较  –&gt; 判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 判断 a,b 的相对大小是否和 c,d 相同</span><br>a &lt; b == c &lt; d<br></code></pre></td></tr></table></figure></li><li><p>位运算符优先级: <code>~  --&gt;  &amp;  --&gt;  ^  --&gt;  |</code> (<strong>反,与,异,或</strong>)</p></li><li><p>逻辑运算符优先级: <code>!  --&gt;  &amp;&amp;  --&gt;  ||</code> (<strong>非与或</strong>)</p></li></ul></li><li><p>三目运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">taxRate = income &gt; <span class="hljs-number">40000</span> &amp;&amp; residence &lt; <span class="hljs-number">5</span> ? <span class="hljs-number">3.5</span> : <span class="hljs-number">2.0</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>三目运算符优先级低于: 算术,移位,关系,位,逻辑运算符.因而允许在条件表达式中包括关系运算符的逻辑组合</strong></li><li>三目运算符优先级高于: 赋值运算符.因而可以最后进行赋值操作</li></ul></li><li><p>逗号运算符</p><ul><li>优先级最低,其结果为最后一个表达式的值</li><li>在宏定义中作用明显</li></ul></li><li><p><strong>C 语言采用短路求值: 当前一个运算数的无法确定逻辑运算的结果时,才会对第二个运算数求值.</strong><br>换言之,如果第一个运算数已经可以确实整个逻辑运算的结果,后一个运算数便不会计算</p></li></ol><h3 id="1-5-作用域"><a href="#1-5-作用域" class="headerlink" title="1.5 作用域"></a>1.5 作用域</h3><ol><li>对象, 函数, 宏, 标识符均有作用域(scope)<ul><li>标识符的作用域: 程序中该标识符可以被使用的区域</li><li><strong>C 语言提供的作用域: 文件, 块, 函数原型, 函数</strong></li><li>对象, 函数, 标识符的作用域由其声明位置决定</li></ul></li><li><strong>文件作用域</strong><ul><li>位于代码块之外的标识符具有文件作用域</li><li>从声明到源文件结尾均可被访问</li><li>函数名具有文件作用域</li></ul></li><li><strong>代码块作用域</strong><ul><li>代码块: 位于一对 <code>&#123;&#125;</code> 之间的所有语句</li><li>代码块中标识符具有代码块作用域</li><li>代码块嵌套时,外层无法用名字访问内层的标识符.如果内层有同名标识符,外层的将会被屏蔽</li></ul></li><li><strong>原型作用域</strong><ul><li>仅适用于函数原型中的参数名</li><li>函数参数名不是必需的,也不用与函数定义的形参名匹配</li></ul></li><li><strong>函数作用域</strong><ul><li>仅适用于语句标签.即 <code>label</code> 语句</li><li>一个函数中所有语句标签必须唯一</li><li>作用: 将标签限制在同一函数内部,防止标签重名</li></ul></li></ol><h3 id="1-6-存储期"><a href="#1-6-存储期" class="headerlink" title="1.6 存储期"></a>1.6 存储期</h3><ol><li><strong>对象的存储期决定其生命周期.分为: 自动, 静态, 线程, 分配</strong></li><li><strong>自动存储期</strong><ul><li>自动存储期对象将在语句块执行结束时被释放</li><li>在语句块或作为函数参数声明的对象将会具有自动存储期</li></ul></li><li><strong>静态存储期</strong><ul><li>静态存储期对象在程序整个执行期间都有效</li><li>文件作用域中声明的对象将会具有静态存储期</li><li><code>static</code> 可将具有自动存储期的变量(位于代码块中)改为静态存储期</li></ul></li><li><strong>分配存储期</strong><ul><li>动态分配内存具有分配存储期.从分配开始,直到释放结束</li><li>动态分配的内存取自堆(heap).由内存管理器管理</li><li>内存管理器负责分配内存和释放内存.分配后由调用者管理内存</li></ul></li><li><strong>线程存储期</strong>(C11 引入)<ul><li>使用<code>_Thread_local</code>关键字声明线程局部变量</li><li>线程局部变量的地址在不同线程中是不同的,在每个线程中都有一份独立的实例</li><li>线程局部变量的析构在线程退出时进行</li></ul></li></ol><h3 id="1-7-链接属性"><a href="#1-7-链接属性" class="headerlink" title="1.7 链接属性"></a>1.7 链接属性</h3><ol><li><p>标识符的链接属性决定如何处理在不同文件中出现的标识符</p><ul><li>外部(<code>external</code>): 无论在哪个源文件,声明多少次.均当作同一实体</li><li>内部(<code>internal</code>): 在同一源文件中被当作同一实体,不同源文件则被看作不同实体</li><li>无(<code>none</code>): 总是被当作不同的独立个体</li><li><strong>具有文件作用域的标识符缺省的链接属性为: <code>external</code></strong></li><li><strong>具有代码块作用域的标识符缺省的链接属性为: <code>none</code></strong></li></ul></li><li><p>修改链接属性</p><ul><li><code>static</code>: 将链接属性为 <code>external</code> 的标识符(位于代码块外)改为 <code>internal</code><ul><li>可用于限制全局变量只能在单个源文件内部访问</li><li>可用于限制内部函数不被其他源文件调用</li></ul></li><li><code>extern</code>: 将链接属性为 <code>none</code> 的变量改为 <code>external</code><ul><li>可用于访问其他文件中的链接属性为 <code>external</code> 的变量</li></ul></li></ul></li><li><p><strong>作用域, 链接属性, 存储类型的总结</strong></p><table><thead><tr><th>变量类型</th><th>声明的位置</th><th>是否存在于堆栈</th><th>作用域</th><th>加上 static</th></tr></thead><tbody><tr><td>全局</td><td>代码块外</td><td>否</td><td>文件作用域</td><td>不允许其他源文件访问</td></tr><tr><td>局部</td><td>代码块内</td><td>是</td><td>代码块作用域</td><td>静态变量</td></tr><tr><td>形参</td><td>函数头部</td><td>是</td><td>函数作用域</td><td>&#x2F;</td></tr></tbody></table></li><li><p>存储类别</p><table><thead><tr><th>存储类别</th><th>存储期</th><th>作用域</th><th>链接</th><th>声明方式</th></tr></thead><tbody><tr><td>自动</td><td>自动</td><td>块</td><td>无</td><td>块内</td></tr><tr><td>寄存器</td><td>自动</td><td>块</td><td>无</td><td>块内, <code>register</code></td></tr><tr><td>静态外部链接</td><td>静态</td><td>文件</td><td>外部</td><td>所有函数外</td></tr><tr><td>静态内部链接</td><td>静态</td><td>文件</td><td>内部</td><td>所有函数外, <code>static</code></td></tr><tr><td>静态无链接</td><td>静态</td><td>块</td><td>无</td><td>块内, <code>static</code></td></tr></tbody></table></li></ol><h2 id="2-控制流"><a href="#2-控制流" class="headerlink" title="2 控制流"></a>2 控制流</h2><h3 id="2-1-分支"><a href="#2-1-分支" class="headerlink" title="2.1 分支"></a>2.1 分支</h3><ol><li><p><code>if</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (expression_1) &#123;<br>    code block <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expression_2) &#123;<br>    code block <span class="hljs-number">2</span>;<br>&#125;<br>...<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expression_n) &#123;<br>    code block n;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    code blcok;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>else if, else</code> 语句是可选的</li><li><strong><code>else</code> 只会和最近的 <code>if</code> 匹配,而与缩进无关</strong></li></ul></li><li><p><code>switch</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (expression) &#123;<br><span class="hljs-keyword">case</span> constant_expression_1:<br>    code block <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> constant_expression_2:<br>    code block <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">break</span>;<br>...<br><span class="hljs-keyword">case</span> constant_expression_n:<br>    code block n;<br>    <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>    code block;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>break</code> 语句是可选的,若没有 <code>break</code>,将发生 <code>break</code> 穿透</strong></li><li><strong><code>default</code> 语句是可选的,用于处理没有成功匹配的情况</strong></li></ul></li></ol><h3 id="2-2-循环"><a href="#2-2-循环" class="headerlink" title="2.2 循环"></a>2.2 循环</h3><ol><li><p><code>while</code>: 先计算表达式,若为真则执行循环体中的代码. 重复该步骤,直到条件表达式为假</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (expression) &#123;<br>    code block;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>do-while</code>: 先执行一次循环体中的代码,然后计算表达式,若为真则循环再次执行语句.重复该步骤,直到条件表达式为假</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br>    code block;<br>&#125; <span class="hljs-keyword">while</span> (expression);<br></code></pre></td></tr></table></figure></li><li><p><code>for</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(initialize; expression; adjust) &#123;<br>    code block;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>开始时,先进行一次初始化 -&gt; 判断循环条件 -&gt; 执行循环体 -&gt; 进行调整. 重复该步骤,直到循环条件为假</li><li><code>for</code> 语句的每一部分都是可选的<ul><li>初始化: 可在外部进行</li><li>循环条件: 省略后将默认为真(死循环)</li><li>调整: 也可在内部语句进行</li></ul></li><li><strong><code>for</code> 是 <code>while</code> 的语法糖,优点在于将决定迭代的条件整合到了一起</strong></li></ul></li><li><p><code>goto</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">goto</span> lable;<br>lable: 语句<br></code></pre></td></tr></table></figure><ul><li><code>:</code> 表示这里有一个标记</li><li><code>label</code> 可以是任何除 C 关键字以外的纯文本.设置在 <code>goto</code> 语句的前后均可</li><li><strong><code>goto</code> 关键字是不被推荐的实践,最好只用于在同一函数内使用</strong></li><li>可用于跳出多层循环, 或者 资源管理</li></ul></li><li><p><code>break</code>: 跳出本层循环</p></li><li><p><code>continue</code>: 跳过本轮循环,进入下一轮</p></li></ol><h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3 数组"></a>3 数组</h2><h3 id="3-1-一维数组"><a href="#3-1-一维数组" class="headerlink" title="3.1 一维数组"></a>3.1 一维数组</h3><ol><li><p>声明方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">数据类型 数组名[数量];<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><ul><li><code>[]</code>: 后缀运算符,表示声明的对象是数组</li><li>数据类型: 指明当对数组中的元素进行访问时得到的数据类型</li><li>数量: 编译器需要根据 <code>数组类型和数量</code> 确定要分配的内存大小</li><li><strong>数组名: 其本质上是一个常量指针,其值为数组首元素的地址</strong></li></ul></li><li><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>若仅给部分元素进行初始化,则其他元素自动初始化为 0</strong></li><li>若省略数组长度,则将由编译器自行计算数组长度</li></ul></li><li><p><strong>访问数组元素: 数组名本质上是常量指针.因此 <code>arr[1]</code> 将被计算为 <code>*(arr+1)</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">数组名[下标] <span class="hljs-comment">// 数组下标索引从 0 开始</span><br>arr[<span class="hljs-number">1</span>]       <span class="hljs-comment">// 取出数组 arr 的第2个元素的值</span><br></code></pre></td></tr></table></figure></li><li><p>获取数组长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> length = <span class="hljs-keyword">sizeof</span>(numbers) / <span class="hljs-keyword">sizeof</span>(numbers[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 计算方法</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))  <span class="hljs-comment">// 宏实现</span></span><br></code></pre></td></tr></table></figure></li><li><p>遍历数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>    code block;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可变长数组: 可以用变量指定数组的维度</p><ul><li>C99 标准前,定义数组时,数组的长度必须为常量表达式或 <code>const</code> 常量</li><li><strong>从 C99 开始,支持可变长数组,即数组的长度在程序运行时才决定.但完成定义后,便不再支持修改长度</strong></li></ul></li></ol><h3 id="3-2-二维数组"><a href="#3-2-二维数组" class="headerlink" title="3.2 二维数组"></a>3.2 二维数组</h3><ol><li><p>定义二维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">数据类型 数组名[行数][列数];<br><span class="hljs-type">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><ul><li><strong>二维数组在内存中线性存储</strong></li><li>根据后缀运算符的结合性<ul><li>从左到右,<code>a</code> 与 <code>[4]</code> 结合.因而 <code>a</code> 是一个拥有4个元素的数组</li><li><code>a[4]</code> 与 <code>[5]</code> 结合.因而 <code>a[4]</code> 的每个元素都是一个拥有5个元素的一维数组</li></ul></li></ul></li><li><p>初始化二维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 根据 线性存放特性 进行初始化 */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;;<br><br><span class="hljs-comment">/* 根据 二维数组本质上是数组的数组特性 进行初始化 */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>    &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;,<br>    &#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;<br>&#125;;<br><span class="hljs-comment">/* 部分值初始化 */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;&#123;<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>&#125;&#125;;<br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;<br><span class="hljs-comment">/* 指定元素初始化(C99) */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, [<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>, [<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>&#125;;<br><span class="hljs-comment">/* 第一个维度元素可不写,交由编译器计算 */</span><br><span class="hljs-type">int</span> a[][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>访问二维数组元素</p><ul><li><strong>数组名被理解为常量指针,而二维数组又是数组的数组</strong></li><li><strong>因而,<code>a[3][4]</code> 将被计算为 <code>*(*(a+3)+4)</code></strong></li></ul></li><li><p>遍历二维数组: 采用嵌套循环的方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; column; ++j)&#123;<br>        code block;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多维数组: 形式上与二维数组类似,仅需在定义时增加下标数量</p></li></ol><h2 id="4-指针"><a href="#4-指针" class="headerlink" title="4 指针"></a>4 指针</h2><h3 id="4-1-指针与变量"><a href="#4-1-指针与变量" class="headerlink" title="4.1 指针与变量"></a>4.1 指针与变量</h3><ol><li><p><strong>指针就是内存地址. 而指针变量是: 存放内存地址的变量</strong></p></li><li><p>定义指针变量的方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">类型名 *指针变量名<br><span class="hljs-type">int</span> *pa<br></code></pre></td></tr></table></figure><ul><li>类型名: 指明对指针变量解引用(<code>*</code>)后得到的数据类型</li></ul></li><li><p><code>void</code> 指针</p><ul><li><strong><code>void</code> 指针称为通用指针,可以指向任意类型的数据</strong><ul><li>不要对 <code>void</code> 指针解引用</li><li>任何类型的指针均可转换为 <code>void</code> 指针,而再转换回来需要强制类型转换</li></ul></li></ul></li><li><p><code>NULL</code> 指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL ((void *)0)</span><br></code></pre></td></tr></table></figure><ul><li><code>(void *)</code>: 强制类型转换,将地址 0 强转为 <code>void</code> 指针<ul><li><strong>由于地址 0 通常不被使用,因此,<code>NULL</code> 是一个空指针,即不指向任何东西</strong></li><li>为防止解引用未初始化的指针,经常将其初始化为 <code>NULL</code></li><li>解引用 <code>NULL</code> 会直接使得程序崩溃.因此,在解引用指针时,应先判断是否为 <code>NULL</code></li></ul></li></ul></li><li><p>指针的运算</p><ul><li><strong>加减: 相当于将指针的位置移动相应的位置.即 <code>p+1</code> 表示指向 <code>p</code> 的下一个元素</strong></li><li>比较: 运用关系运算符进行比较时,可判断指针指向的前后关系</li></ul></li><li><p><code>*</code> 运算符</p><ul><li>在定义指针变量时,用于声明是指针</li><li>在对指针进行取值操作时,获取指针指向元素的值</li><li>定义指针和取值操作是不同的,属于符号的重用</li></ul></li><li><p><code>&amp;</code> 取址运算符: 对变量进行取址操作,获得变量的地址</p></li></ol><h3 id="4-2-指针的组合"><a href="#4-2-指针的组合" class="headerlink" title="4.2 指针的组合"></a>4.2 指针的组合</h3><ol><li><p><strong>二级指针(指针在定义就表明了如何解引用.定义时用到了多少 <code>*</code>,得到值就需要多少 <code>*</code>)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">520</span>;  <span class="hljs-comment">// int 类型变量</span><br><span class="hljs-type">int</span> *p = &amp;num;  <span class="hljs-comment">// int * 类型指针</span><br><span class="hljs-type">int</span> **pp = &amp;p;  <span class="hljs-comment">// int ** 类型的二级指针</span><br></code></pre></td></tr></table></figure></li><li><p>指针数组 和 二级指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *book[] = &#123;<br>    <span class="hljs-string">&quot;C 程序设计语言&quot;</span>,<br>    <span class="hljs-string">&quot;C 专家编程&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>book</code> 是指针数组,每个元素都是指针(字符串).现想要管理每个元素(字符串)</p></li><li><p>建立一个新数组,其中的每个元素都是指针,它们指向需要操作的对象(字符串).即:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> **cbook[<span class="hljs-number">2</span>];<br>cbook[<span class="hljs-number">0</span>] = &amp;book[<span class="hljs-number">0</span>];<br>cbook[<span class="hljs-number">1</span>] = &amp;book[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure></li></ul></li><li><p>指向常量的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> cnum = <span class="hljs-number">520</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;cnum;<br></code></pre></td></tr></table></figure><ul><li>指针可以指向被 <code>const</code> 修饰的变量,不能通过指针修改其值.指针指向可改变</li><li><code>const int</code> 表示指向的是一个整型常量</li></ul></li><li><p><strong>常量指针: 指向的是一个变量,其值可以修改,但指针指向不允许修改</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">520</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p = &amp;num;  <span class="hljs-comment">// const p 表示指针 p 是一个常量</span><br></code></pre></td></tr></table></figure></li><li><p>指向常量的常量指针: 指针自身不允许修改,其指向的值也不允许修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> cnum = <span class="hljs-number">520</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p = &amp;cnum;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-函数"><a href="#5-函数" class="headerlink" title="5 函数"></a>5 函数</h2><h3 id="5-1-函数定义"><a href="#5-1-函数定义" class="headerlink" title="5.1 函数定义"></a>5.1 函数定义</h3><ol><li><p>函数的定义方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">类型名 函数名(参数列表) &#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数的声明方式: 去掉函数体,加上分号即为声明语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">类型名 函数名(参数列表);<br></code></pre></td></tr></table></figure></li><li><p>参数的传递</p><ul><li><strong>C 语言是按值调用的(call-by-value),也称按值传递(pass-by-value)</strong></li><li><strong>形参(parameter)</strong>: 函数定义时的参数.仅在函数被调用时分配内存,调用结束后立即释放</li><li><strong>实参(argument)</strong>: 真实传递给函数的值.这种传值方式具有单向性</li><li>传址: 如果形参是指针,那么可以通过间接的方式修改地址存储的值</li><li>传数组: 本质上是传递数组首元素的地址</li></ul></li><li><p><strong>可变参数函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span>                <span class="hljs-comment">// 可变参数需要的头文件</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n, ...)</span> &#123;              <span class="hljs-comment">// ... 是占位符,表明参数个数不确定</span><br>    <span class="hljs-type">int</span> i, sum = <span class="hljs-number">0</span>;<br>    va_list vap;                   <span class="hljs-comment">// 定义参数列表</span><br>    va_start(vap, n);              <span class="hljs-comment">// 初始化参数列表, n 是第一个参数的名称</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        sum += va_arg(vap, <span class="hljs-type">int</span>);   <span class="hljs-comment">// 获取参数值, int 表示参数类型</span><br>    &#125;                              <span class="hljs-comment">// va_arg() 调用后, vap 自动指向下一个参数</span><br>    va_end(vap);                   <span class="hljs-comment">// 关闭参数列表</span><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-2-函数与指针"><a href="#5-2-函数与指针" class="headerlink" title="5.2 函数与指针"></a>5.2 函数与指针</h3><ol><li><p>指针函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *<span class="hljs-title function_">fp</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// fp 是指针函数</span><br></code></pre></td></tr></table></figure><ul><li><strong>函数的类型由返回值决定.当函数返回值为指针类型时,函数即为指针函数</strong></li><li>指针函数的定义方式类似于定义指针: 在类型后面加上一个 <code>*</code></li><li><strong>不要返回局部变量的地址.因为局部变量仅存在于函数内部</strong></li></ul></li><li><p>函数指针(它是一个指针,指向函数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>);  <span class="hljs-comment">// fp 是函数指针</span><br>   <span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>;  <span class="hljs-comment">// fun 是一个函数名,本质也是一个指针</span><br>   <br>   fp = func;           <span class="hljs-comment">// 对函数指针的赋值方式.类型匹配可直接赋值</span><br>   result = (*fp)(num); <span class="hljs-comment">// K&amp;R C 的调用方式.从声明形式的等价得出</span><br>   result = fp(num);    <span class="hljs-comment">// UNIX 推广者的调用方式.从赋值语句的等价得出</span><br></code></pre></td></tr></table></figure><ul><li><p>函数名 <code>func</code> 是函数的首地址,类型为 <code>int (*)(int)</code></p></li><li><p><strong>对于函数名而言: 它本身是一个指针,且对其取值或取址的值仍是其本身</strong></p></li></ul></li><li><p>函数指针作为参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>), <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>; <span class="hljs-comment">// 第一个参数为函数指针</span><br><br><span class="hljs-comment">/* 函数名 add 作为实参传入 calc 函数.形参为 fp,是一个函数指针 */</span><br>result = calc(add, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure></li><li><p>函数指针作为返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>), <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><br><span class="hljs-comment">/* select 是一个函数.其参数为 char op.</span><br><span class="hljs-comment">** 返回值为一个函数指针.指向的函数类型为 int (*)(int, int) */</span><br><span class="hljs-type">int</span> (*select(<span class="hljs-type">char</span> op))(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><ul><li><code>select</code> 先与 <code>(char op)</code> 结合,成为一个函数,参数为 <code>char op</code></li><li>去掉 <code>*select(char op)</code> 后,剩余 <code>int (*)(int, int)</code> 成为 <code>select</code> 的返回值</li></ul></li></ol><h3 id="5-3-内联函数"><a href="#5-3-内联函数" class="headerlink" title="5.3 内联函数"></a>5.3 内联函数</h3><ol><li><p>宏与内联</p><ul><li><p>考虑下面的宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(x) ((x) * (x))</span><br></code></pre></td></tr></table></figure></li><li><p>若以下述方式调用该宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">result = SQUARE(i++);<br></code></pre></td></tr></table></figure></li><li><p><code>SQUARE(i++)</code> 将展开为 <code>((i++) * (i++))</code>,进行了两次自增操作,与预期不同</p></li></ul></li><li><p><strong>内联函数: 指定一个函数为内联函数,编译器像处理宏定义的方式,将整个内联函数直接在 <code>main</code> 函数中展开</strong></p></li><li><p>内联函数的定义方式: 在函数定义的头前加上关键字 <code>inline</code></p></li><li><p>使用内联函数会导致代码编译的时间增加,但节省函数调用的时间消耗</p></li><li><p><strong>编译器会自动将一些常用的函数优化为内联函数</strong></p></li></ol><h2 id="6-结构体"><a href="#6-结构体" class="headerlink" title="6 结构体"></a>6 结构体</h2><h3 id="6-1-结构体定义"><a href="#6-1-结构体定义" class="headerlink" title="6.1 结构体定义"></a>6.1 结构体定义</h3><ol><li><p>结构体定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名称 &#123;</span><br>    结构体成员<span class="hljs-number">1</span>;<br>    结构体成员<span class="hljs-number">2</span>;<br>    ...<br>    结构体成员n;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>关键字 <code>struct</code> 是必要的,结构体的声明需要分号</li><li><strong>结构体名称约定第一个字符使用大写</strong></li></ul></li><li><p>结构体声明(关键字 <code>struct</code> 是必要的)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名称 结构体变量名;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>访问结构体成员: 使用 <code>.</code> 运算符访问结构体变量</strong></p></li><li><p>初始化结构体</p><ul><li>在定义时即可对其初始化.形式与初始化数组一样:<br>用大括号包含所有成员值,逗号作为分隔符.此时需要将各个成员类型对号入座</li><li>C99 新增特性可以在初始化时指定成员值</li><li>数组初始化时指定成员方式为 <code>[下标]</code>.对应的,结构体初始化时使用 <code>.成员名</code> 的方式指定成员值</li><li><strong>未初始化的成员将被自动初始化.数值型初始化为 0 ,字符型初始化为 <code>&#39;\0&#39;</code></strong></li></ul></li><li><p><strong>编译器会对结构体的成员进行内存对齐.让 CPU 可以更快地读取 &#x2F; 处理数据</strong></p></li><li><p>结构体嵌套后仍使用 <code>.</code> 运算符访问结构体变量.只不过要用多次 <code>.</code> 运算符一直找到最底层的成员</p></li><li><p>结构体与数组</p><ul><li><p>结构体数组仍是数组,其成员为结构体类型的数据</p></li><li><p>结构体数组的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名称 数组名[长度];</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="6-2-结构体与指针"><a href="#6-2-结构体与指针" class="headerlink" title="6.2 结构体与指针"></a>6.2 结构体与指针</h3><ol><li><p><strong>结构体指针: 指向结构体的指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Book</span> *<span class="hljs-title">pt</span>;</span>  <span class="hljs-comment">// pt 是一个指向 struct Book 类型的指针</span><br></code></pre></td></tr></table></figure><ul><li><p>数组名是指向第一个元素的地址,但结构体变量名并非指向该结构体的地址</p></li><li><p>结构体的地址需要通过 <code>&amp;</code> 运算符获取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Book</span> <span class="hljs-title">book</span>;</span><br>pt = &amp;book;  <span class="hljs-comment">// 获取结构体变量的地址</span><br></code></pre></td></tr></table></figure></li><li><p><strong>结构体指针访问结构体成员有两种方法(一般使用 <code>-&gt;</code>,简洁直观)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">(*结构体指针).成员名  <span class="hljs-comment">// 先解引用,再访问成员</span><br>结构体指针 -&gt; 成员名  <span class="hljs-comment">// 使用箭头符号,隐含这是一个指针</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>传递结构体信息: 结构变量可以直接赋值.作为参数传递时也可以直接传递</p></li><li><p>传递指向结构体变量的指针</p><ul><li>直接传递结构体时,如果结构体变量很大,将会导致函数调用过程中时间和空间的开销相对大</li><li>传递结构体指针可以避免这种开销</li></ul></li></ol><h3 id="6-3-typedef"><a href="#6-3-typedef" class="headerlink" title="6.3 typedef"></a>6.3 <code>typedef</code></h3><ol><li><p>给数据类型起别名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> integer;<br>integer a;<br></code></pre></td></tr></table></figure></li><li><p><strong><code>typedef</code> 与 <code>#define</code> 的区别</strong></p><ul><li><p>顺序并不一样(但可统一为前一个对象作为操作对象,后一个对象为操作后的结果)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> integer int  <span class="hljs-comment">// 将 integer 替换为 int</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> integer; <span class="hljs-comment">// 给 int 起别名为 integer</span><br></code></pre></td></tr></table></figure></li><li><p>有修饰符时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 程序编译通过. integer 被替换为 int,a = 4294967295</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> integer int</span><br><span class="hljs-type">unsigned</span> integer a = <span class="hljs-number">-1</span>; <br><br><span class="hljs-comment">// 程序编译报错</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> integer;<br><span class="hljs-type">unsigned</span> integer a = <span class="hljs-number">-1</span>; <br></code></pre></td></tr></table></figure></li><li><p>定义指针变量时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 该语句预处理后替换为 int *a, b</span><br><span class="hljs-comment">** 此时 a 类型为int *, b 类型为 int */</span><br>ptrInt a, b;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ptrInt int *</span><br><br><span class="hljs-comment">/* a, b 类型均为 int *  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> * ptrInt;<br>ptrInt a, b; <br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>与结构体搭配(数据结构的链表需要该技巧)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 将 struct Date   赋予别名 DATE</span><br><span class="hljs-comment">** 将 struct Date * 赋予别名 PDATE */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Date</span> &#123;</span><br>    <span class="hljs-type">int</span> year;<br>    <span class="hljs-type">int</span> month;<br>    <span class="hljs-type">int</span> day;<br>&#125; DATE, *PDATE;<br><br>DATE date;    <span class="hljs-comment">// 定义结构体不再需要关键字 struct</span><br>PDATE pdate;  <span class="hljs-comment">// 定义的是 结构体指针</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="6-4-简化类型声明"><a href="#6-4-简化类型声明" class="headerlink" title="6.4 简化类型声明"></a>6.4 简化类型声明</h3><ol><li><p>数组指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*ptr)[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*PTR2ARRAY)</span>[3];<br></code></pre></td></tr></table></figure></li><li><p>函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*PTR2FUN)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure></li><li><p>指针函数与数组指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* array 是一个指针数组,其元素指向指针函数.指针函数参数为 int,返回值为 int *  */</span><br><span class="hljs-type">int</span> *(*<span class="hljs-built_in">array</span>[<span class="hljs-number">3</span>])(<span class="hljs-type">int</span>);<br><br><span class="hljs-comment">/* 直接使用 typedef 会导致数组长度固定为3, 因此分成两句 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> *(*PRT2FUN)(<span class="hljs-type">int</span>);  <span class="hljs-comment">// PRT2FUN 是一个指针,指向指针函数</span><br>PRT2FUN <span class="hljs-built_in">array</span>[<span class="hljs-number">3</span>];              <span class="hljs-comment">// array 是一个拥有3个元素的数组,元素类型为 PRT2FUN</span><br></code></pre></td></tr></table></figure></li><li><p>参数为函数指针,返回值为函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*funA(<span class="hljs-type">int</span>, <span class="hljs-type">void</span> (*funB)(<span class="hljs-type">int</span>)))(<span class="hljs-type">int</span>);<br><span class="hljs-comment">/* funA 是一个指针函数.有两个参数 int, funB</span><br><span class="hljs-comment">** funB 是一个函数指针,指向的类型为 void (int)</span><br><span class="hljs-comment">** 分析 funA 的返回值: 先化简 void (*funA(参数))(int).</span><br><span class="hljs-comment">** 返回值类型为 void (int),即函数指针 */</span><br><br><span class="hljs-comment">/* 提取出共同点,可以有更为清晰的定义方式 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*PTR2FUN)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-comment">// PTR2FUN 是一个函数指针</span><br>PTR2FUN <span class="hljs-title function_">funA</span><span class="hljs-params">(<span class="hljs-type">int</span>, PTR2FUN)</span>;<br></code></pre></td></tr></table></figure></li><li><p>以显式的方式调用首地址为0的子例程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(*( <span class="hljs-type">void</span> (*)() ) <span class="hljs-number">0</span>)()<br></code></pre></td></tr></table></figure><ul><li><p>先考虑 <code>(* 0)();</code></p><ul><li>本意: 想对地址0进行解引用,然后调用函数</li><li>实际: 无法生效,因为 <code>*</code> 需要一个指针作为操作数,且这里还要求是函数指针</li><li>解决方法: 先将 0 强转为函数指针</li></ul></li><li><p>考虑 <code>(void(*)())</code>.这是就是需要的类型转换符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*funcptr)</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 函数指针</span><br>(*(funcptr)<span class="hljs-number">0</span>)();  <span class="hljs-comment">// 先将0强转为函数指针,然后调用该函数</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="6-5-union"><a href="#6-5-union" class="headerlink" title="6.5 union"></a>6.5 union</h3><ol><li><p><strong>共用体可以将多个成员存储在同一空间中,它们拥有相同的起始地址.最终存储的值取决最后赋值的变量</strong></p></li><li><p>声明方式: 与 struct 类似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> 共用体名称 &#123;</span><br>    共用体成员<span class="hljs-number">1</span>;<br>    共用体成员<span class="hljs-number">2</span>;<br>    ...<br>    共用体成员n;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>共用体的定义与访问方式均与结构体类似</p></li><li><p>初始化共用体: 不能同时对所有成员都初始化</p></li></ol><h3 id="6-6-enum"><a href="#6-6-enum" class="headerlink" title="6.6 enum"></a>6.6 enum</h3><ol><li><p>如果一个变量只有几种可能的值,可以将其定义为枚举类型</p></li><li><p>枚举类型声明方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> 枚举类型名称 &#123;</span><br>    枚举值名称<span class="hljs-number">1</span>, <br>    枚举值名称<span class="hljs-number">2</span>,<br>    ...<br>    枚举值名称n,<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>枚举变量定义方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> 枚举类型名称 枚举变量名;</span><br></code></pre></td></tr></table></figure><ul><li><strong>枚举值名称可以直接像标识符那样命名,称为枚举常量</strong></li><li><strong>默认情况下 枚举常量的值从 0 开始,往后依次递增</strong></li><li>如果不希望从 0 开始,可以在声明时赋值,往后依然递增</li><li>枚举变量允许自增运算,而 C++ 中不允许</li><li>枚举常量的值和名称在编译时已经指定,不再允许修改</li></ul></li></ol><h3 id="6-7-位域"><a href="#6-7-位域" class="headerlink" title="6.7 位域"></a>6.7 位域</h3><ol><li><p><strong>位域将1字节(Byte)的二进制位划分为几个不同的区域,并指定每个区域的位数</strong></p></li><li><p>每个域有一个域名,允许在程序中按域名进行单独的操作</p></li><li><p>使用位域的方法: 在定义结构体时,在结构体成员使用冒号: 和数字表示该成员所占的位数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span> &#123;</span><br>    <span class="hljs-comment">// type [member_name] : width;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a : <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> b : <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> c : <span class="hljs-number">2</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>位域的宽度不能超过它所依附的数据类型的长度.成员变量是有类型的,位域的宽度被该类型所限制</strong></p></li><li><p>位域成员可以没有名称.但需要给出数据类型和位宽.用于填充或调整成员的位置,不能使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> :<span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure></li></ol><h2 id="7-位操作"><a href="#7-位操作" class="headerlink" title="7 位操作"></a>7 位操作</h2><h3 id="7-1-移位运算符"><a href="#7-1-移位运算符" class="headerlink" title="7.1 移位运算符"></a>7.1 移位运算符</h3><ol><li><p>位操作</p><ul><li><strong>C 语言并未明确规定1字节(Byte)的尺寸.C 语言对字节的定义为:</strong><br><strong>可寻址的数据存储单位,其尺寸必须可以容纳运行环境的基本字符集的任何成员</strong></li><li>C 语言仅明确规定了 <code>char</code> 类型占用 1 Byte.其他类型仅给出相对的大小关系.具体尺寸由环境约束</li><li>编译器规定了 1 Byte 的位数.写在头文件 <code>&lt;limits.h&gt;</code> 中</li><li>C 语言允许通过位域的形式来按位存取,且允许精确到 位 的运算</li></ul></li><li><p>左移运算符</p><ul><li><p>左移运算符拥有两个操作数</p></li><li><p>左侧表示被移位的数据,右侧指定移动的位数</p></li><li><p><strong>左移移出的位数全部舍弃.右侧用 0 填充</strong></p></li><li><p>将整数左移 N 位相当于乘以 $2^N$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">result = <span class="hljs-number">0b1001010</span> &lt;&lt; <span class="hljs-number">2</span>;<br><span class="hljs-comment">// result = 0b00101000</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>右移运算符</p><ul><li><p>右移运算符拥有两个操作数</p></li><li><p>左侧表示被移位的数据,右侧指定移动的位数</p></li><li><p><strong>右移移出的位数全部舍弃.左侧用 0 填充(如果是负数,用1填充.因此负数右移永远不会为0)</strong></p></li><li><p>将整数右移 N 位相当于除以 $2^N$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">result = <span class="hljs-number">0b11001010</span> &gt;&gt; <span class="hljs-number">2</span>;<br><span class="hljs-comment">// result = 0b00110010</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>左移运算符,右移运算符均可与赋值号结合</p></li><li><p>未定义行为</p><ul><li>左移 &#x2F; 右移运算符右侧指定移动的位数为 负数 时</li><li>右侧指定移动的位数 大于 左侧操作数的最大宽度时</li></ul></li></ol><h3 id="7-2-掩码"><a href="#7-2-掩码" class="headerlink" title="7.2 掩码"></a>7.2 掩码</h3><ol><li><p>掩码</p><ul><li><strong>掩码是一串二进制数字,通过与目标数字的按位操作,达到屏蔽指定位实现需求</strong></li><li>掩码本身的值一般将想要操作的对象位 置1,不变的对象位 置0</li></ul></li><li><p><strong>判断指定位</strong>: 将源数据对指定的掩码进行按位与 <code>&amp;</code>.判断结果是否与掩码本身相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((value &amp; mask) == mask) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>打开位</strong>: 将源数据对指定的掩码进行按位或 <code>|</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">value |= mask;<br></code></pre></td></tr></table></figure></li><li><p><strong>关闭位</strong>: 将源数据对取反后的掩码进行按位与 <code>&amp;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">value &amp;= ~mask;<br></code></pre></td></tr></table></figure></li><li><p><strong>转置位</strong>: 将源数据对指定的掩码进行按位异或 ^</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">value ^= mask;<br></code></pre></td></tr></table></figure></li></ol><h2 id="8-CLion-远程开发"><a href="#8-CLion-远程开发" class="headerlink" title="8 CLion 远程开发"></a>8 CLion 远程开发</h2><h3 id="8-1-CLion-连接-Linux"><a href="#8-1-CLion-连接-Linux" class="headerlink" title="8.1 CLion 连接 Linux"></a>8.1 CLion 连接 Linux</h3><ol><li><p>新建一个项目,然后在 设置 -&gt; 工具链 中添加 <code>远程主机</code></p><p><img src="/2021/09/01/Computer/C-Language-Basic/8-Clion-tool-chain.png"></p></li><li><p>在 <code>凭据</code> 中添加 SSH 配置</p><p><img src="/2021/09/01/Computer/C-Language-Basic/8-Clion-SSH.png"></p></li><li><p>如果成功连接,则 <code>凭据</code> 会显示已连接</p><p><img src="/2021/09/01/Computer/C-Language-Basic/8-Clion-pass.png"></p></li><li><p>构建工具需要远程主机已安装 CMake(下面是 Ubuntu 安装 CMake 的方法)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update                   # 更新系统包<br>sudo apt install build-essential  # 安装依赖软件包<br>wget https://cmake.org/files/v3.20/cmake-3.20.0.tar.gz  # 下载 CMake 源码<br>tar -zxvf cmake-3.20.0.tar.gz     # 解压源代码<br><br>cd cmake-3.20.0<br>./configure         # 配置 CMake<br>make -j$(nproc)     # 编译 CMake<br>sudo make install   # 安装 CMake<br>cmake --version     # 验证安装<br><br>sudo apt install cmake  # 一条指令安装<br></code></pre></td></tr></table></figure></li><li><p>如果远程主机安装了 CMake,则构建工具部分会自动检测</p><p><img src="/2021/09/01/Computer/C-Language-Basic/8-Clion-make-tool.png"></p></li><li><p>远程主机安装 GDB</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install gdb<br></code></pre></td></tr></table></figure><p><img src="/2021/09/01/Computer/C-Language-Basic/8-Clion-GDB.png"></p></li></ol><h3 id="8-2-远程项目部署"><a href="#8-2-远程项目部署" class="headerlink" title="8.2 远程项目部署"></a>8.2 远程项目部署</h3><ol><li><p>在 <code>设置 -&gt; 构建,执行,部署 -&gt; CMake</code> 进行添加</p><p><img src="/2021/09/01/Computer/C-Language-Basic/8-Clion-CMake-config.png"></p></li><li><p>代码存储位置</p><p><img src="/2021/09/01/Computer/C-Language-Basic/8-Clion-code-loc.png"></p></li><li><p>中文输出到控制台的乱码问题(根本在于 Windows 编码的混乱,将其默认编码改为 utf-8 根治)</p><ul><li><p>在 设置 -&gt; 编辑器 -&gt; 文件编码中,将编码全部选为 <code>UTF-8</code></p></li><li><p>按下 <code>Ctr + Shift + Alt + /</code>.进入注册表.取消勾选 <code>run.processes.with.pty</code></p><ul><li>这可能导致 <code>scanf</code> 和 <code>printf</code> 函数的输出顺序乱序. <code>scanf</code> 总会先执行 即使 <code>printf</code> 在前</li><li>通过执行 <code>fflush(stdout)</code> 语句,强制刷新缓冲区可解决问题</li></ul><p><img src="/2021/09/01/Computer/C-Language-Basic/8-Clion-run-processes-with-pty.png"></p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C 语言</tag>
      
      <tag>计算机</tag>
      
      <tag>Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
