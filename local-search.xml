<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git 使用</title>
    <link href="/2025/07/11/Git/Git/"/>
    <url>/2025/07/11/Git/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-使用"><a href="#Git-使用" class="headerlink" title="Git 使用"></a>Git 使用</h1><h2 id="1-Git"><a href="#1-Git" class="headerlink" title="1 Git"></a>1 Git</h2><h3 id="1-1-Git-安装"><a href="#1-1-Git-安装" class="headerlink" title="1.1 Git 安装"></a>1.1 Git 安装</h3><ol><li><p>在 <a href="https://git-scm.com/download">git 官网</a> 下载对应系统的安装包</p></li><li><p>安装: 一直下一步安装即可</p></li><li><p>检查安装是否成功: 在命令行中输入 <code>git -v</code>.如果出现版本信息,则说明安装成功</p></li><li><p>在 Windows 中,还会自动安装 <code>Git Bash</code>(在文件夹中右键即可看到)</p></li></ol><h3 id="1-2-Git-基础"><a href="#1-2-Git-基础" class="headerlink" title="1.2 Git 基础"></a>1.2 Git 基础</h3><ol><li><p>git 的使用方式分为</p><ul><li>命令行(最基本,最常见)</li><li>图形化界面(GUI)</li><li>IDE 插件&#x2F;扩展</li></ul></li><li><p>初始化操作</p><ul><li><p><strong>git 的所有命令均以 <code>git</code> 开头,后面再接具体的命令.如: <code>git init</code> 表示初始化仓库</strong></p></li><li><p>git 安装后需要进行配置用户名和邮箱,以便查看代码提交者(只需设置一次)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;用户名&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;用户邮箱&quot;</span><br>git config --list  <span class="hljs-comment"># 检查配置是否成功</span><br></code></pre></td></tr></table></figure></li><li><p>如果用户名参数包含空格,则需要使用双引号包裹</p></li><li><p><code>--global</code> 表示全局配置,对所有仓库有效.如果省略则表示本地配置,只对本地仓库有效</p></li></ul></li><li><p>新建仓库</p><ul><li><p>仓库 &#x2F; 版本库(Repository, 简称 Reop): 是一个文件目录,其中的文件被 <code>git</code> 管理</p></li><li><p>对仓库中文件的 修改, 删除, 添加操作都将被 <code>git</code> 追踪</p></li><li><p><strong>本地创建仓库</strong>: 在 <code>Git Bash</code> 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure></li><li><p>此时 <code>git</code> 将会创建一个 <code>.git</code> 的隐藏目录.用于存放仓库的数据(不要自己更改)</p></li><li><p><strong>从服务器克隆仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> url<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-3-Git-概念"><a href="#1-3-Git-概念" class="headerlink" title="1.3 Git 概念"></a>1.3 Git 概念</h3><ol><li><p>工作区域</p><ul><li><p><strong>工作区(Working Directory)</strong>: 实际操作的目录</p></li><li><p><strong>暂存区(Staging Area&#x2F;Index)</strong>: 临时存储区域.保存即将提交到 <code>git</code> 仓库的修改内容</p></li><li><p><strong>本地仓库(Local Repository)</strong>: 存储代码和版本信息的主要位置.包含完整的项目历史和元数据</p><p><img src="/2025/07/11/Git/Git/1-Git-workingArea.png"></p></li></ul></li><li><p>提交流程</p><ul><li><p>在对工作区的文件进行修改后,需要先提交到暂存区,然后将暂存区的修改提交到本地仓库</p></li><li><p>在上述过程中,可以使用 <code>git</code> 命令进行查看, 比较, 撤销修改</p></li><li><p><strong>添加: 从工作区 -&gt; 暂存区</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add<br></code></pre></td></tr></table></figure></li><li><p><strong>提交: 从暂存区 -&gt; 本地仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit<br></code></pre></td></tr></table></figure></li><li><p>在多次添加到暂存区后,到达需要增加版本的地步,就可以进行提交(push)</p></li></ul></li><li><p>文件状态</p><ul><li><p><strong>未跟踪(Untrack)</strong>: 新创建的,未被 <code>git</code> 管理的文件</p></li><li><p><strong>未修改(Unmodified)</strong>: 已经被 <code>git</code> 管理,但内容没有变化</p></li><li><p><strong>已修改(Modified)</strong>: 修改了文件,但未添加到暂存区</p></li><li><p><strong>已暂存(Staged)</strong>: 修改后,并添加到暂存区的文件</p><p><img src="/2025/07/11/Git/Git/1-Git-fileState.png"></p></li></ul></li></ol><h3 id="1-4-提交"><a href="#1-4-提交" class="headerlink" title="1.4 提交"></a>1.4 提交</h3><ol><li><p>添加与提交</p><ul><li><strong><code>git status</code>: 展示目录中的文件的状态</strong></li><li><code>git add fileName</code>: 将指定的 <code>fileName</code> 文件添加到暂存区.还可以接收目录名参数</li><li><code>git commit -m &quot;提交信息备注&quot;</code>: 将暂存区中的修改提交到本地仓库(注意不会提交工作区的文件)</li><li><code>git log</code>: 查看提交记录.包含: 提交ID(唯一的16进制数), 作者, 时间, 备注信息</li></ul></li><li><p>版本穿梭</p><ul><li><p><strong><code>git reset --模式参数 版本号</code>: 穿梭到指定的版本</strong></p><p><img src="/2025/07/11/Git/Git/1-Git-Reset.png"></p></li><li><p><code>soft</code>: 保留工作区和暂存区的内容</p><ul><li>当回退低版本时,高版本添加的文件将被保留到暂存区</li><li>此时对暂存区的这些文件进行修改,就可以再次执行提交</li></ul></li><li><p><code>hard</code>: 不保留工作区和暂存区的内容.这将导致高版本才添加的文件被删除(谨慎使用)</p></li><li><p><strong><code>mixed</code>: 默认参数.只保留工作区中的内容</strong></p><ul><li>当回退低版本时,高版本添加的文件将被保留到工作区,而非暂存区</li><li>在工作区中对内容进行修改后,再进行 添加, 提交 操作</li></ul></li><li><p>使用场景: 多次 <code>commit</code> 后,想要将其合并为一次 <code>commit</code>: 先回退,然后提交</p></li></ul></li></ol><h3 id="1-5-差异"><a href="#1-5-差异" class="headerlink" title="1.5 差异"></a>1.5 差异</h3><ol><li><p><strong>查看差异</strong>: 后续可以使用 IDE 更美观地查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff           <span class="hljs-comment"># 工作区 vs 暂存区</span><br>git diff HEAD      <span class="hljs-comment"># 工作区 + 暂存区 vs 本地仓库</span><br>git diff --cached  <span class="hljs-comment"># 暂存区 vs 本地仓库</span><br>git diff --staged  <span class="hljs-comment"># 暂存区 vs 本地仓库</span><br><br>git diff &lt;commit_hash&gt; &lt;commit_hash&gt;  <span class="hljs-comment"># 比较指定两次提交的差异</span><br>git diff HEAD~ HEAD                   <span class="hljs-comment"># 上一次提交 vs 本地仓库</span><br>git diff &lt;branch_hash&gt; &lt;branch_hash&gt;  <span class="hljs-comment"># 比较两个分支的差异</span><br></code></pre></td></tr></table></figure><p><img src="/2025/07/11/Git/Git/1-Git-diff.png"></p></li><li><p><strong>删除文件</strong>: 删除工作区和暂存区中的指定文件.但版本库不变</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> fileName<br></code></pre></td></tr></table></figure></li><li><p><strong>忽略文件</strong>: 通过 <code>.gitignore</code> 文件来指定忽略特定的文件</p><p><img src="/2025/07/11/Git/Git/1-Gitignore.png"></p><ul><li>新建一个 <code>.gitignore</code> 文件,在其中存储想要被忽略的文件名</li><li>会从上往下逐行匹配,每行表示一个忽略模式</li></ul></li><li><p><strong><code>.gitignore</code> 匹配规则: 使用标准的 Blob 模式匹配</strong></p><ul><li>文件可以使用通配符.如 <code>*.log</code> 表示忽略所有后缀为 log 的文件</li><li>文件夹需要以 <code>/</code> 结尾</li><li>以 <code>#</code> 开头的行表示注释</li></ul></li></ol><h3 id="1-6-分支"><a href="#1-6-分支" class="headerlink" title="1.6 分支"></a>1.6 分支</h3><ol><li><p>分支(Branch): 代码的不同版本</p><ul><li><strong><code>git branch</code>: 查看分支</strong>.其中 <code>*</code> 表示当前所处的分支</li><li><strong><code>git branch name</code>: 创建新分支</strong>.创建新分支后并不会自动切换分支</li><li><strong><code>git switch name</code>: 切换分支</strong>.同时工作区的文件会被自动替换为目标分支的状态</li><li><strong><code>git merge name</code>: 将 <code>name</code> 分支合并到当前分支</strong>.该指令会执行一次提交,因此需要输入提交信息</li><li><code>git log --graph --oneline --decorate --all</code>: 查看分支图</li><li><code>git branch -d name</code>: 删除指定的已合并分支</li></ul></li><li><p>合并冲突</p><ul><li><strong>当合并分支时,出现同一文件被不同分支修改时,会出现冲突,需要手动解决冲突</strong></li><li>此时,使用 <code>git status</code> 命令查看冲突文件的列表.<code>git diff</code> 可以查看冲突的具体内容</li></ul></li><li><p>变基(Rebase): </p><ul><li><strong><code>git rebase main</code>: 将当前分支变基到 <code>main</code> 分支</strong><ul><li>每个分支都有一个 <code>head</code> 指针,指向当前分支的最新提交记录</li><li>当执行变基时,将寻找两个分支的共同的祖先节点</li><li>然后将当前分支的祖先节点之后的提交移植到目标分支的后面</li></ul></li><li>变基使得分支始终保持简单的线性结构.但破坏了原分支的提交记录.不要在公共分支 <code>rebase</code></li><li>分支合并不会破坏提交记录,方便回溯.但产生了额外的节点</li></ul></li><li><p>分支的最佳实践</p><ul><li><p>保证 <code>master</code> 分支中的代码是可发布的.不允许直接修改,只能合并,每当合并时生成一个版本号</p></li><li><p>首先在主分支中分离出自己的分支进行开发测试,先在本地进行提交</p></li><li><p>然后发起推送请求(PR).经过 Review 之后,将该分支合并到主分支中</p><p><img src="/2025/07/11/Git/Git/1-Git-GitHubFlow.png"></p></li></ul></li></ol><h3 id="1-7-关联-github-仓库"><a href="#1-7-关联-github-仓库" class="headerlink" title="1.7 关联 github 仓库"></a>1.7 关联 github 仓库</h3><ol><li><p>要关联本地仓库与远程仓库,首先需要设置 SSH 密钥</p><ul><li><p>检查主机是否已经存在 ssh key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~/.ssh  # 切换到.ssh目录<br>ls         # 如果有 id_rsa(私钥) id_rsa.pub(公钥) 文件,说明已经有 ssh key<br></code></pre></td></tr></table></figure></li><li><p>如果没有 ssh key.则需要先生成(如果有 ssh key.则直接获取)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -b 4096  # 生成 rsa 密钥,大小为 4096<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在 GitHub 账号中添加公钥</p><ul><li><p>回到 GitHub,点击头像 -&gt; <code>Settings</code> -&gt; <code>SSH and GPG keys</code> -&gt; <code>New SSH key</code></p><p><img src="/2025/07/11/Git/Git/1-Git-github-sshkey.png"></p></li><li><p>将 <code>id_rsa.pub</code> 文件中的内容复制到 Key 中即可</p></li><li><p>验证设置是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br><span class="hljs-meta prompt_"># </span><span class="language-bash">成功将显示: Hi Fxs21! You<span class="hljs-string">&#x27;ve successfully authenticated...</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>完成 SSH 的设置后,可以直接使用 SSH 进行 <code>git clone</code> 操作</p></li><li><p>本地仓库和远程仓库是不同的仓库.想要将两者的文件同步.需要 <code>git pull, git push</code> 指令</p><p><img src="/2025/07/11/Git/Git/1-Git-push.png"></p></li><li><p>此时,完成了关联本地仓库与远程仓库的准备工作.先在 github 上创建一个新仓库.然后进行操作</p><ul><li><code>git remote add &lt;shortname&gt; &lt;url&gt;</code>: 将本地仓库关联到远程仓库.同时创建了远程库的别名</li><li><code>git remote -v</code>: 查看当前仓库对应的远程仓库的别名和地址(默认别名 <code>shortname == origin</code>)</li><li><code>git branch -M main</code>: 指定分支名为 <code>main</code></li><li><strong><code>git push -u origin main</code>: 将本地的 main 分支与远程仓库 <code>origin</code> 的 <code>main</code> 分支关联.并推送</strong></li><li><strong><code>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code>: 拉取远程仓库中的分支.默认为 <code>origin</code> 的 <code>main</code> 分支</strong></li></ul></li></ol><h2 id="2-GitHub-Pages"><a href="#2-GitHub-Pages" class="headerlink" title="2 GitHub Pages"></a>2 GitHub Pages</h2><h3 id="2-1-创建-github-仓库"><a href="#2-1-创建-github-仓库" class="headerlink" title="2.1 创建 github 仓库"></a>2.1 创建 github 仓库</h3><ol><li><p><a href="https://github.com/">github</a>: 代码托管平台</p></li><li><p>创建仓库: 名称格式为 <code>username.github.io</code></p><p><img src="/2025/07/11/Git/Git/1-Git-githubCreateRepo.png"></p></li><li><p>在 <code>settings</code> 中找到 <code>Pages</code>.此时 <code>Source</code> 为空.因此需要上传静态页面</p></li></ol><h3 id="2-2-克隆仓库到本地"><a href="#2-2-克隆仓库到本地" class="headerlink" title="2.2 克隆仓库到本地"></a>2.2 克隆仓库到本地</h3><ol><li><p>下载 <code>github desktop</code>,并与 github 账号关联.然后将创建的仓库克隆到本地</p><p><img src="/2025/07/11/Git/Git/2-Git-githubDesktop.png"></p></li><li><p>将需要上传的文件全部复制到本地仓库路径中(需要填写描述信息 Summary)</p><p><img src="/2025/07/11/Git/Git/2-Git-githubDesktop-file.png"></p></li><li><p>然后点击上方的 <code>Publish branch</code>.将本地仓库上传到 <code>github</code></p></li></ol><h3 id="2-3-公网访问项目"><a href="#2-3-公网访问项目" class="headerlink" title="2.3 公网访问项目"></a>2.3 公网访问项目</h3><ol><li><p>此时再次进入 github. 在 <code>settings</code> 中找到 <code>Pages</code>.此时 <code>Source</code> 就有了 <code>master</code> 分支</p><p><img src="/2025/07/11/Git/Git/2-Git-githubSource.png"></p></li><li><p>显示 Your site is live at <a href="https://fxs21.github.io/">https://fxs21.github.io/</a>: 表示成功部署可以在网页中打开</p><p><img src="/2025/07/11/Git/Git/2-Git-shark.png"></p></li></ol><h3 id="2-4-开源项目的结构"><a href="#2-4-开源项目的结构" class="headerlink" title="2.4 开源项目的结构"></a>2.4 开源项目的结构</h3><ol><li><p>开源项目: jQuery 为例</p><p><img src="/2025/07/11/Git/Git/2-Git-jQuery.png"></p></li></ol><h2 id="3-IDE-集成-Git"><a href="#3-IDE-集成-Git" class="headerlink" title="3 IDE 集成 Git"></a>3 IDE 集成 Git</h2><h3 id="3-1-配置-Git"><a href="#3-1-配置-Git" class="headerlink" title="3.1 配置 Git"></a>3.1 配置 Git</h3><ol><li><p>以 Pycharm 为例.需要先配置 Git</p><ul><li><p>需要给 Pycharm 指出 Git 的安装目录.显示出版本信息表示配置成功</p></li><li><p><kbd>设置</kbd> -&gt; <kbd>版本控制</kbd> -&gt; <kbd>Git</kbd> -&gt; 选择 Git 可执行文件路径为 <code>Git\cmd\git.exe</code></p><p><img src="/2025/07/11/Git/Git/3-Git-PycharmSet.png"></p></li></ul></li><li><p>初始化 git: 点击左下角的 <kbd>Git</kbd> -&gt; <kbd>创建 Git 仓库...</kbd>.选择创建仓库的目录后确认即可</p></li><li><p>git 界面</p><p><img src="/2025/07/11/Git/Git/3-Git-Pycharm.png"></p></li></ol><h3 id="3-2-Git-操作"><a href="#3-2-Git-操作" class="headerlink" title="3.2 Git 操作"></a>3.2 Git 操作</h3><ol><li><p>对现有的 Git 仓库进行操作</p><ul><li><strong>获取网络上的 Git 仓库</strong>: 在编辑器右键 -&gt; <kbd>Git</kbd> -&gt; <kbd>克隆...</kbd>.填写 <code>URL</code> 和 <code>本地目录</code>即可</li><li><strong>新建分支</strong>: 点击左上角的 <kbd>VCS 微件</kbd> -&gt; <kbd>新建分支</kbd>.输入新分支的名称,进行创建</li><li><strong>提交修改</strong>: 在新分支修改文件后,IDE 将会检测到修改<br>点击左侧的 <kbd>提交</kbd>.选择需要进行版本管理的文件.在下方的<kbd>提交消息</kbd>中添加更改信息即可<br>点击<kbd>提交消息</kbd>的右下角的设置,勾选<kbd>格式化代码</kbd>将会根据代码样式自动编辑文件</li><li><strong>修正</strong>: 如果忘记添加某些需要提交的文件,可以勾选<kbd>修正</kbd>再次提交</li><li><strong>推送到远程仓库</strong>: <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>K</kbd> 打开推送对话框.即可推送提交</li></ul></li><li><p>查看项目历史记录</p><ul><li>点击左下的 <kbd>Git</kbd>.可以看到 git 分支.提交记录可以进行筛选,右键可以对其进行多种操作</li><li>工具栏右侧可以看到相关信息.双击提交文件树中的文件可以查看具体差异</li><li><kbd>与本地比较</kbd> 也可以对比文件的差异.其中绿色表示无差异,蓝色表示存在差异</li></ul></li><li><p>功能分支工作流</p><ul><li><p>完成分支工作后准备推送到远程.需要检查是否与 Main 分支中已提交的内容产生冲突</p><p><img src="/2025/07/11/Git/Git/3-Git-Branch01.png"></p></li><li><p>签出 <code>Main</code> 分支: 点击左上角的 <kbd>VCS 微件</kbd> -&gt; 选中<kbd>Main</kbd> -&gt; <kbd>签出</kbd></p></li><li><p>更新 <code>Main</code> 分支: <kbd>Ctrl</kbd><kbd>T</kbd>打开<code>更新项目</code>对话框进行更新.此时 Main 分支可能已经作出更改:</p><p><img src="/2025/07/11/Git/Git/3-Git-Branch02.png"></p></li><li><p><strong>变基</strong>: 将提交放在他人的修改之后可能更加合适,此时就需要进行变基<br>点击左上角的 <kbd>VCS 微件</kbd> -&gt; 选中<kbd>feature</kbd> -&gt; <kbd>签出并变基到 Main</kbd></p><p><img src="/2025/07/11/Git/Git/3-Git-Branch03.png"></p></li><li><p><strong>更新到远程仓库</strong>: 右键<code>HEAD</code>,选择<kbd>推送</kbd>.此时由于本地的<code>feature</code>分支 变基后与远程冲突<br>因此,需要使用<kbd>强制推送</kbd>(慎重使用)</p></li></ul></li></ol><h3 id="3-3-设置-GitHub-账号"><a href="#3-3-设置-GitHub-账号" class="headerlink" title="3.3 设置 GitHub 账号"></a>3.3 设置 GitHub 账号</h3><ol><li><p><kbd>文件</kbd> -&gt; <kbd>设置</kbd> -&gt; <kbd>版本控制</kbd> -&gt; <kbd>GitHub</kbd> -&gt; <kbd>添加账号</kbd></p><p><img src="/2025/07/11/Git/Git/3-Git-github.png"></p></li><li><p>分享到 Github: <kbd>Git</kbd> -&gt; <kbd>GitHub</kbd> -&gt; <kbd>在 GitHub 上共享项目</kbd></p></li><li><p><code>clone</code>: 在首页 -&gt; <kbd>从VCS获取</kbd> -&gt; <kbd>仓库URL</kbd></p><p><img src="/2025/07/11/Git/Git/3-Git-clone.png"></p></li><li><p><code>push</code>: 默认使用 HTTPS.因此需要修改为 SSH.别名也需要修改,否则会冲突</p><p><img src="/2025/07/11/Git/Git/3-Git-push-1.png"></p></li><li><p><code>pull</code>: 注意在修改代码之前,应该保证代码是最新版本.因此需要先进行 <code>pull</code></p><p><img src="/2025/07/11/Git/Git/3-Git-pull.png"></p></li></ol><h2 id="4-hexo"><a href="#4-hexo" class="headerlink" title="4 hexo"></a>4 hexo</h2><h3 id="4-1-安装-hexo"><a href="#4-1-安装-hexo" class="headerlink" title="4.1 安装 hexo"></a>4.1 安装 <a href="https://hexo.io/zh-cn/">hexo</a></h3><ol><li><p><code>git</code> 配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;fxs&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;yshuang68@163.com&quot;</span><br>git config --list<br></code></pre></td></tr></table></figure></li><li><p>安装 NodeJS: <a href="https://nodejs.org/en">官网下载</a>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">node -v  # 验证安装<br>npm config set prefix &quot;D:\code\npm_path&quot;  # 配置 npm 的全局安装路径<br></code></pre></td></tr></table></figure></li><li><p>安装 <code>hexo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g  <span class="hljs-comment"># 安装 hexo</span><br>hexo -v                  <span class="hljs-comment"># 验证安装</span><br></code></pre></td></tr></table></figure></li><li><p>初始化 <code>hexo</code>(新建一个空目录,然后使用 <code>git bash</code> 打开)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init  <span class="hljs-comment"># 从 github 拉取代码</span><br>git init   <span class="hljs-comment"># 初始化 git 仓库</span><br></code></pre></td></tr></table></figure></li><li><p><code>hexo</code> 的 hello world</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s<br></code></pre></td></tr></table></figure><ul><li><p>打开网址 <a href="http://localhost:4000/.%E8%83%BD%E7%9C%8B%E5%88%B0">http://localhost:4000/.能看到</a> hello world 网页表示配置成功</p><p><img src="/2025/07/11/Git/Git/4-hexo-hello-world.png"></p></li></ul></li></ol><h3 id="4-2-hexo-部署"><a href="#4-2-hexo-部署" class="headerlink" title="4.2 hexo 部署"></a>4.2 hexo 部署</h3><ol><li><p>配置 SSH 免密登录</p><ul><li><p>先检查是否已经生成过密钥(<code>PowerShell </code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls ~\.ssh\id_rsa.pub  # 查看是否已经生成过密钥<br>cat ~\.ssh\id_rsa.pub # 查看生成的密钥(复制输出的内容.以 ssh-rsa AAA... 开头)  <br></code></pre></td></tr></table></figure></li><li><p>若没有生成过则生成密钥(默认保存路径为 <code>C:\Users\你的用户名\.ssh\id_rsa</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -b 4096<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在 GitHub 上添加公钥(参考 [1.7章](# 1.7 关联 github 仓库))</p></li><li><p>安装部署插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li><li><p>配置 hexo 上传的地址(打开 <code>_config.yml</code> 文件,在最后添加内容.<strong>注意这里的配置决定了仓库地址</strong>)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">&#x27;git&#x27;</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:Fxs21/Fxs21.github.io.git</span><br></code></pre></td></tr></table></figure></li><li><p>使用 hexo 命令将代码部署到远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl <span class="hljs-comment"># 清除文件</span><br>hexo g  <span class="hljs-comment"># 生成静态文件.路径为 ./public/</span><br>hexo d  <span class="hljs-comment"># 上传到服务器</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="4-3-hexo-配置"><a href="#4-3-hexo-配置" class="headerlink" title="4.3 hexo 配置"></a>4.3 hexo 配置</h3><ol><li><p><strong>更换主题</strong>: 在 <a href="https://hexo.io/themes/">Themes | Hexo</a> 选择合适的主题.这里以 <code>Fluid</code> 为例,根据 <a href="https://github.com/fluid-dev/hexo-theme-fluid">参考文档</a> 安装</p><ul><li><p>安装 <code>Fluid</code> 主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure></li><li><p>在博客目录下创建 <code>_config.fluid.yml</code> 文件</p></li><li><p>将 <code>./node_modules/hexo-theme-fluid/_config.yml</code> 的内容复制到 <code>_config.fluid.yml</code> 文件</p></li><li><p>更改默认的主题: 打开 <code>_config.yml</code> 文件,修改 <code>theme, language</code> 项</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>     <span class="hljs-comment"># 指定主题</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CH</span>  <span class="hljs-comment"># 指定语言</span><br></code></pre></td></tr></table></figure></li><li><p>创建关于页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about<br></code></pre></td></tr></table></figure></li><li><p>在 <code>./source/about/index.md</code> 文件中添加一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">layout: about<br></code></pre></td></tr></table></figure></li></ul></li><li><p>工作目录(初始化之后的目录)</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br><span class="hljs-string">|   ├── _drafts</span><br><span class="hljs-string">|   └── _posts</span><br>└── themes<br></code></pre></td></tr></table></figure><ul><li><strong><code>_config.yml</code>: 网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 文件.可以在此配置大部分的参数</strong></li><li><code>package.json</code>: 应用程序的信息. <a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> 渲染引擎 已默认安装</li><li><code>scaffolds</code>: 模板文件夹.新建文章时根据此文件创建</li><li><strong><code>source</code>: 存放用户资源</strong><ul><li>除 <code>_posts</code> 文件夹之外,开头命名为 <code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略</li><li>Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹,而其他文件会被拷贝过去</li></ul></li><li><code>themes</code>: 主题文件夹.Hexo 会根据主题来生成静态页面</li></ul></li><li><p><strong>站点配置</strong>: Hexo 博客目录下的 <code>_config.yml</code> 文件</p><ul><li><p>站点名称</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Shuang</span> <span class="hljs-string">blog</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">&#x27;Shuang blog&#x27;</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;Shuang blog&#x27;</span><br><span class="hljs-attr">keywords:</span> <span class="hljs-string">Shuang</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">Shuang</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">&#x27;Asia/Shuanghai&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>资源文件夹</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ul><li>启用后,资源图片将会被自动解析为其对应文章的路径</li><li>例如: <code>image.jpg</code> 位置为 <code>/2020/01/02/foo/image.jpg</code>.这表示它是 <code>/2020/01/02/foo/</code> 文章的一张资源图片</li><li><code>![](image.jpg)</code> 将会被解析为 <code>&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt;</code></li></ul></li></ul></li></ol><h3 id="4-4-Fluid-主题"><a href="#4-4-Fluid-主题" class="headerlink" title="4.4 Fluid  主题"></a>4.4 <a href="https://hexo.fluid-dev.com/docs/start/">Fluid </a> 主题</h3><ol><li><p>配置文件的修改</p><ul><li><strong>主题配置</strong>: <code>theme/fluid/_config.yml</code> 或者 <code>_config.fluid.yml</code> 文件</li></ul></li><li><p>Fluid 主题默认总体概览</p><p><img src="/2025/07/11/Git/Git/4-fluid-appearance.png"></p></li><li><p>主题字体</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 主题字体配置</span><br><span class="hljs-attr">font:</span><br>  <span class="hljs-attr">font_size:</span> <span class="hljs-string">16px</span><br>  <span class="hljs-attr">font_family:</span> <span class="hljs-string">consolas</span>  <span class="hljs-comment"># 使用 consolas 字体</span><br>  <span class="hljs-attr">letter_spacing:</span> <span class="hljs-number">0.</span><span class="hljs-string">02em</span><br>  <span class="hljs-attr">code_font_size:</span> <span class="hljs-number">85</span><span class="hljs-string">%</span><br></code></pre></td></tr></table></figure></li><li><p>导航栏左侧标题(默认为 <code>Fluid</code>)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">blog_title:</span> <span class="hljs-string">&quot;windsand&quot;</span>  <span class="hljs-comment"># 将会以文本的形式显示</span><br></code></pre></td></tr></table></figure></li><li><p>首页背景图以及 slogan 文本</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">index:</span><br>  <span class="hljs-comment"># 首页 Banner 头图,可以是相对路径或绝对路径,以下相同</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/train.png</span>  <span class="hljs-comment"># 首页背景图.注意要自己存放图片资源到路径</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">100</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br>  <span class="hljs-comment"># 首页副标题的独立设置</span><br>  <span class="hljs-attr">slogan:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">text:</span> <span class="hljs-string">&quot;人生如逆旅,我亦是行人&quot;</span>  <span class="hljs-comment"># 首页 slogan</span><br></code></pre></td></tr></table></figure></li><li><p>文章页背景图(归档页, 分类页, 标签页, 关于页, 自定义页, 404 页, 友链页 同理)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/train.png</span>  <span class="hljs-comment"># 与上面的首页背景图配置方法相同</span><br></code></pre></td></tr></table></figure></li><li><p>文章内数学公式</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">math:</span><br>  <span class="hljs-comment"># 开启后文章默认可用,自定义页面如需使用,需在 Front-matter 中指定 math: true</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>   <br>  <span class="hljs-comment"># 开启后,只有在文章 Front-matter 里指定 math: true 才会在文章页启动公式转换</span><br>  <span class="hljs-comment"># 以便在页面不包含公式时提高加载速度</span><br>  <span class="hljs-attr">specific:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="4-5-文章属性"><a href="#4-5-文章属性" class="headerlink" title="4.5 文章属性"></a>4.5 文章属性</h3><ol><li><p>以本文为例,在 <code>front-matter</code> 中编写内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">typora-root-url:</span> <span class="hljs-string">./Git</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Git</span> <span class="hljs-string">使用</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Git</span>, <span class="hljs-string">工具箱</span>, <span class="hljs-string">笔记</span>, <span class="hljs-string">Code</span>]<br><span class="hljs-attr">categories:</span> <span class="hljs-string">工具箱</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">&quot;Git 的使用方式介绍; GitHub Pages 页面的配置方法; 在 IDE 中使用 Git; hexo 的安装使用; typora 的配置; MarkDown 语法.&quot;</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/Git.svg</span><br><span class="hljs-attr">math:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><img src="/2025/07/11/Git/Git/4-Hexo-front-matter.png"></p></li><li><p><code>typora-root-url</code>: typora 中图片的根目录</p></li><li><p><code>title</code>: 文章的标题.将会在主页中显示</p></li><li><p><code>tags</code>: 文章的标签.将会在主页中显示,点击可以跳转.一篇文章可以有多个 tag</p></li><li><p><code>categories</code>: 文章的类别.分类下面可以有多篇文章</p></li><li><p><code>excerpt</code>: 文章的摘要</p></li><li><p><code>index_img</code>: 文章封面图的路径.本示例的路径为 <code>./source/img/Git.svg</code></p></li></ol><h2 id="5-typora"><a href="#5-typora" class="headerlink" title="5 typora"></a>5 typora</h2><h3 id="5-1-typora-配置"><a href="#5-1-typora-配置" class="headerlink" title="5.1 typora 配置"></a>5.1 typora 配置</h3><ol><li><p>为了与 hexo 部署兼容(主要是图片存放路径)</p><ul><li><p>文件 -&gt; 偏好设置 -&gt; 图像 -&gt; 插入图片时 -&gt; 复制到指定路径 <code>./$&#123;filename&#125;</code></p><p><img src="/2025/07/11/Git/Git/5-typora-image-setting.png"></p></li><li><p>格式 -&gt; 图像 -&gt; 设置图片根目录 -&gt; 将 <code>./$&#123;filename&#125;</code> 目录设置为根目录</p></li></ul></li><li><p>图片命令不要包含中文或空格.否则可能显示异常</p></li><li><p>为了更好的结构化管理,图片命名时前缀加上图片所在的章节</p></li></ol><h3 id="5-2-MarkDown-语法"><a href="#5-2-MarkDown-语法" class="headerlink" title="5.2 MarkDown 语法"></a>5.2 MarkDown 语法</h3>]]></content>
    
    
    <categories>
      
      <category>工具箱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>工具箱</tag>
      
      <tag>笔记</tag>
      
      <tag>Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 使用</title>
    <link href="/2024/01/19/Linux/Linux/"/>
    <url>/2024/01/19/Linux/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-使用"><a href="#Linux-使用" class="headerlink" title="Linux 使用"></a>Linux 使用</h1><h2 id="0-导论"><a href="#0-导论" class="headerlink" title="0 导论"></a>0 导论</h2><h3 id="0-1-准备环境"><a href="#0-1-准备环境" class="headerlink" title="0.1 准备环境"></a>0.1 准备环境</h3><ol><li>Linux 学习环境搭建目标: 在 Windows 中,首先创建一个虚拟机,然后安装 <code>CentOS</code>(现推荐安装 [wsl](# 0.3 wsl))</li><li>安装 <code>Vmware</code><ul><li>先在 BIOS 中开启 <code>虚拟化设备支持</code></li><li>安装只需一直下一步即可</li></ul></li><li>安装 <code>CentOS</code><ul><li>将界面修改为中文: 在快捷方式的目标栏添加 <code> --locale zh_CN</code></li></ul></li><li>如果遇到打开虚拟机就蓝屏: 在 Windows 功能中打开 <code>虚拟机监控程序平台, 虚拟机平台</code></li><li><strong>网络连接模式</strong><ul><li>桥接模式: 虚拟系统可和外部系统通讯,但容易造成 IP 冲突</li><li>NAT 模式: 网络地址转化模式.可和外部系统通讯,而不造成 IP 冲突</li><li>主机模式: 独立的系统.不进行通讯</li></ul></li><li>虚拟机功能<ul><li>克隆: 直接复制文件,系统也是文件,复制文件即可克隆系统</li><li>快照: 保存快照后,可以在快照管理回到之前的状态</li><li>删除和迁移: 与克隆类似,直接操作文件</li></ul></li></ol><h3 id="0-2-远程登陆"><a href="#0-2-远程登陆" class="headerlink" title="0.2 远程登陆"></a>0.2 远程登陆</h3><ol><li><p>Xshell &amp; Xftp 安装(Xshell 用于执行指令.Xftp 用于文件传输)</p></li><li><p>Linux 终端输入 <code>ifconfig</code> 查询 ip 地址(inet 后面即为 ip 地址)</p></li><li><p>Windows 中命令行输入 <code>ping ip</code>,检查是否联通</p></li><li><p>进入 Xshell -&gt; 新建会话 -&gt; 主机输入 Linux 的 ip -&gt; 完成</p><p><img src="/2024/01/19/Linux/Linux/0-Xshell-remote.png"></p></li><li><p>双击左侧主机名 -&gt; 接收并保存 -&gt; 输入用户名和密码.即可登录</p><p><img src="/2024/01/19/Linux/Linux/0-Xshell-login.png"></p></li></ol><h3 id="0-3-wsl"><a href="#0-3-wsl" class="headerlink" title="0.3 wsl"></a>0.3 wsl</h3><ol><li><p>先在 BIOS 中开启 <code>虚拟化设备支持</code>(任务管理器中显示 <code>虚拟化已开启</code> 即可)</p><p><img src="/2024/01/19/Linux/Linux/0-Virtualization.png"></p></li><li><p>win + R 输入 control 进入控制面板 -&gt; 程序和功能 -&gt; 启用或关闭 Windows 功能.<br>开启 <code>Virtual Machine Platform</code> 和 <code>适用于 Linux 的 Windos 子系统</code>(完成该步骤后需要重启电脑)</p><p><img src="/2024/01/19/Linux/Linux/0-Windows-feature.png"></p></li><li><p>打开终端,执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">wsl --update   # 安装 linux 子系统<br>wsl --version  # 检查版本信息<br>wsl --list --online         # 列出可以在线安装的版本 <br>wsl --install Ubuntu-24.04  # 安装 Ubuntu 24.04.然后根据提示新建用户<br></code></pre></td></tr></table></figure><p><img src="/2024/01/19/Linux/Linux/0-wsl-install.png"></p></li><li><p>更新所有软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update     # 拉取可更新软件列表<br>sudo apt upgrade -y # 更新所有软件<br>sudo apt install neofetch htop  # 安装 neofetch<br>neofetch  # 运行 neofetch.显示系统信息<br>htop      # 交互式界面显示系统资源使用情况<br></code></pre></td></tr></table></figure></li></ol><h2 id="1-Linux-基础"><a href="#1-Linux-基础" class="headerlink" title="1 Linux 基础"></a>1 Linux 基础</h2><h3 id="1-1-Linux-目录结构"><a href="#1-1-Linux-目录结构" class="headerlink" title="1.1 Linux 目录结构"></a>1.1 Linux 目录结构</h3><ol><li><p><strong>Linux 一切皆文件</strong></p><p><img src="/2024/01/19/Linux/Linux/1-Linux%E7%9B%AE%E5%BD%95.jpg"></p></li><li><p><code>/</code>: 根目录,包含整个文件系统</p><ul><li><code>/bin</code>: 二进制文件目录.包含一些常用的命令和工具.如 ls, cp, mv…</li><li><code>/sbin</code>: 系统二进制文件目录.包含一些系统管理命令和工具.如 shutdown, reboot…</li><li><code>/boot</code>: 启动目录.包含启动 Linux 系统所需的文件,如内核文件和引导程序</li><li><strong><code>/dev</code>: 设备目录.包含系统中的设备文件.如 硬盘, 光驱, 键盘…</strong></li><li><code>/etc</code>: 配置文件目录.包含系统和应用程序的配置文件.如网络配置, 用户配置…</li><li><strong><code>/home</code>: 用户主目录.包含系统中所有用户的主目录</strong></li><li><code>/lib</code>: 库文件目录.包含系统和应用程序所需的共享库文件</li><li><code>/media</code>: 挂载目录.包含可移动设备的挂载点,如 U盘, 光盘…</li><li><strong><code>/mnt</code>: 挂载目录.包含临时挂载的文件系统</strong></li><li><strong><code>/opt</code>: 可选目录.包含第三方应用程序的安装目录</strong></li><li><code>/proc</code>: 进程目录.包含系统和进程的信息.如 内存使用, CPU使用…</li><li><code>/root</code>: root 用户主目录</li><li><code>/tmp</code>: 临时目录.包含系统和应用程序的临时文件</li><li><code>/usr</code>: 用户程序目录.包含系统和用户安装的应用程序和文件</li><li><code>/var</code>: 可变目录.包含系统和应用程序的可变数据.如日志文件, 缓存文件…</li></ul></li></ol><h3 id="1-2-vim"><a href="#1-2-vim" class="headerlink" title="1.2 vim"></a>1.2 vim</h3><ol><li><p>vim 键盘图</p><p><img src="/2024/01/19/Linux/Linux/1-vi-vim-cheat-sheet-sch.gif"></p></li><li><p>vim 的工作模式: 命令模式, 输入模式, 命令行模式</p><p><img src="/2024/01/19/Linux/Linux/1-vim-vi-workmodel.png"></p></li><li><p>命令模式: 当启动 vi&#x2F;vim 时,默认为命令模式</p><ul><li><kbd>x</kbd>: 删除当前光标所在处的字符</li><li><kbd>G</kbd>: 定位到最后一行, <kbd>gg</kbd> 则定位到首行</li><li><strong><kbd>yy</kbd>: 复制当前行,在前面加一个数字可以选定行数,如 5yy</strong></li><li><strong><kbd>dd</kbd>: 剪切当前行,在前面加一个数字可以选定行数,如 3dd</strong></li><li><strong><kbd>p</kbd>: 粘贴复制的内容</strong></li><li><kbd>u</kbd>: 撤销操作</li><li><kbd>Ctrl</kbd><kbd>r</kbd>: 重做上一次的撤销</li><li>定位到指定行: 输入行数然后 <kbd>Shif</kbd><kbd>g</kbd></li></ul></li><li><p>插入模式: 可以直接输入文本</p><ul><li><strong><kbd>ESC</kbd>: 进入命令行模式</strong></li><li><kbd>Page Up</kbd> &#x2F; <kbd>Page Down</kbd>: 上下翻页</li></ul></li><li><p>命令行模式: 保存或退出文件,设置编辑环境</p><ul><li><strong><kbd>:w</kbd>: 保存文件</strong></li><li><strong><kbd>:q</kbd>: 退出编辑器</strong></li><li><kbd>:q!</kbd>: 强制退出,且不保存</li><li><kbd>:set nu</kbd>: 显示行号.<kbd>:set nonu</kbd>: 隐藏行号. <kbd>:整数</kbd>:跳转到某行</li><li><strong><kbd>/text</kbd>: 查找文本信息.此时输入<kbd>n</kbd>查找下一个.<kbd>N</kbd>查找下一个</strong></li><li><kbd>?text</kbd>: 向上查找文本信息</li></ul></li></ol><h2 id="2-Linux-命令"><a href="#2-Linux-命令" class="headerlink" title="2. Linux 命令"></a>2. Linux 命令</h2><h3 id="2-1-基础命令"><a href="#2-1-基础命令" class="headerlink" title="2.1 基础命令"></a>2.1 基础命令</h3><ol><li><p>命令格式</p><ul><li><p>linux 的命令格式为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">命令名称 [-命令选项] [命令参数]<br></code></pre></td></tr></table></figure></li><li><p>命令名称实际上也可以是 Shell 脚本</p></li><li><p>命令选项</p><ul><li>长格式: 如 <code>man --help</code></li><li>短格式: 如 <code>man -h</code></li></ul></li><li><p>命令参数: 如文件, 目录, 用户等资源</p></li></ul></li><li><p>开关机</p><ul><li><code>shutdown -h now</code>: 立即关机</li><li><strong><code>shutdown -h 1</code>: 1分钟后关机.这也是 <code>shutdown</code> 的默认形式</strong></li><li><code>shutdown -r now</code>: 立即重启</li><li><code>halt</code>: 立即关机</li><li><strong><code>reboot</code>: 立即重启</strong></li><li><strong><code>sync</code>: 把内存里的数据同步到磁盘(建议在关机前先执行该指令)</strong></li></ul></li><li><p>登录 Linux(一般仅使用普通用户登录)</p><ul><li><code>su -username</code>: 切换登陆用户</li><li><code>logout</code>: 注销用户</li><li><strong>在登陆后可使用 <code>su -root</code> 切换到 root 用户.然后使用 <code>logout</code> 可以切换回普通用户</strong></li></ul></li><li><p>用户管理(要想使用 Linux 系统资源,需要向管理员申请账号)</p><ul><li><strong><code>useradd 用户名</code>: 添加用户.且登陆后将默认进入 <code>/home/username</code> 目录</strong></li><li><code>passwd 用户名</code>: 指定 &#x2F; 修改密码</li><li><code>userdel 用户名</code>: 删除用户,但保留目录</li><li><code>id 用户名</code>: 查询用户信息</li><li><code>whoami</code>: 查看当前登录用户</li></ul></li><li><p>用户组(对具有相似权限的用户分组管理)</p><ul><li><strong><code>groupadd 组名</code>: 创建用户组(若创建用户时未指定组,默认创建同名组)</strong></li><li><code>groupdel 组名</code>: 删除用户组</li><li><code>groupmod -n 新名称 原名称</code>: 更改用户组名</li><li><code>usermod -g 组名 用户名</code>: 修改用户的组别</li><li><code>gpasswd -d 组名 用户组</code>: 从组中删除用户</li></ul></li><li><p>帮助指令</p><ul><li><code>man [指令或配置文件]</code>: 获取帮助信息.如 <code>man ls</code></li><li><code>help 指令</code>: 获得 shell 内置命令的帮助信息.如 <code>help cd</code></li></ul></li></ol><h3 id="2-2-文件目录"><a href="#2-2-文件目录" class="headerlink" title="2.2 文件目录"></a>2.2 文件目录</h3><ol><li>路径切换<ul><li><strong><code>pwd</code>: 显示当前目录的绝对路径</strong></li><li><strong><code>ls [目录/文件]</code>: 展示文件和目录</strong><ul><li><code>-a</code>: 显示所有文件和目录(包括隐藏文件,即以 <code>.</code> 开头的文件)</li><li><code>-l</code>: 以列表形式显示</li></ul></li><li><strong><code>cd</code>: 切换到指定目录</strong><ul><li><code>cd ~</code>: 回到家目录</li><li><code>cd ..</code>: 回到上一级目录</li><li><code>cd -</code>: 返回上一次目录</li></ul></li></ul></li><li>目录与文件<ul><li><strong><code>touch 文件名</code>: 创建空文件</strong></li><li><strong><code>mkdir 目录名</code>: 创建目录(默认只能创建一级目录)</strong><ul><li><code>mkdir -p 目录名1/目录名2</code>: 创建多级目录</li></ul></li><li><strong><code>rmdir 要删除的空目录名</code>: 删除空目录</strong></li><li><strong><code>rm 要删除的文件或目录</code>: 删除文件或目录</strong><ul><li><code>-r</code>: 递归删除整个文件夹</li><li><code>-f</code>: 强制删除不提示</li></ul></li><li><strong><code>cp 待拷贝文件或目录 目标目录</code>: 将文件复制到指定目录</strong><ul><li><code>-r</code>: 递归复制整个文件夹</li><li><code>\cp</code>: 直接覆盖同名文件,不进行提示</li></ul></li><li><strong><code>mv 原文件 目标目录</code>: 移动文件或目录(如果位于同一目录,则作用为重命名)</strong></li></ul></li><li>文件信息<ul><li><code>diff 文件名</code>: 比较文件的差异.(<code>-c</code>: 查看具体信息)</li><li><strong><code>cat 文件名</code>: 查看文件内容.不能修改.(<code>-n</code>: 显示行号)</strong></li><li><code>more 文件名</code>: 分批显示.<kbd>Space</kbd>向下翻页,<kbd>Enter</kbd>显示下一行,<kbd>Q</kbd>直接离开</li><li><code>less 文件名</code>: 分屏查看文件内容</li><li><strong><code>echo</code>: 输出内容到控制台(如 echo $PATH)</strong></li><li><code>tail -f 文件名</code>: 实时追踪文件的所有更新</li></ul></li><li><strong>指令 <code>&gt;</code> 和 <code>&gt;&gt;</code>: 重定向和追加</strong><ul><li><code>cat 文件1 &gt; 文件2</code>: 将文件1内容覆盖到文件2</li><li><code>echo &quot;内容&quot; &gt;&gt; 文件名</code>: 将内容追加到文件中</li></ul></li><li><strong><code>ln -s [源文件或目录] [软链接名]</code>: 创建软链接</strong></li><li><strong><code>history</code>: 查看 &#x2F; 执行历史指令</strong></li></ol><h3 id="2-3-时间日期"><a href="#2-3-时间日期" class="headerlink" title="2.3 时间日期"></a>2.3 时间日期</h3><ol><li><strong><code>date</code>: 显示当前日期</strong><ul><li><code>date</code>: 显示当前日期</li><li><code>date + %Y</code>: 显示当前年份</li><li><code>date + %m</code>: 显示当前月份</li><li><code>date + %d</code>: 显示当前天数</li><li><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code>: 显示年月日时分秒</li></ul></li><li>date 设置时间(如: <code>date -s &quot;2021-06-18 08:00:00&quot;</code>)</li><li><strong><code>cal</code>: 显示本月日历</strong><ul><li><code>cal 2025</code>: 显示 2025年日历</li></ul></li></ol><h3 id="2-4-查找"><a href="#2-4-查找" class="headerlink" title="2.4 查找"></a>2.4 查找</h3><ol><li><p><strong><code>find</code>: 从指定目录向下递归遍历各个子目录,将满足条件的文件 &#x2F; 目录显示在终端</strong></p><ul><li><p>基本语法: <code>find [搜索范围] [选项]</code></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-name&lt;查询方式&gt;</td><td>按指定文件名 查找模式</td></tr><tr><td>-user&lt;用户名&gt;</td><td>查找属于指定用户名所有文件</td></tr><tr><td>-size&lt;文件大小&gt;</td><td>按照指定文件大小查找文件(+n 大于, -n 小于, n 等于)</td></tr></tbody></table></li><li><p>查找示例</p><ul><li>查找 <code>/home</code> 目录的 <code>hello.txt</code> 文件: <code>find /home -name hello.txt</code></li><li>查找 <code>/opt</code> 目录中拥有者为 <code>nobody</code> 的文件: <code>find /opt -user nobody</code></li><li>查找整个系统中大于 200M 的文件: <code>find / -size +200M</code></li></ul></li></ul></li><li><p><strong><code>locate</code>: 事先建立系统中所有文件名称及路径的 <code>locate</code> 数据库</strong></p><ul><li>第一次运行时,必须先使用 <code>updatedb</code> 指令创建 <code>locate</code> 数据库</li><li>查询速度快,需及时更新 <code>locate</code> 时刻</li></ul></li><li><p><strong><code>which</code>: 查看某个指令所属目录</strong></p></li><li><p><strong><code>grep</code>: 过滤查找(常和 | 结合使用)</strong></p><ul><li><code>grep [选项] 查找内容 源文件</code></li><li><code>-n</code>: 显示匹配行及行号</li><li><code>-i</code>: 忽略大小</li><li><code>-r</code>: 递归查找</li><li><code>-v</code>: 反向过滤</li></ul></li></ol><h3 id="2-5-压缩和解压"><a href="#2-5-压缩和解压" class="headerlink" title="2.5 压缩和解压"></a>2.5 压缩和解压</h3><ol><li><p>**<code>gzip 文件名</code>: 压缩为 <em>.gz 文件</em>*</p></li><li><p>**<code>gunzip 文件名</code>: 解压 <em>.gz 解压文件</em>*</p></li><li><p><strong><code>zip</code>: 压缩目录 &#x2F; 文件</strong></p><ul><li><code>zip [选项] *.zip 将要压缩的内容</code>: 压缩文件和目录</li><li><code>-r</code>: 递归压缩,即压缩整个目录</li></ul></li><li><p><strong><code>unzip</code>: 解压文件</strong></p><ul><li><p><code>unzip [选项] *.zip</code>: 解压文件</p></li><li><p><code>-d&lt;目录&gt;</code>: 指定存放目录.默认为当前目录</p></li></ul></li><li><p><strong><code>tar</code>: 打包指令</strong></p><ul><li><code>tar [选项] *.tar.gz 打包的内容</code>: 打包目录.文件名后缀 <code>.tar.gz</code></li></ul><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>产生 <code>.tar</code> 打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后文件名</td></tr><tr><td>-z</td><td>打包同时压缩</td></tr><tr><td>-x</td><td>解包 <code>.tar</code> 文件</td></tr></tbody></table></li></ol><h3 id="2-6-运行级别"><a href="#2-6-运行级别" class="headerlink" title="2.6 运行级别"></a>2.6 运行级别</h3><ol><li>运行级别一般为 3 或 5<ul><li>0: 系统停机状态,即关机状态</li><li>1: 单用户模式,只有 root 用户可以登录.用于系统维护和修复</li><li>2: 多用户模式,没有 NFS 服务.但可以使用网络</li><li>3: <strong>多用户模式,完全启动系统.可以使用所有服务</strong></li><li>4: 保留,未使用</li><li>5: <strong>多用户模式,与运行级别3相同.但是在此级别下启动X Window系统,即图形界面</strong></li><li>6: 系统重启级别</li></ul></li><li>运行级别指令<ul><li><code>init 1</code>: 切换到运行级别1</li><li><code>runlevel</code>: 查看当前运行级别</li></ul></li></ol><h2 id="3-权限管理"><a href="#3-权限管理" class="headerlink" title="3 权限管理"></a>3 权限管理</h2><h3 id="3-1-组"><a href="#3-1-组" class="headerlink" title="3.1 组"></a>3.1 组</h3><ol><li><strong>Linux 每个用户都属于某个组.每个文件有 所有者, 所在组, 其他组</strong></li><li>所有者: 文件的创建者自然成为文件的所有者<ul><li><code>ls -ahl</code>: 查看文件&#x2F;目录所有者</li><li><code>chown 用户名 文件名</code>: 修改文件&#x2F;目录所有者</li><li><strong><code>chown 用户名:组名 文件名</code>: 修改所有者以及所在组</strong><ul><li><code>-R</code>: 将目录的子目录和文件进行递归修改</li></ul></li></ul></li><li>所在组: 文件 &#x2F; 目录的所在组 为 所有者的所在组<ul><li><code>chgrp 组名 文件名</code>: 修改文件&#x2F;目录所在组</li></ul></li><li>其他组: 除所有者和所在组之外的用户</li></ol><h3 id="3-2-文件权限"><a href="#3-2-文件权限" class="headerlink" title="3.2 文件权限"></a>3.2 文件权限</h3><ol><li><p><strong>文件所属分为拥有者(owner), 所属群组(group), 其他人(other).</strong><br><strong>而三种身份各有 读(read), 写(write), 执行(execute)权限</strong></p></li><li><p>考虑 <code>ls -l</code> 命令,显示的信息形如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc<br></code></pre></td></tr></table></figure><ul><li>从左到右分别为: 文件权限, 链接数, 文件拥有者, 文件所属用户组, 文件大小(Bytes), 最后被修改的时间, 文件名</li></ul></li><li><p>文件权限共 9位.其含义为</p><ul><li><strong>第 0 位: 文件类型(d ,-, l, c, b)</strong><ul><li><code>d</code>: 目录.相当于文件夹</li><li><code>-</code>: 普通文件</li><li><code>l</code>: 链接.相当于快捷方式</li><li><code>c</code>: 字符设备.如鼠标键盘</li><li><code>b</code>: 块设备.如硬盘</li></ul></li><li><strong>1 ~ 3位: 文件所有者的权限.如 rwx 表示可读可写可执行</strong></li><li><strong>4 ~ 6位: 所在组用户的权限.如 rw- 表示可读可写,但不能执行</strong></li><li><strong>7 ~ 9位: 其他用户对该文件的权限.如 r– 表示仅能读</strong></li></ul></li><li><p><strong>目录权限表示方式</strong></p><ul><li><code>r</code>: 可读.可以查看文件 或 可用 <code>ls</code> 查看目录内容</li><li><code>w</code>: 可写.可创建, 删除, 重命名, 移动其中的文件或目录</li><li><code>x</code>: 可执行.可以执行文件 或 可进入该目录(成为工作目录)</li><li><code>-</code>: 对应位置如果出现 <code>-</code>,表示没有该类型权限</li><li><code>rwx</code> 还可以用数字形式表示(<code>r = 4, w = 2, x = 1</code>).如 rwx &#x3D; 4 + 2 +1 &#x3D; 7</li></ul></li><li><p><strong><code>chmod</code>: 修改文件或目录的权限</strong></p><ul><li><code>u</code>: 所有者, <code>g</code>: 所在组, <code>o</code>: 其他人, <code>a</code>: 所有人. 使用 <code>+, -, =</code>赋予权限</li><li><code>chmod u=rwx,g=rx,o=x 文件名</code>: 对文件设置权限</li><li><code>chmod o+w 文件名</code>: 对其他组增加 w 可写权限</li><li><code>chmod a-x 文件名</code>: 对所有人取消 x 可执行权限</li><li><code>chmod 751 文件名</code>: 与 <code>chmod u=rwx,g=rx,o=x 文件名</code> 等价</li></ul></li></ol><h3 id="3-3-定时任务"><a href="#3-3-定时任务" class="headerlink" title="3.3 定时任务"></a>3.3 定时任务</h3><ol><li><p>任务调度: 系统在某个时间执行的特定命令或程序</p><ul><li>系统工作.需要周期性的执行,如病毒扫描</li><li>用户工作.如对 mysql 数据库的备份</li></ul></li><li><p><code>crond</code> 定时任务</p><ul><li>基础语法: <code>crontab [选项]</code><ul><li><code>-e</code>: 编辑 <code>crontab</code> 任务</li><li><code>-l</code>: 查询 <code>crontab</code> 任务</li><li><code>-r</code>: 删除当前用户的所有 <code>crontab</code> 任务</li></ul></li><li>示例: <code>*/1**** ls -l /etc &gt; /tmp/to.txt</code> 将会每分钟都执行一次</li></ul></li><li><p>时间规则</p><ul><li><p>5个占位符的含义</p><table><thead><tr><th>序号</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>1</td><td>每小时的分钟数</td><td>0 ~ 59</td></tr><tr><td>2</td><td>每天的小时数</td><td>0 ~ 23</td></tr><tr><td>3</td><td>每月的天数</td><td>1 ~ 31</td></tr><tr><td>4</td><td>每天的月份</td><td>1 ~ 12</td></tr><tr><td>5</td><td>每周星期数</td><td>0 ~ 7(0和7均为星期天)</td></tr></tbody></table></li><li><p>特殊符号</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>通配符,表示任意时间</td></tr><tr><td>,</td><td>分隔不连续的时间.如 <code>08,17***</code> 表示每天的8时0分,17时0分</td></tr><tr><td>-</td><td>连续的时间范围.如 <code>05**1-6</code> 表示周一到周六的5时0分</td></tr><tr><td>*&#x2F;n</td><td>每次的间隔时间.如 <code>*/10****</code> 表示每次间隔10分钟</td></tr></tbody></table></li></ul></li></ol><h3 id="3-4-进程"><a href="#3-4-进程" class="headerlink" title="3.4 进程"></a>3.4 进程</h3><ol><li><p>进程</p><ul><li>Linux 中每个执行的程序都是一个进程.每个进程都会分配一个ID号(pid)</li><li>每个进程可以以前台或后台的形式存在</li><li>一般系统服务均以后台进程形式存在,且常驻于系统,直到关机才结束</li></ul></li><li><p><strong><code>ps</code>: 查看当前系统中正在执行的进程</strong></p><ul><li><p><code>ps -a</code>: 显示当前终端的所有进程信息</p></li><li><p><code>ps -u</code>: 以用户的格式显示进程信息</p></li><li><p><code>ps -x</code>: 显示后台进程运行的参数</p></li><li><p>示例: <code>ps -aux</code></p><p><img src="/2024/01/19/Linux/Linux/3-Linux-process.png"></p></li></ul></li><li><p>父子进程</p><ul><li><strong><code>ps -ef</code>: 全格式显示当前所有进程</strong></li><li>显示的 ppid 指出该进程的父进程</li><li>搭配 <code>| grep</code> 可以进行过滤</li></ul></li><li><p>终止进程</p><ul><li><strong><code>kill [选项] 进程号</code>: 通过进程号终止进程</strong></li><li><code>killall 进程名称</code>: 通过进程名称终止进程,同时会终止其所有子进程</li></ul></li><li><p><code>pstree</code>: 查看进程树</p><ul><li><code>-p</code>: 显示进程的 pid</li><li><code>-u</code>: 显示进程的用户</li></ul></li><li><p>服务(service): 其本质仍然是进程.通常会监听某个端口,等待其他程序的请求</p><ul><li><code>service 服务名 [start | stop | restart | reload | status]</code></li><li>CentOS7.0后,很多服务不再使用 <code>service</code> 指令管理,而使用 <code>systemctl</code></li><li><code>systemctl [start | stop | restart | status] 服务名</code></li><li><code>systemctl</code> 管理的服务在 <code>/user/lib/systemd/system</code> 查看</li></ul></li></ol><h2 id="4-开发环境"><a href="#4-开发环境" class="headerlink" title="4 开发环境"></a>4 开发环境</h2><h3 id="4-1-包管理"><a href="#4-1-包管理" class="headerlink" title="4.1 包管理"></a>4.1 包管理</h3><ol><li>rpm(RedHat Package Manager)<ul><li><strong>rpm 用于互联网下载包的打包,安装.生成 <code>.RPM</code> 的文件</strong></li><li>Linux 的分发版均有采用,成为行业标准</li></ul></li><li>查询软件包<ul><li><code>rpm -qa</code>: 查询所有安装的 rpm 软件包</li><li><code>rpm -qa | grep firefox</code>: 查询具体的某个软件包</li><li><code>rpm -qi firefox</code>: 查询软件包的具体信息</li></ul></li><li>安装与删除软件包<ul><li><code>rpm -ivh rpm包的全路径名称</code>: 安装软件包需要有全路径</li><li><code>rpm -e firefox</code>: 删除软件包</li></ul></li><li>yum: Shell 前端软件包管理器<ul><li>yum 基于 rpm 包管理.能从指定服务器自动下载 rpm 包并安装</li><li>yum 将会自动处理依赖性关系,并一次安装所有依赖的软件包</li></ul></li><li>yum 指令<ul><li><code>yum list | grep firefox</code>: 查询 yum 服务器中的相关软件包信息</li><li><code>yum install firefox</code>: 下载安装软件包及依赖</li></ul></li></ol><h3 id="4-2-JavaEE"><a href="#4-2-JavaEE" class="headerlink" title="4.2 JavaEE"></a>4.2 JavaEE</h3><ol><li><p>JDK8</p><ul><li><p>创建目录: <code>mkdir /opt/jdk</code>(一般安装的软件置于 opt 目录下)</p></li><li><p>将安装包通过 xftp 上传到刚才创建的目录</p></li><li><p>解压安装包: <code>tar -zxvf jdk-8u261-linux-x64.tar.gz</code></p></li><li><p>创建目录: <code>mkdir /usr/local/java</code></p></li><li><p>移动整个解压后的目录: <code>mv /opt/jdk/jdk1.8.0_261 /usr/local/java</code></p></li><li><p>配置环境变量: <code>vim /etc/profile</code>.在最下方添加两行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export JAVA_HOME=/usr/local/java/jdk1.8.0_261<br>export PATH=$JAVA_HOME/bin:$PATH<br></code></pre></td></tr></table></figure></li><li><p>使环境变量生效: <code>source /etc/profile</code></p></li><li><p>测试安装: 编写 <code>Hello, world</code> 程序,编译运行</p></li></ul></li><li><p>tomcat8</p><ul><li>同样将安装文件上传并解压缩到 <code>/opt/tomcat</code> 目录</li><li>进入解压后的 <code>bin</code> 目录,启动 tomcat: <code>./startup.sh</code></li><li>开放端口 8080<ul><li><code>firewall-cmd --permanent add-port=8080/tcp</code></li><li><code>firewall-cmd --reload</code></li></ul></li><li>测试安装: 访问 <a href="http://linuxip:8080/">http://linuxip:8080</a><ul><li><code>cd ../webapps/ROOT/</code>: 在默认访问目录中增加 HTML 文件</li><li><code>vim test.html</code>: 编写 HTML 代码</li><li>然后访问 <a href="http://linuxip:8080/test.html">http://linuxip:8080/test.html</a> 将能正常打开页面</li></ul></li></ul></li></ol><h3 id="4-3-Ubuntu"><a href="#4-3-Ubuntu" class="headerlink" title="4.3 Ubuntu"></a>4.3 Ubuntu</h3><ol><li><p><strong>Ubuntu: 一个以桌面应用为主的开源 GNU&#x2F;Linux 操作系统</strong></p><ul><li>基于 GNU&#x2F;Linux.支持 x86, amd64, ppc 架构.由 Canonical 打造</li><li>Python 开发者一般选择 Ubuntu 作为生产平台</li><li>下载桌面版: <a href="https://cn.ubuntu.com/download">Ubuntu系统下载 | Ubuntu</a></li></ul></li><li><p>中文支持</p><ul><li>Ubuntu 默认只有英文.需要安装中文语言包(需要联网)</li><li>打开 Language Support 菜单 -&gt; Language Support 选项卡 -&gt; Install</li><li>选中 Chinese(Simplified) -&gt; Apply Changes 提交.此时系统将会自动下载</li><li>默认显示中文需要将 <code>汉语(中国)</code> 拖动到第一位</li></ul></li><li><p>root 权限</p><ul><li><strong>Ubuntu 安装后只有普通用户权限.若需要 root 权限,应在命名前加上 <code>sudo</code></strong></li><li>当使用 <code>su root</code> 切换到 root 用户时,因还未设置密码,将会抛出 <code>error</code></li><li>设置 root 用户的密码并使用<ul><li><code>sudo password</code>: 给 root 用户设置密码</li><li><code>su root</code>: 切换到 root 用户</li><li>提示符 <code>$</code> 表示一般用户.<code>#</code> 表示 root 用户</li><li><code>exit</code>: 退出 root 用户</li></ul></li></ul></li><li><p>python</p><ul><li>Ubuntu 默认安装 python 的开发环境</li><li><code>python3</code> 将会展示版本信息</li></ul></li><li><p><strong>apt(Advanced Packaging Tool): 安装包管理工具</strong></p><ul><li><p>在 Ubuntu 中,可以使用 <code>apt</code> 命令进行软件包的安装, 删除, 清理…</p></li><li><p><code>/etc/apt/sources.list</code> 文件中存放着 apt 服务器的地址</p></li><li><p>apt 通过指令完成软件的安装, 更新, 卸载</p></li><li><p>镜像网站: 因为服务器位于美国,连接缓慢,由镜像网站获取其资源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update            # 更新源<br>sudo apt-get install &lt;package&gt; # 安装 package<br>sudo apt-get remove &lt;package&gt;  # 删除 package<br><br>sudo apt-cache search &lt;package&gt; # 搜索软件包<br>sudo apt-cache show &lt;package&gt;   # 获取包的相关信息<br>sudo apt-get install &lt;package&gt; --reinstall # 重新安装包<br><br>sudo apt-get -f install               # 修复安装<br>sudo apt-get remove &lt;package&gt; --purge # 删除包,包括配置文件<br>sudo apt-get build-dep &lt;package&gt;      # 安装相关编译环境<br><br>sudo apt-get upgrade               # 更新已安装的包<br>sudo apt-get dist-upgrade          # 升级系统<br>sudo apt-cache depends &lt;package&gt;   # 查看该包所依赖的包<br>sudo apt-cache rdepends &lt;package&gt;  # 查看该包被哪些包依赖<br>sudo apt-get source package        # 下载软件包的源代码 *<br></code></pre></td></tr></table></figure></li></ul></li><li><p>修改 apt 更新源</p><ul><li>备份文件: <code>sudo cp /ect/apt/sources.list /etc/apt/sources.list.backup</code></li><li>使用 root 用户,清空源文件中的所有内容: <code>echo &#39;&#39; &gt; source.list</code></li><li>将需要的<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">镜像地址</a>拷贝到 <code>source.list</code> 文件中</li><li>更新源地址: <code>sudo apt-get update</code></li></ul></li><li><p>远程登录</p><ul><li>SSH(Secure Shell): 建立于应用层和传输层基础上的安全协议</li><li>与 CentOS 不同,Ubuntu 默认没有安装 SSHD 服务</li><li>安装 SSH: <code>sudo apt-get install openssh-server</code></li><li>启动 SSH: <code>service sshd restart</code></li></ul></li><li><p>Linux 登录到 Ubuntu</p><ul><li>同样需要安装 SSH</li><li>登录指令: <code>ssh 目标主机的用户名@目标主机IP地址</code></li><li>退出: <code>logout</code></li></ul></li></ol><h2 id="5-Shell"><a href="#5-Shell" class="headerlink" title="5 Shell"></a>5 Shell</h2><h3 id="5-1-Shell-概念"><a href="#5-1-Shell-概念" class="headerlink" title="5.1 Shell 概念"></a>5.1 Shell 概念</h3><ol><li><p><strong>Shell: 命令行解释器.为用户提供一个向 Linux 内核发送请求以便运行程序的界面系统级程序</strong></p><ul><li>运维工程师对服务器集群进行管理时,需要编写 Shell 程序进行服务器管理</li><li>JavaEE, Python程序员需要编写 Shell 维护程序和服务器</li><li>大数据程序员需要编写 Shell 程序管理集群</li></ul></li><li><p>Shell 脚本</p><ul><li><p>文件内容需要以 <code>#!/bin/bash</code> 开头,一般后缀为 <code>.sh</code></p></li><li><p>文件本身需要有可执行权限.赋予权限: <code>chmod u+x hello.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>echo &quot;Hello,world!&quot;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>执行脚本</p><ul><li><code>脚本的绝对路径或相对路径</code>: 即可执行(需要有 <code>+x</code> 权限)</li><li><code>sh 脚本路径</code>: 这样执行无需 <code>+x</code> 执行权限</li></ul></li><li><p>注释</p><ul><li>单行注释: <code># content</code></li><li>多行注释: <code>:&lt;&lt;! content !</code></li></ul></li></ol><h3 id="5-2-变量"><a href="#5-2-变量" class="headerlink" title="5.2 变量"></a>5.2 变量</h3><ol><li>系统变量<ul><li>如: <code>$HOME, $PWD, $SHELL, $USER</code>.可使用 <code>echo $HOME</code> 打印当前用户的家目录</li><li>显示当前 Shell 的所有系统变量</li></ul></li><li>自定义变量<ul><li>语法: <code>变量名=value</code>.注意语句中不要加入空格.变量名的命名限制与C相同</li><li>销毁变量: <code>unset 变量名</code>.Shell 编程变量名一般大写</li><li>声明静态变量: <code>readonly 变量名</code>.不能使用 <code>unset</code> 销毁</li><li>打印变量: <code>echo $变量名</code>.注意需要加上 <code>$</code> 符号</li></ul></li><li>将命令的返回值赋给变量<ul><li>A&#x3D;`date`: 将 data 作为一个命令执行,然后将结果赋值给变量 A</li><li><code>A=$(date)</code>: 与上述写法等价.变量 A 将会存储当前时间信息</li></ul></li><li>环境变量<ul><li><code>export 变量名=值</code>: 将 Shell 变量输出为环境变量 &#x2F; 全局变量</li><li><code>export 配置文件</code>: 使修改后的配置信息立即生效</li><li><code>echo $变量</code>: 查询环境变量的值</li></ul></li><li>位置参数<ul><li><code>$0</code>: 表示命令本身,<code>$1 ~ $9</code>表示第1 ~ 9个参数.对于超过10的,要用 <code>&#123;&#125;</code> 包裹</li><li><code>$*</code>: 表示所有的参数.且将所有参数当作整体处理</li><li><code>$@</code>: 表示所有的参数.但将每个参数分开处理</li><li><code>$#</code>: 获取命令行中所有参数的个数</li></ul></li><li>预定义变量: Shell 已定义的变量,可以直接在 Shell 脚本中使用<ul><li><code>$$</code>: 当前进程的进程号 pid</li><li><code>$!</code>: 后台运行的最后一个进程的进程号 pid</li><li><code>#?</code>: 最后一次执行的命令的返回状态.0表示正确执行</li></ul></li><li>运算<ul><li>语法: <code>$((运算式))</code> 或 <code>$[运算式]</code></li></ul></li></ol><h3 id="5-3-控制流"><a href="#5-3-控制流" class="headerlink" title="5.3 控制流"></a>5.3 控制流</h3><ol><li><p>条件表达式: <code>[ condition ]</code>.注意两端的空格,非空返回 true</p></li><li><p>分支语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ condition1 ]<br>then<br>code block1<br>elif [ condition2 ]<br>then<br>code block2<br>fi<br></code></pre></td></tr></table></figure></li><li><p>case</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $变量名 in<br>&quot;value1&quot;)<br>code block1<br>;;<br>&quot;value2&quot;)<br>code block2<br>*)<br>code block<br>esac<br></code></pre></td></tr></table></figure></li><li><p>for</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for 变量名 in value1 value2...<br>do<br>code block<br>done<br></code></pre></td></tr></table></figure></li><li><p>while</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">while [ condition ]<br>do<br>code block<br>done<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-4-函数"><a href="#5-4-函数" class="headerlink" title="5.4 函数"></a>5.4 函数</h3><ol><li><p>读取控制台输入</p><ul><li>基础语法: <code>read 选项 参数</code></li><li>选项: <code>-p</code> 指定读取值时的提示符. <code>-t</code> 指定等待的秒数</li><li>参数: 指定存储输入值的变量名</li></ul></li><li><p>系统函数</p><ul><li><code>basename</code>: 返回完整路径最后一个 <code>/</code> 后的内容,常用于获取文件名</li><li><code>basename [pathname] [suffix]</code></li><li><code>dirname</code>: 返回完整路径最后一个 <code>/</code> 前的内容,常用于获取路径</li></ul></li><li><p>自定义函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ function ] funname[()]<br>&#123;<br>Action;<br>[return int;]<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具箱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具箱</tag>
      
      <tag>Code</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法分析 - C 语言描述</title>
    <link href="/2024/01/19/Data%20Structures%20and%20Algorithm%20Analysis%20in%20C/Data%20Structures%20and%20Algorithm%20Analysis%20in%20C/"/>
    <url>/2024/01/19/Data%20Structures%20and%20Algorithm%20Analysis%20in%20C/Data%20Structures%20and%20Algorithm%20Analysis%20in%20C/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法分析"><a href="#数据结构与算法分析" class="headerlink" title="数据结构与算法分析"></a>数据结构与算法分析</h1><h2 id="0-算法分析"><a href="#0-算法分析" class="headerlink" title="0 算法分析"></a>0 算法分析</h2><h3 id="0-1-基础概念"><a href="#0-1-基础概念" class="headerlink" title="0.1 基础概念"></a>0.1 基础概念</h3><ol><li>概念<ul><li>数据结构: 组织大量数据的方法</li><li>算法分析: 对算法运行时间的评估</li><li><strong>算法(algorithm)</strong>: 为求解一个问题所需遵循的,被清楚指定的简单指令集合</li><li>当某种算法被给定时,则需要确定该算法所需的时间和空间等资源量</li></ul></li><li><strong>抽象数据类型(Abstract Data Type,ADT)</strong>: 是一些操作的集合,是数学上的抽象<ul><li>例如表,集合,图以及它们的操作可看作抽象数据类型</li><li>例如集合ADT,可以有 并(union), 交(intersection), 补(complement), 求大小(size)等操作</li><li>基本思路: 只在程序中编写一次,其他地方需要运行 ADT 上的操作时,可通过调用函数实现</li></ul></li><li>定义: 建立无穷大量之间的相对级别<ul><li>$\mathrm{if} \quad \exists c,n_0\in N_+,N\geq n_0\quad\mathrm{s.t.} T(N)\leq cf(N), \mathrm{then} \quad T(N)&#x3D;O(f(N))$</li><li>$\mathrm{if} \quad \exists c,n_0\in N_+,N\geq n_0  \quad  \mathrm{s.t.} T(N)\geq cg(N),\mathrm{then} \quad T(N)&#x3D;\Omega(g(N))$</li><li>$T(N)&#x3D;O(h(N))  \quad and\quad T(N)&#x3D;\Omega(h(N)) \iff T(N)&#x3D;\Theta(h(N))$</li><li>$T(N)&#x3D;O(p(N)) \quad and \quad T(N)\neq \Theta(p(N)), \mathrm{then} \quad T(N)&#x3D;o(f(N))$</li></ul></li><li>简要说明<ul><li>$O$: 高阶无穷大</li><li>$\Omega$: 低阶无穷大</li><li>$\Theta$: 同阶无穷大</li><li>$o$: 严格的高阶无穷大</li></ul></li><li><strong>一般采用大$O$记法</strong>.例如 $T(N)&#x3D;2N^2+N&#x3D;O(N^2)$<ul><li>不要将常数或低阶项放入大$O$,直接忽略即可</li><li>典型的增长率(递增排列): $C, \mathrm{log}N, \mathrm{log}^2N, N, N\mathrm{log}N, N^2, N^3, 2^N$</li><li>可以使用洛必达法则确定两个函数的相对级别</li></ul></li></ol><h3 id="0-2-计算方式"><a href="#0-2-计算方式" class="headerlink" title="0.2 计算方式"></a>0.2 计算方式</h3><ol><li>为在正式的框架中分析算法,需要一个计算模型<ul><li>假定一个标准计算机,它顺序执行指令.拥有简单的指令系统(如加减乘除,赋值等)</li><li>特别地,该模型机执行任意一条简单指令都恰好花费一个时间单元</li><li>该模型机具有无限内存</li></ul></li><li>待分析的问题<ul><li>最重要的资源一般为运行时间</li><li>在这里分析对运行时间的影响因素有: 使用的算法, 对该算法的输入(主要方面)</li><li>考虑两个函数<ul><li>$T_{avg}(N)$: 输入为 N 时算法所花费的平均时间</li><li>$T_{worst}(N)$: 输入为 N 时算法在最坏情况下花费的时间</li><li><strong>主要考虑 $T_{worst}(N)$.因为它为所有的输入提供了一个运行时间上界</strong></li></ul></li><li>当两个程序花费的时间大致相同时,判断运行速度的方法是将其编码并运行</li><li>为简化分析,系数,低阶项,常数项直接抛弃.只计算其上界: 大$O$</li></ul></li></ol><h3 id="0-3-运行时间计算"><a href="#0-3-运行时间计算" class="headerlink" title="0.3 运行时间计算"></a>0.3 运行时间计算</h3><ol><li><p>分析案例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 计算 1~n 的立方和 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> partialSum = <span class="hljs-number">0</span>;<span class="hljs-comment">// 声明不计时间,赋值计1个时间单元</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i &lt;= n, i++) &#123;<span class="hljs-comment">// 初始化赋值计1次,判断循环条件计n+1次,自增计n次</span><br>        partialSum += i * i * i;<span class="hljs-comment">// 乘法2次,加法1次,赋值1次.重复n次,共计4n个时间单元</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> partialSum;<span class="hljs-comment">// 返回计1个时间单元</span><br>&#125;  <span class="hljs-comment">// 本算法共计6n+4个时间单元,即 O(N)</span><br></code></pre></td></tr></table></figure></li><li><p>一般法则</p><ul><li><code>for</code>: 运行时间最多为循环语句的运行时间乘以迭代次数</li><li>嵌套 <code>for</code>: 由里向外分析循环.嵌套循环内部一条语句总运行时间为: 该语句运行时间乘以<code>for</code>循环大小的乘积</li><li>顺序语句: 对各语句的运行时间求和(事实上,只需考虑运行时间最长的语句)</li><li><code>if/else</code>: 判断语句运行时间加上分支语句中最长的运行时间</li><li><strong>分析的基本策略为从内部向外扩展.如果有函数调用,则应该首先分析</strong></li></ul></li><li><p>考虑 Fibonacci 数列递归求和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-1</span>) + fib(n<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>运行时间为: $T(N)&#x3D;T(N-1)+T(N-2)\quad (n\geq2)$.这是一个指数级增长</li><li>运行效率低下的原因为: 进行了大量的重复计算,且计算结果被抛弃</li><li>改进: 用一个数组将计算结果存储起来,将可以大大提高运行效率</li></ul></li><li><p>最大子序列和问题的四种算法</p></li></ol><ul><li><p>问题: 给定整数 $A_1,A_2,\dots,A_n$, 求  $\sum\limits^j_{k&#x3D;i}A_k$ 的最大值(假定数组中均为负数,则最大子序列和为0)</p></li><li><p>穷举所有的可能 $\Theta(n^3)$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumN3</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i; j&lt;n; j++) &#123;<br>            <span class="hljs-type">int</span> thisSum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i; k&lt;=j; k++) &#123;<br>                thisSum += a[k];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(thisSum &gt; maxSum)<br>                maxSum = thisSum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分析可知,最内层的 for 冗余,将其去掉 $O(N^2)$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumN2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-type">int</span> thisSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i; j&lt;n; j++) &#123;<br>            thisSum += a[j];<br>            <span class="hljs-keyword">if</span>(thisSum &gt; maxSum)<br>                maxSum = thisSum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>递归 $O(N\mathrm{logN})$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumNlogN</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left == right) <span class="hljs-comment">// 参数为数组,左边界,右边界</span><br>        <span class="hljs-keyword">return</span> a[left] &gt; <span class="hljs-number">0</span> ? a[left] : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> center = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> maxLeftSum, maxRightSum;<br>    maxLeftSum = maxSubseqSumNlogN(a, left, center);  <span class="hljs-comment">// 递归调用</span><br>    maxRightSum = maxSubseqSumNlogN(a, center + <span class="hljs-number">1</span>, right);<br><br>    <span class="hljs-type">int</span> maxLeftBrdSum,  maxRightBrdSum,     leftBrdSum,     rightBrdSum;<br>    maxLeftBrdSum = <span class="hljs-number">0</span>;  maxRightBrdSum = <span class="hljs-number">0</span>; leftBrdSum = <span class="hljs-number">0</span>; rightBrdSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=center; i&gt;=left; i--) &#123;  <span class="hljs-comment">// 计算中值到左边界的最大和</span><br>        leftBrdSum += a[i];<br>        <span class="hljs-keyword">if</span>(leftBrdSum &gt; maxLeftBrdSum)<br>            maxLeftBrdSum = leftBrdSum;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=center+<span class="hljs-number">1</span>; i&lt;=right; i++) &#123;  <span class="hljs-comment">// 计算中值到右边界的最大和</span><br>        rightBrdSum += a[i];<br>        <span class="hljs-keyword">if</span>(rightBrdSum &gt; maxRightBrdSum)<br>            maxRightBrdSum = rightBrdSum;<br>    &#125;<br>    <span class="hljs-comment">// 返回三者的最大值</span><br>    <span class="hljs-keyword">if</span> (maxLeftSum &gt;= maxRightSum)<br>        <span class="hljs-keyword">return</span> maxLeftSum &gt;= maxLeftBrdSum + maxRightBrdSum ? maxLeftSum : maxLeftBrdSum + maxRightBrdSum;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> maxRightSum &gt;= maxLeftBrdSum + maxRightBrdSum ? maxRightSum : maxLeftBrdSum + maxRightBrdSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>线性算法 $O(N)$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumN</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> thisSum, maxSum;<br>    thisSum = <span class="hljs-number">0</span>; maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++) &#123;<br>        thisSum += a[j];<br>        <span class="hljs-keyword">if</span>(thisSum &gt; maxSum)<br>            maxSum = thisSum;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(thisSum &lt; <span class="hljs-number">0</span>)<br>            thisSum = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行代码(将上述代码置于一个文件下即可运行)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">-2</span>&#125;;<br>    <span class="hljs-type">int</span> arrLength = <span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(N^3)   = %d\n&quot;</span>,maxSubseqSumN3(a, arrLength));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(N^2)   = %d\n&quot;</span>,maxSubseqSumN2(a, arrLength));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(NlogN) = %d\n&quot;</span>,maxSubseqSumNlogN(a, <span class="hljs-number">0</span>, arrLength - <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(N)     = %d\n&quot;</span>,maxSubseqSumN(a, arrLength));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li><p>运行时间中的对数</p><ul><li><p>对数经常出现的场景有</p><ul><li>若算法利用 $O(1)$ ,即在常数时间里将问题的规模削减一部分(如50%).则该算法为 $O(\mathrm{log}N)$</li><li>若算法利用 $O(1)$ ,即在常数时间里将问题的规模消减一个常数(如 -1).则该算法为 $O(N)$</li></ul></li><li><p>考虑到仅仅是将 N 个数据读入耗费的时间即为 $\Theta(N)$ .当谈及$O(\mathrm{log}N)$ 时均假定数据已读入</p></li></ul></li><li><p>下面三个算法均为 $O(\mathrm{log}N)$</p><ul><li><p>二分查找(给定整数$X$,已排序数组 $A_0,A_1,\dots,A_{n-1}$ ,求满足$A_i&#x3D;X$的下标 $i$)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">float</span> elementType;<br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> elementType arr[], elementType x, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> low, mid, high;<br>    low = <span class="hljs-number">0</span>; high =n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>        mid = (low+high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(arr[mid] &lt; x)<br>            low = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; x)<br>            high = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>欧几里得算法(计算最大公因数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> m,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rem;<br>    <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>) &#123;<br>        rem = m % n;<br>        m = n;<br>        n = rem;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>幂运算</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">int</span> x,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == n)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> == n % <span class="hljs-number">2</span> ? <span class="hljs-built_in">pow</span>(x * x, n / <span class="hljs-number">2</span>) : <span class="hljs-built_in">pow</span>(x * x, n / <span class="hljs-number">2</span>) * x;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1 线性表"></a>1 线性表</h2><h3 id="1-1-单链表"><a href="#1-1-单链表" class="headerlink" title="1.1 单链表"></a>1.1 单链表</h3><ol><li><p>表: 形如 $a_1, a_2,\dots ,a_n$ 的有限序列.其中 $a_i$ 为数据元素 </p><ul><li>其大小为 n (当 n&#x3D;&#x3D;0 称为空表,empty list)</li><li>表的操作: 创建空表(makeEmpty), 插入元素(Insert), 删除元素(Delete), 查找元素(find), 打印表(printList)</li><li>由于数组对于插入和删除元素的运行太慢,一般不用简单数组实现表</li></ul></li><li><p>链表: 由一系列的无需在内存中相连的结构组成</p><ul><li>每个结构含有表元素以及指向该元素后继元结构的指针(next 指针)</li><li>最后一个元素的 next 指针 指向 NULL</li><li><strong>预留一个标志节点作为表头(head).其位置为0</strong></li></ul></li><li><p>链表接口(具体实现见 <code>single_linked_list</code>.不考虑数组实现方式)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SINGLE_LINKED_LIST_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SINGLE_LINKED_LIST_H</span><br><br><span class="hljs-comment">/*********************************************************/</span><br><span class="hljs-comment">/* node:        结构体类型名,链表结点</span><br><span class="hljs-comment">** ptr2node:    结构体指针,指向链表结点的指针</span><br><span class="hljs-comment">** list:        结构体指针,一般将头结点声明为 list 类型</span><br><span class="hljs-comment">** position:    结构体指针,一般将其它结点声明为 position 类型</span><br><span class="hljs-comment">** elementType: 元素类型名 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr2node</span>;</span><br><span class="hljs-keyword">typedef</span> ptr2node <span class="hljs-built_in">list</span>;<br><span class="hljs-keyword">typedef</span> ptr2node position;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    elementType element;<br>    position next;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(elementType x, elementType y)</span>;<br><br><span class="hljs-comment">/*********************************************************/</span><br><span class="hljs-comment">/* 链表相关函数.除了创建空链表,其它函数都需要参数 list l,以指明操作对象 */</span><br><span class="hljs-comment">/********** 1.创建与销毁 **********/</span><br><span class="hljs-built_in">list</span> <span class="hljs-title function_">makeList</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">clearList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deleteList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><br><span class="hljs-comment">/********** 2.获取长度 **********/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmptyList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isLast</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, position p)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">lenList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><br><span class="hljs-comment">/********** 3.增删改查 **********/</span><br>position <span class="hljs-title function_">findPosition</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x)</span>;<br>position <span class="hljs-title function_">findPrevious</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">findIndex</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x, compare func)</span>;<br>elementType *<span class="hljs-title function_">findElem</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, <span class="hljs-type">int</span> index)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x, position p)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* SINGLE_LINKED_LIST_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p>常见错误</p><ul><li>未初始化指针: 如果不知道应将指针初始化为什么,则将其初始化为 NULL</li><li><code>malloc</code> 函数的使用<ul><li>声明一个结构体指针是并不创建该结构.仅留出足够容纳结构的空间</li><li>若只需要一个结构体指针沿着表前进(例: <code>printList</code> 函数中的 <code>tmp</code>),则不需要使用 <code>malloc</code></li><li>当空间不再需要时.应使用 <code>free</code> 函数回收</li><li>若链表未执行过删除操作,则 <code>malloc</code> 调用次数应等于表的大小.若有表头,调用次数会多一次</li></ul></li></ul></li></ol><h3 id="1-2-链表使用"><a href="#1-2-链表使用" class="headerlink" title="1.2 链表使用"></a>1.2 链表使用</h3><ol><li><p>双链表: 在数据结构中增加一个域,使其指向前一个单元</p><ul><li><p>增加空间需求.因为需要额外存储一个指针</p></li><li><p>使得插入和删除的开销增加一倍.因为需要对增加的指针进行定位</p></li><li><p>简化删除操作.因为不再需要定位前驱元</p></li></ul></li><li><p>循环链表: 令最后一个单元指向第一个单元(可以存在表头,令最后一个单元指向表头)</p></li><li><p><strong>桶排序(bucket sort)</strong></p><ul><li>问题: 存在 $n$ 个整数 $a_i(0\leq x_i\leq M-1,1\leq i\leq n)$ 需要排序</li><li>预留一个大小为 $M$ 的 count 数组.即 count 有 $M$ 个单元(桶).初始情况下 count 内元素为空</li><li>当 $a_i$ 被读入时,$\mathrm{count}[a_i]$ 自增1;所有的输入被读入后,扫描数组 count,打印排好序的表</li><li>该算法的时间花费为 $O(M+N)$</li></ul></li><li><p><strong>基数排序(radix sort)是桶式排序的推广</strong></p><ul><li><p>考虑当桶的数量远大于数的个数时.桶排序便不再适合</p></li><li><p>若存在 $n$ 个整数 $a_i(0\leq x_i\leq n^p-1,1\leq i\leq n)$ 需要排序.进行多次桶式排序</p></li><li><p>第一步以最低位进行桶式排序,依次按位数桶式排序,直到最高位完成进行桶式排序</p></li><li><p>该算法的时间花费为 $O(p(n+b))$.其中 p 为趟数,n 为元素个数,b 为桶数</p></li><li><p>例: 对 0~9 的立方进行基数排序</p><ul><li>原始数组: [0, 1, 512, 343, 64, 125, 216, 27, 8, 729]</li><li>第一次排序结果: [0, 1, 512 ,343, 64, 125, 216, 27, 8, 729]</li><li>第二次排序结果: [8, 1, 0], [216, 512], [729,27,125],  [343], [64]</li><li>第三次排序结果: [64,27,8,1,0], [125], [216], [343], [512], [729]</li></ul></li></ul></li></ol><h3 id="1-3-栈"><a href="#1-3-栈" class="headerlink" title="1.3 栈"></a>1.3 栈</h3><ol><li><p>栈(stack): 限制插入和删除只能在一个位置(栈顶, top)进行的表</p><ul><li>栈的基本操作有: 入栈(push),出栈(pop)</li><li>栈的特点: 后进先出(LIFO),且只有栈顶元素可访问</li><li>栈的链表实现及其操作不涉及栈的大小,因此均为常数时间开销.缺点在于需要承担 <code>malloc,free</code> 的开销</li><li>当栈采用头插法进行入栈,则头节点的后继元即为栈顶,因此出栈只需删除头节点的后继元</li></ul></li><li><p>栈接口(具体实现见 <code>stack</code>.不考虑数组实现方式)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STACK_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr2node</span>;</span><br><span class="hljs-keyword">typedef</span> ptr2node <span class="hljs-built_in">stack</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    elementType element;<br>    ptr2node next;<br>&#125;;<br><br><span class="hljs-built_in">stack</span> <span class="hljs-title function_">makeStack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deleteStack</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s, elementType x)</span>;<br>elementType <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* STACK_H */</span></span><br></code></pre></td></tr></table></figure></li></ol><h3 id="1-4-队列"><a href="#1-4-队列" class="headerlink" title="1.4 队列"></a>1.4 队列</h3><ol><li><p>队列(queue): 限制插入(队尾, rear)和删除(队头, front)只能在两端分别进行的表</p><ul><li>队列的基本操作有入队(enqueue),出队(dequeue)</li><li>队列的特点: 先进先出(FIFO);只有队头元素可访问</li></ul></li><li><p>队列的链表实现的注意事项</p><ul><li>队列需要指向队头(front)和队尾(rear)的两个指针</li><li>当进行入队操作时,采用尾插法,且需要将 rear 指针向后移动一位</li><li>当进行出队操作时,需要先判断队列是否为空(front &#x3D;&#x3D; rear),然后删除 front 指针的后继元</li></ul></li><li><p>队列接口(具体实现见 <code>queue</code>.不考虑数组实现方式)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> QUEUE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUEUE_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr2node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    elementType element;<br>    ptr2node next;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ptr2node front;<br>    ptr2node rear;<br>&#125; *<span class="hljs-built_in">queue</span>;<br><br><span class="hljs-built_in">queue</span> <span class="hljs-title function_">makeQueue</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deleteQueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q, elementType e)</span>;<br>elementType <span class="hljs-title function_">dequeue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* QUEUE_H */</span></span><br></code></pre></td></tr></table></figure></li></ol><h2 id="2-树"><a href="#2-树" class="headerlink" title="2 树"></a>2 树</h2><h3 id="2-1-树的实现"><a href="#2-1-树的实现" class="headerlink" title="2.1 树的实现"></a>2.1 树的实现</h3><ol><li><p>树的递归定义: 一棵<strong>树</strong>是一些节点的集合(可以是空集).若非空,则一棵树由称为<strong>根</strong>(root)的节点 r,以及0个或多个非空的(子)树 $T_1,T_2,\dots,T_k$ 组成,这些<strong>子树</strong>中的每一颗的根都被来自根 r 的一条有向边所连接</p><ul><li><strong>叶</strong>(leaf): 没有子节点的节点</li><li><strong>兄弟</strong>(sibling): 具有相同父节点的节点</li><li><strong>路径</strong>(path): 从节点 $n_1$ 到 $n_k$ 的路径为 $n_1, n_2,\dots,n_k$ 的一个序列.且对于 $1\leq i&lt;k$,有 $n_i$ 是 $n_{i+1}$ 的父节点</li><li><strong>路径的长</strong>(length): 路径上 边的条数,即 $k-1$.每一节点到自身的路径长为0</li><li><strong>深度</strong>(depth): 对于任意节点 $n_i$,其深度为从根到 $n_i$ 的唯一路径的长</li></ul></li><li><p>树的实现</p><ul><li><p>在每一个节点除数据外,还需要的两个指针指向它的第一子节点(向下)及下一个兄弟节点(向右)</p></li><li><p>树的节点声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">prtToNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> &#123;</span><br>    elementType element;<br>    prtToNode firstChild;<br>    prtToNode nextSibling;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>树的遍历</p><ul><li><p>树经常用于操作系统中的目录结构</p><ul><li>例如 Unix 系统中的文件 <code>/usr/mark/book/ch1.r</code></li><li>第一个 &#x2F; 后的每个 &#x2F; 都表示一条边</li></ul></li><li><p>考虑以下述格式打印目录中的所有文件: 深度为 $d_i$ 的文件的名称前有 $d_i$ 个 <kbd>tab</kbd> 进行缩进,然后打印</p></li><li><p>实现思路: 以递归的方式打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">listDir</span><span class="hljs-params">(directoryOrFile d, <span class="hljs-type">int</span> depth)</span> &#123;<br>    <span class="hljs-keyword">if</span>(d is a legitimate entry) &#123;<br>        printName(d, depth);<br>        <span class="hljs-keyword">if</span>(d is a directory) &#123;<br>            <span class="hljs-keyword">for</span> each child, c, of d<br>                <span class="hljs-title function_">listDir</span><span class="hljs-params">(c, depth + <span class="hljs-number">1</span>)</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">listDirectory</span><span class="hljs-params">(directoryOrFile d)</span> &#123;<br>    listDir(d, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>算法核心函数 <code>listDir</code>: 参数为目录树的引用.如果是目录,则递归的处理子节点,文件名则被缩进后打印</li><li>驱动函数 <code>listDirectory</code>: 考虑到 <code>listDir</code> 的参数 <code>depth</code> 为内部递归变量.<br>因此需要驱动函数(这里赋值为0)</li></ul></li></ul></li></ol><h3 id="2-2-二叉树"><a href="#2-2-二叉树" class="headerlink" title="2.2 二叉树"></a>2.2 二叉树</h3><ol><li><p><strong>二叉树</strong>: 每个节点的子节点都不超过2个的树</p><ul><li>平均二叉树的深度通常比节点数 N 小得多,平均深度为 $O(\sqrt N)$</li><li><strong>二叉查找树</strong>(binary search tree)的平均深度为 $O(\log N)$.但在最坏的情况下可以为 N-1</li></ul></li><li><p>二叉树的实现</p><ul><li><p>由于二叉树最多有两个子节点,因此可以直接用指针指向它们</p></li><li><p>二叉树的节点声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">ptrToNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ptrToNode</span> <span class="hljs-title">tree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> &#123;</span><br>    elementType element;<br>    tree left;<br>    tree right;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="2-3-二叉查找树"><a href="#2-3-二叉查找树" class="headerlink" title="2.3 二叉查找树"></a>2.3 二叉查找树</h3><ol><li><p>二叉树经常用于查找.给树中的每个节点指定一个关键字值(假定为整数,且唯一)</p></li><li><p><strong>二叉查找树</strong>: 对于树中的每个节点 X,其左子树所有关键字值小于X关键字值,右子树所有关键字值大于X关键字值</p><ul><li>考虑到树的递归定义,对二叉查找树的操作通常采用递归处理</li><li>考虑到所有的元素都是有序的,因此假定运算符 <code>&lt;, =, &gt;</code> 均可用于这些元素</li></ul></li><li><p>二叉查找树的声明(<code>searchTree.h</code>文件中)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SEARCH_TREE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEARCH_TREE_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">position</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">searchTree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> &#123;</span><br>    elementType element;<br>    searchTree left;<br>    searchTree right;<br>&#125;<br><br>searchTree <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">(searchTree t)</span>;  <span class="hljs-comment">// 创建空树</span><br>position <span class="hljs-title function_">find</span><span class="hljs-params">(elementType x, searchTree t)</span>;  <span class="hljs-comment">// 查找元素位置</span><br>position <span class="hljs-title function_">findMin</span><span class="hljs-params">(searchTree t)</span>;  <span class="hljs-comment">// 查找最小值位置</span><br>position <span class="hljs-title function_">findMax</span><span class="hljs-params">(searchTree t)</span>;  <span class="hljs-comment">// 查找最大值位置</span><br>searchTree <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, searchTree t)</span>;  <span class="hljs-comment">// 插入元素</span><br>searchTree <span class="hljs-title function_">delete</span><span class="hljs-params">(elementType x, searchTree t)</span>;  <span class="hljs-comment">// 删除元素</span><br>elementType <span class="hljs-title function_">retrieve</span><span class="hljs-params">(position p)</span>;  <span class="hljs-comment">// 检索位置信息</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* SEARCH_TREE_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p>源文件 <code>searchTree.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c">searchTree <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">(searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t != <span class="hljs-literal">NULL</span>) &#123;<br>        makeEmpty(t-&gt;left);<br>        makeEmpty(t-&gt;right);<br>        <span class="hljs-built_in">free</span>(t);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>position <span class="hljs-title function_">find</span><span class="hljs-params">(elementType x, searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(x &lt; t-&gt;element)<br>        <span class="hljs-keyword">return</span> find(x, t-&gt;left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t-&gt;element)<br>        <span class="hljs-keyword">return</span> find(x, t-&gt;right);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> t;<br>&#125;<br><br>position <span class="hljs-title function_">findMin</span><span class="hljs-params">(searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;left == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> t;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> findMin(t-&gt;left);<br>&#125;<br><br>position <span class="hljs-title function_">findMax</span><span class="hljs-params">(searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t != <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">while</span>(t-&gt;right != <span class="hljs-literal">NULL</span>)<br>            t = t-&gt;right;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br>searchTree <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>) &#123;<br>        t = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> treeNode));<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">NULL</span>)<br>            fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            t-&gt;element = x;<br>            t-&gt;left = t-&gt;right = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; t-&gt;element)<br>        t-&gt;left = insert(x, t-&gt;left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t-&gt;element)<br>        t-&gt;right = insert(x, t-&gt;right);<br>    <span class="hljs-comment">/* else x已经在树中,不在执行任何操作 */</span><br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br>searchTree <span class="hljs-title function_">delete</span><span class="hljs-params">(elementType x, searchTree t)</span> &#123;<br>    position tmp;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)  <span class="hljs-comment">/* 空树 */</span><br>        Error(<span class="hljs-string">&quot;Element not found&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; t-&gt;element)  <span class="hljs-comment">/* 向左 */</span><br>        t-&gt;left = delete(x, t-&gt;left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t-&gt;element)  <span class="hljs-comment">/* 向右 */</span><br>        t-&gt;right = delete(x, t-&gt;right);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;left &amp;&amp; t-&gt;right) &#123; <span class="hljs-comment">/* 2个子节点 */</span><br>        tmp = findMin(t-&gt;right);<br>        t-&gt;element = tmp-&gt;element;<br>        t-&gt;right = delete(t-&gt;element, t-&gt;right);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        tmp = t;<br>        <span class="hljs-keyword">if</span>(t-&gt;left == <span class="hljs-literal">NULL</span>)<br>            t = t-&gt;right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;right == <span class="hljs-literal">NULL</span>)<br>            t = t-&gt;left;<br>        <span class="hljs-built_in">free</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-AVL-树"><a href="#2-4-AVL-树" class="headerlink" title="2.4 AVL 树"></a>2.4 AVL 树</h3><ol><li><strong>AVL树</strong>(Adelson-Velskii Landis): 带有平衡条件(需易保持)的二叉查找树.且保证树的深度为$O(\log N)$<ul><li>AVL 树要求每个节点的左子树和右子树的高度最多差1(空树的高度定义为-1)</li><li>AVL 树的高度最多为$1.44\log (N+2)-1.328$. 因此可以保证除插入外的操作(删除为惰性)均为 $O(\log N)$</li></ul></li><li><strong>旋转</strong>: AVL 树的插入操作可能会破坏平衡条件,因此隐含着困难.但总是可以经过修正使得性质恢复<ul><li>插入后,只有插入点到根节点路径上的节点的平衡可能被改变.沿着此路径向上找到一个破坏了 AVL 条件的节点,调整该节点重新平衡该树,将会使得整棵树满足 AVL 条件</li><li>设需要重新平衡的节点为 $\alpha$.导致不平衡出现的插入位置共有4种情况<ol><li>左子节点的左子树</li><li>左子节点的右子树</li><li>右子节点的左子树</li><li>右子节点的右子树</li></ol></li><li>情形1,4 与 情形2,3 为关于 $\alpha$节点的对称.分别通过单旋转和双旋转进行处理</li></ul></li></ol><h2 id="3-散列"><a href="#3-散列" class="headerlink" title="3 散列"></a>3 散列</h2><h3 id="3-1-散列函数"><a href="#3-1-散列函数" class="headerlink" title="3.1 散列函数"></a>3.1 散列函数</h3><ol><li><p>散列表(hash table)ADT: 仅支持二叉查找树所允许的一部分操作,其实现常称为<strong>散列</strong>(hashing)</p><ul><li>散列以常数平均时间执行 插入,删除,查找,但需要元素间任何排序信息的操作不会得到有效支持</li><li>理想的散列表数据结构是一个含有<strong>关键字</strong>的具有固定大小的数组</li><li>关键字的典型是带有信息的字符串,而表的大小记为 Table-Size</li></ul></li><li><p><strong>映射函数</strong>(hash function): 将关键字映射到 [0, Table-Size) 区间中的某个数,且放到适当的单元中</p><ul><li>理想的映射函数应运算简单,且保证不同的关键字映射到不同的单元</li><li>实际上不可能,因为关键字是无穷的,而单元的数量是有限的</li><li>因此要找一个散列函数,能在单元间均匀的分配关键字</li><li><strong>冲突</strong>(collision): 两个关键字散列到同一个值</li></ul></li><li><p>散列函数</p><ul><li><p>若输入的关键字为整数,一般采用返回 <code>key mod tableSize</code>.保证表的大小为素数时效果较好</p></li><li><p>若输入的关键字为字符串</p><ol><li><p>可以将字符串中的字符的 ASCII 码值之和作为关键字(简单,但当表很大时将会分配不均)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index;<br>index <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">int</span> tableSize)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashVal = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*key != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        hashVal += *key++;<br>    <span class="hljs-keyword">return</span> hashVal % tableSize;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>考虑计算 $\mathrm{\sum\limits_{i&#x3D;0}^{keySize&#x3D;1}key[keySize-i-1]}\cdot 32^i$(根据 Horner 法则计算 32 的多项式函数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">index <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">int</span> tableSize)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashVal = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*key != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        hashVal = (hashVal &lt;&lt; <span class="hljs-number">5</span>) + *key++;<br>    <span class="hljs-keyword">return</span> hashVal % tableSize;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如计算 $h_k &#x3D; k_1 + 32k_2 + 32^2k_3$ 的方式为 $h_k &#x3D; ((k_3) \times 32 + k_2) \times 32+k_1$ </li><li>关键行中的 <code>&lt;&lt; 5</code> 即为乘以32, 且其中的加法还可以使用按位异或 <code>^</code> 代替</li><li>该算法的优点在于极其简单,当允许溢出时速度很也快</li><li>如果关键字特别长,不仅时间花费大,而且前面的字符还会被移出.此时通常不采用全部字符</li></ul></li></ol></li></ul></li></ol><h3 id="3-2-消除冲突"><a href="#3-2-消除冲突" class="headerlink" title="3.2 消除冲突"></a>3.2 消除冲突</h3><ol><li><p>当一个元素被插入处已存在另一个元素(即不同关键字的散列值相同),此时将产生冲突</p><ul><li>解决冲突的方式有: 分离链接法(separate chaining), 开放定址法(open addressing)</li></ul></li><li><p>分离链接法: 将散列到同一个值的所有元素保存到一个表中</p><ul><li><p>示例: 关键字为前10个数的平方(0, 1, 4, 9, 16, 25, 36, 49, 64, 81).散列函数为 $hash(x) &#x3D; x \space mod \space 10$</p></li><li><p>则分离链接散列表形如</p><p><img src="/2024/01/19/Data%20Structures%20and%20Algorithm%20Analysis%20in%20C/Data%20Structures%20and%20Algorithm%20Analysis%20in%20C/3-Detach-link-hash-tables.png"></p></li><li><p>插入操作: 遍历相应的表以检查该元素是否以处于适当的位置.如果是新元素,则将其插入到表的前端&#x2F;末尾</p></li><li><p>分离链接散列表的的实现</p><ul><li><p>头文件 <code>hashSeq.h</code> 中(其中 listNode 的结构与链表相同)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HASH_SEQ_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HASH_SEQ_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTbl</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">position</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTbl</span> *<span class="hljs-title">hashTable</span>;</span><br><br>hashTable <span class="hljs-title function_">initializeTable</span><span class="hljs-params">(<span class="hljs-type">int</span> tableSize)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">destroyTable</span><span class="hljs-params">(hashTable h)</span>;<br>position <span class="hljs-title function_">find</span><span class="hljs-params">(elementType key, hashTable h)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType key, hashTable h)</span>;<br>elementType <span class="hljs-title function_">retrieve</span><span class="hljs-params">(position p)</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br>    elementType element;<br>    position next;<br>&#125;<br><span class="hljs-keyword">typedef</span> position <span class="hljs-built_in">list</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTbl</span> &#123;</span><br>    <span class="hljs-type">int</span> tableSize;<br>    <span class="hljs-built_in">list</span> *theLists;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>源文件 <code>hashSeq.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">hashTable <span class="hljs-title function_">initializeTable</span><span class="hljs-params">(<span class="hljs-type">int</span> tableSize)</span> &#123;<br>    hashTable h;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>(tableSize &lt; minTableSize) &#123;<br>        error(<span class="hljs-string">&quot;Table size too small&quot;</span>);<br>        retrun <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>    h = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> hashTbl));<br>    <span class="hljs-keyword">if</span>(h == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    h-&gt;tableSize = nextPrime(tableSize);<br>    <br>    h-&gt;theLists = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">list</span>) * h-&gt;tableSize);<br>    <span class="hljs-keyword">if</span>(h-&gt;theLists == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; h-&gt;tableSize; i++) &#123;<br>        h-&gt;theLists[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> listNode));<br>        <span class="hljs-keyword">if</span>(h-&gt;theLists[i] == <span class="hljs-literal">NULL</span>)<br>            fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            h-&gt;theLists[i]-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType key, hashTable h)</span> &#123;<br>    position pos, newCell;<br>    <span class="hljs-built_in">list</span> l;<br>    pos = find(key, h);<br>    <span class="hljs-keyword">if</span>(pos == <span class="hljs-literal">NULL</span>) &#123;<br>        newCell = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> listNode));<br>        <span class="hljs-keyword">if</span>(newCell == <span class="hljs-literal">NULL</span>)<br>            fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            l = h-&gt;thelists[hash(key, h-&gt;tableSize)];<br>            newCell-&gt;next = l-&gt;next;<br>            newCell-&gt;element = key;<br>            l-&gt;next = newCell;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>开放定址法: 当冲突发生时,尝试选择另外的单元,知道找出空的单元为止</p><ul><li>考虑单元 $h_0(X),h_1(X),h_2(X), \cdots,$相继试选.其中 $h_i(X) &#x3D; (hash(x)+F(i))\mod \mathrm{tableSize}$</li><li>函数 $F$ 是冲突解决方法,且 $F(0) &#x3D; 0$ </li><li>开放地址法需要将所有数据置于表内,因此散列表较大.但省去了给新单元分配地址的时间</li></ul></li></ol><h3 id="3-3-再散列"><a href="#3-3-再散列" class="headerlink" title="3.3 再散列"></a>3.3 再散列</h3><ol><li><p><strong>再散列</strong>(rehashing): 对于开放定址法,如果表的元素太满,则操作时间消耗增长,且插入可能失败.此时可以建立另外一个约两倍大的表(同时使用一个相关的新散列函数),扫描整个原始散列表,计算每个元素的新散列值并将其插入到新表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">hashTable <span class="hljs-title function_">rehash</span><span class="hljs-params">(hashTable h)</span> &#123;<br>    <span class="hljs-type">int</span> i, oldSize;<br>    cell *oldCell;<br>    oldCells = h-&gt;theCells;<br>    oldSize = h-&gt;tableSize;<br>    h = initializeTable(<span class="hljs-number">2</span> * oldSize);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; oldSize; i++) &#123;<br>        <span class="hljs-keyword">if</span>(oldCells[i].info == legitimate)<br>            insert(oldCells[i].element, h);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(oldCells);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-优先队列"><a href="#4-优先队列" class="headerlink" title="4 优先队列"></a>4 优先队列</h2><h3 id="4-1-优先队列"><a href="#4-1-优先队列" class="headerlink" title="4.1 优先队列"></a>4.1 优先队列</h3><ol><li><strong>优先队列</strong>(priority queue): 是允许至少插入(入队)和删除最小(出队:找出,返回,删除优先队列中的最小元素)的数据结构</li><li>优先队列的简单实现方式<ul><li>使用简单链表: 在表头进行插入$O(1)$,遍历链表以实现删除最小元$O(n)$</li><li>始终让表保持排序状态: 进行顺序插入$O(n)$和删除操作$O(1)$</li><li>二叉查找树: 对插入和删除操作均为 $O(\log n)$</li></ul></li></ol><h3 id="4-2-二叉堆"><a href="#4-2-二叉堆" class="headerlink" title="4.2 二叉堆"></a>4.2 二叉堆</h3><ol><li><p>二叉堆(binary heap) 具有两个性质: 结构性和堆序性.因此堆的操作需要堆的所有性质都被满足才终止</p></li><li><p>结构性质: <strong>堆</strong>(heap): 一颗被完全填满的二叉树(完全二叉树, complete binary tree),底层可以例外(从左到右填入)</p><ul><li>高为 h 的完全二叉树节点数为: $[2^h, 2^{h+1})$.因而完全二叉树的高是 $\lfloor \log N \rfloor$</li><li>完全二叉树可以用数组进行表示,而不需要指针</li><li>考虑位置为 i 的元素,其左子节点位于 2i,右子节点位于左子节点后的 2i+1,父节点位于 $\lfloor i&#x2F;2 \rfloor$ </li><li>堆数据结构将由 一个数组(无论关键为什么类型),一个代表最大值的整数,当前堆大小的整数 组成</li></ul></li><li><p>堆序性质: 使操作快速执行</p><ul><li>考虑需要找出最小元,因此最小元应该在根上</li><li>将任意子树也视为一个堆,则任意节点应小于其所有后裔</li><li><strong>堆序性质</strong>: 在一个堆中,对于任意节点 X, X父节点的关键字小于X的关键字(根节点除外)</li></ul></li><li><p>优先队列的声明(<code>binaryHeap.h</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BIN_HEAP_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIN_HEAP_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapStruct</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapStruct</span> *<span class="hljs-title">priorityQueue</span>;</span><br><br>priorityQueue <span class="hljs-title function_">initialize</span><span class="hljs-params">(<span class="hljs-type">int</span> maxElements)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, priorityQueue h)</span>;<br>elementType <span class="hljs-title function_">deleteMin</span><span class="hljs-params">(priorityQueue h)</span>;<br>elementType <span class="hljs-title function_">findMin</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">(priorityQueue h)</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapStruct</span> &#123;</span><br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> size;<br>    elementType *elements;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>优先队列的操作(<code>binaryHeap.c</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">priorityQueue <span class="hljs-title function_">initialize</span><span class="hljs-params">(<span class="hljs-type">int</span> maxElements)</span> &#123;<br>    priorityQueue h;<br>    <span class="hljs-keyword">if</span>( maxElements &lt; minPQSize )<br>        error(<span class="hljs-string">&quot;Priority queue size is too small&quot;</span>);<br>    h = <span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>( <span class="hljs-keyword">struct</span> heapStruct ) );<br>    <span class="hljs-keyword">if</span>(h == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    h-&gt;elements = <span class="hljs-built_in">malloc</span>( ( maxElements + <span class="hljs-number">1</span> ) * <span class="hljs-keyword">sizeof</span>(elementsType) );<br>    <span class="hljs-keyword">if</span>( h-&gt;elements == <span class="hljs-literal">NULL</span> )<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    h-&gt;capacity = maxElements;<br>    h-&gt;size = <span class="hljs-number">0</span>;<br>    h-&gt;elements[<span class="hljs-number">0</span>] = minData;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, priorityQueue h)</span> &#123;<br>    <span class="hljs-keyword">if</span>(isFull(h)) &#123;<br>        error(<span class="hljs-string">&quot;Priority queue is full&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = ++h-&gt;size; h-&gt;elements[ i / <span class="hljs-number">2</span> ] &gt; x; i /= <span class="hljs-number">2</span>)<br>        h-&gt;elements[ i ] = h-&gt;elements[ i / <span class="hljs-number">2</span> ];<br>    h-&gt;elements[i] = x;<br>&#125;<br><br>elementType <span class="hljs-title function_">deleteMin</span><span class="hljs-params">(priorityQueue h)</span> &#123;<br>    <span class="hljs-type">int</span> child;<br>    elementType minElement, lastElement;<br>    <span class="hljs-keyword">if</span>( isEmpty(h) ) &#123;<br>        error(<span class="hljs-string">&quot;Priority queue is full&quot;</span>);<br>        <span class="hljs-keyword">return</span> h-&gt;elements[<span class="hljs-number">0</span>];<br>    &#125;<br>    minElement = h-&gt;elements[<span class="hljs-number">1</span>];<br>    lastElement = h-&gt;elements[h-&gt;size--];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i * <span class="hljs-number">2</span> &lt;=  h-&gt;size; i = child) &#123;<br>        child = i * <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(child != h-&gt;size &amp;&amp; h-&gt;elements[child+<span class="hljs-number">1</span>] &lt; h-&gt;elements[child])<br>            child++;<br>        <span class="hljs-keyword">if</span>(lastElement &gt; h-&gt;elements[child])<br>            h-&gt;elements[i] = h-&gt;elements[child];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    h-&gt;elements[i] = lastElement;<br>    <span class="hljs-keyword">return</span> minElement;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-排序"><a href="#5-排序" class="headerlink" title="5 排序"></a>5 排序</h2><ol><li>排序算法接受的参数为: 数组首地址, 及一个表示数组元素个数的整数</li><li>基于比较的排序: 假定对于元素而言,运算符 <code>&lt;, &gt;</code> 是存在的</li><li>逆序(inversion): 与线性代数中的关于排列的逆序数定义类似<ul><li>n 个互异数的数组的平均逆序数为 $\frac{n(n-1)}4$</li><li>通过交换相邻元素进行排序的任何算法平均需要 $\Omega(N^2)$</li><li>排序算法通过删除逆序进行,为了有效运行,必须每次删除不止一个逆序</li></ul></li><li>间接排序(indirect sorting): 由于交换结构的操作是昂贵的,因而可以创建数组(其元素为指向结构的指针).通过比较指针指向的关键字,并在必要时交换指针来进行排序</li><li>排序的一般下界<ul><li>任何只用到比较的算法在最坏的情况下需要 $\Omega(N\log N)$ 次比较,因而归并排序和堆排序最优</li><li>任何只用到比较的算法在平均的情况下需要 $\Omega(N\log N)$ 次比较,因而快速排序是最优的</li></ul></li></ol><h3 id="5-1-插入排序"><a href="#5-1-插入排序" class="headerlink" title="5.1 插入排序"></a>5.1 插入排序</h3><ol><li><p>插入排序(insert sort)</p><ul><li><p>将数组假想为两部分: 前面的为已排序数组,后面的为待排序数组</p></li><li><p>初始状态为已排序数组只有第一个元素,剩余为待排序数组</p></li><li><p>遍历待排序数组,将每个未排序元素插入到已排序数组中恰当的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    elementType tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>; p &lt; n; ++p) &#123;<br>        tmp = arr[p];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = p; j&gt;<span class="hljs-number">0</span> &amp;&amp; arr[j<span class="hljs-number">-1</span>] &gt; tmp; --j)<br>            arr[j] = arr[j<span class="hljs-number">-1</span>];<br>        arr[j] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>时间复杂度: $O(N^2)$</p><ul><li>当输入数据为逆序时,达到此上界</li><li>当输入数据已排序时,运行时间为 $O(N)$</li><li><strong>对于几乎已经排序的数据(逆序数 I 较小),插入排序很快,其时间为 $O(I+N)$</strong></li></ul></li></ol><h3 id="5-2-希尔排序"><a href="#5-2-希尔排序" class="headerlink" title="5.2 希尔排序"></a>5.2 希尔排序</h3><ol><li><p>希尔排序(缩小增量排序, diminishing increment sort): 先将整个待排序的序列分割为若干子序列分别进行直接插入排序,待整个序列中的记录基本有序时,在对全体进行直接插入排序</p><ul><li><p>增量序列: $h_1, h_2, \dots,h_t$,其中 $h_1 &#x3D; 1$</p></li><li><p>$h_k$-排序数组: $\forall i,arr[i] \leq arr[i+h_k]$</p></li><li><p>希尔增量通常取 $h_t &#x3D; \lfloor n&#x2F;2 \rfloor, h_k &#x3D; \lfloor h_{k+1}&#x2F;2 \rfloor$ </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    elementType tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> increment = n/<span class="hljs-number">2</span>; increment &gt; <span class="hljs-number">0</span>; increment /= <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = increment; i &lt; n; ++i) &#123;<br>            tmp = arr[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &gt;= increment; j -= increment)<br>                <span class="hljs-keyword">if</span>(tmp &lt; arr[j - increment])<br>                    a[j] = a[j - increment];<br>            <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">break</span>;<br>                arr[j] = tmp;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>时间复杂度(希尔排序算法简单,但分析极其困难)</p><ul><li>希尔增量下的希尔排序的最坏情形运行时间 $\Theta(N^2)$</li><li>Hibbard 增量: 形如 $1, 3, 7, \dots , 2^k-1$.最坏情形运行时间 $\Theta(N^\frac32)$</li></ul></li></ol><h3 id="5-3-堆排序"><a href="#5-3-堆排序" class="headerlink" title="5.3 堆排序"></a>5.3 堆排序</h3><ol><li><p>堆排序(heap sort): 考虑建立二叉堆 $O(N)$,执行 N 次 <code>deleteMin</code> $O(N\log N)$.按照顺序,最小的元素将会先离开堆,将这些元素记录到第二个数组即可得到排序数组</p></li><li><p>上述算法需要额外的数组空间,可以每次在 <code>deleteMin</code> 操作后,将最后空出来的单元用于存放元素.此时得到的将是逆序的排序数组,因而可以构建具有 <code>deleteMax</code> 操作的二叉堆</p></li><li><p>堆排序是非常稳定的算法: 平均使用的比较只比最坏情形略少</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> leftChild(i) (2 * (i) + 1)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">percDown</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> child;<br>    <span class="hljs-keyword">for</span>(elementType tmp = arr[i]; leftChild(i) &lt; n; i = child) &#123;<br>        <span class="hljs-keyword">if</span>(child != n - <span class="hljs-number">1</span> &amp;&amp; arr[child + <span class="hljs-number">1</span>] &gt; arr[child])<br>            child++;<br>        <span class="hljs-keyword">if</span>(tmp &lt; a[child])<br>            arr[i] = arr[child];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    arr[i] = tmp;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        percDown(arr, i, n);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>        swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[i]);<br>        percDown(arr, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-4-归并排序"><a href="#5-4-归并排序" class="headerlink" title="5.4 归并排序"></a>5.4 归并排序</h3><ol><li><p>考虑合并2个已排序的数组: 设定2个指针分别指向数组的起始位置.比较2个指针指向的元素,将较小的元素放入输出数组,并移动指针.重复这一过程,直到某一指针到达末尾</p></li><li><p>归并排序(merge sort): 以分治递归的形式合并已排序数组 $O(N\log N)$.使用的比较次数几乎最优</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mSort</span><span class="hljs-params">(elementType arr[], elementType tmpArr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> center;<br>    <span class="hljs-keyword">if</span>(left &lt; right) &#123;<br>        center = (left + right) / <span class="hljs-number">2</span>;<br>        mSort(arr, tmpArr, left, center);<br>        mSort(arr, tmpArr, center + <span class="hljs-number">1</span>, right);<br>        merge(arr, tmpArr, left, center + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mergeSord</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    elementType *tmpArr = <span class="hljs-built_in">malloc</span>( n * <span class="hljs-keyword">sizeof</span>(elementType) );<br>    <span class="hljs-keyword">if</span>(tmpArr != <span class="hljs-literal">NULL</span>) &#123;<br>        mSort(arr, tmpArr, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">free</span>(tmpArr);<br>    &#125; <span class="hljs-keyword">else</span><br>        fatalError(<span class="hljs-string">&quot;No space for tmp array!&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(elementType arr[], elementType tmpArr[], <span class="hljs-type">int</span> lpos, <span class="hljs-type">int</span> rpos, <span class="hljs-type">int</span> rightEnd)</span> &#123;<br>    <span class="hljs-type">int</span> leftEnd = rpos - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> tmpPos = lpos;<br>    <span class="hljs-type">int</span> numElements = rightEnd - lpos + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(lpos &lt;= leftEnd &amp;&amp; rpos &lt;= rightEnd)<br>        <span class="hljs-keyword">if</span>(arr[lpos] &lt;= arr[rpos])<br>            tmpArr[tmpPos++] = arr[lpos++];<br>    <span class="hljs-keyword">else</span><br>            tmpArr[tmpPos++] = arr[rpos++];<br>    <span class="hljs-keyword">while</span>(lpos &lt;= leftEnd)<br>        tmpArr[tmpPos++] = arr[lpos++];<br>    <span class="hljs-keyword">while</span>(rpos &lt;= rightEnd)<br>        tmpArr[tmpPos++] = arr[rpos++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numElements; ++i, --rightEnd) &#123;<br>        arr[rightEnd] = tmpArr[rightEnd];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-5-快速排序"><a href="#5-5-快速排序" class="headerlink" title="5.5 快速排序"></a>5.5 快速排序</h3><ol><li><p>快速排序(quick sort): 实践中最快的已知排序算法,平均运行时间 $O(N\log N)$</p><ul><li>若 S 中元素个数为 0 或 1,则直接返回</li><li>选取 S 中的任意元素 v,其称为基准(pivot)</li><li>分区并排序: 将 $S-{v}$ 分为两个不相交集合: $S_1 &#x3D;{x\in S-{v}|x\leq v},S_2 &#x3D;{x\in S-{v}|x\geq v} $ </li><li>递归地将小于基准元素的子数列和大于基准值元素的子数组排序</li></ul></li><li><p>选取基准</p><ul><li>错误的方式: 选取第一个元素作为基准.若输入是预排序或反序的,将会产生劣质的分割</li><li>安全的方式: 随机选取基准.但考虑到生成随机数是昂贵的,因而无法减少算法其余部分的平均运行时间</li><li>数中值分割法: 基准的最好选择是数组的中值,但这很难算出.因而可以考虑三个元素(左侧,中心,右侧位置)的中值作为基准.消除了预排序输入的坏情形,并减少约 5% 的时间</li></ul></li><li><p>分割策略</p><ul><li>将基准元与最后的元素进行交换,使得基准元离开要被分割的数据段</li><li>设置双指针 i, j. 初始时刻分别指向数组的第一个元素和倒数第二个元素(因为最后一个元素为基准)</li><li>当 i &lt; j 时,将 i 右移,直到遇到大于基准元的数.同理,将 j 左移,直到遇到小于基准元的数</li><li>若停止后的仍满足 i &lt; j,则将 i, j 指向的两个元素互换.重复该过程,直到 i, j 彼此交错</li><li>当 i, j 交错后,将基准元与 i 所指向的元素互换,即可完成分割</li></ul></li><li><p>对于小数组(n &lt; 20),快速排序不如插入排序好</p><ul><li>由于快速排序是递归的,因此小数组排序的情况经常发生</li><li>对小数组不进行递归排序,而进行插入排序将会节约15%的时间.截至范围可选择 n&#x3D;10</li></ul></li><li><p>快速排序的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    qSort(arr, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>&#125;<br><br>elementType <span class="hljs-title function_">median3</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> center = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(arr[left] &gt; arr[center])<br>        swap(&amp;arr[left], &amp;arr[center]);<br>    <span class="hljs-keyword">if</span>(arr[left] &gt; arr[right])<br>        swap(&amp;arr[left], &amp;arr[right]);<br>    <span class="hljs-keyword">if</span>(arr[center] &gt; arr[right])<br>        swap(&amp;arr[center], &amp;arr[right]);<br>    swap(&amp;arr[center], &amp;arr[right - <span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> arr[right - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">qSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    elementType pivot;<br>    <span class="hljs-keyword">if</span>(left + cutOff &lt;= right) &#123;<br>        pivot = median3(arr, left, right);<br>        <span class="hljs-type">int</span> i = left;<br>        <span class="hljs-type">int</span> j = right - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(;;) &#123;<br>            <span class="hljs-keyword">while</span>(arr[++i] &lt; pivot) &#123;&#125;<br>            <span class="hljs-keyword">while</span>(arr[--j] &lt; pivot) &#123;&#125;<br>            <span class="hljs-keyword">if</span>(i &lt; j)<br>                swap(&amp;arr[i], &amp;arr[j]);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        swap(&amp;arr[i], &amp;arr[right - <span class="hljs-number">1</span>]);<br>        qSort(arr, left, i - <span class="hljs-number">1</span>);<br>        qSort(arr, i + <span class="hljs-number">1</span>, right);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        insertSort(arr + left, right - left + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-图论算法"><a href="#6-图论算法" class="headerlink" title="6 图论算法"></a>6 图论算法</h2><h3 id="6-1-图的定义"><a href="#6-1-图的定义" class="headerlink" title="6.1 图的定义"></a>6.1 图的定义</h3><ol><li>图(graph): 由顶点(vertex)的集合 V,边(edge)的集合 E 组成<ul><li>每条边都是点对(v, w), 其中 $v,w\in V$</li><li>若点对是有序的,则图是有向(directed)的,称为有向图(digraph)</li><li>顶点 v, w 邻接等价于当 $(v,w)\in E$</li><li>边可以有第三种成分: 权(weight) 或 值(cost)</li></ul></li><li>图中的路径(path)<ul><li>路径是顶点序列: $w_1, w_2, \dots, w_N \space\space \mathrm{s.t.}(w_i,w_{i+1})\in E,1\leq i&lt;E$ </li><li>路径的长(length): 边的数量,即 N-1</li><li>环(loop): 从一个顶点到自身的边</li><li>简单路径: 所有的顶点都互异,但第一个和最后一个顶点可以相同</li></ul></li><li>图中的圈(cycle)<ul><li>有向图中的圈: 满足 $w_1 &#x3D; w_N$ 且长至少为1的一条路径</li><li>无向图中的圈则额外要求边是互异的</li></ul></li><li>连通(connected)<ul><li>在无向图中从每一个顶点到每个其他顶点都存在一条路径</li><li>在有向图中,这种性质称为强连通(strongly connected)</li><li>若有向图不是强连通的,但其基础图(underlying graph, 即去掉弧的方向)是连通的,则称为弱连通(weakly connected)</li><li>完全图(complete graph): 每个顶点间都存在一条边</li></ul></li><li>图的表示(有向图)<ul><li>使用一个二维数组,即**邻接矩阵(adjacent matrix)**表示<ul><li>对于每条边(u, v),置 <code>A[u][v] = 1</code>.其他元素为0</li><li>若该边有一个权,则可置 <code>A[u][v]</code> 等于该权.使用很大&#x2F;小的数表示不存在的边</li><li>若图是稀疏的(sparse), 该方法所需求的空间 $\Theta(|V|^2)$ 过大了</li></ul></li><li><strong>邻接表(adjacent list)</strong>: 对每一个顶点,使用一个表存放所有的邻接点<ul><li>空间需求为 $O(|E|+|V|)$</li><li>邻接表是图的标准表示方法</li></ul></li><li>考虑到实际中顶点都有名字,因此需要使用散列表建立名字到数字的映射<ul><li>散列表中对每个顶点存储一个名字和一个内部编号( 1 ~ |V| 之间)</li></ul></li></ul></li></ol><h3 id="6-2-最短路径算法"><a href="#6-2-最短路径算法" class="headerlink" title="6.2 最短路径算法"></a>6.2 最短路径算法</h3><ol><li><p>输入一个赋权图: 与每条边 $(v_i, v_j)$ 联系的是穿越该弧的代价 $c_{i,j}$</p><ul><li>赋权路径长(weighted path length): $v_1v_2\dots v_N$ 路径的值为 $\sum\limits^{N-1}<em>{i&#x3D;1}c</em>{i,j}$</li></ul></li><li><p>单源最短路径问题: 给定赋权图 $G&#x3D;(V,E)$ 和特定顶点 s 作为输入,找出 s 到 G 每个点的最短赋权路径</p></li><li><p>无权最短路径</p><ul><li><p>广度优先搜索(breadth-first search): 按层处理顶点,距离最近的先辈赋值,最远的最后赋值</p></li><li><p>显然顶点s到自身距离为0,然后考察与s邻接的点,其距离为1.然后考察邻接的邻接,直到完成所有点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unWeigted</span><span class="hljs-params">(table t)</span> &#123;<br>    vertex v, w;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> currDist = <span class="hljs-number">0</span>; currDist &lt; numVetex; ++currDist)<br>        <span class="hljs-keyword">for</span> each vertex v<br>            <span class="hljs-title function_">if</span><span class="hljs-params">(!t[v].known &amp;&amp; t[v].dist == currDist)</span> &#123;<br>                t[v].known = True;<br>                <span class="hljs-keyword">for</span> each w adjacent to v<br>                    <span class="hljs-title function_">if</span><span class="hljs-params">(t[w].dist == infinity)</span> &#123;<br>                        t[w].dist = currDist + <span class="hljs-number">1</span>;<br>                        t[w].path = v;<br>                    &#125;<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Dijkstra 算法: 考虑赋权图的单源最短路径问题.仍借鉴无权时的思路</p><ul><li>顶点 s 到自身的距离为0,将其标记为已知,因为此时多了一个已知点,则可以获得其到达邻接点的距离</li><li>选取距离最小的点(贪心法,greedy algorithm)标记为已知,则有可以更新其到达邻接点的距离</li><li>重复该过程,直到获得到达目标点的最短距离</li><li>对于没有负值边的图,该算法总能完成.一旦出现负值边,则可能出现错误的答案</li></ul></li></ol><h2 id="7-算法设计技巧"><a href="#7-算法设计技巧" class="headerlink" title="7 算法设计技巧"></a>7 算法设计技巧</h2><h3 id="7-1-贪婪算法"><a href="#7-1-贪婪算法" class="headerlink" title="7.1 贪婪算法"></a>7.1 贪婪算法</h3><ol><li>贪婪算法分阶段工作.在每一个阶段,认为所作的决定是最好的,而不考虑将来的后果(即局部最优)<ul><li>当算法终止时,若局部最优就是全局最优,则算法正确.否则将得到一个次优解(suboptimal solution)</li><li>若不要求绝对最佳答案,也可通过简单的贪婪算法生成近似答案</li></ul></li><li>Huffman 编码<ul><li>ASCII 编码有约100个可打印字符和控制字符组成,需要 $\lceil \log 128\rceil&#x3D;7$ 位表示,可添加第8位作为校验位<ul><li>现实中,许多文件都含有大量的数字,空格和换行,而 q, x 很少</li><li>采用非等长编码,使经常出现的字符代码较短,可以节约磁盘空间</li></ul></li><li>对于代表字符的二进制代码,可以用二叉树来表示<ul><li>只在树叶上有数据.且每个字符从根节点开始,用0指示向左分支,用1指示向右分支</li><li>若字符 $c_i$ 在深度 $d_i$ 处,且出现 $f_i$ 次.则该字符代码的值(cost)为 $\sum d_i f_i$</li></ul></li></ul></li><li>Huffman 算法<ul><li>假设字符数量为 C.算法开始时存在 C 棵单节点树(每个字符一颗)</li><li>任意选取有最小权(树的权等于其树叶频率的和)的两棵树,任意形成以这两棵树为子树的新树</li><li>将这样的过程进行 C-1 次.即可得到最优 Huffman 编码树</li></ul></li></ol><h3 id="7-2-分治算法"><a href="#7-2-分治算法" class="headerlink" title="7.2 分治算法"></a>7.2 分治算法</h3><ol><li>分治(divide and conquer)算法<ul><li>分: 递归解决较小的问题(基本情况除外)</li><li>治: 从子问题的解 构建原问题的解</li></ul></li><li>最近点问题: 找出平面上点列中最近(欧几里得距离)的一对点<ul><li>暴力算法: 计算每个点对之间的距离,找出最小值 $O(N^2)$</li><li>分治算法思路<ul><li>将平面上的点分为两半,最近点对存在三种可能: 均在左, 均在右, 一个在左一个在右</li><li>记不同情况的最近点对的最小距离为: 左侧点集 $d_l$,右侧点集 $d_r$,两侧点间的距离 $d_c$</li><li>对于 $d_l, d_r$,可以递归的进行计算.关键在于如何计算 $d_c$</li></ul></li><li>$d_c$ 的计算<ul><li>令 $\delta &#x3D; \min(d_l, d_r)$.如果 $d_c$ 对 $\delta$ 有改进,则只需计算 $d_c$</li><li>若 $d_c$ 是这样的距离,则定义 $d_c$ 的两个点必然在分割线的 $\delta$ 邻域内(一个带状区域).限制考察点的数量</li><li>对于均匀分布的点集,则平均有 $O(\sqrt N)$ 个点位于邻域内,此时可采用暴力求解 $O(N)$</li></ul></li></ul></li><li>选择问题: 找出含有 N 个元素的表 S 中的第 k 个最小的元素(对于中位数 $k &#x3D; \lceil N&#x2F;2 \rceil$ 特别关注)<ul><li>通过对元素的快速排序,此问题以 $O(N\log N)$ 的最坏情形时间解决</li><li>五分化中项的中项 选择快速排序的基准<ul><li>将 N 个元素分为 $\lfloor N&#x2F;5 \rfloor$ 组,每5个元素一组,最多忽略4个元素</li><li>找出每组的中项,得到 $\lfloor N&#x2F;5 \rfloor$ 个中项的表 M,找出 M 的中项并返回</li></ul></li><li>使用五分化中项的中项的快速选择算法的运行时间为 $O(N)$.但实践中该算法并不实用</li></ul></li></ol><h3 id="7-3-动态规划"><a href="#7-3-动态规划" class="headerlink" title="7.3 动态规划"></a>7.3 动态规划</h3><ol><li><p>动态规划(dynamic programming)</p><ul><li>数学递归公式均可直接翻译为递归算法,但现实中编译器往往不发正确对待递归算法,而导致低效</li><li>当这种情况发生时,便需要给编译器提供帮助.改写为非递归的算法,并将子问题的答案记录在一个表内</li></ul></li><li><p>使用表代替递归</p><ul><li><p>计算 Fibonacci 数的自然递归效率非常低,是指数级别的</p></li><li><p>使用一个表将中间的计算结果存储起来,则可避免大量的冗余计算,下面计算 $c_n &#x3D; \frac2n\sum\limits_{i&#x3D;0}^{n-1}c_i+n,\space c_0 &#x3D; 1$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">double</span> *c = <span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>( <span class="hljs-type">double</span> ) * ( n + <span class="hljs-number">1</span> ) );<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    c[<span class="hljs-number">0</span>] = <span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j)<br>            sum += c[j];<br>        c[i] = <span class="hljs-number">2.0</span> * sum / i + i;<br>    &#125;<br>    <span class="hljs-type">int</span> answer = c[n];<br>    <span class="hljs-built_in">free</span>(c);<br>    <span class="hljs-keyword">return</span> answer;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机科学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
