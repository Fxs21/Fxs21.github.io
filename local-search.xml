<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ESP32</title>
    <link href="/2024/07/01/Embedded/ESP32/"/>
    <url>/2024/07/01/Embedded/ESP32/</url>
    
    <content type="html"><![CDATA[<h1 id="ESP32-IDF"><a href="#ESP32-IDF" class="headerlink" title="ESP32-IDF"></a>ESP32-IDF</h1><h2 id="0-开发环境搭建"><a href="#0-开发环境搭建" class="headerlink" title="0 开发环境搭建"></a>0 开发环境搭建</h2><h3 id="0-1-ESP32-S3-开发板"><a href="#0-1-ESP32-S3-开发板" class="headerlink" title="0.1 ESP32-S3 开发板"></a>0.1 ESP32-S3 开发板</h3><ol><li><p>开发板型号: <a href="https://docs.espressif.com/projects/esp-dev-kits/zh_CN/latest/esp32s3/esp32-s3-devkitc-1/index.html">ESP32-S3-DevKitC-1-wroom-1</a> 进入 ESP32 官网查看开发板资料</p><p><img src="/2024/07/01/Embedded/ESP32/0-ESP32-S3-DevKitC-1-wroom-1.png"></p><ul><li>拥有两个 USB 接口.一个是 USB 转串口, 另一个是 USB OTG 接口(JTAG 调试)</li><li>拥有两个按键: RST 是复位键. 若按住 Boot 键的同时按一下 RST 进入 <code>固件下载</code> 模式</li><li>RGB LED: 可寻址 RGB 发光二极管(WS2812). 注意 v1.0 由 GPIO48 驱动, v1.1 由 GPIO38 驱动</li></ul></li><li><p>芯片型号: <code>ESP32-S3 N16R8</code>.模组 <code>ESP32-S3-DevKitC-1-N16R8V</code> 引脚</p><p><img src="/2024/07/01/Embedded/ESP32/0-ESP32-S3-DevKitC-Pin.jpg"></p></li><li><p>本文档实际使用的开发板为 <a href="https://wiki.lckfb.com/zh-hans/szpi-esp32s3/">实战派开发板S3介绍 | 立创开发板技术文档中心</a></p></li><li><p>ESP32-S3-WROOM-1-N16R8: 乐鑫(Espressif)推出的一款高性能 Wi-Fi&#x2F;蓝牙双模模组</p><ul><li>ESP32-S3: 主控芯片型号(Xtensa LX7 双核, 240MHz)</li><li>WROOM-1: 模组系列(集成 PCB 天线)</li><li>N16: 内置 16MB SPI Flash.(四线 SPI, 支持 120MHz, 理论传输速率 60MB&#x2F;s)</li><li>R8: 内置 8MB Octal PSRAM(八线 Octal PSRAM, 最高 120MHz, 理论带宽 120MB&#x2F;s)</li><li>无线: 2.4GHz Wi-Fi 4 (802.11 b&#x2F;g&#x2F;n) + Bluetooth 5 LE</li><li>天线: 板载 PCB 天线</li></ul></li></ol><h3 id="0-2-Linux-环境"><a href="#0-2-Linux-环境" class="headerlink" title="0.2 Linux 环境"></a>0.2 <a href="https://www.bilibili.com/video/BV1eRg7exEcT?spm_id_from=333.788.videopod.episodes&vd_source=ca18f72085fcabc81ea5ba4e594aefe7&p=2">Linux 环境</a></h3><ol><li><p>搭建 Linux 开发环境参考 Linux 文档环境搭建部分.这里默认搭建完成,并使用的是 Ubuntu</p></li><li><p>环境搭建</p><ul><li><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install git wget flex bison gperf python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 net-tools<br></code></pre></td></tr></table></figure></li><li><p>拉取 ESP-IDF 源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建工作目录</span><br>mkdir esp32<br>cd esp32<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用脚本,将 github 地址映射为 gitee,减少因网络而导致的配置失败</span><br>git clone https://gitee.com/EspressifSystems/esp-gitee-tools.git<br>cd esp-gitee-tools   # 执行 gitee 工具切换镜像脚本<br>./jihu-mirror.sh set # 执行脚本,将 github 地址映射为 gitee<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拉取 esp-idf 源码</span><br>cd ..<br>git clone --recursive https://github.com/espressif/esp-idf.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到 5.2 版本(包括子模块).保持环境一致(非必需)</span><br>cd esp-idf<br>git checkout v5.2<br>git submodule update --init --recursive<br></code></pre></td></tr></table></figure></li><li><p>配置编译环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">更换 pip 源(非必需).可以使用 pip config list 命令查看当前的 pip 镜像源</span><br>pip config set global.index-url http://mirrors.aliyun.com/pypi/simple<br>pip config set global.trusted-host mirrors.aliyun.com<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装编译工具</span><br>../esp-gitee-tools/install.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置环境变量.该操作每次打开一个终端都要运行,后面介绍解决办法</span><br>source export.sh<br></code></pre></td></tr></table></figure></li><li><p>编译示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载课程配套源码,作为编译例程</span><br>cd ~/esp32<br>git clone --recursive https://gitee.com/vi-iot/esp32-board.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置芯片型号,并编译 helloworld 例程</span><br>cd esp32-board/helloworld # idf.py 的指令需要在项目的所处的目录中执行<br>idf.py set-target esp32s3 # 配置芯片型号.需查阅开发板原理图<br>idf.py build              # 编译项目<br></code></pre></td></tr></table></figure></li><li><p>烧录示例: 需要将开发板连接到 Linux(如果使用是 WSL, 可参考 Linux 文档的连接 USB 设备部分)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">烧录指令.出现 Done 表示烧录完成.需要进入烧录模式(按住 boot 键,按一次 reset)</span><br>idf.py flash<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时会出现 /dev/ttyUSB0 failed to connect... 因此先修改权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">该操作会随着设备拔插失效,因此每次都要执行.后面描述解决办法</span><br>sudo chmod 777 /dev/ttyUSB0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">烧录并监视串口. Ctrl + ] 退出</span><br>idf.py flash monitor<br></code></pre></td></tr></table></figure></li></ul></li><li><p>优化配置</p><ul><li><p>永久环境变量: 将添加环境变量的语句添加到 <code>.profile</code> 文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;export IDF_PATH=\&quot;~/esp32/esp-idf\&quot;&quot; &gt;&gt; ~/.profile<br>echo &quot;source \&quot;$IDF_PATH/export.sh\&quot;&quot; &gt;&gt; ~/.profile<br></code></pre></td></tr></table></figure></li><li><p>解决每次插拔设备后权限不足的问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将当前用户添加到 dialout 组.使其获得串口设备的访问权限</span><br>sudo usermod -aG dialout $USER<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后重新连接客户会话终端.后续不再需要修改权限</span><br>exit              # 完全退出当前 SSH 会话或终端.然后需要手动重新连接<br>id | grep dialout # 验证修改.需要确认当前用户已经加入了 dialout 组<br></code></pre></td></tr></table></figure></li></ul></li><li><p>使用 VSCode (远程连接部分参考 C 环境搭建部分)打开文件目录,可以看到上面示例的工程结构和源码</p><p><img src="/2024/07/01/Embedded/ESP32/0-Ubuntu-VSCode-hello.png"></p></li><li><p><code>ESP-IDF</code> 插件(在 VSCode 中选择虚拟机安装拓展)</p><ul><li>解决 VSCode 会因为不知道源码路径,头文件引入会标红,代码补全也无法使用的问题</li><li>按 <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>P</kbd>, 搜索 <code>esp-idf add VS Code Configuration Folder</code> 将源码路径添加到工程</li></ul></li></ol><h3 id="0-3-Windows-环境"><a href="#0-3-Windows-环境" class="headerlink" title="0.3 Windows 环境"></a>0.3 <a href="https://www.bilibili.com/video/BV1Jm411r7zz?spm_id_from=333.788.videopod.episodes&vd_source=ca18f72085fcabc81ea5ba4e594aefe7&p=2">Windows 环境</a></h3><ol><li><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/get-started/windows-setup.html">官网下载</a> ESP-IDF Windows Installer Download.然后默认安装即可</p></li><li><p>通过命令行编译并烧录</p><ul><li>在 Espressif 安装目录下 <code>.\frameworks\esp-idf-v5.2.3\examples\get-started</code> 有例程 <code>hello_world</code></li></ul></li></ol><ul><li>将例程 <code>hello_world</code> 复制出来.然后运行 <code>ESP-IDF 5.2 PowerShell</code> 程序<ul><li>进入到复制的目录下,使用 <code>idf.py build</code> 指令进行编译</li></ul></li><li>将 esp32 开发板与电脑进行连接,打开设备管理器查看端口号<ul><li>使用 <code>idf.py -p COM5 flash monitor</code> 指令进行下载程序并监视</li></ul></li></ul><ol start="3"><li><p>安装插件 <code>ESP-IDF</code> 并完成下列配置</p><ul><li><p>点击 VSCode 的查看 -&gt; 命令面板 -&gt; 搜索 <code>Configure ESP-IDF Extension</code> -&gt; <code>USE EXITING SETUP</code></p><p><img src="/2024/07/01/Embedded/ESP32/0-ESP-IDF-Configure.png"></p></li><li><p>出现下面提示,表示配置成功</p><p><img src="/2024/07/01/Embedded/ESP32/0-ESP-IDF-sucess.png"></p></li></ul></li><li><p>在 VSCode 最下方会出现 ESP-IDF 相关的快捷操作按钮</p><ul><li>在  MenuConfige 中,将 Serial flasher config 的 Flash Size 选为实际大小</li><li>点击相应图标即可进行编译, 烧录, 监控, 清空项目</li></ul></li></ol><h3 id="0-4-快速上手"><a href="#0-4-快速上手" class="headerlink" title="0.4 快速上手"></a>0.4 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/get-started/linux-macos-setup.html">快速上手</a></h3><ol><li><p>这里是官方文档描述的快速上手步骤.参考上面的 Linux 环境搭建的步骤也可以</p></li><li><p>在拉取的 <code>esp-idf/examples</code> 目录中有很多示例代码.以 <code>get-started/hello_world</code> 为例</p></li><li><p>编译下载流程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd example/get-started/hello_world # 进入工程目录<br>idf.py set-target esp32s3          # 设置芯片类型<br>idf.py menuconfig                  # 修改 Flash 大小<br>idf.py build flash monitor         # 编译, 烧录, 监控<br></code></pre></td></tr></table></figure></li><li><p>启动流程</p><ul><li>一级引导程序: 固化于 ROM 中,不可修改.加载二级引导程序到 RAM 执行<ul><li>通过检查 IO0 引脚的电平,选择程序模式</li><li>当芯片上电检测到 IO0 引脚为低电平时,进入下载模式,否则执行二级引导程序</li></ul></li><li>二级引导程序: <code>boot loader</code> 程序.从 0x8000 处读取分区表,处理各种段,加载应用程序</li><li>应用程序: 硬件外设和基本 C 语言运行环境的初始化, <code>freeRTOS</code> 初始化, 最后执行 <code>app_main()</code> 函数</li></ul></li></ol><h3 id="0-5-IDE-工具"><a href="#0-5-IDE-工具" class="headerlink" title="0.5 IDE 工具"></a>0.5 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/api-guides/tools/idf-py.html">IDE 工具</a></h3><ol><li><p><code>idf.py</code> 命令行工具提供了一个前端界面, 管理工程构建, 工程部署, 工程调试等操作</p><ul><li><code>CMake</code>: 配置要构建的工程</li><li><code>Ninja</code>: 构建工程</li><li><code>esptool</code>: 烧录目标芯片</li><li>注意 <code>idf.py</code> 应在 ESP-IDF 工程目录下运行.即包含 <code>CMakeLists.txt</code> 文件的目录</li></ul></li><li><p>前置工作相关</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py set-target esp32s3  # 指定芯片类型为 esp32s3<br>idf.py menuconfig          # 打开配置界面.一般第一次需要修改 flash size<br>idf.py save-defconfig      # 生成 sdkconfig.defaults 默认配置文件<br>idf.py create-project test # 创建一个名为 test 的工程<br></code></pre></td></tr></table></figure></li><li><p>构建项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py build       # 编译项目代码, 生成可执行固件.默认输出到 build 目录<br>idf.py clean       # 清除构建生成的临时文件(保留配置)<br>idf.py fullclean   # 彻底清除构建目录和配置(包括 sdkconfig)<br>idf.py reconfigure # 重新运行 CMake 并更新配置<br></code></pre></td></tr></table></figure></li><li><p>烧录固件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py flash          # 构建并烧录. -p &lt;port&gt; 指定串口, -b &lt;baud&gt; 指定烧录波特率<br>idf.py flash-settings # 仅烧录分区表和配置(非完整固件)<br>idf.py erase-flash    # 擦除整个 flash<br>idf.py erase-otadata  # 擦除 OTA 数据<br></code></pre></td></tr></table></figure></li><li><p>调试监控</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py monitor # 启动串口监视器,查看设备日志(默认波特率 115200). Ctrl + ] 退出监视器<br>idf.py gdb     # 启动 GDB 调试器(需提前配置 OpenOCD 或 JTAG)<br>idf.py openocd # 启动 OpenOCD 调试服务<br></code></pre></td></tr></table></figure></li><li><p>其他</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py size  # 显示应用程序大小.包括 RAM 和 flash 及各部分大小<br><br>idf.py merge bin        # 合并二进制文件<br>idf.py create-component # 创建新组件<br></code></pre></td></tr></table></figure></li><li><p>切换 idf 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前 idf 版本</span><br>idf.py --version<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换 idf 版本</span><br>cd ~/esp32/esp-idf  # 需要进入到 esp-idf 目录进行操作<br>git checkout v5.4.1 # 切换到 V5.4.1<br>git submodule update --init --recursive  # 更新子模块<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重新安装工具链</span><br>./install.sh     # 安装匹配的工具链<br>source export.sh # 设置环境变量<br></code></pre></td></tr></table></figure></li></ol><h3 id="0-6-工程选项配置"><a href="#0-6-工程选项配置" class="headerlink" title="0.6 工程选项配置"></a>0.6 工程选项配置</h3><ol><li><p>在工程目录下执行下面命令打开交互式配置菜单(基于 Kconfig)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py menuconfig<br></code></pre></td></tr></table></figure><p><img src="/2024/07/01/Embedded/ESP32/0-Ubuntu-idf-menuconfig.png"></p><ul><li><code>menuconfig</code> 用于配置芯片型号, 串口, Wi-Fi 等参数</li><li>配置保存在 <code>sdkconfig</code> 文件中</li></ul></li><li><p>目前阶段可修改的配置</p><ul><li>系统主频: <code>Component config -&gt; ESP system setting -&gt; cpu frequency</code> 选为 240MHz</li><li>Flash 大小: <code>Serial flasher config -&gt; Flash size</code> 选为 16MB(需要根据具体芯片型号选择)</li><li>按 <kbd>S</kbd> 保存, <kbd>Q</kbd> 退出</li></ul></li><li><p>注意: 修改了 <code>menuconfig</code> 后,需要重新编译工程(<code>idf.py build</code>)</p></li></ol><h3 id="0-7-API-约定"><a href="#0-7-API-约定" class="headerlink" title="0.7 API 约定"></a>0.7 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/api-reference/api-conventions.html">API 约定</a></h3><ol><li><p>编程接口</p><ul><li>在 ESP-IDF 组件的公共头文件中声明的 C 函数, 结构体, 枚举, 类型定义, 预处理器宏</li><li>编译系统函数, 预定义变量, 选项</li><li><code>Kconfig</code> 选项, 可用于代码及编译系统文件</li><li>主机工具及其命令行参数</li></ul></li><li><p>错误处理</p><ul><li>多数 ESP-IDF API 会返回由 <code>esp_err_t</code> 类型定义的错误代码.实质上是带符号的整型<ul><li><code>ESP_OK</code> 代表成功,其值定义为0</li><li>错误代码通常均以 <code>ESP_ERR_</code> 前缀开头</li><li>常见错误(比如内存不足, 超时, 无效参数等)的错误代码则已经在 <code>esp_err.h</code> 文件中定义</li></ul></li><li>向 <code>esp_err_to_name</code> 函数传递错误码作为参数即可转换为具体的错误消息</li><li>宏 <code>ESP_ERROR_CHECK</code> 的功能和 <code>assert</code> 类似.若参数不等于 <code>ESP_OK</code>,则打印错误消息,并调用 <code>abort()</code></li></ul></li><li><p>配置结构体</p><ul><li><p>为确保应用程序与未来 ESP-IDF 版本的兼容性,请正确初始化配置结构体</p></li><li><p>多数 ESP-IDF 中的初始化, 配置, 安装函数: 形如 <code>..._init(), ..._config(), ..._install()</code>,<br>都需要一个指向配置结构体的指针作为参数</p></li><li><p><strong>应用程序必须初始化结构体的所有字段</strong></p></li><li><p>使用 C99 的指定初始化器完成结构体的初始化.以简洁的方式设置字段,并将剩余字段初始化为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">esp_timer_create_args_t</span> my_timer_args = &#123;<br>    .callback = &amp;my_timer_callback,<br>    <span class="hljs-comment">/* 正确，字段 .arg 和 .name 已初始化为零 */</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>私有 API</p><ul><li><strong>某些头文件包含的 API 仅限于在 ESP-IDF 源代码中使用,不支持在应用程序中使用</strong></li><li>此类头文件的名称或路径通常带有 <code>private</code> 或 <code>esp_private</code></li><li>私有 API 可能在次要或补丁版本之间以不兼容的方式被删除或更改</li></ul></li></ol><h3 id="0-8-FreeRTOS-接口"><a href="#0-8-FreeRTOS-接口" class="headerlink" title="0.8 FreeRTOS 接口"></a>0.8 <a href="https://www.bilibili.com/video/BV1eRg7exEcT?spm_id_from=333.788.videopod.episodes&vd_source=ca18f72085fcabc81ea5ba4e594aefe7&p=6">FreeRTOS 接口</a></h3><ol><li><p>创建任务: 在 ESP-IDF 中,为了支持双核实现了新的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskCreatePinnedToCore</span> <span class="hljs-params">(</span><br><span class="hljs-params">    TaskFunction_t pxTaskCode,  <span class="hljs-comment">// 指向任务函数的指针</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> pcName,   <span class="hljs-comment">// 任务名,最大长度为 configMax_TASK_NAME_LEN</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> configSTACK_DEPTH_TYPE usStackDepth,  <span class="hljs-comment">// 任务堆栈大小,默认单位为4字节</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span> *<span class="hljs-type">const</span> pvParameters,  <span class="hljs-comment">// 传递给任务函数的参数</span></span><br><span class="hljs-params">    UBaseType_t uxPriority,    <span class="hljs-comment">// 任务优先级, 0 ~ configMAX_PRIORITIES - 1</span></span><br><span class="hljs-params">    TaskHandle_t *<span class="hljs-type">const</span> pxCreatedTask,  <span class="hljs-comment">// 任务句柄,即任务的控制块</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> BaseType_t xCoreID   <span class="hljs-comment">// 分配到哪个内核运行</span></span><br><span class="hljs-params">)</span>;<br><span class="hljs-comment">// 返回值 pdPASS 表示创建成功. errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY 表示失败</span><br></code></pre></td></tr></table></figure></li><li><p>阻塞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelay</span><span class="hljs-params">(<span class="hljs-type">const</span> TickType_t xTicksToDelay)</span>;<br>vTaskDelay(pdMS_TO_TICKS(<span class="hljs-number">1000</span>));  <span class="hljs-comment">// pdMS_TO_TICKS 会将时间转换为节拍数</span><br></code></pre></td></tr></table></figure></li><li><p>队列操作</p><ul><li><p>创建队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">QueueHandle_t <span class="hljs-title function_">xQueueCreate</span><span class="hljs-params">(     <span class="hljs-comment">// 创建队列.成功则返回队列句柄</span></span><br><span class="hljs-params">    UBaseType_t uxQueueLength,  <span class="hljs-comment">// 队列容量</span></span><br><span class="hljs-params">    UBaseType_t uxItemSize)</span>;    <span class="hljs-comment">// 每个队列项所占内存的大小.单位为字节</span><br></code></pre></td></tr></table></figure></li><li><p>发送 &#x2F; 接收消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueSend</span><span class="hljs-params">(QueueHandle_t xQueue,        <span class="hljs-comment">// 队列句柄</span></span><br><span class="hljs-params">                      <span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvItemToQueue,   <span class="hljs-comment">// 待发送消的指针</span></span><br><span class="hljs-params">                      TickType_t xTickToWait)</span>;     <span class="hljs-comment">// 等待时间</span><br>BaseType_t <span class="hljs-title function_">xQueueReceive</span><span class="hljs-params">(QueueHandle_t xQueue,     <span class="hljs-comment">// 队列句柄</span></span><br><span class="hljs-params">                         <span class="hljs-type">void</span> *pvBuffer,           <span class="hljs-comment">// 接收消息缓冲区的指针</span></span><br><span class="hljs-params">                         TickType_t xTickToWait)</span>   <span class="hljs-comment">// 等待时间</span><br></code></pre></td></tr></table></figure></li><li><p>中断版本(<code>FromISR</code> 后缀)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueSendFromISR</span><span class="hljs-params">(QueueHandle_t xQueue,       <span class="hljs-comment">// 队列句柄</span></span><br><span class="hljs-params">                             <span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvItemToQueue,  <span class="hljs-comment">// 待发送消的指针</span></span><br><span class="hljs-params">                             BaseType_t *pxHigherPriorityTaskWoken)</span>;<br><span class="hljs-comment">// pxHigherPriorityTaskWoken: 如果被系统设为 pdTRUE,则中断退出前要执行上下文切换函数</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>信号量</p><ul><li><p>创建信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateBinary</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">// 创建二值信号量</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateCounting</span><span class="hljs-params">(<span class="hljs-comment">// 创建计数型信号量</span></span><br><span class="hljs-params">                      UBaseType_t uxMaxCount,       <span class="hljs-comment">// 最大信号量数</span></span><br><span class="hljs-params">                      UBaseType_t uxInitialCount)</span>;  <span class="hljs-comment">// 初始信号数</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateMutex</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">// 创建互斥锁</span><br></code></pre></td></tr></table></figure></li><li><p>获取 &#x2F; 释放信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xSemaPhoreTake</span><span class="hljs-params">(<span class="hljs-comment">// 获取信号量,成功返回 pdTRUE</span></span><br><span class="hljs-params">    SemaphoreHandle_t xSemaphore,  <span class="hljs-comment">// 信号量句柄</span></span><br><span class="hljs-params">    TickType_t xTicksToWait)</span>;      <span class="hljs-comment">// 等待时间</span><br>BaseType_t <span class="hljs-title function_">xSemaPhoreGive</span><span class="hljs-params">(SemaphoreHandle_t xSemaphore)</span>;  <span class="hljs-comment">// 释放信号量</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vSemaphoreDelete</span><span class="hljs-params">(SemaphoreHandle_t xSemaphore)</span>;      <span class="hljs-comment">// 删除信号量</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>事件组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">EventGroupHandle_t <span class="hljs-title function_">xEventGroupCreate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <span class="hljs-comment">// 创建事件组</span><br>EventBits_t <span class="hljs-title function_">xEventGroupWaitBits</span><span class="hljs-params">(<span class="hljs-comment">// 等待事件组中的某些标志位</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> EventGroupHandle_t xEventGroup,    <span class="hljs-comment">// 事件组句柄</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> EventBits_t uxBitsToWaitFor,       <span class="hljs-comment">// 需要等待哪些位</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> BaseType_t xClearOnExit,           <span class="hljs-comment">// 是否自动清除标志位</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> BaseType_t xWaitForAllBits,        <span class="hljs-comment">// 是否需要等待的标志位全成功才返回</span></span><br><span class="hljs-params">    TickType_t xTicksToWait)</span>;                <span class="hljs-comment">// 最大阻塞时间</span><br>EventBits_t <span class="hljs-title function_">xEventGroupSetBits</span><span class="hljs-params">(<span class="hljs-comment">// 设置标志位</span></span><br><span class="hljs-params">    EventGroupHandle_t xEventGroup,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> EventBits_t uxBitsToSet)</span>;          <span class="hljs-comment">// 需要设置哪些位</span><br>EventBits_t <span class="hljs-title function_">xEventGroupClearBits</span><span class="hljs-params">(<span class="hljs-comment">// 清除标志位</span></span><br><span class="hljs-params">EventGroupHandle_t xEventGroup,</span><br><span class="hljs-params"><span class="hljs-type">const</span> EventBits_t uxBitsToClear)</span>;        <span class="hljs-comment">// 需要清除哪些位</span><br></code></pre></td></tr></table></figure></li><li><p>直达任务通知</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskNotify</span><span class="hljs-params">(<span class="hljs-comment">// 将通知直接发送到任务,并可能取消该任务的阻塞态</span></span><br><span class="hljs-params">TaskHandle_t xTaskToNotify,  <span class="hljs-comment">// 通知的任务句柄</span></span><br><span class="hljs-params"><span class="hljs-type">uint32_t</span> ulValue,            <span class="hljs-comment">// 携带的通知值</span></span><br><span class="hljs-params">eNotifyAction eAction)</span>;      <span class="hljs-comment">// 执行的操作</span><br>BaseType_t <span class="hljs-title function_">xTaskNotifyWait</span><span class="hljs-params">(<span class="hljs-comment">// 等待接收任务通知</span></span><br><span class="hljs-params"><span class="hljs-type">uint32_t</span> ulBitsToClearOnEntry,  <span class="hljs-comment">// 进入函数清除的通知值位</span></span><br><span class="hljs-params"><span class="hljs-type">uint32_t</span> ulBitsToClearOnExit,   <span class="hljs-comment">// 退出函数清除的通知值位</span></span><br><span class="hljs-params"><span class="hljs-type">uint32_t</span> *pulNotificationValue, <span class="hljs-comment">// 通知值</span></span><br><span class="hljs-params">TickType_t xTicksToWait)</span>;       <span class="hljs-comment">// 等待时长</span><br></code></pre></td></tr></table></figure></li><li><p><code>esp-idf</code> 的 <code>freeRTOS</code></p><ul><li>优先级问题: esp32 有双核,因此任务是可以并行的</li><li>esp-idf 自动创建5个任务: 空闲, 定时器, app_main, IPC, ESP 定时器</li><li>esp-idf 不使用原生的 FreeRTOS 内存堆管理,实现了自己的堆</li><li>创建任务使用 <code>xTaskCreatePinnedToCore()</code></li><li>删除任务应避免删除另一个核心的任务</li><li>临界区使用自旋锁确保同步(因为还有一个核心)</li><li>若任务中用到浮点运算,则创建任务时必须指定具体运行的核心,而不能由系统安排</li><li>通常负责处理无线网络的任务固定到 CPU0, 处理应用程序其余部分的任务被固定到 CPU1</li></ul></li></ol><h2 id="1-基础外设"><a href="#1-基础外设" class="headerlink" title="1 基础外设"></a>1 基础外设</h2><h3 id="1-1-GPIO"><a href="#1-1-GPIO" class="headerlink" title="1.1 GPIO"></a>1.1 <a href="https://www.bilibili.com/video/BV1eRg7exEcT?spm_id_from=333.788.videopod.episodes&vd_source=ca18f72085fcabc81ea5ba4e594aefe7&p=11">GPIO</a></h3><ol><li><p>ESP32 芯片具有 34 个物理 GPIO 管脚(0 ~ 19, 21 ~ 23, 25 ~ 27, 32 ~ 39)</p><ul><li>每个管脚都可用作一个通用的 IO, 或连接一个内部的外设信号</li><li>通过 IO MUX, RTC IO MUX, GPIO 交换矩阵,可配置外设模块的输入信号来源于任何的 IO 管脚</li><li>外设模块的输出信号也可连接到任意 IO 管脚</li></ul></li><li><p>IO 管脚配置</p><ul><li>作为简单的 GPIO 输入读取引脚上的电平, 或作为简单的 GPIO 输出以输出所需的电平</li><li>作为外设信号的输入 &#x2F; 输出</li></ul></li><li><p>使用 <code>gpio_dump_io_configuration()</code> 函数用来输出指定管脚的实时配置状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">gpio_dump_io_configuration(<span class="hljs-built_in">stdout</span>, (<span class="hljs-number">1ULL</span> &lt;&lt; <span class="hljs-number">4</span>) | (<span class="hljs-number">1ULL</span> &lt;&lt; <span class="hljs-number">18</span>) | (<span class="hljs-number">1ULL</span> &lt;&lt; <span class="hljs-number">26</span>));<br><span class="hljs-comment">// 输出 GPIO4, GPIO18, GPIO26 的配置状态</span><br></code></pre></td></tr></table></figure></li><li><p>API 参考</p><ul><li><p>头文件: <code>#include &quot;driver/gpio.h&quot;</code></p></li><li><p>配置 &#x2F; 重置 GPIO 引脚</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span> pin_bit_mask;  <span class="hljs-comment">// 64bit.每个 bit 表示一个 GPIO</span><br>    <span class="hljs-type">gpio_mode_t</span> mode;       <span class="hljs-comment">// GPIO 的模式: input / output</span><br>    <span class="hljs-type">gpio_pullup_t</span> pull_up_en;      <span class="hljs-comment">// 内部上拉是否使能</span><br>    <span class="hljs-type">gpio_pulldown_t</span> pull_down_en;  <span class="hljs-comment">// 内部下拉是否使能</span><br>    <span class="hljs-type">gpio_int_type_t</span> intr_type;     <span class="hljs-comment">// GPIO 中断类型</span><br>&#125; <span class="hljs-type">gpio_config_t</span>;<br><br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_config</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">gpio_config_t</span> *pGPIOConfig)</span>;<br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_reset_pin</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num)</span>;<br></code></pre></td></tr></table></figure></li><li><p>使能 &#x2F; 失能 GPIO 中断(GPIO 36, GPIO39 不能在使用 ADC, WiFi, 蓝牙, 睡眠模式 时开启)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_set_intr_type</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num, <span class="hljs-type">gpio_int_type_t</span> intr_type)</span>;<br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_intr_disable</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num)</span>;<br></code></pre></td></tr></table></figure></li><li><p>指定 GPIO 输出电平 &#x2F; 获取 GPIO 输入电平</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_set_level</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num, <span class="hljs-type">uint32_t</span> level)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">gpio_get_level</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num)</span>;<br></code></pre></td></tr></table></figure></li><li><p>安装中断服务: 会为所有 GPIO 中断注册一个全局 ISR. 与 <code>gpio_isr_register</code> 函数不兼容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** 此函数配合通过 gpio_isr_handler_add 函数注册各个引脚处理程序</span><br><span class="hljs-comment">  * @param  intr_alloc_flags: 分配中断的标志 */</span><br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_install_isr_service</span><span class="hljs-params">(<span class="hljs-type">int</span> intr_alloc_flags)</span><br></code></pre></td></tr></table></figure></li><li><p>添加 GPIO 中断服务函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** @param gpio_num: GPIO 引脚号</span><br><span class="hljs-comment">  * @param isr_handler: 指定引脚的中断服务函数</span><br><span class="hljs-comment">  * @param args: 传递给中断服务函数的参数 */</span><br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_isr_handler_add</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num, <span class="hljs-type">gpio_isr_t</span> isr_handler, <span class="hljs-type">void</span> *args)</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-2-外部中断"><a href="#1-2-外部中断" class="headerlink" title="1.2 外部中断"></a><a href="https://www.bilibili.com/video/BV1vTCUYyETZ?spm_id_from=333.788.videopod.episodes&vd_source=ca18f72085fcabc81ea5ba4e594aefe7&p=4">1.2 外部中断</a></h3><ol><li><p>硬件信息: 立创 S3 开发板的按键为 IO0, 位于右上角.接 10K 上拉电阻</p><p><img src="/2024/07/01/Embedded/ESP32/1-boot-key.png"></p></li><li><p>实验思路</p><ul><li>将 IO0 设为上拉输入模式,并开启下降沿中断,注册其中断函数</li><li>在 <code>app_main</code> 函数中创建一个任务(用于 GPIO0 下降沿触发后待执行), 以及一个消息队列</li><li>当中断触发时,获取到参数 GPIO0.然后通过消息队列传递给任务,该任务将 GPIO 端口和电平打印出来</li></ul></li><li><p><code>main.c</code> 文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;freertos/FreeRTOS.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;freertos/task.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;freertos/queue.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/gpio.h&quot;</span></span><br><br><span class="hljs-type">static</span> QueueHandle_t gpio0_queue = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 定义队列句柄</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> IRAM_ATTR <span class="hljs-title function_">gpio_isr_handler</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> &#123; <span class="hljs-comment">/* GPIO 中断服务函数 */</span><br>    <span class="hljs-type">uint32_t</span> gpio_num = (<span class="hljs-type">uint32_t</span>) arg;  <span class="hljs-comment">// 获取入口参数</span><br>    xQueueSendFromISR(gpio0_queue, &amp;gpio_num, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 发送队列消息.注意中断要用 FromISR</span><br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">gpio_task_example</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> &#123; <span class="hljs-comment">/* GPIO 任务函数 */</span><br>    <span class="hljs-type">uint32_t</span> gpio_num;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span>(xQueueReceive(gpio0_queue, &amp;gpio_num, portMAX_DELAY))  <span class="hljs-comment">// 死等队列消息</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;GPIO[%ld] intr. val: %d\n&quot;</span>, gpio_num, gpio_get_level(gpio_num)); <span class="hljs-comment">// 打印内容</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">app_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">gpio_config_t</span> io0_conf = &#123;<br>        .intr_type = GPIO_INTR_NEGEDGE,  <span class="hljs-comment">// 下降沿中断</span><br>        .mode = GPIO_MODE_INPUT,         <span class="hljs-comment">// 输入模式</span><br>        .pin_bit_mask = <span class="hljs-number">1</span> &lt;&lt; GPIO_NUM_0, <span class="hljs-comment">// 选择 GPIO0</span><br>        .pull_down_en = <span class="hljs-number">0</span>,               <span class="hljs-comment">// 禁能内部下拉</span><br>        .pull_up_en = <span class="hljs-number">1</span>                  <span class="hljs-comment">// 使能内部上拉</span><br>    &#125;;<br>    gpio_config(&amp;io0_conf);  <span class="hljs-comment">// 配置 GPIO</span><br>    gpio0_queue = xQueueCreate(<span class="hljs-number">10</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint32_t</span>));  <span class="hljs-comment">// 创建一个消息队列</span><br>    xTaskCreate(gpio_task_example, <span class="hljs-string">&quot;gpio_task_example&quot;</span>, <span class="hljs-number">2048</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>, <span class="hljs-literal">NULL</span>);  <span class="hljs-comment">// 创建中断任务</span><br>    gpio_install_isr_service(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 安装 GPIO0 的中断</span><br>    gpio_isr_handler_add(GPIO_NUM_0, gpio_isr_handler, (<span class="hljs-type">void</span>*)GPIO_NUM_0);  <span class="hljs-comment">// GPIO0 添加中断处理</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实验现象: 每次按下 IO0_boot 引脚都会打印</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">GPIO[0] intr, val: 0<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-3-ledc"><a href="#1-3-ledc" class="headerlink" title="1.3 ledc"></a>1.3 <a href="https://www.bilibili.com/video/BV1eRg7exEcT?spm_id_from=333.788.videopod.episodes&vd_source=ca18f72085fcabc81ea5ba4e594aefe7&p=12">ledc</a></h3><ol><li>ledc 主要用于控制 LED,也可产生 PWM 信号用于其他设备的控制<ul><li>LED PWM 控制器可在无需 CPU 干预的情况下自动改变占空比,实现亮度和颜色渐变</li><li>该控制器有 8 路通道,可以产生独立的波形,驱动 RGB LED 等设备</li><li>LEDC 通道共有两组,分别为 8 路高速通道和 8 路低速通道<ul><li>高速通道模式在硬件中实现,可以自动且无干扰地改变 PWM 占空比</li><li>低速通道模式下,PWM 占空比需要由软件中的驱动器改变,每组通道都可以使用不同的时钟源</li></ul></li></ul></li><li>控制 WS2812B</li></ol><h3 id="1-4-定时器"><a href="#1-4-定时器" class="headerlink" title="1.4 定时器"></a>1.4 定时器</h3><h3 id="1-5-PWM"><a href="#1-5-PWM" class="headerlink" title="1.5 PWM"></a>1.5 PWM</h3><h3 id="1-6-ADC"><a href="#1-6-ADC" class="headerlink" title="1.6 ADC"></a>1.6 ADC</h3><h3 id="1-7-UART"><a href="#1-7-UART" class="headerlink" title="1.7 UART"></a>1.7 UART</h3><h3 id="1-8-I2C"><a href="#1-8-I2C" class="headerlink" title="1.8 I2C"></a>1.8 I2C</h3><ol><li><p>硬件信息: 姿态传感器 QMI8658A.SDA 连接于 IO1, SCL 连接于 IO2</p><p><img src="/2024/07/01/Embedded/ESP32/1-QMI8658A.png"></p></li><li><p>实验目标: 通过 I2C 与 QMI8658A 传感器通信,获取加速度和倾角值</p></li><li><p>使用的 i2c 相关接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">i2c_master_bus_handle_t</span> bus_handle;<br><span class="hljs-type">static</span> <span class="hljs-type">i2c_master_dev_handle_t</span> qmi8658_handle;<br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">bsp_i2c_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">i2c_master_bus_config_t</span> i2c_mst_config = &#123;<br>        .clk_source = I2C_CLK_SRC_DEFAULT,<br>        .i2c_port = BSP_I2C_NUM,    <span class="hljs-comment">// 0</span><br>        .scl_io_num = BSP_I2C_SCL,  <span class="hljs-comment">// GPIO_NUM_2</span><br>        .sda_io_num = BSP_I2C_SDA,  <span class="hljs-comment">// GPIO_NUM_1</span><br>        .glitch_ignore_cnt = <span class="hljs-number">7</span>,<br>        .flags.enable_internal_pullup = <span class="hljs-literal">true</span>,<br>    &#125;;<br><br>    ESP_ERROR_CHECK(i2c_new_master_bus(&amp;i2c_mst_config, &amp;bus_handle));<br><br>    <span class="hljs-type">i2c_device_config_t</span> dev_cfg = &#123;<br>        .dev_addr_length = I2C_ADDR_BIT_LEN_7,<br>        .device_address = QMI8658_SENSOR_ADDR,  <span class="hljs-comment">// 0x6A</span><br>        .scl_speed_hz = BSP_I2C_FREQ_HZ,        <span class="hljs-comment">// 100,000</span><br>    &#125;;<br>    ESP_ERROR_CHECK(i2c_master_bus_add_device(bus_handle, &amp;dev_cfg, &amp;qmi8658_handle));<br>    <span class="hljs-keyword">return</span> ESP_OK;<br>&#125;<br><br><span class="hljs-comment">// 读取 QMI8658 寄存器的值</span><br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">qmi8658_register_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> reg_addr, <span class="hljs-type">uint8_t</span> *data, <span class="hljs-type">size_t</span> len)</span> &#123;<br>    <span class="hljs-keyword">return</span> i2c_master_transmit_receive(qmi8658_handle, &amp;reg_addr, <span class="hljs-number">1</span>, data, len, <span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-comment">// 给 QMI8658 的寄存器写值</span><br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">qmi8658_register_write_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> reg_addr, <span class="hljs-type">uint8_t</span> data)</span> &#123;<br>    <span class="hljs-type">uint8_t</span> write_buf[<span class="hljs-number">2</span>] = &#123;reg_addr, data&#125;;<br>    <span class="hljs-keyword">return</span> i2c_master_transmit(qmi8658_handle, write_buf, <span class="hljs-keyword">sizeof</span>(write_buf), <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-9-SPI"><a href="#1-9-SPI" class="headerlink" title="1.9 SPI"></a>1.9 SPI</h3><h3 id="1-10-PSRAM"><a href="#1-10-PSRAM" class="headerlink" title="1.10 PSRAM"></a>1.10 PSRAM</h3><ol><li><p>ESP-IDF 默认不启用 PSRAM,即使硬件支持.需在配置中显式开启</p><ul><li>因为 PSRAM 的时钟配置和电源管理可能影响功耗和稳定性</li></ul></li><li><p>启用 PSRAM</p><ul><li><p>ESP32-S3-WROOM-1-N16R8 的 PSRAM 通过 <strong>Octal SPI</strong> 连接,需确保配置为 <code>OPI</code> 模式</p></li><li><p>在 <code>menuconfig</code> 中开启 <code>external SPI-connected RAM</code> 并选择为 <code>Octal Mode PSRAM</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Component config -&gt; ESP PSRAM -&gt; Support for external, SPI-connected RAM<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Mode (QUAD/OCT) of SPI RAM chip <span class="hljs-keyword">in</span> use (Octal Mode PSRAM) -&gt; Octal Mode PSRAM</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>日志分析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">boot.esp32s3: Boot SPI Speed : 80MHz  # SPI Flash 运行频率为 80MHz<br>boot.esp32s3: SPI Mode       : DIO    # DIO 模式(Dual I/O, 双线数据输入输出)<br>boot.esp32s3: SPI Flash Size : 16MB   # 检测到外部 SPI Flash 容量为 16MB<br><br>boot: ## Label     Usage       Type  ST   Offset    Length<br>boot:  0 nvs       WiFi data    01   02  00009000  00006000 # 存储 Wi-Fi 配置等非易失性数据<br>boot:  1 phy_init  RF data      01   01  0000f000  00001000 # 存储 RF 射频校准数据<br>boot:  2 factory   factory app  00   00  00010000  00100000 # 主应用程序固件分区<br><br>I (233) esp_psram: Found 8MB PSRAM device  # 检测到 8MB Octal PSRAM,初始化成功<br>I (238) esp_psram: Speed: 40MHz            # 速度: 40MHz<br>I (973) esp_psram: SPI SRAM memory test OK # PSRAM 自检通过.耗时较长,约 700ms<br><br>cpu_start: Pro cpu start user code # 主核(CPU0)开始执行用户代码<br>cpu_start: cpu freq: 160000000 Hz  # CPU 主频设置为 160MHz<br><br>heap_init: Initializing. RAM available for dynamic allocation: # 初始化堆内存<br>heap_init: At 3FC95C20 len 00053AF0 (334 KiB): RAM  # 内部 RAM<br>heap_init: At 3FCE9710 len 00005724 (21 KiB): RAM   # 内部 RAM<br>heap_init: At 3FCF0000 len 00008000 (32 KiB): DRAM  # 用于 DMA<br>heap_init: At 600FE010 len 00001FD8 (7 KiB): RTCRAM # 深度睡眠可保留内存<br>esp_psram: Adding pool of 8192K of PSRAM memory to heap allocator # PSRAM 加入堆分配器<br><br>I (1104) main_task: Calling app_main() # 调用用户编写的 app_main(),应用程序正式运行<br></code></pre></td></tr></table></figure></li><li><p>PSRAM 内存申请(系统初始化后,PSRAM 已自动加入堆分配器)</p><ul><li><p>标准分配函数(自动选择)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 普通 malloc 可能分配到内部 RAM 或 PSRAM</span><br><span class="hljs-comment">// 系统优先使用内部 RAM,大内存会自动分配到 PSRAM</span><br><span class="hljs-type">uint8_t</span> *buffer = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>); <span class="hljs-comment">// 分配 2MB</span><br></code></pre></td></tr></table></figure></li><li><p>强制分配到 PSRAM</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_heap_caps.h&quot;</span></span><br><br><span class="hljs-comment">// 明确分配在 PSRAM</span><br><span class="hljs-type">uint8_t</span> *psram_buffer = heap_caps_malloc(<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>, MALLOC_CAP_SPIRAM); <br><br><span class="hljs-comment">// 分配并初始化为 0</span><br><span class="hljs-type">uint8_t</span> *psram_buffer_zero = heap_caps_calloc(<span class="hljs-number">1024</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>), MALLOC_CAP_SPIRAM);<br></code></pre></td></tr></table></figure></li><li><p>C++ 对象分配到 PSRAM</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_heap_caps.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SensorData</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">float</span> readings[<span class="hljs-number">2048</span>];<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">heap_caps_malloc</span>(size, MALLOC_CAP_SPIRAM);<br>&#125;<br><br>SensorData *data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SensorData</span>(); <span class="hljs-comment">// 分配到 PSRAM</span><br></code></pre></td></tr></table></figure></li><li><p>检查内存位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_spiram.h&quot;</span></span><br><br><span class="hljs-keyword">if</span> (esp_spiram_is_initialized()) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PSRAM 可用, 总大小: %d MB\n&quot;</span>, esp_spiram_get_size() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (esp_ptr_external_ram(ptr)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;指针指向 PSRAM\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>PSRAM 与 RAM 的区别</p><table><thead><tr><th align="left">特性</th><th align="left">内部 RAM (SRAM)</th><th align="left">PSRAM (SPI PSRAM)</th></tr></thead><tbody><tr><td align="left"><strong>物理位置</strong></td><td align="left">芯片内部</td><td align="left">外部 SPI 芯片 (通常 Octal 8线)</td></tr><tr><td align="left"><strong>速度</strong></td><td align="left">160MHz 全速访问 (5-10ns)</td><td align="left">40-80MHz SPI 访问 (25-50ns)</td></tr><tr><td align="left"><strong>容量</strong></td><td align="left">较小 (ESP32-S3: 512KB)</td><td align="left">较大 (通常 2MB&#x2F;4MB&#x2F;8MB)</td></tr><tr><td align="left"><strong>功耗</strong></td><td align="left">低 (集成设计)</td><td align="left">较高 (需 SPI 总线驱动)</td></tr><tr><td align="left"><strong>保留数据</strong></td><td align="left">睡眠时可保留</td><td align="left">断电&#x2F;深度睡眠丢失数据</td></tr><tr><td align="left"><strong>DMA 支持</strong></td><td align="left">完全支持</td><td align="left">不支持 (需复制到内部 RAM)</td></tr><tr><td align="left"><strong>访问方式</strong></td><td align="left">CPU 直接寻址</td><td align="left">通过 SPI 控制器间接访问</td></tr><tr><td align="left"><strong>成本</strong></td><td align="left">较高 (占用芯片面积)</td><td align="left">较低 (独立芯片)</td></tr></tbody></table></li><li><p>性能差异演示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// SRAM 写入耗时: 130152 cycles</span><br><span class="hljs-comment">// PSRAM 写入耗时: 162400 cycles</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">test_speed</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">uint8_t</span> *sram_buf = heap_caps_malloc(<span class="hljs-number">10000</span>, MALLOC_CAP_INTERNAL);<br>    <span class="hljs-type">uint8_t</span> *psram_buf = heap_caps_malloc(<span class="hljs-number">10000</span>, MALLOC_CAP_SPIRAM);<br><br>    <span class="hljs-type">uint32_t</span> start = esp_cpu_get_cycle_count();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) sram_buf[i] = i % <span class="hljs-number">256</span>;<br>    <span class="hljs-type">uint32_t</span> sram_time = esp_cpu_get_cycle_count() - start;<br><br>    start = esp_cpu_get_cycle_count();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) psram_buf[i] = i % <span class="hljs-number">256</span>;<br>    <span class="hljs-type">uint32_t</span> psram_time = esp_cpu_get_cycle_count() - start;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SRAM 写入耗时: %lu cycles\nPSRAM 写入耗时: %lu cycles\n&quot;</span>, <br>           sram_time, psram_time);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最佳实践</p><ul><li>PSRAM: 大型缓冲(图像 &#x2F; 音频), 不频繁访问的配置数据</li><li>内部 RAM: 高频访问数据, DMA 缓冲区, RTOS 任务栈</li></ul></li></ol><h2 id="2-设备驱动"><a href="#2-设备驱动" class="headerlink" title="2 设备驱动"></a>2 设备驱动</h2><h3 id="2-1-TF-Card"><a href="#2-1-TF-Card" class="headerlink" title="2.1 TF Card"></a>2.1 TF Card</h3><ol><li><p>硬件连接</p><p><img src="/2024/07/01/Embedded/ESP32/2-TFCard.png"></p><ul><li>TF 与 ESP32 的通信方式: SPI, SDIO.这里采用 SDIO 的一线模式</li></ul></li><li><p>使用的 <code>sdmmc</code> 相关接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_vfs_fat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sdmmc_cmd.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/sdmmc_host.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BSP_SD_CLK               (47)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BSP_SD_CMD               (48)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BSP_SD_D0                (21)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MOUNT_POINT              <span class="hljs-string">&quot;/sdcard&quot;</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> mount_point[] = MOUNT_POINT;<br><br><span class="hljs-comment">/* 挂载参数配置 */</span><br><span class="hljs-type">esp_vfs_fat_sdmmc_mount_config_t</span> mount_config = &#123;<br>    .format_if_mount_failed = <span class="hljs-literal">true</span>,    <span class="hljs-comment">// 如果挂载不成功是否需要格式化 SD 卡</span><br>    .max_files = <span class="hljs-number">5</span>,                    <span class="hljs-comment">// 允许打开的最大文件数</span><br>    .allocation_unit_size = <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>  <span class="hljs-comment">// 分配单元大小</span><br>&#125;;<br><br><span class="hljs-comment">/* SDMMC 主机接口配置 */</span><br><span class="hljs-type">sdmmc_host_t</span> host = SDMMC_HOST_DEFAULT(); <br><br><span class="hljs-comment">/* SDMMC 插槽配置 */</span><br><span class="hljs-type">sdmmc_slot_config_t</span> slot_config = SDMMC_SLOT_CONFIG_DEFAULT();<br>slot_config.width = <span class="hljs-number">1</span>;         <span class="hljs-comment">// 设置为1线 SD 模式</span><br>slot_config.clk = BSP_SD_CLK;  <span class="hljs-comment">// 指定 CLK 的 GPIO</span><br>slot_config.cmd = BSP_SD_CMD;  <span class="hljs-comment">// 指定 CMD 的 GPIO</span><br>slot_config.d0 = BSP_SD_D0;    <span class="hljs-comment">// 指定 DATA0 的 GPIO</span><br>slot_config.flags |= SDMMC_SLOT_FLAG_INTERNAL_PULLUP; <span class="hljs-comment">// 打开内部上拉电阻</span><br><br><span class="hljs-comment">/* 挂载 SD 卡 */</span><br><span class="hljs-type">sdmmc_card_t</span> *card;<br>esp_vfs_fat_sdmmc_mount(mount_point, &amp;host, &amp;slot_config, &amp;mount_config, &amp;card);<br>sdmmc_card_print_info(<span class="hljs-built_in">stdout</span>, card); <span class="hljs-comment">// 终端打印SD卡的一些信息</span><br><br><span class="hljs-comment">/* 卸载 SD 卡 */</span><br>esp_vfs_fat_sdcard_unmount(mount_point, card);<br></code></pre></td></tr></table></figure></li><li><p><code>menuconfig</code> 配置项</p><ul><li>长文件名支持: 在 <code>Component config</code> -&gt; <code>FAT Filesystem support</code> -&gt; <code>Long filename support</code> 中,<br>选择 <code>Long file name buffer in heap</code>.否则文件名仅支持8个字符</li><li>簇(cluster)字节数: 将 blocksize 改为 4096</li><li>中文支持: 在 OEM Code Page 中选择 <code>Simplified Chinese(DBCS)</code></li><li>编码格式: 在 API character encoding 中选择 <code>API users UTF-8 encoding</code></li></ul></li></ol><h3 id="2-2-录音-p7"><a href="#2-2-录音-p7" class="headerlink" title="2.2 录音 &#x3D;&#x3D;p7&#x3D;&#x3D;"></a>2.2 录音 &#x3D;&#x3D;p7&#x3D;&#x3D;</h3><ol><li><p>硬件连接</p><p><img src="/2024/07/01/Embedded/ESP32/2-AUDIO-ADC.png"></p><ul><li>使用 I2C 配置 ES7210 芯片</li><li>使用 I2S 接收数据(I2S_DI)</li></ul></li><li><p>相关接口</p><ul><li><p>需要先引入组件 <a href="https://components.espressif.com/components/espressif/es7210/versions/1.0.1~1">ES7210</a>: 执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">idf.py add-dependency &quot;espressif/es7210^1.0.1~1&quot;<br></code></pre></td></tr></table></figure></li><li></li></ul></li></ol><h3 id="2-3-放音-p8"><a href="#2-3-放音-p8" class="headerlink" title="2.3 放音 &#x3D;&#x3D;p8&#x3D;&#x3D;"></a>2.3 放音 &#x3D;&#x3D;p8&#x3D;&#x3D;</h3><ol><li><p>硬件连接</p><p><img src="/2024/07/01/Embedded/ESP32/2-AUDIO-DAC.png"></p><ul><li>使用 I2C 配置 ES8311 芯片</li><li>使用 I2S 输出数据(I2S_DO)</li></ul></li><li><p>ES8311 将数据传输到 NS4150B 功放</p><p><img src="/2024/07/01/Embedded/ESP32/2-AUDIO-DAC-NS4150B.png"></p></li><li><p>IO 拓展芯片控制 NS4150B 的开关 <code>PA_EN</code>(高有效)</p><p><img src="/2024/07/01/Embedded/ESP32/2-PCA9557PW.png"></p></li><li><p>相关接口</p></li><li></li></ol><h3 id="2-4-LCD"><a href="#2-4-LCD" class="headerlink" title="2.4 LCD"></a>2.4 LCD</h3><p>1. </p><h3 id="2-5-摄像头"><a href="#2-5-摄像头" class="headerlink" title="2.5 摄像头"></a>2.5 摄像头</h3><h3 id="2-6-LVGL"><a href="#2-6-LVGL" class="headerlink" title="2.6 LVGL"></a>2.6 LVGL</h3><h3 id="2-7-MP3"><a href="#2-7-MP3" class="headerlink" title="2.7 MP3"></a>2.7 MP3</h3><h3 id="2-8-语音识别"><a href="#2-8-语音识别" class="headerlink" title="2.8 语音识别"></a>2.8 语音识别</h3><h3 id="2-9-人脸识别"><a href="#2-9-人脸识别" class="headerlink" title="2.9 人脸识别"></a>2.9 人脸识别</h3><h3 id="2-10-LVGL-p20"><a href="#2-10-LVGL-p20" class="headerlink" title="2.10 LVGL &#x3D;&#x3D;p20&#x3D;&#x3D;"></a>2.10 LVGL &#x3D;&#x3D;p20&#x3D;&#x3D;</h3><ol><li>组件</li><li>LVGL 介绍</li><li>LVGL 移植<ul><li>在项目根目录新建 components 目录.然后在 CMakeLists.txt 中添加</li></ul></li><li></li></ol><h3 id="2-11-系统存储"><a href="#2-11-系统存储" class="headerlink" title="2.11 系统存储"></a>2.11 系统存储</h3><h2 id="3-蓝牙-API"><a href="#3-蓝牙-API" class="headerlink" title="3 蓝牙 API"></a>3 蓝牙 API</h2><h2 id="4-联网-API"><a href="#4-联网-API" class="headerlink" title="4 联网 API"></a>4 联网 API</h2><h2 id="5-系统-API"><a href="#5-系统-API" class="headerlink" title="5 系统 API"></a>5 系统 API</h2><h2 id="6-附录"><a href="#6-附录" class="headerlink" title="6 附录"></a>6 附录</h2><h3 id="6-1-Arduino"><a href="#6-1-Arduino" class="headerlink" title="6.1 Arduino"></a>6.1 <a href="https://www.bilibili.com/video/BV1RM4y1a7J5?spm_id_from=333.788.videopod.episodes&vd_source=ca18f72085fcabc81ea5ba4e594aefe7">Arduino</a></h3><ol><li><p><a href="https://www.arduino.cc/">下载安装 IDE</a></p><p><img src="/2024/07/01/Embedded/ESP32/6-Arduino-Main_Menu.png"></p></li><li><p>Arduino IDE 的基础设置</p><ul><li>中文: <code>file</code> -&gt; <code>preference</code> -&gt; <code>language</code> -&gt; 选择中文</li><li>安装开发板资源: 工具 -&gt; 开发板 -&gt; 开发板管理器 -&gt; 搜索 ESP32 并安装(需要能连接 <code>Github</code>)</li></ul></li><li><p>Arduino 基础</p><ul><li>在 <code>void setup()&#123;&#125;</code> 函数中的代码在上电时运行一次,用于初始化</li><li>在 <code>void loop()&#123;&#125;</code> 函数中的代码将会死循环运行</li></ul></li><li><p>Hello,world(在 工具 -&gt; 串口监视器中查看输出)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 初始化串口</span><br>  Serial.<span class="hljs-built_in">begin</span>(<span class="hljs-number">9600</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;<br>  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello,world!\n&quot;</span>);<br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="6-2-PlatformIO"><a href="#6-2-PlatformIO" class="headerlink" title="6.2 PlatformIO"></a>6.2 PlatformIO</h3><ol><li><p>在 VSCode 中安装 PlatformIO IDE 插件.并等待期完成初始化</p><p><img src="/2024/07/01/Embedded/ESP32/6-PlatformIO.png"></p></li><li><p>主界面</p><p><img src="/2024/07/01/Embedded/ESP32/6-PlatformIO-Menu.png"></p></li><li><p>新建项目(点击 <code>New Project</code>)</p><ul><li>Board 选择 <code>ESP32-S3-DevKitC-1</code></li><li>反勾选 <code>use default location</code>.选择工程存放目录</li></ul></li><li><p>生成的工程结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">/my_project<br>  |-- .pio<span class="hljs-comment">// 编译生成的二进制文件,日志...</span><br>  |-- .vscode<br>  |-- include<span class="hljs-comment">// 头文件</span><br>  |-- lib<span class="hljs-comment">// 项目依赖的库文件</span><br>  |-- src  <span class="hljs-comment">// 源代码</span><br>  |-- tests<span class="hljs-comment">// 测试代码,数据.用于单元测试</span><br>   -- .gitignore<br>   -- platformio.ini<span class="hljs-comment">// 配置文件</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="6-3-MicroPython"><a href="#6-3-MicroPython" class="headerlink" title="6.3 MicroPython"></a>6.3 <a href="https://www.bilibili.com/video/BV1G34y1E7tE/?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click&vd_source=ca18f72085fcabc81ea5ba4e594aefe7">MicroPython</a></h3><ol><li><p>开发环境搭建</p><ul><li><p>安装 IDE: <a href="https://thonny.org/">Thonny</a>.界面如下</p><p><img src="/2024/07/01/Embedded/ESP32/6-thonny.png"></p></li><li><p>下载解释器: <a href="https://micropython.org/">MicroPython</a> 官网中 download 找到对应开发板,下载后缀为 <code>.bin</code> 的 Firmware</p><p><img src="/2024/07/01/Embedded/ESP32/6-MicroPython.png"></p></li></ul></li><li><p>烧录固件</p><ul><li><p>连接 ESP32 开发板,并安装 USB 转串口驱动(在设备管理器中查看)</p><p><img src="/2024/07/01/Embedded/ESP32/6-CH343.png"></p></li><li><p>在 Thonny 中配置解释器: <code>运行</code> -&gt; <code>配置解释器</code></p><p><img src="/2024/07/01/Embedded/ESP32/6-Thonny-Interpreter.png"></p></li><li><p>烧录解释器: 在下拉菜单中 <code>Select local MicroPython image...</code> 选择下载的 <code>Firmware</code></p><p><img src="/2024/07/01/Embedded/ESP32/6-Thonny-Download-Interpreter.png"></p></li><li><p>下载时可能需要按住 boot 键才能开始下载.耐心等待,直到出现 <code>Done!</code></p></li><li><p>成功烧录的标志: 左侧文件栏中出现 <code>MicroPython 设备</code> 或 Shell 窗口显示 <code>MicroPython</code></p></li></ul></li><li><p>Hello,world</p><ul><li><p>新建文件,并写入 <code>print(&quot;Hello,world!&quot;)</code>.将其保存到 <code>MicroPython设备</code></p></li><li><p>点击 <code>运行当前脚本</code>,即可运行.此时 Python 程序已运行于 ESP32</p><p><img src="/2024/07/01/Embedded/ESP32/6-Hello-world.png"></p></li></ul></li><li><p>对于 MicroPython 的 api,需参考其<a href="http://www.micropython.com.cn/en/latet/esp32/quickref.html">官网文档</a></p></li><li><p>MicroPython REPL(交互解释器) 位于 UART0.波特率115200</p></li></ol><h3 id="6-4-WIFI"><a href="#6-4-WIFI" class="headerlink" title="6.4 WIFI"></a>6.4 WIFI</h3><ol><li><p><code>Wi-Fi</code> 是基于 <code>IEEE 802.11</code> 标准的无线网络技术.让联网设备以无线电波的形式,加入采用 <code>TCP/IP</code> 通信协议的网络</p><ul><li>**Access Point(<code>AP</code>) 无线接入点: 提供无线接入的设备.**如光猫是结合 WiFi 和 internet 路由功能的AP</li><li>**Station(<code>STA</code>) 无线终端: 连接到 AP 的装置.**如手机,电脑等设备处于 STA 模式.这个模式不允许其他设备接入</li></ul></li><li><p>SSID</p><ul><li><strong>BSSID</strong>: 无线路由器的 MAC 地址(本质是<strong>MAC 地址</strong>)</li><li><strong>SSID</strong>: 搜索到的 wifi 名字(本质是<strong>字符串</strong>)</li><li><strong>ESSID</strong>: 实际上与 ssid 相同,但可以多个路由器为同一名字</li></ul></li><li><p>ESP32 连接 WIFI(注意: ESP32 不支持 5G 路由器)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">do_connect</span>():<br>    <span class="hljs-keyword">import</span> network<br>    wlan = network.WLAN(network.STA_IF)  <span class="hljs-comment"># 创建 STA 接口</span><br>    wlan.active(<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 激活接口</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> wlan.isconnected():  <span class="hljs-comment"># 若未连接 WIFI,则尝试连接指定 WIFI</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;connecting to network...&#x27;</span>)<br>        wlan.connect(<span class="hljs-string">&#x27;ssid&#x27;</span>, <span class="hljs-string">&#x27;key&#x27;</span>)<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> wlan.isconnected():<br>            <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># 一次连接未成功后处理.若未连接这里将会阻塞</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;network config:&#x27;</span>, wlan.ifconfig())<br></code></pre></td></tr></table></figure></li><li><p>测试 ESP32 连接状态</p><ul><li><p>当 ESP32 连接到路由器后,用同一局域网下的电脑发送 &#x2F; 接收数据</p></li><li><p>使用 <code>NetAssist</code> 网络调试助手软件测试</p></li><li><p>ESP32 发送 &#x2F; 接收数据</p><ul><li><p>在 <code>NetAssist</code> 中打开网络(配置左上角的 <code>选项</code> -&gt; <code>字符集编码</code> 选择 <code>uft-8</code>)</p><p><img src="/2024/07/01/Embedded/ESP32/6-NetAssist-RX.png"></p></li><li><p>在 ESP32 中发送数据.查看电脑端接收的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 1. 创建 udp 套接字</span><br>udp_socket = socket(AF_INET, SOCK_DGRAM)<br><span class="hljs-comment"># 2. 准备接收方的地址.需要与 NetAssist 配置对应</span><br>dest_addr = (<span class="hljs-string">&#x27;192.168.0.102&#x27;</span>, <span class="hljs-number">8080</span>)<br><span class="hljs-comment"># 3. 从键盘获取数据</span><br>send_data = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-comment"># 4. 发送数据到指定的电脑上,并接收一次数据</span><br>udp_socket.sendto(send_data.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), dest_addr)<br>recv_data = udp_socket.recvfrom(<span class="hljs-number">1024</span>)<br><span class="hljs-built_in">print</span>(send_data)<br><span class="hljs-comment"># 5. 关闭套接字</span><br>udp_socket.close()<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="6-5-WS2812B"><a href="#6-5-WS2812B" class="headerlink" title="6.5 WS2812B"></a>6.5 WS2812B</h3><ol><li><p>WS2812B 参数</p><ul><li><p>额定工作电压 5V.IC 控制电路与 LED 点光源共用一个电源  </p></li><li><p>每个像素点的三基色颜色可实现256级亮度显示.完成16777216种颜色的全真色彩显示</p></li><li><p>端口扫描频率 2KHz.串行级联接口,能通过一根信号线完成数据的接收与解码</p><p><img src="/2024/07/01/Embedded/ESP32/6-WS2812B.png"></p></li></ul></li><li><p>WS2812B 通信方式</p><ul><li><p>数据协议采用单线归零码的通讯方式</p></li><li><p>基本数据时序</p><p><img src="/2024/07/01/Embedded/ESP32/6-WS2812B-Wave.png"></p></li><li><p>数据传输时间(注意 T0H+T0L 或 T1H+T1L 需要大于等于 1.25us)</p><table><thead><tr><th>符号</th><th>含义</th><th>时间范围</th></tr></thead><tbody><tr><td>T0H</td><td>0码的高电平持续时间</td><td>220ns~380ns</td></tr><tr><td>T1H</td><td>1码的高电平持续时间</td><td>580ns~1µs</td></tr><tr><td>T0L</td><td>0码的低电平持续时间</td><td>580ns~1µs</td></tr><tr><td>T1L</td><td>0码的低电平持续时间</td><td>580ns~1µs</td></tr><tr><td>RES</td><td>帧单位的低电平时间</td><td>280µs 以上</td></tr></tbody></table></li><li><p>24bit 数据结构(RGB 各 8bit,注意顺序为 G -&gt; R -&gt; B)</p><p><img src="/2024/07/01/Embedded/ESP32/6-WS2812B-Data-Structure.png"></p></li><li><p>级联方式</p><p><img src="/2024/07/01/Embedded/ESP32/6-WS2812B-Concat.png"></p></li><li><p>完整数据传输时序(每24bit数据为一组,每经过一个 WS2812B 先发送的一组数据将会留下)</p><p><img src="/2024/07/01/Embedded/ESP32/6-WS2812B-Period.png"></p></li></ul></li><li><p>SPI 参数</p><ul><li>ESP32 的两路硬件 SPI 可达到 80MHz 速率.将波特率设为 2.5MHz,即可获得 400ns 脉冲.<ul><li>使得 T0H &#x3D; 400ns, T0L &#x3D; 850ns.可满足时序在误差允许范围的要求</li><li>而 RES 需要50us以上低电平,对应 50*2.5&#x3D;125 位(进位到16*8&#x3D;128),取16个0x00的数据作为 RES</li></ul></li><li>WS2812 的逻辑0,对应 SPI 的数据 100.逻辑1,对应 SPI 的数据 110</li><li>WS2812 一组 RGB 需要 24bit,因此对应 SPI 数据为 24*3 &#x3D; 72bit &#x3D; 9Bit</li></ul></li><li><p>点亮 WS2815B</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> Pin, Timer, SPI<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># mosi 为数据输出引脚,对应 WS2812B 的 DI,默认为高电平.其他引脚并未用到</span><br>hspi = SPI(<span class="hljs-number">1</span>, <span class="hljs-number">2500000</span>, sck=Pin(<span class="hljs-number">47</span>), mosi=Pin(<span class="hljs-number">48</span>), miso=Pin(<span class="hljs-number">15</span>), polarity=<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">byte2bin</span>(<span class="hljs-params">b</span>):<br>    bstr = <span class="hljs-built_in">bin</span>(b)[<span class="hljs-number">2</span>:]  <span class="hljs-comment"># 转为2进制字符串</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>*(<span class="hljs-number">8</span>-<span class="hljs-built_in">len</span>(bstr)) + bstr  <span class="hljs-comment"># 不满8位时前面补0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rgb2byte</span>(<span class="hljs-params">r,g,b</span>):<br>    <span class="hljs-built_in">str</span> = byte2bin(g) + byte2bin(r) + byte2bin(b)<br>    spistr = <span class="hljs-string">&#x27;&#x27;</span>.join([(<span class="hljs-keyword">lambda</span> s: <span class="hljs-string">&#x27;100&#x27;</span> <span class="hljs-keyword">if</span> s==<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;110&#x27;</span>)(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>])<br>    rgbdim = [<span class="hljs-built_in">int</span>(spistr[i*<span class="hljs-number">8</span>:i*<span class="hljs-number">8</span>+<span class="hljs-number">8</span>], <span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">bytes</span>(rgbdim)<br><br>rstbyte = <span class="hljs-built_in">bytes</span>([<span class="hljs-number">0x00</span>]*<span class="hljs-number">16</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    rgbbyte = rgb2byte(<span class="hljs-number">0xff</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>)<br>    outbyte = rstbyte+rgbbyte+rstbyte<br>    hspi.write(outbyte)<br>    time.sleep_ms(<span class="hljs-number">500</span>)<br><br>    rgbbyte = rgb2byte(<span class="hljs-number">0x0</span>,<span class="hljs-number">0xff</span>,<span class="hljs-number">0x0</span>)<br>    outbyte = rstbyte+rgbbyte+rstbyte<br>    hspi.write(outbyte)<br>    time.sleep_ms(<span class="hljs-number">500</span>)<br><br>    rgbbyte = rgb2byte(<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0xff</span>)<br>    outbyte = rstbyte+rgbbyte+rstbyte<br>    hspi.write(outbyte)<br>    time.sleep_ms(<span class="hljs-number">500</span>)<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ESP32</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS</title>
    <link href="/2024/06/01/Embedded/FreeRTOS/"/>
    <url>/2024/06/01/Embedded/FreeRTOS/</url>
    
    <content type="html"><![CDATA[<h1 id="FreeRTOS"><a href="#FreeRTOS" class="headerlink" title="FreeRTOS"></a>FreeRTOS</h1><h2 id="0-简介"><a href="#0-简介" class="headerlink" title="0 简介"></a>0 简介</h2><h3 id="0-1-优势"><a href="#0-1-优势" class="headerlink" title="0.1 优势"></a>0.1 优势</h3><ol><li>FreeRTOS 通过 MIT 开源许可免费分发.包括一个内核和一组不断丰富的 IoT 库</li><li>FreeRTOS 的构建突出可靠性和易用性</li><li><strong>开源和免费</strong>: 通过 MIT 许可证发布,可免费使用, 修改, 分发</li><li><strong>轻量级设计</strong>: 适用资源受限的嵌入式系统,不占同过多内存和处理器资源</li><li><strong>应用广泛</strong>: 工业自动化, 医疗设备, 消费电子产品, 汽车电子…</li><li><strong>多平台支持</strong>: 设计注重可移植性,可移植到不同硬件平台,支持多种处理器架构</li><li><strong>功能丰富</strong>: 提供了多任务调度, 任务通信, 同步等功能.适用复杂的嵌入式应用场景</li></ol><h3 id="0-2-特点"><a href="#0-2-特点" class="headerlink" title="0.2 特点"></a>0.2 特点</h3><ol><li><strong>任务调度</strong>: 通过任务调度器管理多个任务,支持不同优先级的任务,实现任务有序执行</li><li><strong>任务通信和同步</strong>: 提供了队列,信号量等机制,支持任务间的通信和同步,确保数据安全传递</li><li><strong>内存管理</strong>: 提供简单的内存管理机制,适用于嵌入式环境,有效利用有效的内存资源</li><li><strong>定时器和中断处理</strong>: 支持定时器功能,能够处理中断</li></ol><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1 基础"></a>1 基础</h2><h3 id="1-1-多任务处理"><a href="#1-1-多任务处理" class="headerlink" title="1.1 多任务处理"></a>1.1 多任务处理</h3><ol><li>多任务操作系统: 多个用户可以同时执行多个程序</li><li>多任务操作系统简化软件设计<ul><li>将复杂的程序分割为一组更小,更易于管理的任务</li><li>分割后,可以更简单的执行软件测试, 分解工作, 复用代码</li><li>复杂的时序和排序细节可以交由系统解决</li></ul></li><li><strong>多任务操作系统可以通过任务间快速切换制造并发执行的假象</strong></li></ol><h3 id="1-2-任务调度"><a href="#1-2-任务调度" class="headerlink" title="1.2 任务调度"></a>1.2 任务调度</h3><ol><li>一个处理器核心在某一时刻只能运行一个任务,在任务间快速切换模拟多任务同时执行</li><li><strong>任务调度器</strong>: 决定某一时刻要执行哪个任务.</li><li>内核可以在任务生命周期内多次挂起并稍后恢复一个任务</li><li><strong>调度策略</strong>: 任务调度器决定任何时间点执行哪个任务的算法</li><li>FreeRTOS 优先级数值越大,优先级越高</li><li><strong>FreeRTOS 默认使用固定优先级的抢占式任务调度策略,对同等优先级的任务执行时间片轮询调度</strong></li><li><strong>抢占式调度</strong>: 更高优先级的任务在任何时刻可以抢占正在执行的低优先级任务.提高实时性</li><li><strong>时间片轮询</strong>: 相同优先级任务轮流执行一个时间片,任务进入等待时,切换到下一个.公平分配 CPU 时间</li></ol><h3 id="1-3-任务状态"><a href="#1-3-任务状态" class="headerlink" title="1.3 任务状态"></a>1.3 任务状态</h3><ol><li><p>FreeRTOS 任务有四种状态</p><ul><li><p>运行态: 实际运行的状态.若只有一个内核,则任何时间都只有一个任务处于运行态</p></li><li><p>就绪态: 准备就绪但未执行的任务.因为有其他更高或同等优先级任务处于运行态</p></li><li><p>阻塞态: 正在等待延时或外部事件</p></li><li><p>挂起态: 类似暂停. <code>vTaskSuspend()</code> 进入挂起态, <code>vTaskResume()</code> 进入就绪态</p><p><img src="/2024/06/01/Embedded/FreeRTOS/FreeRTOS-status.png"></p></li></ul></li><li><p>只有就绪态可转变为运行态.想要运行就要先转变为就绪态</p></li></ol><h3 id="1-4-滴答"><a href="#1-4-滴答" class="headerlink" title="1.4 滴答"></a>1.4 滴答</h3><ol><li>FreeRTOS 一般将 Systick 作为时钟来源</li><li>休眠时,RTOS 任务需指定唤醒的时间.阻塞时,需指定等待的最长时间</li><li>FreeRTOS 实时内核通过滴答计数变量测量时间</li><li>定时器中断(RTOS 滴答中断)按严格的时间精度增加滴答数</li><li>实时内核可以按选择的定时器中断频率的分辨率测量时间</li><li>每次滴答数增加时,实时内核必须检查是否为解除阻塞或唤醒任务的时间</li><li>在滴答 ISR 期间唤醒或解除阻塞的任务优先级可能高于被中断任务的优先级</li></ol><h3 id="1-5-上下文切换"><a href="#1-5-上下文切换" class="headerlink" title="1.5 上下文切换"></a>1.5 上下文切换</h3><ol><li>上下文: 任务执行时,需要的处理器, 寄存器, ram, rom 资源</li><li>上下文切换: 在任务挂起时保存任务的上下文,任务恢复时操作系统内核恢复上下文</li><li>上下文切换时机: 任务切换时<ul><li>真正切换上下文的执行在 PendSV(系统异常) 的 ISR 处理</li><li>PendSV 可以手动触发,且可以在其他更高中断优先级的 ISR 中设置</li><li>FreeRTOS 会将 PendSV 设置为最低中断优先级,切面影响到其他 ISR</li></ul></li></ol><h3 id="1-6-空闲任务"><a href="#1-6-空闲任务" class="headerlink" title="1.6 空闲任务"></a>1.6 空闲任务</h3><ol><li>RTOS 调度器启动时,自动创建空闲任务,确保始终存在一个能够运行的任务</li><li>空闲任务以最低优先级创建,确保有更高优先级任务处于准备就绪状态时,空闲任务不使用 CPU 时间</li><li>空闲任务负责释放被删除任务的内存</li></ol><h2 id="2-FreeRTOS-移植"><a href="#2-FreeRTOS-移植" class="headerlink" title="2 FreeRTOS 移植"></a>2 FreeRTOS 移植</h2><h3 id="2-1-源码结构"><a href="#2-1-源码结构" class="headerlink" title="2.1 源码结构"></a>2.1 源码结构</h3><ol><li><p>获取源码: <a href="https://www.freertos.org/">官网下载</a></p></li><li><p>FreeRTOS 目录结构</p><blockquote><p>├── <strong>FreeRTOS</strong> (内核)<br>│   ├── Demo (例程)<br>│   ├── License (证书)<br>│   ├── Source (内核源码)<br>│   │   ├── include (头文件)<br>│   │   └── portable (移植文件,编译器环境相关)<br>│   └── Test (测试)<br>│<br>├── FreeRTOS-Plus (扩展组件,一般使用第三方组件)<br>└── tools (工具集)</p></blockquote></li></ol><h3 id="2-2-HAL-库项目移植"><a href="#2-2-HAL-库项目移植" class="headerlink" title="2.2 HAL 库项目移植"></a>2.2 HAL 库项目移植</h3><ol><li><p>在根目录创建 FreeRTOS 目录,在其中创建 <code>source, portable</code> 目录</p><ul><li>source: 下载目录的 FreeRTOS&#x2F;Source 下的所有 .c 文件</li><li>portable<ul><li>FreeRTOS&#x2F;Source&#x2F;portable&#x2F;RVDS 的相关文件</li><li>FreeRTOS&#x2F;Source&#x2F;portable&#x2F;MemMang 的 <code>heap_4.c</code></li><li>FreeRTOS&#x2F;Source&#x2F;include 整个目录</li></ul></li><li>FreeRTOSConfig.h: 工程配置文件.可以在 DEMO 中寻找</li></ul></li><li><p>在 Keil 中添加路径…….</p></li><li><p>在系统配置文件 <code>FreeRTOSConfig.h</code> 中添加必须下面的3个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortPendSVHandlerPendSV_Handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vPortSVCHandlerSVC_Handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetSchedulerState 1</span><br></code></pre></td></tr></table></figure></li><li><p>在 <code>stm32f1xx_it.c</code> 文件中注释掉 <code>PendSV_Handler, SVC_Handler</code> 函数.否则会重复定义</p></li><li><p>配置时钟源: 在 <code>stm32f1xx_it.c</code> 文件包含 <code>FreeRTOS.h, task.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FreeRTOS.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task.h&quot;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">xPortSysTickHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) &#123;  <span class="hljs-comment">// 如果开启了任务调度器</span><br>        xPortSysTickHandler();  <span class="hljs-comment">// 启动 freeRTOS 的滴答 ISR</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>hal</code> 库的延时函数默认使用 <code>SysTick</code>.将 FreeRTOS 的时钟配置为 <code>SysTick</code> 后可能引发问题</p><ul><li>在中断调用 hal 库中提供的延时函数时,因为其优先级低,导致无法计数器无法累加,时间卡死</li><li>在 CubeMX 中选择 <code>Timebase Source</code> 默认为 <code>SysTick</code>, 改为其他未使用的定时器</li><li>在 NVIC 中找到 <code>Time base interrupt</code>,将其优先级改为1.因此可以正常使用延时</li></ul></li></ol><h3 id="2-3-寄存器项目移植"><a href="#2-3-寄存器项目移植" class="headerlink" title="2.3 寄存器项目移植"></a>2.3 寄存器项目移植</h3><ol><li><p>前置步骤与 hal 库一致,直到第 4 步,因为寄存器开发没有 <code>stm32f1xx_it.c</code> 文件</p></li><li><p>在某一个文件中实现滴答定时器的中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">xPortSysTickHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) &#123;  <span class="hljs-comment">// 如果开启了任务调度器</span><br>        xPortSysTickHandler();  <span class="hljs-comment">// 启动 freeRTOS 的滴答 ISR</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自己实现的延时函数不应再依赖 <code>SysTick</code>, 防止卡死</p></li></ol><h3 id="2-4-系统配置文件"><a href="#2-4-系统配置文件" class="headerlink" title="2.4 系统配置文件"></a>2.4 系统配置文件</h3><ol><li>在系统配置文件 <code>FreeRTOSConfig.h</code> 中有很多配置项.可在 <a href="https://www.freertos.org/zh-cn-cmn-s/Documentation/02-Kernel/03-Supported-devices/02-Customization">官方文档</a> 查看详细信息</li><li>主要分为 <code>config</code> 参数 和 <code>INCLUDE</code> 宏<ul><li><code>config</code>: 功能配置.如基本配置, 内存配置, 钩子配置, 中断配置…</li><li><code>INCLUDE</code>: 裁剪功能(使用条件编译实现.1 表示可用,0 表示禁用)</li></ul></li></ol><h3 id="2-5-FreeRTOS-数据类型"><a href="#2-5-FreeRTOS-数据类型" class="headerlink" title="2.5 FreeRTOS 数据类型"></a>2.5 FreeRTOS 数据类型</h3><ol><li><code>TickType_t</code>: 用于表示系统节拍计数器的值<ul><li><code>configUSE_16_BIT_TICKS</code> 为 <code>true</code> 时, <code>TickType_t</code> 是16bit.否则为 32bit</li><li>记录 FreeRTOS 中系统过去的节拍次数</li></ul></li><li><code>BaseType_t</code>: 架构中最有效, 自然的类型. 32位架构下被定义为 32位类型</li><li><code>UBaseType_t</code>: <code>BaseType_t</code> 的 <code>unsigned</code> 版</li><li><code>StackType_t</code>: 用于存储堆栈的类型</li></ol><h3 id="2-6-FreeRTOS-命名规范"><a href="#2-6-FreeRTOS-命名规范" class="headerlink" title="2.6 FreeRTOS 命名规范"></a>2.6 FreeRTOS 命名规范</h3><ol><li>变量名采用驼峰式大小写,一般不用缩写<ul><li><code>uint32_t</code> 类型变量用 <code>ul</code> 前缀,即 <code>unsigned long</code></li><li><code>uint16_t</code> 类型变量用 <code>us</code> 前缀,即 <code>unsigned short</code></li><li><code>uint8_t</code> 类型变量用 <code>uc</code> 前缀,即 <code>unsigned char</code></li><li>非 <code>stdint</code> 类型的变量用 <code>x</code> 前缀.如 <code>BaseType_t</code></li><li>非 <code>stdint</code> 类型的无符号变量用 <code>u</code> 前缀,如 <code>UBaseType_t</code></li><li><code>size_t</code> 类型变量用 <code>x</code> 前缀</li><li>枚举变量用 <code>e</code> 前缀</li><li>指针变量用 <code>p</code> 前缀</li></ul></li><li>函数使用驼峰式大小写,一般不用缩写<ul><li>文件作用域静态(私有)函数用 <code>prv</code> 前缀</li><li>API 函数以其返回类型为前缀.对于 <code>void</code> 用 <code>v</code> 前缀</li><li>API 函数名称用定义 API 函数文件为前缀</li><li>如 <code>vTaskDelay</code>: 返回类型 <code>void</code>,定义于 <code>task.c</code>, 作用为 <code>delay</code></li></ul></li><li>宏使用完整的单词拼写<ul><li>宏用定义宏的文件为前缀.如 <code>FreeRTOSConfig.h</code> 定义 <code>configUSE_PREEMPTION</code></li><li>除前缀外,宏全大写,并使用下划线分隔</li></ul></li></ol><h2 id="3-创建删除任务"><a href="#3-创建删除任务" class="headerlink" title="3 创建删除任务"></a>3 创建删除任务</h2><h3 id="3-1-创建删除任务-API"><a href="#3-1-创建删除任务-API" class="headerlink" title="3.1 创建删除任务 API"></a>3.1 创建删除任务 API</h3><ol><li><p>任务 API 函数</p><table><thead><tr><th>API 函数</th><th>描述</th></tr></thead><tbody><tr><td>xTaskCreate</td><td>动态方式创建任务</td></tr><tr><td>xTaskCreateStatic</td><td>静态方式创建任务</td></tr><tr><td>vTaskDelete</td><td>删除任务</td></tr></tbody></table><ul><li>动态创建任务: 任务的控制块和栈空间由 FreeRTOS 管理</li><li>静态创建任务: 任务的控制块和栈空间由用户分配提供</li></ul></li><li><p>动态创建任务函数声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskCreate</span> <span class="hljs-params">(</span><br><span class="hljs-params">    TaskFunction_t pxTaskCode,  <span class="hljs-comment">// 指向任务函数的指针</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> pcName,   <span class="hljs-comment">// 任务名,最大长度为 configMax_TASK_NAME_LEN</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> configSTACK_DEPTH_TYPE usStackDepth,  <span class="hljs-comment">// 任务堆栈大小,默认单位为4字节</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span> *<span class="hljs-type">const</span> pvParameters,  <span class="hljs-comment">// 传递给任务函数的参数</span></span><br><span class="hljs-params">    UBaseType_t uxPriority,    <span class="hljs-comment">// 任务优先级, 0 ~ configMAX_PRIORITIES - 1</span></span><br><span class="hljs-params">    TaskHandle_t *<span class="hljs-type">const</span> pxCreatedTask  <span class="hljs-comment">// 任务句柄,即任务的控制块</span></span><br><span class="hljs-params">)</span>;<br><span class="hljs-comment">// 返回值 pdPASS 表示创建成功. errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY 表示失败</span><br></code></pre></td></tr></table></figure></li><li><p>动态创建任务步骤</p><ul><li>将宏 <code>configSUPPORT_ALLOCATION</code> 配置为1</li><li>定义函数入口参数</li><li>编写任务函数</li><li><code>xTaskCreate</code> 创建的任务立刻进入就绪态,由任务调度器调度运行</li></ul></li><li><p>静态创建任务函数与动态的区别在于</p><ul><li>动态创建任务使用任务句柄作为参数</li><li>静态创建任务使用任务堆栈和任务控制块指针,返回任务句柄</li></ul></li><li><p>删除任务函数声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelete</span><span class="hljs-params">(TaskHandle_t xTaskToDelete)</span>;<br><span class="hljs-comment">// xTaskToDelete: 待删除任务的任务句柄</span><br><span class="hljs-comment">// 若传入 NULL: 删除任务自身(当前正在运行的任务)</span><br></code></pre></td></tr></table></figure><ul><li>被删除的任务将从就绪态任务列表, 阻塞态任务列表, 挂起态任务列表, 事件列表中移除</li><li>空闲任务负责释放被删除任务中系统分配的内存</li></ul></li></ol><h3 id="3-2-创建任务示例"><a href="#3-2-创建任务示例" class="headerlink" title="3.2 创建任务示例"></a>3.2 创建任务示例</h3><ol><li><p>目标: 使用 <code>xTaskCreate</code> 和 <code>vTaskDelete</code></p><ul><li><code>start_task</code>: 启动任务,用于创建其他任务</li><li><code>task1</code>: 让 LED1 每 500ms 闪烁一次</li><li><code>task2</code>: 让 LED2 每 500ms 闪烁一次</li><li><code>task3</code>: 判断 KEY1 是否按下,按下时删除 <code>task1</code></li></ul></li><li><p>创建 <code>task_test.h</code> 文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __TASK_TEST_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __TASK_TEST_H</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">freertos_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>创建 <code>task_test.c</code> 文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task_test.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FreeRTOS.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task.h&quot;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">start_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">task1</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">task2</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">task3</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">freertos_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">/* 1. 创建启动任务 */</span><br>    TaskHandle_t start_task_handler;<br>    xTaskCreate( (TaskFunction_t)start_task, <span class="hljs-string">&quot;start_task&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, &amp;start_task_handler);<br>    <span class="hljs-comment">/* 2. 启动调度器 */</span><br>    vTaskStartScheduler();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">start_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    taskENTER_CRITICAL();  <span class="hljs-comment">// 进入临界区.临界区的代码不会被打断</span><br>    <span class="hljs-comment">/* 1. 创建需要运行的任务 */</span><br>    <span class="hljs-type">static</span> TaskHandle_t task1_handler;<br>    <span class="hljs-type">static</span> TaskHandle_t task2_handler;<br>    <span class="hljs-type">static</span> TaskHandle_t task3_handler;<br>    xTaskCreate( (TaskFunction_t)task1, <span class="hljs-string">&quot;task1&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, &amp;task1_handler);<br>    xTaskCreate( (TaskFunction_t)task2, <span class="hljs-string">&quot;task2&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, &amp;task2_handler);<br>    xTaskCreate( (TaskFunction_t)task3, <span class="hljs-string">&quot;task3&quot;</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, &amp;task3_handler);<br>    <span class="hljs-comment">/* 2. 删除自身(启动任务),退出任务.因为启动任务只需执行一次 */</span><br>    vTaskDelete(<span class="hljs-literal">NULL</span>);<br>    taskEXIT_CRITICAL();  <span class="hljs-comment">// 退出临界区.与进入临界区成对出现</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">task1</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;task1 working...\n&quot;</span>);<br>        LED_Toggle(LED1_Pin);<br>        vTaskDelay(<span class="hljs-number">500</span>);  <span class="hljs-comment">// 该延时函数会让任务进入阻塞态</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">task2</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;task2 working...\n&quot;</span>);<br>        LED_Toggle(LED2_Pin);<br>        vTaskDelay(<span class="hljs-number">500</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">task3</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    <span class="hljs-type">uint8_t</span> key = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;task3 working...\n&quot;</span>);<br>        key = key_detect();<br>        <span class="hljs-keyword">if</span>(key == KEY1 &amp;&amp; task1_handler != <span class="hljs-literal">NULL</span>) &#123;<br>            vTaskDelete(task1_handler);<br>            task1_handler = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        vTaskDelay(<span class="hljs-number">500</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 <code>main.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;task_test.h&quot;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    freertos_start();  <span class="hljs-comment">// 程序开启任务调度器后不会执行之后的代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-3-挂起和恢复"><a href="#3-3-挂起和恢复" class="headerlink" title="3.3 挂起和恢复"></a>3.3 挂起和恢复</h3><ol><li><p>挂起任务.类似暂停</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSuspend</span><span class="hljs-params">( TaskHandle_t xTaskToSuspend )</span>;<br><span class="hljs-comment">// xTaskToSuspend: 待挂起任务的任务句柄.为 NULL 表示挂起任务自身</span><br><span class="hljs-comment">// 需要将宏 INCLUDE_vTaskSuspend 配置为1</span><br></code></pre></td></tr></table></figure></li><li><p>恢复任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskResume</span><span class="hljs-params">( TaskHandle_t xTaskToResume )</span>;<br><span class="hljs-comment">// 需要将宏 INCLUDE_vTaskResume 配置为1</span><br><span class="hljs-comment">// 无论 suspend 多少次,只需 resume 一次.被恢复的任务重新进入就绪态</span><br></code></pre></td></tr></table></figure></li><li><p>在中断恢复被挂起的任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskResumeFromISR</span><span class="hljs-params">( TaskHandle_t xTaskToResume )</span>;<br><span class="hljs-comment">// 返回值: pdTRUE(pdFALSE) 表示任务恢复后需要(不需要)进行任务切换</span><br><span class="hljs-comment">// 需要将宏 INCLUDE_vTaskResume 和 INCLUDE_vTaskResumeFromISR 配置为1</span><br><span class="hljs-comment">// 在中断服务程序调用 Freertos 的 API 函数,要求中断优先级不高于 FreeRTOS 管理的最高中断优先级</span><br></code></pre></td></tr></table></figure></li><li><p>查看任务状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TRACE_FACILITY 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_STATS_FROMATTING_FUNCTIONS 1</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskList</span><span class="hljs-params">( <span class="hljs-type">char</span> *pcWriteBuffer )</span>;<br><span class="hljs-comment">// 输出格式形如:</span><br>名称   状态  优先级  堆栈使用  任务编号<br>task1   x      <span class="hljs-number">1</span>       <span class="hljs-number">79</span>       <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-中断管理"><a href="#3-4-中断管理" class="headerlink" title="3.4 中断管理"></a>3.4 中断管理</h3><ol><li><p>优先级配置</p><ul><li>STM32 通过优先级配置寄存器支持16级不同优先级中断.数字越小表示优先级越高(FreeRTOS 任务相反)</li><li>FreeRTOS 将 PendSV, SysTick 设为最低中断优先级(15),保证任务切换不会阻塞系统对其他中断的响应</li><li>FreeRTOS 通过 BASEPPRI 寄存器实现中断管理,屏蔽优先级低于某一阈值的中断</li><li>建议将所有的优先级指定为抢占优先级,方便 FreeRTOS 管理</li><li>在中断服务函数中调用 FreeRTOS 的 API 函数,必须使用 <code>From_ISR</code> 后缀的函数</li></ul></li><li><p>临界段代码</p><ul><li><p>临界区: 必须在不被打断的情况下完整运行的代码段.如对外设初始化有严格时序要求的代码</p></li><li><p>相关函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">taskENTER_CRITICAL();  <span class="hljs-comment">// 进入临界区</span><br>taskEXIT_CRITICAL();   <span class="hljs-comment">// 退出临界区</span><br>taskENTER_CRITICAL_FROM_ISR();<br>taskEXIT_CRITICAL_FROM_ISR();<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="3-5-时间片调度"><a href="#3-5-时间片调度" class="headerlink" title="3.5 时间片调度"></a>3.5 时间片调度</h3><ol><li>在 FreeRTOS 中,同等优先级的任务轮流分享相同的 CPU 时间.一个时间片的长度等同于 SysTick 中断的周期</li><li>延时函数<ul><li><code>vTaskDelay</code>: 相对延时.从执行该函数开始,直到延时完指定的参数</li><li><code>xTaskDelayUntil</code>: 绝对延时.将整个任务的运行周期视为整体.适合固定频率定期执行的任务</li></ul></li></ol><h2 id="4-消息队列"><a href="#4-消息队列" class="headerlink" title="4 消息队列"></a>4 消息队列</h2><ol><li><p>队列是任务间通信的主要形式,可用于任务之间以及中断和任务之间发送消息.特点有</p><ul><li>FIFO 顺序: 先进先出</li><li>线程安全: 队列操作时原子的</li><li>阻塞和非阻塞: 任务可通过阻塞和非阻塞的方式收发消息</li><li>优先级继承: 确保高优先级任务在队列操作期间不会被低优先级任务阻塞</li><li>可变长度项: 队列中的项可以是不同长度的数据块,而非固定大小</li></ul></li><li><p>队列 API</p><table><thead><tr><th>API 函数</th><th>描述</th></tr></thead><tbody><tr><td>xQueueCreate</td><td>动态方式创建队列</td></tr><tr><td>xQueueCreateStatic</td><td>静态方式创建队列</td></tr></tbody></table></li><li><p>向队列写入消息</p><table><thead><tr><th>API 函数</th><th>描述</th></tr></thead><tbody><tr><td>xQueueSend</td><td>向队列尾部写入消息</td></tr><tr><td>xQueueSendToFront</td><td>向队列头部写入消息</td></tr></tbody></table></li><li><p>从队列读取消息</p><table><thead><tr><th>API 函数</th><th>描述</th></tr></thead><tbody><tr><td>xQueueReceive</td><td>从队列头部读取消息,并删除消息</td></tr><tr><td>xQueuePeek</td><td>从队列头部读取消息,但不删除</td></tr></tbody></table></li></ol><h2 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5 信号量"></a>5 信号量</h2><ol><li><p>信号量是一种用于任务间同步和资源管理的机制.信号量可以是二值的(0 &#x2F; 1)或计数型(正整数)</p><ul><li>信号量的基础操作: 获取, 释放</li><li>管理对共享资源的访问,确保同一时刻只有一个任务可以访问共享资源</li><li>适用于对资源的互斥访问,控制任务的执行顺序.或限制同时访问某一资源的任务数量</li></ul></li><li><p>二值信号量: 主要用于共享资源的互斥访问 或 任务间同步</p><ul><li><p>0: 资源不可用. 1: 资源可用</p></li><li><p>二值信号量 API</p><table><thead><tr><th>API 函数</th><th>描述</th></tr></thead><tbody><tr><td>xSemaphoreCreateBinary</td><td>使用动态方式创建二值信号量</td></tr><tr><td>xSemaphoreGive</td><td>释放信号量</td></tr><tr><td>xSemaphoreTake</td><td>获取信号量</td></tr></tbody></table></li></ul></li><li><p>计数型信号量: 用于事件计数或资源数量计数</p><ul><li><p>计数型信号量 API</p><table><thead><tr><th>API 函数</th><th>描述</th></tr></thead><tbody><tr><td>xSemaphoreCreateCounting</td><td>使用动态方式创建计数型信号量</td></tr><tr><td>xSemaphoreGetCount</td><td>获取计数值</td></tr></tbody></table></li></ul></li><li><p>互斥信号量: 包含优先级继承机制的二值信号量,防止优先级翻转</p><ul><li>互斥信号量 API: <code>xSemaphoreCreateMutex</code> 动态创建互斥信号量</li></ul></li></ol><h2 id="6-事件标志组"><a href="#6-事件标志组" class="headerlink" title="6 事件标志组"></a>6 事件标志组</h2><ol><li>事件标志组是一个标志牌集合,每个标志位代表一种特定的状态或事件<ul><li>任务通过等待或设置这些标志位,实现任务之间的协同工作</li></ul></li><li>事件标志位可以规定将标志置1表示事件发生,0表示未发生<ul><li>事件标志位存储在单个无符号整数变量中.事件 0 存储于 bit0…</li></ul></li></ol><h2 id="7-任务通知"><a href="#7-任务通知" class="headerlink" title="7 任务通知"></a>7 任务通知</h2><ol><li>任务通知允许一个任务向其他任务发送简单的通知或信号,实现任务间的同步和协作<ul><li>任务通知通常替代二值信号量或事件标志组,提供更轻量级的任务间通信方式</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>FreeRTOS</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32</title>
    <link href="/2024/04/01/Embedded/STM32/"/>
    <url>/2024/04/01/Embedded/STM32/</url>
    
    <content type="html"><![CDATA[<h1 id="STM32"><a href="#STM32" class="headerlink" title="STM32"></a>STM32</h1><h2 id="0-开发板介绍"><a href="#0-开发板介绍" class="headerlink" title="0 开发板介绍"></a>0 开发板介绍</h2><h3 id="0-1-STM32-开发板"><a href="#0-1-STM32-开发板" class="headerlink" title="0.1 STM32 开发板"></a>0.1 STM32 开发板</h3><p><img src="/2024/04/01/Embedded/STM32/0-STM32F103C8T6-Board-Features.jpg"></p><ol><li>使用右侧 SWD 接口下载程序及供电</li><li>32.768KHz 晶振: 连接到 LSE(low-speed external clock signal),给 RTC 提供时钟.<br>如果无需使用掉电不丢失时间的功能,可去掉.由内部 40KHz 的 RC 时钟源给 RTC 提供时钟</li><li>8MHz 晶振: 连接到 HSE(high-speed external clock signal),给 SYSCLK 提供时钟.<br>由于芯片内部的 HSI RC 时钟源不够精准,<strong>通常采用外部独立时钟源来为芯片提供系统时钟</strong></li></ol><h3 id="0-2-开发板引脚图"><a href="#0-2-开发板引脚图" class="headerlink" title="0.2 开发板引脚图"></a>0.2 开发板引脚图</h3><p><img src="/2024/04/01/Embedded/STM32/0-STM32F103C8T6-Blue-Pill-Pin-Layout.gif"></p><h3 id="0-3-最小系统电路"><a href="#0-3-最小系统电路" class="headerlink" title="0.3 最小系统电路"></a>0.3 最小系统电路</h3><p><img src="/2024/04/01/Embedded/STM32/0-minimal-system-circuit.png"></p><ol><li>3V3 与 GND 间的 100nF 滤波电容: 保证供电电压的稳定</li><li><strong>晶振</strong>: 8MHz 晶振的典型电路.20pF 作为起振电容.接到芯片的5,6号脚.3,4号引脚预留接 32.768KHz 晶振</li><li><strong>复位</strong>: NRST 接到7号引脚,低电平复位<ul><li>刚上电时,电容充电,相当于短路,NRST 下拉至 GND(上电复位).充满电后短路,上拉至 3V3</li><li>之后,K1 断开时,NRST 拉至 3V3.K1 闭合时,电容放电,NRST 接地(手动复位)</li></ul></li><li><strong>启动配置</strong>: H1 起到开关的作用.实际中采用跳线帽的方式选择模式</li><li><strong>下载端口</strong>: SWDIO, SWCLK 分别接到芯片的34,37号引脚(PA13,14).正负极间同样可以加滤波电容</li></ol><h2 id="1-STM32"><a href="#1-STM32" class="headerlink" title="1 STM32"></a>1 STM32</h2><h3 id="1-1-STM32-命名规则"><a href="#1-1-STM32-命名规则" class="headerlink" title="1.1 STM32 命名规则"></a>1.1 STM32 命名规则</h3><p><img src="/2024/04/01/Embedded/STM32/1-STM32-naming.png"></p><h3 id="1-2-存储器和总线构架"><a href="#1-2-存储器和总线构架" class="headerlink" title="1.2 存储器和总线构架"></a>1.2 存储器和总线构架</h3><p><img src="/2024/04/01/Embedded/STM32/1-system-architecture.png"></p><h3 id="1-3-F103C8T6-引脚定义"><a href="#1-3-F103C8T6-引脚定义" class="headerlink" title="1.3 F103C8T6 引脚定义"></a>1.3 F103C8T6 引脚定义</h3><p><img src="/2024/04/01/Embedded/STM32/1-STM32F103C8T6-pin-define.png"></p><h3 id="1-4-片上资源-外设"><a href="#1-4-片上资源-外设" class="headerlink" title="1.4 片上资源(外设)"></a>1.4 片上资源(外设)</h3><table><thead><tr><th>英文缩写</th><th>名称</th><th>英文缩写</th><th>名称</th></tr></thead><tbody><tr><td>NVIC</td><td>嵌套向量中断控制器</td><td>CAN</td><td>CAN 通信</td></tr><tr><td>SysTick</td><td>系统滴答定时器</td><td>USB</td><td>USB 通信</td></tr><tr><td>RCC</td><td>复位和时钟控制</td><td>RTC</td><td>实时时钟</td></tr><tr><td>GPIO</td><td>通用 IO 口</td><td>CRC</td><td>CRC 校验</td></tr><tr><td>AFIO</td><td>复用 IO 口</td><td>PWR</td><td>电源控制</td></tr><tr><td>EXTI</td><td>外部中断</td><td>BKP</td><td>备份寄存器</td></tr><tr><td>TIM</td><td>定时器</td><td>IWDG</td><td>独立看门狗</td></tr><tr><td>ADC</td><td>模数转换器</td><td>WWDG</td><td>窗口看门狗</td></tr><tr><td>DMA</td><td>直接内存访问</td><td>DAC</td><td>数模转换器</td></tr><tr><td>USART</td><td>同步 &#x2F; 异步串口通信</td><td>SDIO</td><td>SD 卡接口</td></tr><tr><td>I2C</td><td>I2C 通信</td><td>FSMC</td><td>可变静态存储控制器</td></tr><tr><td>SPI</td><td>SPI 通信</td><td>USB OTG</td><td>USB 主机接口</td></tr></tbody></table><h2 id="2-工程建立"><a href="#2-工程建立" class="headerlink" title="2 工程建立"></a>2 工程建立</h2><h3 id="2-1-搭建开发环境"><a href="#2-1-搭建开发环境" class="headerlink" title="2.1 搭建开发环境"></a>2.1 搭建开发环境</h3><ol><li><p><strong>Keil5 MDK: IDE, 集成开发环境</strong></p><ul><li><p>运行 <code>MDK542a.exe</code> 文件,更改安装路径后,一路点击 <code>next</code> 即可</p></li><li><p>软件注册: 以管理员身份运行 Keil5 -&gt; <code>File</code> -&gt; <code>License Management</code> -&gt; 复制 CID</p><p><img src="/2024/04/01/Embedded/STM32/2-register-Keil.png"></p></li><li><p>运行 <code>keygen_new2032.exe</code> 文件 -&gt; 粘贴 <code>CID</code> -&gt; <code>Target</code> 选 <code>ARM</code> -&gt; 点击 <code>Generate</code> 生成序列码</p><p><img src="/2024/04/01/Embedded/STM32/2-keygen.png"></p></li><li><p>将序列码粘贴到 keil5 中的 <code>New License ID Code</code> 栏 -&gt; <code>ADD LIC</code></p></li></ul></li><li><p><strong>器件支持包: 对相应的 MCU 型号提供支持</strong></p><ul><li><p>离线安装: 下载后,运行相应的器件支持包文件即可(<code>Keil.STM32F1xx_DFP.2.2.0.pack</code>)</p></li><li><p>在线安装: 打开 Keil -&gt; <code>Pack Installer</code> -&gt; <code>Device</code> -&gt; <code>STMicroelectronics</code> -&gt; install 后缀 <code>DFP</code> 的文件</p><p><img src="/2024/04/01/Embedded/STM32/2-pack-installer.png"></p></li></ul></li><li><p><strong>STLink 驱动</strong>: Keil5 安装目录中自带(<code>Keil5\ARM\STLink\USBDriver\dpinst_amd64.exe</code>)</p></li><li><p><strong>JLink 驱动</strong>: 同样位于 Keil5 安装目录中(<code>Keil5\ARM\Segger\JLink.exe</code>)</p></li><li><p><strong>USB 转串口驱动</strong>: 运行 <code>CH341SER.EXE</code></p></li><li><p>STM32 开发方式</p><ul><li>基于寄存器: STM32 结构复杂,寄存器数量太多,不推荐</li><li>基于库函数: 使用 ST 官方提供的函数,间接配置寄存器(官方停止维护)</li><li>基于 HAL 库: 图形化界面配置 STM32(官方主推)</li></ul></li><li><p>基于库函数需要 STM32 库函数的文件(固件库)</p></li></ol><h3 id="2-2-寄存器开发"><a href="#2-2-寄存器开发" class="headerlink" title="2.2 寄存器开发"></a>2.2 寄存器开发</h3><ol><li><p>在 Keil5 中 -&gt; <code>Project</code> -&gt; <code>New uVision Project</code> -&gt; 设置工程文件名(project) -&gt; 选择芯片型号</p><ul><li><p>此时工程目录下将会有一个 <code>project.uvprojx</code> 文件.该文件为 keil 工程文件</p></li><li><p>配合使用 git 管理代码版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init<br></code></pre></td></tr></table></figure></li><li><p>创建 <code>.gitignore</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">.vscode/<br>DebugConfig/<br>Listings/<br>Objects/<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>添加固件库文件: 在工程目录中创建 Start 目录存放下列启动文件(STM32程序从启动文件开始执行)</strong></p><p><img src="/2024/04/01/Embedded/STM32/2-Start-directory.png"></p></li><li><p><strong>将文件添加到工程</strong></p><ul><li><p>将左侧的 <code>Source Group 1</code> 改名为 <code>Start</code> -&gt; 右击后选择 <code>Add Existing Files to Group</code> 添加文件</p><p><img src="/2024/04/01/Embedded/STM32/2-add-start-file.png"></p></li><li><p>启动文件需要根据型号选择(这里选择仅 <code>startup_stm32f10x_md.s</code>)</p></li></ul></li><li><p><strong>添加文件夹的头文件路径</strong>: <code>Options</code> -&gt; <code>C/C++</code> -&gt; 在 <code>Include Paths</code> 栏添加路径</p></li><li><p><strong>编写测试函数</strong>: 首先创建 User 目录用于存放用户代码</p><ul><li><p>创建 <code>main.c</code> 文件并添加到工程</p><ul><li><p>右键 <code>Target</code> -&gt; <code>Add Group</code> 并将名称改为 <code>User</code> -&gt; 右键 <code>Add New item...</code></p></li><li><p>选择 <code>C File</code> -&gt; 名称设为 <code>main</code> -&gt; 修改文件存放路径为 <code>User</code> 目录</p></li></ul></li><li><p>测试配置: 打开 <code>main</code> 文件在空白处右击,选择 insert <code>#include file stm32f10x.h</code> -&gt; 编写任意代码 -&gt; <code>Build</code></p></li><li><p>若编译没有错误说明工程建立正常.到此可以进行<strong>基于寄存器的开发</strong>.如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;  <span class="hljs-comment">/* 点亮 PC13 的 LED */</span><br>RCC-&gt;APB2ENR |= <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<span class="hljs-comment">/* 开启 APB2 的 GPIOC 时钟 */</span><br>GPIOC-&gt;CRH |= <span class="hljs-number">3</span> &lt;&lt; (<span class="hljs-number">4</span> * (<span class="hljs-number">13</span> - <span class="hljs-number">8</span>));<span class="hljs-comment">/* 指定 GPIO_Pin_13 为推挽输出.50MHz */</span><br>GPIOC-&gt;ODR &amp;= !(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">13</span>);<span class="hljs-comment">/* 指定 GPIO_Pin_13 引脚的电压为低 */</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>连接最小系统板时需要选择对应的调试方式(这里使用 STLink)</p><ul><li><p><code>Options</code> -&gt; <code>Debug</code> -&gt; Use 栏选择 <code>ST-Link Debugger</code> -&gt; <code>Settings</code> -&gt; <code>Flash Download</code> -&gt; 勾选 <code>Reset and Run</code></p><p><img src="/2024/04/01/Embedded/STM32/2-debug-config.png"></p></li></ul></li></ol><h3 id="2-3-标准库开发"><a href="#2-3-标准库开发" class="headerlink" title="2.3 标准库开发"></a>2.3 标准库开发</h3><ol><li><p>在工程新建 <code>Library</code> 目录,添加 <code>Libraries\STM32F10x_StdPeriph_Driver\src, inc</code> 目录下的所有文件(各23个)</p></li><li><p>将 <code>Project\STM32F10x_StdPeriph_Template</code> 目录下的三个文件添加到工程的 <code>User</code> 目录</p><p><img src="/2024/04/01/Embedded/STM32/2-User-directory.png"></p></li><li><p>添加全局宏定义</p><ul><li><p>打开 <code>&quot;stm32f10x.h&quot;</code> 文件,在文件末尾有条件编译语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_STDPERIPH_DRIVER</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x_conf.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>因此需要宏定义 <code>USE_STDPERIPH_DRIVER</code>: <code>Options</code> -&gt; 在 <code>C/C++ Define</code> 栏填 <code>USE_STDPERIPH_DRIVER</code></p></li></ul></li><li><p>需要再次完成 <strong>将文件添加到工程,添加文件夹的头文件路径</strong> 步骤</p></li><li><p>至此可以进行<strong>基于库函数的开发</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-comment">/* 配置 GPIOC.并设置为: 推挽输出,引脚选中13, 速率50MHz */</span><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);<br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOC, &amp;GPIO_InitStructure);<br>GPIO_ResetBits(GPIOC, GPIO_Pin_13);  <span class="hljs-comment">// 将 PC13 置为低电平</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>库函数调用逻辑: 复位中断函数才是程序的入口(在复位后执行).其职责为调用 <code>SystemInit, main</code> 函数</p><p><img src="/2024/04/01/Embedded/STM32/2-Engineering-architecture.png"></p></li></ol><h3 id="2-4-Keil5-使用"><a href="#2-4-Keil5-使用" class="headerlink" title="2.4 Keil5 使用"></a>2.4 Keil5 使用</h3><ol><li><strong>界面设置(Configuration)</strong><ul><li><code>Configuration</code> -&gt; <code>Color &amp; Fonts</code> -&gt; <code>C/C++ Editor files</code> -&gt; 设置字体及其大小</li><li><code>Configuration</code> -&gt; <code>Editor</code> -&gt; <code>Encoding</code> 改为 <code>UTF-8</code> 编码, <code>Tab Size</code> 改为4</li><li><code>Manage Project Items</code> -&gt; 可以调整左侧文件显示的顺序</li></ul></li><li>Keil 中直接写入汉字报错的解决方式<ul><li><code>Options</code> -&gt; <code>C/C++</code> -&gt; <code>Misc Controls</code> 栏填入 <code>--no-multibyte-chars</code></li></ul></li></ol><h3 id="2-5-串口下载"><a href="#2-5-串口下载" class="headerlink" title="2.5 串口下载"></a>2.5 串口下载</h3><ol><li><p>启动模式</p><table><thead><tr><th>BOOT1</th><th>BOOT 0</th><th>启动模式</th><th>说明</th></tr></thead><tbody><tr><td>X</td><td>0</td><td>主闪存存储器</td><td><strong>主闪存存储器被选为启动区域(主要使用方式)</strong></td></tr><tr><td>0</td><td>1</td><td>系统存储器</td><td>系统存储器被选为启动区域.运行 BootLoader(串口下载)</td></tr><tr><td>1</td><td>1</td><td>内置 SRAM</td><td>内置 SRAM 被选为启动区域(程序调试)</td></tr></tbody></table></li><li><p>FlyMcu 串口下载程序</p><ul><li><p>需要连接 USB转串口模块的 RX(PA9), TX(PA10), GND</p></li><li><p>需要工程生成的 HEX 文件(在 Keil 中 <code>Options for target</code> -&gt; <code>output</code> 勾选 <code>Creact HEX File</code>)</p><p><img src="/2024/04/01/Embedded/STM32/2-CreateHEX.png"></p></li><li><p><code>搜索串口</code> -&gt; bps 默认115200 -&gt; 选择下载的程序文件(.hex)</p></li><li><p>单片机引脚配置: 让STM32执行 <code>BootLoader</code> 程序</p><ul><li>将 Boot0 配置为1(插在右边), Boot1 配置为0(插在左边)</li><li>按下复位键,此时 STM32 将不断接收 USART1 的数据.刷新到主闪存</li></ul></li><li><p>点击<code>开始编程</code>.写入完成后,将 Boot0 配置为0(插在左边).按下复位键.程序开始执行</p><p><img src="/2024/04/01/Embedded/STM32/2-FlyMcu.png"></p></li></ul></li><li><p><strong>STM32 一键下载</strong>(需要搭建另外的电路)</p><ul><li>但是仍可以勾选<code>编程后执行</code>,反勾选<code>编程到FLASH时写选项字节</code></li><li>然后 boot0 选为1 -&gt; 按下复位键 -&gt; 下载程序.完成下载后程序会直接运行</li><li>原理为指定运行程序从 0800 0000 开始运行.复位其本质后仍执行 <code>BootLoader</code> 程序</li></ul></li><li><p>ST-LINK Utility(需连接 ST Link 下载)</p><p><img src="/2024/04/01/Embedded/STM32/2-ST-LINK-Utility.png"></p><ul><li><strong><code>Target</code> -&gt; <code>Option Bytes</code>(快捷键 Ctrl + B): 打开选项字节的设置页面</strong></li></ul></li></ol><h3 id="2-6-HAL-库开发"><a href="#2-6-HAL-库开发" class="headerlink" title="2.6 HAL 库开发"></a>2.6 HAL 库开发</h3><ol><li><p>CubeMX <a href="https://www.st.com/en/development-tools/stm32cubemx.html">官网下载</a></p><ul><li><p>运行 <code>SetupSTM32CubeMX-6.12.1-Win.exe</code> 安装 CubeMX</p></li><li><p>注意第一次需要使用管理员权限打开</p></li><li><p>安装支持包(在线安装): Help -&gt; Manage embedded software packages.选择对应版本下载</p><p><img src="/2024/04/01/Embedded/STM32/2-Cube-pack-manager.png"></p></li><li><p>创建项目: Access to MCU selector -&gt; 选择相应 MCU</p><p><img src="/2024/04/01/Embedded/STM32/2-Cube-pin.png"></p></li><li><p><strong>引脚配置</strong></p><ul><li><strong>RCC 选择 Crystal&#x2F;Ceramic Resonator</strong></li><li><strong>SYS 中 Debug 选择 Serial Wire</strong></li><li><strong>PC13 选择 GPIO_Output</strong></li></ul></li><li><p><strong>时钟配置: HCLK 设为72MHz</strong></p><p><img src="/2024/04/01/Embedded/STM32/2-Cube-clock.png"></p></li><li><p>项目配置</p><ul><li><p>需要指定项目名称, IDE 选择 <code>MDK-ARM</code></p></li><li><p>在 <code>Code Generator</code> 中勾选 <code>Generate peripheral initialization as a pair of &quot;.c/.h&quot; files per peripheral</code></p><p><img src="/2024/04/01/Embedded/STM32/2-Cube-project-config.png"></p></li></ul></li></ul></li></ol><h3 id="2-7-VSCode-插件"><a href="#2-7-VSCode-插件" class="headerlink" title="2.7 VSCode 插件"></a>2.7 VSCode 插件</h3><ol><li><p>VSCode <a href="https://code.visualstudio.com/">官网下载</a></p><ul><li><p>安装插件: <code>C/C++, Keil Assistant</code></p><p><img src="/2024/04/01/Embedded/STM32/2-VSCode-plug.png"></p></li><li><p>关联 Keil: 设置中搜索 keil, 在 <code>Keil Assistant.MDK: Uv4 Path</code> 栏指定 UV4 路径</p><p><img src="/2024/04/01/Embedded/STM32/2-Keil4-path.png"></p></li><li><p>在资源管理器中将会新增 keil 栏.可以进行编译下载(其本质仍是调用 Keil 的配置)</p><p><img src="/2024/04/01/Embedded/STM32/2-Keil.png"></p></li></ul></li></ol><h2 id="3-GPIO-输入输出"><a href="#3-GPIO-输入输出" class="headerlink" title="3 GPIO 输入输出"></a>3 GPIO 输入输出</h2><h3 id="3-1-GPIO-结构"><a href="#3-1-GPIO-结构" class="headerlink" title="3.1 GPIO 结构"></a>3.1 GPIO 结构</h3><ol><li><p>GPIO 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/3-GPIO-struct.png"></p><ul><li>I&#x2F;O 引脚连接驱动器寄存器到 APB2</li><li>内核写入(读取)输出寄存器(输入寄存器),以此控制(读取) I&#x2F;O 引脚的高低电平</li></ul></li><li><p>IO 口的基本结构</p><p><img src="/2024/04/01/Embedded/STM32/3-IOpin-struct.png"></p></li><li><p>输入电路分析</p><ul><li><code>保护二极管</code>对输入电压进行限幅: 确保输入电压范围在 $V_{SS} \sim V_{DD}$</li><li><code>上拉电阻和下拉电阻</code>: 避免引脚悬空导致的输入数据不确定, 设定一个默认值<ul><li>上方闭合,下方断开: <strong>上拉输入模式,即默认高电平</strong></li><li>上方断开,下方闭合: <strong>下拉输入模式,即默认低电平</strong></li><li>开关均断开: <strong>浮空输入模式</strong></li></ul></li><li><code>施密特触发器</code>(图中翻译错误): 对输入电压整形,然后写入<code>输入数据寄存器</code><ul><li>输入电压大于某个上限,输出瞬间升为高电平;</li><li>输入电压小于某个下限,输出瞬间将为低电平;否则不变</li></ul></li><li>模拟输入, 复用功能输入<ul><li><strong>模拟输入</strong>需要连续量,因此在施密特触发器之前.连接到 ADC.此时 GPIO 失效</li><li><strong>复用功能输入</strong>(如串口的输入引脚)需要数字量,因此在施密特触发器之后</li></ul></li></ul></li><li><p>输出电路分析: 输出可由 <code>输出数据寄存器</code>(普通IO输出) 或 <code>片上外设</code>(<strong>复用功能输出</strong>) 控制</p><ul><li><code>位设置/清除寄存器</code>: 单独操作输出数据寄存器的某一位, 而不影响其他位<br>将需要置1的对应写1,其余写0,即可自动将相应位置置1,其他位不变</li><li><code>输出数据寄存器</code>: 输出整个寄存器的数据.只能整体写入,不能单独操作某一位</li><li><code>数据输出选择器</code>: 选择由输出数据寄存器或是复用功能输出</li><li><code>P-MOS, N-MOS</code>的作用: 输出控制<ul><li>当 P-MOS,N-MOS 均有效时为<strong>推挽输出</strong>, 高低电平均有驱动能力</li><li>当 P-MOS 无效, N-MOS 有效时为<strong>开漏输出</strong>,仅低电平具有驱动能力<ul><li>当数据寄存器为1时,N-MOS 断开,呈现出高阻态</li><li>当数据寄存器为0时,N-MOS 导通,输出低电平</li><li>开漏输出模式可以用于通信协议的驱动,如 I2C</li><li>开漏输出模式输出 5V 信号: 在 I&#x2F;O 口外接一个上拉电阻到 5V 电源正极</li></ul></li><li>当 P-MOS N-MOS 均无效时,输出关闭,端口电平由外部控制</li></ul></li></ul></li></ol><h3 id="3-2-标准库代码分析"><a href="#3-2-标准库代码分析" class="headerlink" title="3.2 标准库代码分析"></a>3.2 标准库代码分析</h3><ol><li><p>对 <code>stm32f10x_gpio.h, stm32f10x_gpio.c</code> 源码的分析</p></li><li><p><strong>头文件中的通用格式</strong>: 防止重复包含以及保证对 C++ 的兼容性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __STM32F10x_GPIO_H  <span class="hljs-comment">/* 防止头文件重复包含 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __STM32F10x_GPIO_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus  <span class="hljs-comment">/* 对 C++ 的兼容 */</span></span><br> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* 对 C++ 的兼容 */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __STM32F10x_GPIO_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>参数合理性判断</strong>: 对于后续编写的函数,需要判断传入参数是否为 GPIO.在调用函数前断言</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOB) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOC) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOD) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOE) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOF) || \</span><br><span class="hljs-meta">                                    ((PERIPH) == GPIOG))</span><br><br><span class="hljs-comment">/* 分析: 断言参数 expr.若非零,则通过.否则断言失败,直接在编译时报错,并指出错误位置 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))</span><br></code></pre></td></tr></table></figure></li><li><p><strong>枚举定义</strong>: 初始化时,需要根据手册中的位组合确定模式时,提前对其定义.枚举非常多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 分析: 对于输出最大速率寄存器的组合,在这里直接定义为对应的值,方便使用 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>  GPIO_Speed_10MHz = <span class="hljs-number">1</span>,<span class="hljs-comment">/* MODE = 01 */</span><br>  GPIO_Speed_2MHz,<span class="hljs-comment">/* MODE = 10 */</span><br>  GPIO_Speed_50MHz<span class="hljs-comment">/* MODE = 11 */</span><br>&#125; GPIOSpeed_TypeDef;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-3-HAL-库"><a href="#3-3-HAL-库" class="headerlink" title="3.3 HAL 库"></a>3.3 HAL 库</h3><ol><li><p>使用 HAL 库使 led 闪烁</p><p><img src="/2024/04/01/Embedded/STM32/3-GPIO-HAL.png"></p></li></ol><h3 id="3-4-中断方式读取按键"><a href="#3-4-中断方式读取按键" class="headerlink" title="3.4 中断方式读取按键"></a>3.4 中断方式读取按键</h3><ol><li><p>按键操作定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 操作定义</span><br><span class="hljs-comment">** 短按: 按下时间 &lt; 1秒</span><br><span class="hljs-comment">** 长按: 按下时间 &gt; 1秒</span><br><span class="hljs-comment">** </span><br><span class="hljs-comment">** 按键事件</span><br><span class="hljs-comment">** 长按事件: 出现1次长按操作</span><br><span class="hljs-comment">** 单击事件: 1次短按后,间隔0.5秒内无操作</span><br><span class="hljs-comment">** 双击事件: 2次短按时间 &lt; 0.5秒.则这2次短按产生一次双击事件</span><br><span class="hljs-comment">** 特别的:   短按 + 0.5秒内长按不算双击.长按 + 0.5秒内短按也不算双击</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>实现思路</p></li></ol><h2 id="4-EXTI-外部中断"><a href="#4-EXTI-外部中断" class="headerlink" title="4 EXTI 外部中断"></a>4 EXTI 外部中断</h2><h3 id="4-1-中断"><a href="#4-1-中断" class="headerlink" title="4.1 中断"></a>4.1 中断</h3><ol><li><p>中断系统</p><ul><li>中断允许微控制器在执行主程序的同时,对发生的特定事件做出及时响应</li><li>在 STM32 中,中断用于处理外部事件,如按键输入,定时器溢出,串口数据接收等</li><li><strong>中断处理程序: 一段特殊的代码,用于处理中断事件</strong></li><li>当中断发生时,自动跳转到对应中断向量表项中存储的中断处理程序地址,并执行其中的代码</li></ul></li><li><p>中断向量表</p><ul><li><strong>中断处理程序的入口地址存储在中断向量表中</strong></li><li>中断向量表是一个存储中断处理程序地址的数组,每个中断都有一个对应的向量表项</li></ul></li><li><p><strong>中断优先级: 每个中断都有一个优先级,用于确定中断的相对重要性</strong></p><ul><li>较高优先级的中断将优先处理,而较低优先级的中断可能会被延迟处理</li><li><strong>中断嵌套: 即在一个中断处理程序中,可以允许更高优先级的中断打断当前正在执行的中断处理程序.以确保对于紧急事件的及时响应</strong></li></ul></li></ol><h3 id="4-2-NVIC"><a href="#4-2-NVIC" class="headerlink" title="4.2 NVIC"></a>4.2 NVIC</h3><p><img src="/2024/04/01/Embedded/STM32/4-NVIC.png"></p><ol><li><strong>NVIC(Nested Vectored Interrupt Controller, 嵌套向量中断控制器)是内核外设</strong><ul><li>中断通道可以将 EXTI, TIM, ADC, USART… 作为输入</li><li>只有一条输出通道,根据中断优先级分配先后顺序</li></ul></li><li>优先级分组: 由优先级寄存器的4位决定<ul><li>优先级寄存器分为高 n 位的抢占优先级和低 (4-n) 位的响应优先级</li><li><strong>抢占优先级可以中断嵌套,响应优先级则需要进行排队</strong></li></ul></li><li>优先级规则<ul><li>优先级数字越小,优先级越高.如果不设置优先级,默认为0</li><li>若抢占优先级和响应优先级都一样,则查找中断向量表,值小的先响应</li></ul></li></ol><h3 id="4-3-EXTI"><a href="#4-3-EXTI" class="headerlink" title="4.3 EXTI"></a>4.3 EXTI</h3><ol><li><p>EXTI 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/4-EXTI.png"></p></li><li><p><strong>EXTI(Extern Interrupt, 外部中断)</strong></p><ul><li>EXTI 可以监测指定 GPIO 口的电平信号,当其指定的 GPIO 口产生电平变化时,EXTI 将立即向 NVIC 发出中断申请,经过 NVIC 裁决后即可中断 CPU 主程序,使 CPU 执行 EXTI 对应的中断程序</li><li>支持所有的 GPIO 口.但同 Pin 不能同时触发</li><li><strong>触发方式: 上升 &#x2F; 下降 &#x2F; 双边沿, 软件触发</strong></li><li>通道数: 16个 GPIO_Pin, PVD 输出, RTC 闹钟, USB 唤醒, 以太网唤醒</li></ul></li><li><p>响应方式</p><ul><li><strong>中断响应: 正常中断流程,申请中断</strong></li><li><strong>事件响应: 不申请中断,通向其他外设,触发其他外设的操作</strong></li></ul></li><li><p>判断代码是否成功进入中断的方法</p><ul><li>进入调试模式,在中断函数设置一个断点</li><li>选择全速运行代码,手动触发一个中断条件,使代码进入中断</li><li>如果代码运行到设置的断点处,说明进入了中断</li></ul></li></ol><h3 id="4-4-AFIO"><a href="#4-4-AFIO" class="headerlink" title="4.4 AFIO"></a>4.4 AFIO</h3><ol><li><p><strong>AFIO 功能: 引脚复用功能重映射, 中断引脚选择</strong></p></li><li><p>中断引脚选择: PA0~PG0 只能有一个通过 AFIO 的选择到达 EXTI</p><p><img src="/2024/04/01/Embedded/STM32/4-AFIO.png"></p></li><li><p>AFIO 引脚重映射(以 TIM2 的 CH1 为例)</p><ul><li><p>TIM2 的 CH1 原本位于 PA0.可以将其重映射到 PA15</p><p><img src="/2024/04/01/Embedded/STM32/4-AFIO-redefine.png"></p></li><li><p>因此,可以使用部分重映射1或完全重映射实现使用 PA15 作为 TIM2 的 CH1</p></li><li><p>需要注意的是,PA15 原本的功能是作为 JTAG 的调试功能,因此还需要将其关闭,作为普通 GPIO 引脚</p><p><img src="/2024/04/01/Embedded/STM32/4-JTAG-disable.png"></p></li></ul></li></ol><h3 id="4-5-HAL-库操作"><a href="#4-5-HAL-库操作" class="headerlink" title="4.5 HAL 库操作"></a>4.5 HAL 库操作</h3><ol><li><p>直接在引脚上选择 GPIO_EXTI</p><p><img src="/2024/04/01/Embedded/STM32/4-HAL-EXTI-pin.png"></p></li><li><p>在 GPIO 中选择其配置</p><p><img src="/2024/04/01/Embedded/STM32/4-HAL-EXTI-pin-config.png"></p></li><li><p>enable EXTI 中断线</p><p><img src="/2024/04/01/Embedded/STM32/4-NVIC-enable.png"></p></li><li><p>在 NVIC 中配置优先级(注意 hal_delay 的实现依赖于 SysTick 中断,因此若在中断使用 delay 需要 SysTick 优先级高于当前中断)</p><p><img src="/2024/04/01/Embedded/STM32/4-NVIC-priority.png"></p></li><li><p>生成的代码主要关注 <code>stm32f1xx_it.c</code> 文件,会增加一个中断处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* This function handles EXTI line1 interrupt. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">EXTI1_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  HAL_GPIO_EXTI_IRQHandler(key1_Pin);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>其底层会调用到一个弱实现的回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span> &#123;<br>  <span class="hljs-comment">/* EXTI line interrupt detected */</span><br>  <span class="hljs-keyword">if</span> (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != <span class="hljs-number">0x00u</span>) &#123;<br>    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);<br>    HAL_GPIO_EXTI_Callback(GPIO_Pin);<br>  &#125;<br>&#125;<br><br>__weak <span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_Callback</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span> &#123;<br>  UNUSED(GPIO_Pin);  <span class="hljs-comment">/* Prevent unused argument(s) compilation warning */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>因此可以通过重新实现回调函数来执行逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_Callback</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span> &#123;<br>  <span class="hljs-keyword">if</span> (GPIO_Pin == key1_Pin)<br>      <span class="hljs-comment">// 具体逻辑...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="5-TIM-定时器"><a href="#5-TIM-定时器" class="headerlink" title="5 TIM 定时器"></a>5 TIM 定时器</h2><h3 id="5-1-定时器"><a href="#5-1-定时器" class="headerlink" title="5.1 定时器"></a>5.1 定时器</h3><ol><li><p><strong>定时器: 对输入时钟计数,在计数值达到设定值时触发中断</strong></p><ul><li>基本定时功能: 每隔一段时间产生一个中断</li><li>定时器输出比较: 常用来产生 PWM 波形</li><li>定时器输入捕获: 测量方波频率</li><li>定时器编码器接口: 读取正交编码器的输出波形</li></ul></li><li><p>定时器类型</p><table><thead><tr><th><strong>类型</strong></th><th align="left"><strong>编号</strong></th><th><strong>总线</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>基本定时器</td><td align="left">TIM6 &amp; TIM7</td><td>APB1</td><td>定时中断, 主模式触发 DAC</td></tr><tr><td>通用定时器</td><td align="left">TIM2 ~ TIM5</td><td>APB1</td><td>拥有基本定时器全部功能. 额外具有: 内外时钟源选择,<br />输入捕获输出比较, 编码器接口, 主从触发模式等功能</td></tr><tr><td>高级定时器</td><td align="left">TIM1 &amp; TIM8</td><td>APB2</td><td>拥有通用定时器全部功能. 额外具有: 重复计数器,<br />死区生成, 互补输出, 刹车输入等功能</td></tr></tbody></table></li><li><p>基本定时器</p><p><img src="/2024/04/01/Embedded/STM32/5-basic-timer.png"></p><ul><li><strong>时基单元: 最基本的计数计时电路</strong><ul><li><code>PSC 预分频器</code>: 对 72MHz 的时钟进行预分频.实际分频系数 &#x3D; PSC + 1</li><li><code>CNT 计数器</code>: 对预分频后的时钟进行计数.每有一个上升沿,CNT ++</li><li><code>ARR 自动重装载寄存器</code>: 存储计数目标.<strong>当计数值 &#x3D;&#x3D; 重装值时,产生一个中断信号,并清零计数器</strong></li></ul></li><li><strong>主模式输出: 可以将定时器的更新事件映射到触发控制器(TRGO),TRGO 接到 DAC 的触发转换引脚</strong></li></ul></li><li><p>通用定时器</p><p><img src="/2024/04/01/Embedded/STM32/5-universal-timer.png"></p><ul><li><strong>通用计时器的时基单元: 通用定时器包含基本定时器的电路.时基单元是相似的</strong></li><li>内外时钟选择:<code>TIMx_ETR</code>引脚接一个外部方波时钟.经过<code>极性选择,边沿检测,预分频器,输入滤波</code>后分为两路<ul><li>向上进入<code>触发控制器</code>,作为时基单元的时钟</li><li>向下进入<code>TRGI</code>,用作触发输入.触发定时器的从模式</li></ul></li><li><code>ITR</code> 信号: 来自其他定时器从 <code>TRGO</code> 的输出</li><li><code>TIIF_ED</code>: 连接到输入捕获单元的 CH1 引脚</li><li><code>TI1FP1, TI2FP2</code>: 连接到输入滤波器和边沿检测器的后面</li><li><strong>主模式输出: TRGO 可将内部的事件映射到 TRGO 引脚</strong></li></ul></li><li><p>高级定时器</p><p><img src="/2024/04/01/Embedded/STM32/5-advanced-timer.png"></p><ul><li>高级定时器包含了通用定时器的电路.额外增加了下列内容<ul><li>申请中断的后面加入一个 <code>REP</code> 重复次数计数器,可以每个几个计数周期才发生一次更新事件&#x2F;中断</li><li><code>DTG</code> 寄存器: 死区生成电路.右侧输出引脚变为了两个,可以输出一对互补的 PWM 波</li><li><code>TIMxBKIN</code>: 若 <code>TIMxBKIN</code> 引脚产生刹车信号或内部时钟失效,将由控制电路自动切断电机输出</li></ul></li></ul></li></ol><h3 id="5-2-时基单元"><a href="#5-2-时基单元" class="headerlink" title="5.2 时基单元"></a>5.2 时基单元</h3><ol><li><p>预分频时序图</p><p><img src="/2024/04/01/Embedded/STM32/5-count-timing-sequence-1-2.png"></p><ul><li><p><code>预分频缓冲器(影子寄存器)</code>: 实际上起作用的寄存器.预分频控制寄存器修改后,为保证此计数周期内频率一致.<br>该修改并不立即生效,在本次计数结束后才生效.<code>自动加载寄存器, 捕获 / 比较寄存器</code>同样有影子寄存器</p></li><li><p>计数器计数频率公式<br>$$<br>\mathrm{CK_CNT} &#x3D; \frac{\mathrm{CK_PSC}}{\mathrm{(PSC +1)}}<br>$$</p></li></ul></li><li><p>计数器时序图</p><p><img src="/2024/04/01/Embedded/STM32/5-count-timing-sequence.png"></p><ul><li><strong>计数器溢出频率公式</strong><br>$$<br>\mathrm{freq} &#x3D; \frac{\mathrm{CK_CNT}}{\mathrm{(ARR + 1)}}<br>&#x3D; \frac{\mathrm{CK_PSC}}{\mathrm{(PSC +1)(ARR + 1)}}<br>$$</li></ul></li></ol><h3 id="5-3-RCC-时钟树"><a href="#5-3-RCC-时钟树" class="headerlink" title="5.3 RCC 时钟树"></a>5.3 RCC 时钟树</h3><p><img src="/2024/04/01/Embedded/STM32/5-RCC-clock-tree.png"></p><ol><li>RCC 产生和配置时钟,然后发送给各个外设的系统<ul><li><strong>时钟是所有外设运行的基础,需要最先配置</strong></li><li>左侧为时钟产生电路,右侧为时钟分配电路.中间的 <code>SYSCLK</code> 为系统时钟(72MHz)</li></ul></li><li><strong>程序在 <code>main</code> 函数之前会执行 <code>SystemInit</code> 函数,以配置时钟树</strong><ul><li>首先尝试以 线路1 按照 8MHz 频率运行,稳定后切换为 线路2</li><li>CSS 可以检测时钟运行是否正常.若出错会切换到内部时钟</li></ul></li></ol><h3 id="5-4-定时中断"><a href="#5-4-定时中断" class="headerlink" title="5.4 定时中断"></a>5.4 定时中断</h3><ol><li><p>定时中断基本结构</p><p><img src="/2024/04/01/Embedded/STM32/5-timer-interrupt-struct.png"></p></li><li><p>基本定时中断配置步骤</p><ul><li>开启 RCC 的 TIM 外设时钟</li><li>时基单元的时钟源选择(选择内部时钟模式). 配置时基单元</li><li>配置中断输出控制,允许更新中断输出到 NVIC. 配置 NVIC,打开定时器的中断通道</li></ul></li></ol><h3 id="5-5-输出比较"><a href="#5-5-输出比较" class="headerlink" title="5.5 输出比较"></a>5.5 输出比较</h3><ol><li><p><strong>OC(Output Compare, 输出比较)</strong></p><ul><li><strong>通过比较 CNT 和 CCR 寄存器值(CNT 计数自增,CCR 手动给定).</strong><br><strong>然后对输出电平 置1 &#x2F; 置0 &#x2F; 翻转,实现输出一定频率和占空比的 PWM 波形</strong></li><li>每个高级寄存器(前3个通道拥有死区生成和互补输出功能)和通用寄存器均拥有4个输出比较通道</li><li>CCR 被输入捕获和输出比较共用<ul><li>使用输入捕获时,CCR 作为捕获寄存器</li><li>使用输出比较时,CCR 作为比较寄存器</li></ul></li></ul></li><li><p><strong>PWM(Pulse Width Modulation 脉冲宽度调制)</strong></p><ul><li>在惯性系统中,可以通过对一系列脉冲的宽度进行调制,来等效地获得所需要的模拟参量</li><li>参数: 频率: $freq &#x3D; \frac{1}{T_S}$, 占空比: $duty &#x3D; \frac{T_{ON}}{T_S}$, 分辨率: 占空比变化步距(1%即可)<br>其中 $T_S$ 为周期(高低电平变化一次的时间), $T_{ON}$ 为周期中高电平的维持时间</li></ul></li><li><p>捕获 &#x2F; 比较通道</p><p><img src="/2024/04/01/Embedded/STM32/5-capture-channel.png"></p></li><li><p>输出比较模式(输出模式控制器)</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>冻结</td><td>CNT&#x3D;CCR 时,REF 保持为原状态.即维持为暂停时刻的状态不变</td></tr><tr><td>匹配时置有效电平</td><td>CNT&#x3D;CCR 时,REF 置有效电平</td></tr><tr><td>匹配时置无效电平</td><td>CNT&#x3D;CCR 时,REF 置无效电平</td></tr><tr><td>匹配时电平翻转</td><td>CNT&#x3D;CCR 时,REF 电平翻转</td></tr><tr><td>强制为无效电平</td><td>CNT 与 CCR 无效,REF 强制为无效电平</td></tr><tr><td>强制为有效电平</td><td>CNT 与 CCR 无效.REF 强制为有效电平</td></tr><tr><td><strong>PWM 模式1</strong></td><td><strong>向上计数: CNT &lt; CCR 时,REF 置有效电平;CNT ≥ CCR 时,REF 置无效电平</strong> <br />向下计数: CNT &gt; CCR 时,REF 置无效电平;CNT ≤ CCR 时,REF 置有效电平</td></tr><tr><td><strong>PWM 模式2</strong></td><td><strong>向上计数: CNT &lt; CCR 时,REF 置无效电平,CNT ≥ CCR 时,REF 置有效电平</strong> <br />向下计数: CNT &gt; CCR 时,REF 置有效电平,CNT ≤ CCR 时,REF 置无效电平</td></tr></tbody></table></li><li><p>高级定时器输出比较(相较于通用定时器可以输出互补电平信号和产生死区)</p><p><img src="/2024/04/01/Embedded/STM32/5-advanced-timer-output.png"></p><ul><li>输出 <code>OC1,OC1N</code> 分别接到外部推挽电路的控制极,2个推挽电路构成 H桥,3个推挽电路即可驱动三相无刷电机</li><li><code>死区生成器</code>: 在 MOS 管关闭时,进行一段延时,然后是另一个 MOS 管导通.防止因器件原因造成正负极短路</li></ul></li><li><p>PWM 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/5-PWM-struct.png"></p><ul><li>图示中蓝线为 CNT(不断自增); 红线为 CCR(手动设置); 黄线为 ARR(手动设置).PWM 模式1</li><li>输出 PWM 波形不需要进行中断申请</li></ul></li><li><p><strong>PWM 参数计算</strong></p><ul><li><p>已知 $\mathrm{CK_PSC}$, PSC, ARR, CCR.计算频率, 占空比, 分辨率</p><ul><li><p>频率:     $\mathrm{freq} &#x3D; \frac{\mathrm{CK_PSC}}{\mathrm{(PSC + 1)}\mathrm{(ARR + 1)}}$</p></li><li><p>占空比: $\mathrm{Duty} &#x3D; \frac{\mathrm{CCR}}{\mathrm{(ARR + 1)}}$</p></li><li><p>分辨率: $\mathrm{Reso} &#x3D; \frac{1}{(\mathrm{ARR} + 1)}$</p></li></ul></li><li><p>已知 时钟频率, PWM 频率, 占空比, 分辨率时.计算 PSC, ARR, CCR</p><ul><li>$\mathrm{ARR+1} &#x3D; \frac{1}{\mathrm{Reso}}$</li><li>$\mathrm{CCR} &#x3D; \frac{\mathrm{Duty}}{\mathrm{Reso}}$ </li><li>$\mathrm{PSC + 1} &#x3D; \frac{\mathrm{Reso\cdot CK_{PSC}}}{\mathrm{freq}}$</li></ul></li><li><p><strong>确定 PSC, ARR, CCR 的方式</strong></p><ul><li>首先根据分辨率决定 ARR.如要求分辨率为 1% 时, (ARR + 1) &#x3D; 100.此后固定 ARR 的值,方便计算</li><li>此时 CRR 值即为占空比的百分数.如 CCR &#x3D; 50 时,占空比 duty &#x3D; 50%.代码中改变 CRR,即可调节占空比</li><li>最后确定 PSC 的值.代码中改变 PSC,即可调节频率</li></ul></li></ul></li></ol><h3 id="5-6-输入捕获"><a href="#5-6-输入捕获" class="headerlink" title="5.6 输入捕获"></a>5.6 输入捕获</h3><ol><li><p><strong>IC(Input Capture 输入捕获)</strong></p><ul><li>输入捕获模式下<ul><li>当通道输入引脚出现指定电平跳变时,当前 CNT 的值将被锁存到 CCR 中</li><li>可用于测量 PWM 波形的频率, 占空比, 脉冲间隔, 电平持续时间等参数</li></ul></li><li>每个高级定时器和通用定时器都拥有4个输入捕获通道<ul><li>可配置为 PWMI 模式,同时测量频率和占空比</li><li>可配合主从触发模式,实现硬件全自动测量</li></ul></li></ul></li><li><p><strong>频率测量方法</strong></p><ul><li><strong>测频法</strong>: 在闸门时间 T 内对上升沿计次 N,则频率 $f_x &#x3D; \frac{N}{T}$</li><li><strong>测周法</strong>: 两个上升沿内以标准频率 $f_c$ 计次 N,则频率 $f_x &#x3D; \frac{f_c}{N}$</li><li><strong>中界频率</strong>: 测频法与测周法误差相等的频率 $f_m &#x3D; \sqrt{\frac{f_c}{T}}$</li></ul></li><li><p>捕获比较通道框图</p><p><img src="/2024/04/01/Embedded/STM32/5-capture-channel-block.png"></p></li><li><p>主从触发模式</p><p><img src="/2024/04/01/Embedded/STM32/5-%E4%B8%BB%E4%BB%8E%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F.png"></p><ul><li><strong>主模式: 可将定时器内部的信号映射到 TRGO 引脚,触发其他外设</strong></li><li><strong>从模式: 接收其他外设或使用自身外设的信号.用以控制自身控制器的运行</strong></li><li>触发源选择: 指定 从模式的触发信号 得到 TRGI,然后触发选定的从模式</li></ul></li><li><p>输入捕获基本结构</p><p><img src="/2024/04/01/Embedded/STM32/5-capture-struct.png"></p><ul><li>从GPIO口输入方波信号,经过<code>滤波器, 边沿检测, 极性选择</code>得到 <code>TI1FP1</code>,最后连接到 <code>CCR1</code></li><li>当<code>TI1FP1</code>出现上升沿,不断自增的 <code>CNT</code> 转运到 <code>CCR1</code> 中</li><li>同时,触发源选择为 <code>TI1FP1</code>,从模式配置为 <code>Reset</code>.当 <code>TI1FP1</code> 出现上升沿,<code>CNT</code> 自动清零,再次自增</li></ul></li><li><p>PWMI 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/5-PWMI-struct.png"></p><ul><li>PWMI 与 输入捕获的区别在于使用2个通道捕获同一 GPIO,可以同时测量周期和占空比</li><li>当上升沿来临,<code>TI1FP1</code> 触发,<code>CCR1</code> 捕获,清零 <code>CNT</code></li><li><code>TI1FP2</code>配置为下降沿触发.当下降沿来临,<code>TI1FP2</code> 触发,<code>CCR2</code> 捕获,不清零 <code>CNT</code></li><li>因而 <code>CCR2</code> 的值反映高电平维持时间,<code>CCR1</code> 的值反映周期的时间.占空比为 $\frac{CCR2}{CCR1}$</li></ul></li></ol><h3 id="5-7-编码器"><a href="#5-7-编码器" class="headerlink" title="5.7 编码器"></a>5.7 编码器</h3><ol><li><p>编码器接口(Encoder Interface)</p><ul><li>编码器接口可接收增量(正交)编码器的信号<ul><li>根据编码器旋转产生的正交信号脉冲</li><li>自动控制 CNT 自增或自减,从而指示 编码器的位置, 旋转方向, 旋转速度</li></ul></li><li>每个高级定时器和通用定时器都拥有1个编码器接口</li><li>编码器接口的两个输入引脚借用了输入捕获的通道1和通道2</li></ul></li><li><p>正交编码器</p><p><img src="/2024/04/01/Embedded/STM32/5-encoder.png"></p><ul><li>由于正转和反转输出的波形一致,故仅凭一项输出信号无法判断旋转方向.因此需要 A, B相</li><li>A相与B相 相位差90°.每当出现边沿变化时,判断另一相的状态,对照右侧表格,即可确定旋转方向</li></ul></li><li><p>编码器接口基本结构</p><p><img src="/2024/04/01/Embedded/STM32/5-encoder-struct.png"></p><ul><li><p>当编码器正转时,CNT++; 反转时,CNT–.结合固定的闸门时间,即可完成测速任务</p></li><li><p><code>TI1FP1, TI2FP2</code>来自 GPIO 端口输入.<strong>类似于一个外部时钟源,配置为编码器模式</strong></p><ul><li>因此此时 PSC 建议设为 0,不进行分频.ARR 设为 65535,最大</li></ul></li><li><p>配置 GPIO 为输入模式 -&gt; 配置时基单元 -&gt; 配置输入捕获单元 -&gt; 配置编码器接口(下行代码)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 编码器接口配置.并设置为: 定时器3, 选择编码器模式, TI1, TI2都计数, 不反相</span><br><span class="hljs-comment">** 注意此时参数的 Rising 和 Falling 不再代表上升沿和下降沿了,而是代表是否反相</span><br><span class="hljs-comment">** 此函数必须在输入捕获初始化之后进行,否则输入捕获的配置会覆盖此函数的部分配置 */</span><br>TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12,<br>                           TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="6-ADC"><a href="#6-ADC" class="headerlink" title="6 ADC"></a>6 ADC</h2><h3 id="6-1-ADC-功能"><a href="#6-1-ADC-功能" class="headerlink" title="6.1  ADC  功能"></a>6.1  ADC  功能</h3><ol><li><p><strong>ADC(Analog-Digital Converter, 模拟-数字转换器)</strong></p><ul><li>作用: 可将引脚上连续变化的模拟电压 转换为内存中存储的数字变量</li><li>18个输入通道: 可测量16个外部(GPIO)和2个内部信号源(温度传感器,内部参考电压)<ul><li>输入电压范围: 0 ~ 3.3V</li><li>分辨率为 12位: 即表示范围 $0 \sim 2^{12}-1$</li><li>1$\mu$s 转换时间: 即开始转换到产生结果耗时.对应频率为 1MHz</li></ul></li><li>STM32 增强功能: 规则组和注入组两个转换单元</li></ul></li><li><p>逐次逼近型 ADC 结构(<code>ADC0809</code> 内部结构图, 8位逐次逼近型)</p><p><img src="/2024/04/01/Embedded/STM32/6-approx-ADC.png"></p></li><li><p>ADC 框图</p><p><img src="/2024/04/01/Embedded/STM32/6-ADC-block.png"></p></li><li><p>ADC 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/6-ADC-struct.png"></p><ul><li>配置 GPIO 为模拟输入模式 -&gt; 配置数据选择器 -&gt; 配置 ADC 转换器 -&gt; 开启 ADC</li></ul></li></ol><h3 id="6-2-ADC-模式"><a href="#6-2-ADC-模式" class="headerlink" title="6.2 ADC 模式"></a>6.2 ADC 模式</h3><ol><li><p><strong>规则组的转换模式</strong></p><ul><li>单次转换: 在一次转换结束后,转换结果存放在数据寄存器中,置 EOC 标志位,结束转换</li><li>连续转换: 在一次转换结束后,置 EOC 标志位,立即开始下一轮的转换</li><li>非扫描模式: 规则组的序列只有一个通道有效.即只处理一个通道的信号</li><li>扫描模式: 规则组的序列有效,一次转换多个通道的信号</li></ul></li><li><p>ADC 转换触发控制</p><p><img src="/2024/04/01/Embedded/STM32/6-ADC-external-trigger.png"></p></li><li><p>数据对齐: 对于一个 12bit ADC,其转换结果为 12bit.而数据寄存器为16bit,需进行数据对齐</p><ul><li><strong>右对齐: 有效数据右对齐,左边补0</strong></li><li>左对齐: 有效数据左对齐,右边补0</li></ul></li><li><p>转换时间(采样, 保持, 量化, 编码)</p><ul><li>ADC 的总转换时间: <code>T = 采样时间 + 12.5 * ADC 周期</code></li><li>采样时间可在程序中配置.量化编码因是12位 ADC,需要 12.5 个周期</li><li>例: 采样时间配置为1.5, ADC 频率为14MHz,则总转换时间为14个 ADC 周期,即 1us</li></ul></li></ol><h2 id="7-DMA"><a href="#7-DMA" class="headerlink" title="7 DMA"></a>7 DMA</h2><h3 id="7-1-DMA-功能"><a href="#7-1-DMA-功能" class="headerlink" title="7.1 DMA 功能"></a>7.1 DMA 功能</h3><ol><li><p><strong>DMA(Direct Memory Access, 直接存储器存取)</strong></p><ul><li>DMA 可以提供外设和存储器或者存储器和存储器之间的高速数据传输</li><li>本质上是从某个地址取出数据,转运到另一地址</li><li>作用: DMA 数据传输无须 CPU 干预,节省 CPU 的资源</li><li>12个独立可配置的通道: DMA1(7个通道), DMA2(5个通道)</li><li>每个通道都支持软件触发和特定的硬件触发</li></ul></li><li><p><strong>存储器映像</strong></p><table><thead><tr><th>类型</th><th>起始地址</th><th>存储器</th><th>用途</th></tr></thead><tbody><tr><td>ROM</td><td>0x0800 0000</td><td>程序存储器 Flash</td><td>存储编译后的 C 语言程序代码</td></tr><tr><td></td><td>0x1FFF F000</td><td>系统存储器</td><td>存储 BootLoader,用于串口下载</td></tr><tr><td></td><td>0x1FFF F800</td><td>选项字节</td><td>存储一些独立于程序代码的配置参数</td></tr><tr><td>RAM</td><td>0x2000 0000</td><td>运行内存 SRAM</td><td>存储运行过程中的临时变量</td></tr><tr><td></td><td>0x4000 0000</td><td>外设寄存器</td><td>存储各个外设的配置参数</td></tr><tr><td></td><td>0xE000 0000</td><td>内核外设寄存器</td><td>存储内核各个外设的配置参数</td></tr></tbody></table></li><li><p>DMA 框图</p><p><img src="/2024/04/01/Embedded/STM32/7-DMA-block.png"></p><ul><li>DMA 通过 <code>DMA 总线</code>主动访问各种存储器.DMA 总线是被分时复用的<ul><li><code>仲裁器</code>根据通道的优先级处理 DMA 通道的冲突</li><li><code>总线矩阵</code>也有仲裁器,当 CPU 和 DMA 访问同一目标时.保障 CPU 正常工作</li></ul></li><li>DMA 作为外设,也有寄存器.连接在 <code>AHB 总线</code>上,因此 CPU 可以访问,配置 DMA<ul><li>硬件可通过 DMA 请求线路向 DMA 发出硬件触发信号</li></ul></li></ul></li></ol><h3 id="7-2-DMA-转运"><a href="#7-2-DMA-转运" class="headerlink" title="7.2 DMA 转运"></a>7.2 DMA 转运</h3><ol><li><p><strong>DMA 基本结构</strong></p><p><img src="/2024/04/01/Embedded/STM32/7-DMA-struct.png"></p><ul><li>DMA 数据转运<ul><li>条件: DMA 使能, <code>传输计数器</code> &gt; 0, 触发源有触发信号</li><li>方向: 外设 -&gt; 存储器, 存储器 -&gt; 外设, Flash -&gt; SRAM</li><li>参数: 源端和目标的 <code>起始地址, 数据宽度, 地址是否自增</code></li></ul></li><li><strong>传输计数器</strong>: 在完成一次转运后会进行自减,当其值为0时结束转运,起始地址参数复位<ul><li><code>自动重装器</code>: 可以在传输计数器自减到0后,恢复传输计数器的值,再次自减.使得可以循环转运</li><li>DMA 转运完成后,必须先关闭 DMA,然后再次开启,才能给 <code>传输计数器</code> 写值</li></ul></li><li>触发方式: 由 <code>M2M</code> 控制<ul><li>软件触发: DMA 不断运行,直到 <code>传输计数器</code> 清零.此时不应开启 <code>自动重装器</code>,一般用于存储器间数据转运</li><li>硬件触发: 达到某种条件(如 ADC 转换完成,串口接收到数据,达到定时时间),触发 DMA 运行</li></ul></li></ul></li><li><p>DMA1 请求映像 </p><p><img src="/2024/04/01/Embedded/STM32/7-DMA1-request-map.png"></p><ul><li><strong>每个通道的硬件触发源不同.而软件触发都一样.需要根据触发选择 ADC 通道</strong></li><li>对于外设请求信号的选择: 由外设的 DMA 控制决定,开启就可以发出请求信号</li><li>外设请求信号经过 或门到硬件请求.一般只开启一个外设请求</li></ul></li><li><p>DMA 传输数据宽度</p><ul><li>源端宽度 &#x3D; 目标宽度: 正常传输</li><li>源端宽度 &gt; 目标宽度: 高位舍弃</li><li>源端宽度 &lt; 目标宽度: 高位补0</li></ul></li></ol><h2 id="8-USART-串口"><a href="#8-USART-串口" class="headerlink" title="8 USART 串口"></a>8 USART 串口</h2><h3 id="8-1-通信接口"><a href="#8-1-通信接口" class="headerlink" title="8.1 通信接口"></a>8.1 通信接口</h3><ol><li><p><strong>通信协议</strong></p><table><thead><tr><th>名称</th><th>引脚</th><th>双工</th><th>时钟</th><th>电平</th><th>设备</th></tr></thead><tbody><tr><td>USART</td><td>TX, RX</td><td>全双工</td><td>异步</td><td>单端</td><td>点对点</td></tr><tr><td>I2C</td><td>SCL, SDA</td><td>半双工</td><td>同步</td><td>单端</td><td>多设备</td></tr><tr><td>SPI</td><td>SCLK, MOSI, MISO, CS</td><td>全双工</td><td>同步</td><td>单端</td><td>多设备</td></tr><tr><td>CAN</td><td>CAN_H, CAN_L</td><td>半双工</td><td>异步</td><td>差分</td><td>多设备</td></tr><tr><td>USB</td><td>DP, DM</td><td>半双工</td><td>异步</td><td>差分</td><td>点对点</td></tr></tbody></table><ul><li>全双工: 通信双方能够同时进行双向通信.一般需要2根通信线</li><li>半双工: 通信双方无法同时输入 &#x2F; 输出数据</li><li>单工: 数据传输方向为单向</li><li>时钟: 确定数据的采集时机</li></ul></li><li><p>电平标准: 数据1&#x2F;0的表达方式(当电平信号不一致时,需要加入电平转换芯片)</p><table><thead><tr><th>电平标准</th><th>data: 1</th><th>data: 0</th></tr></thead><tbody><tr><td><strong>TTL</strong></td><td><strong>+3.3V 或 +5V</strong></td><td><strong>0V</strong></td></tr><tr><td>RS232 电平</td><td>-3 ~ -15V</td><td>+3 ~ +15</td></tr><tr><td>RS485 电平(差分信号)</td><td>+2 ~ +6V</td><td>-2 ~ -6V</td></tr></tbody></table></li><li><p>串口时序</p><p><img src="/2024/04/01/Embedded/STM32/8-uart-timing-sequence.png"></p></li><li><p>串口参数</p><ul><li><strong>波特率: 串口通信的速率.每秒传输码元的个数</strong></li><li>比特率: 每秒传输的比特数(bit&#x2F;s).二进制情况下,码元即是 bit,波特率等于比特率</li><li>起始位: 标志一个数据帧的开始,固定为低电平(空闲时为高电平)</li><li><strong>数据位: 数据帧的有效载荷.1为高电平,0为低电平.低位先行</strong></li><li>校验位: 用于数据验证(如奇校验表示连同校验位共有奇数个1,还有 CRC 校验)</li><li>停止位: 用于数据帧间隔.固定为高电平</li></ul></li></ol><h3 id="8-2-USART-外设"><a href="#8-2-USART-外设" class="headerlink" title="8.2 USART 外设"></a>8.2 USART 外设</h3><ol><li><p><strong>USART(Universal Synchronous&#x2F;Asynchronous Receiver&#x2F;Transmitter, 通用同步&#x2F;异步收发器)</strong></p><ul><li>STM32 内部集成 USART 外设<ul><li>可根据数据寄存器的一个字节数据自动生成数据帧时序.由 TX 引脚发送</li><li>可自动接收 RX 引脚的数据帧时序,拼接为一个字节数据,存放于数据寄存器</li><li>自带波特率发生器.最高达4.5Mbits&#x2F;s(本质是一个预分频器)</li></ul></li><li>可配置参数<ul><li>数据位长度(<strong>8</strong> &#x2F; 9). 停止位长度(0.5 &#x2F; <strong>1</strong> &#x2F; 1.5 &#x2F; 2)</li><li>校验位: <strong>无校验,</strong> 奇校验, 偶校验</li><li>支持同步模式, 硬件流控制, DMA, 智能卡, IrDA, LIN</li></ul></li><li>stm32f103 的 usart1 的引脚: tx - PA9, rx - PA10</li></ul></li><li><p>USART 框图</p><p><img src="/2024/04/01/Embedded/STM32/8-USART-block.png"></p><ul><li><code>TX</code> 引脚连接 <code>发送移位寄存器</code>,在<code>发送器控制</code>的控制下,将数据按位移出<ul><li>当 <code>TDR</code>(只写) 被写入数据时,先检查<code>移位寄存器</code>是否有数据正在移位</li><li>若无,则数据发送到<code>移位寄存器</code>,同时,置 <code>TXE 标志位</code>,可以再次向 <code>TDR</code> 写入数据</li><li>若有,则等待移位完成后,立即转移数据</li></ul></li><li><code>RX</code> 连接通向 <code>接收移位寄存器</code>,在<code>接收器控制</code>的控制下,将数据按位移出<ul><li><code>接收移位寄存器</code>按位读取 <code>RX</code> 引脚的信号</li><li>读取满1byte 后,将数据转移到 <code>RDR</code>.同时,置 <code>RXNE 标志位</code>.此时可从 <code>RDR</code>(只读)读出数据</li></ul></li></ul></li><li><p>USART 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/8-USART-struct.png"></p><ul><li>APB的时钟信号到达波特率发生器进行分频</li><li>发送器 &#x2F; 接收器的波特率 &#x3D; $\mathrm{\frac{f_{PCLK}} { {16} \cdot {DIV} } }$. 由 <code>波特率寄存器 BRR</code> 中的 <code>DIV</code> 决定</li></ul></li></ol><h3 id="8-3-重定向-printf"><a href="#8-3-重定向-printf" class="headerlink" title="8.3 重定向 printf"></a>8.3 重定向 <code>printf</code></h3><ol><li><p>格式化打印: 对 <code>printf</code>函数的重定向</p></li><li><p>打开工程文件中的 <code>Options for target</code>,勾选 <code>Use MicroLIB</code>(Keil 为嵌入式平台准备的精简库)</p><p><img src="/2024/04/01/Embedded/STM32/8-UseMicroLib.png"></p></li><li><p><strong>由于<code>printf</code>函数底层调用<code>fput</code>函数不断打印,因此可以将 <code>printf</code> 函数重定向为向串口发送数据</strong></p></li><li><p>方法1: 重写的<code>fputc</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span> &#123;<br>serial_send_byte(ch);  <span class="hljs-comment">// 这是一个串口传输数据的函数,需要自行实现</span><br><span class="hljs-keyword">return</span> ch;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方法2: 对 <code>sprintf</code> 的封装(<code>sprintf</code> 函数: 将内容打印打印到字符串中)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">serial_printf</span><span class="hljs-params">(<span class="hljs-type">char</span> *format, ...)</span> &#123;<br><span class="hljs-type">char</span> <span class="hljs-built_in">string</span>[<span class="hljs-number">100</span>];               <span class="hljs-comment">// 定义字符数组</span><br>va_list arg;                    <span class="hljs-comment">// 定义可变参数列表数据类型的变量 arg</span><br>va_start(arg, format);          <span class="hljs-comment">// 从 format 开始,接收参数列表到 arg 变量</span><br><span class="hljs-built_in">vsprintf</span>(<span class="hljs-built_in">string</span>, format, arg);  <span class="hljs-comment">// 使用 vsprintf 打印格式化字符串和参数列表到字符数组中</span><br>va_end(arg);                    <span class="hljs-comment">// 结束变量 arg</span><br>serial_send_string(<span class="hljs-built_in">string</span>);     <span class="hljs-comment">// 串口发送字符数组的函数,需要自行实现</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="8-4-HAL-库"><a href="#8-4-HAL-库" class="headerlink" title="8.4 HAL 库"></a>8.4 HAL 库</h3><ol><li>配置 UART1</li></ol><p>   <img src="/2024/04/01/Embedded/STM32/8-USART-HAL.png"></p><ol start="2"><li><p>在 <code>stm32f1xx_hal_uart.h</code> 中有很多中断回调函数,以及功能实现函数</p><ul><li><p>收发函数(还有中断和 dma 版本)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_StatusTypeDef <span class="hljs-title function_">HAL_UART_Transmit</span><span class="hljs-params">(UART_HandleTypeDef *huart, </span><br><span class="hljs-params">                                    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *pData, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_UART_Receive</span><span class="hljs-params">(UART_HandleTypeDef *huart, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint8_t</span> *pData, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint32_t</span> Timeout)</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="9-I2C-通信"><a href="#9-I2C-通信" class="headerlink" title="9 I2C 通信"></a>9 I2C 通信</h2><h3 id="9-1-I2C-协议"><a href="#9-1-I2C-协议" class="headerlink" title="9.1 I2C 协议"></a>9.1 I2C 协议</h3><ol><li><p><strong>I2C(Inter IC BUS).由 Philips 公司开发的一种通用数据总线</strong></p><ul><li><strong>通信线: SCL(Serial Clock), SDA(Serial Data)</strong></li><li>属于同步通信,半双工通信.可以数据应答,支持总线挂载多设备</li><li>I2C 外设出厂会有一个地址(7位或10位)</li></ul></li><li><p>硬件电路</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-bus.png"></p><ul><li>SDA 和 SCL 的控制<ul><li>主机拥有对 SCL 线的完全控制权.也可控制空闲状态下的 SDA 线</li><li>从机只能读取 SCL 线,也不允许主动控制 SDA 线</li><li>仅在应答或主机要读取从机时才能获取 SDA 的控制权</li></ul></li><li>接线方式<ul><li>所有 I2C 设备的 SCL 连在一起,SDA 连在一起.均默认为高电平</li><li><strong>设备的 SCL 和 SDA 均要配置成开漏输出模式,禁止输出高电平</strong></li><li>SCL 和 SDA 各添加一个上拉电阻,阻值一般为4.7KΩ</li></ul></li></ul></li><li><p><strong>I2C 时序基本单元</strong></p><ul><li><p><strong>起始与终止</strong>: 始终由主机控制,从机无权发送该指令</p><ul><li><p>起始条件: 主机拉低 SDA 电平(下降沿,此时从机复位).然后拉低 SCL,占用 SCL</p></li><li><p>终止条件: 主机先放开 SCL,然后放开 SDA (上升沿).回到初始态</p></li><li><p><strong>除了起始和终止条件,每个时序单元的 SCL 以低电平开始,也以低电平结束</strong></p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-start-end.png"></p></li></ul></li><li><p><strong>发送数据</strong></p><ul><li><p>起始状态后.SCL,SDA均为低电平.主机将数据置于 SDA 线(高位先行)</p></li><li><p>然后释放 SCL.从机在 SCL 高电平期间读取数据位,需要尽快读取,最好在上升沿时就立即读取</p></li><li><p>当 SCL 高电平时, SDA 不应发生变化,维持一段时间后,主机再次拉低 SCL.完成一位数据的传输</p></li><li><p>循环上述过程8次,即可传输一个字节的数据</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-send-byte.png"></p></li></ul></li><li><p><strong>接收数据</strong></p><ul><li><p>主机需要先释放 SDA.在 SCL 低电平期间,从机将数据置于 SDA 线(高位先行)</p></li><li><p>然后主机释放 SCL.由主机读取数据位</p></li><li><p><strong>SDA 总是在 SCL 低电平(下降沿)时被放置数据,在 SCL 高点平(上升沿)时被读取</strong></p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-receive-byte.png"></p></li></ul></li><li><p><strong>主机发送应答</strong>: 主机接收完一个字节后,在下一个时钟发送一位数据.<strong>0为应答,1为非应答</strong></p></li><li><p><strong>接收从机应答</strong>: 主机发送完一个字节后,在下一个时钟接收一位数据.<strong>0为应答,1为非应答</strong></p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-ack.png"></p></li></ul></li><li><p>指定地址写: 给指定设备(slave addr)的指定地址(reg addr)写入指定数据(data)</p><ul><li><p>起始条件 -&gt; 发送 1byte(前 7bit 为 slave addr, 后 1bit 表示读(1) &#x2F; <strong>写(0)</strong> ) -&gt; 从机应答0 -&gt; </p></li><li><p>发送 1byte 数据(reg addr) -&gt; 从机应答0 -&gt; </p></li><li><p>发送 1byte 数据(data) -&gt; 从机应答0 -&gt; 终止条件</p></li><li><p>后续字节: 传输真正的数据(寄存器的地址将会自增).当完成传输时,主机需要产生一个终止条件</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-write-reg.png"></p></li></ul></li><li><p>当前地址读: 对于指定设备(slave addr),读取从机当前地址指针的数据(data)</p><ul><li><p>起始条件 -&gt; 发送 1byte(前 7bit 为 slave addr, 后 1bit 表示<strong>读(1)</strong> &#x2F; 写(0) ) -&gt; 从机应答0 -&gt;</p></li><li><p>接收 1byte data(此时从机在 scl 低电平写入 sda,主机在 scl 高电平读取 sda) -&gt; 主机应答1 -&gt; 终止条件</p></li><li><p>当主机不想再接收数据时,需要在发送应答时给出非应答,此时从机将不再发送数据</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-read-reg.png"></p></li></ul></li><li><p>指定地址读: 给指定设备(slave addr)的指定地址(reg addr)读取数据(data)</p><ul><li><p>起始条件 -&gt; 发送 1byte(前 7bit 为 slave addr, 后 1bit 表示读(1) &#x2F; <strong>写(0)</strong> ) -&gt; 从机应答0 -&gt; </p></li><li><p>发送 1byte 数据(reg addr) -&gt; 从机应答0 -&gt; </p></li><li><p>重复起始条件 -&gt; 发送 1byte(前 7bit 为 slave addr, 后 1bit 表示<strong>读(1)</strong> &#x2F; 写(0) ) -&gt; 从机应答0 -&gt;</p></li><li><p>接收 1byte data(此时从机在 scl 低电平写入 sda,主机在 scl 高电平读取 sda) -&gt; 主机应答1 -&gt; 终止条件  </p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-set-addr-read-reg.png"></p></li></ul></li></ol><h3 id="9-2-I2C-外设"><a href="#9-2-I2C-外设" class="headerlink" title="9.2 I2C 外设"></a>9.2 I2C 外设</h3><ol><li><p>STM32 内部集成了硬件 I2C 收发电路</p><ul><li>可以由硬件自动执行时钟生成,起始终止条件生成,应答位收发,数据收发等功能.减轻CPU的负担</li><li>支持 7bit &#x2F; 10bit 地址模式(若第一字节的前5位为11110,则表示10位地址)</li><li>支持不同的通讯速度,标准速度(高达100 kHz), 快速(高达400 kHz)</li><li>支持 DMA, 多主机模型, 兼容 SMBus(System Management Bus)协议</li></ul></li><li><p>I2C 基本结构图</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-struct.png"></p></li><li><p>硬件 I2C 波形</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-hardware-wave.png"></p></li></ol><h3 id="9-3-HAL-库"><a href="#9-3-HAL-库" class="headerlink" title="9.3 HAL 库"></a>9.3 HAL 库</h3><ol><li><p>I2C2 配置</p><p><img src="/2024/04/01/Embedded/STM32/9-I2C-hal.png"></p></li><li><p>在 <code>stm32f1xx_hal_i2c.h</code> 中有很多中断回调函数,以及功能实现函数</p><ul><li><p>收发函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Write</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> DevAddress,  <span class="hljs-comment">// 注意是 7bit地址 &lt;&lt; 1</span></span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> MemAddress,</span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> MemAddSize, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint8_t</span> *pData, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                    <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Read</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> DevAddress, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> MemAddress, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> MemAddSize, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint8_t</span> *pData, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                   <span class="hljs-type">uint32_t</span> Timeout)</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="10-SPI-通信"><a href="#10-SPI-通信" class="headerlink" title="10 SPI 通信"></a>10 SPI 通信</h2><h3 id="10-1-SPI-协议"><a href="#10-1-SPI-协议" class="headerlink" title="10.1 SPI 协议"></a>10.1 SPI 协议</h3><ol><li><p><strong>SPI(Serial Peripheral Interface): 由Motorola公司开发的一种通用数据总线</strong></p><ul><li>通信线: SCK(Serial Clock), SS(Slave Select),<br>MOSI(Master Output Slave Input), MISO(Master Input Slave Output)</li><li>同步, 全双工.支持总线挂载多设备(一主多从)</li></ul></li><li><p>硬件电路</p><p><img src="/2024/04/01/Embedded/STM32/10-SPI-bus.jpg"></p><ul><li>所有 SPI 设备的 SCK, MOSI, MISO 分别连在一起<ul><li><strong>SCK: 时钟线</strong>.完全由主机掌控.由主机进行输出,从机得到输入</li><li><strong>MOSI: 主机输出从机输入</strong>.在主机上,表现为数据输出.在从机上,表现为数据输入</li><li><strong>MISO: 主机输入从机输出</strong>.在主机上,表现为数据输入.在从机上,表现为数据输出</li></ul></li><li><strong>主机另外引出多条 SS 控制线,分别接到各从机的 SS 引脚</strong><ul><li>当从机的 SS 高电平时,MISO 必须为高阻态,不允许从机输出,防止 MISO 数据冲突</li><li>SS 低电平有效,且只能同时选中一个从机.如需指定从机输入输出数据.则将对应的 SS 拉至低电平</li><li>输出的引脚需配置为推挽输出,保证高低电平均有强驱动能力.输入的引脚需配置为浮空或上拉输入</li></ul></li></ul></li><li><p>SPI 数据交换</p><p><img src="/2024/04/01/Embedded/STM32/10-SPI-swap-byte.png"></p><ul><li><code>波特率发生器</code>时钟上升沿时,所有移位寄存器向左移位,置于引脚</li><li><code>波特率发生器</code>时钟下降沿时,对引脚电平采样,置于移位寄存器的最低位</li><li>主机与从机的数据交换<ul><li>在一个周期内,从机由高位移出的数据传输到主机的低位,主机由高位移出的数据传输到从机的低位</li><li>循环8次后,从机的数据完整到达主机,主机的数据也完整达到从机,完成一次数据交换</li></ul></li><li>如果仅需主机发送数据,仍然需要执行数据交换,忽略接收到的数据即可</li><li>如果仅需接收从机数据,仍然需要执行数据交换,此时主机可使用任意数据交换(一般0x00或0xFF)</li></ul></li><li><p>SPI 基本时序</p><ul><li><p>起始条件: SS 从高电平切换到低电平</p></li><li><p>终止条件: SS 从低电平切换到高电平</p></li><li><p>可选择 上升&#x2F;下降沿 移位.可配置时钟相位提前半个时钟</p><ul><li><code>CPOL(Clock Polarity)</code><ul><li>CPOL&#x3D;0: SCK 空闲时为低电平</li><li>CPOL&#x3D;1: SCK 空闲时为高电平</li></ul></li><li><code>CPHA(Clock phase)</code><ul><li>CPHA&#x3D;0: SCK 奇数边沿时移入数据.偶数边沿移出数据(提前)</li><li>CPHA&#x3D;1: SCK 奇数边沿时移出数据.偶数边沿移入数据(正常)</li></ul></li></ul></li><li><p><strong>模式0 使用最多(CPOL&#x3D;0,CPHA&#x3D;0): 空闲时,SCK为低电平,上升沿采集数据</strong></p><p><img src="/2024/04/01/Embedded/STM32/10-SPI-mode0.jpg"></p></li></ul></li><li><p>SPI 通常使用指令码和读写数据的方式操作从机: 从机选择 -&gt; 发送指令 -&gt; 发送数据<br>向指定设备发送指令 0x02,然后写入数据</p><p><img src="/2024/04/01/Embedded/STM32/10-SPI-timing-sequence.jpg"></p></li></ol><h3 id="10-2-SPI-外设"><a href="#10-2-SPI-外设" class="headerlink" title="10.2 SPI 外设"></a>10.2 SPI 外设</h3><ol><li><p>STM32 内部集成了硬件 SPI 收发电路</p><ul><li>可配置 8 &#x2F; 16位数据帧, 高 &#x2F; 低位先行</li><li>时钟频率: PCLK &#x2F; (2, 4, 8, 16, 32, 64, 128, 256)</li><li>支持多主机模型(主&#x2F;从操作), 可精简为半双工&#x2F;单工通信, 支持 DMA, 兼容 I2S 协议</li></ul></li><li><p>SPI 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/10-SPI-struct.png"></p></li></ol><h3 id="10-3-HAL-库"><a href="#10-3-HAL-库" class="headerlink" title="10.3 HAL 库"></a>10.3 HAL 库</h3><ol><li><p>SPI1 配置</p><p><img src="/2024/04/01/Embedded/STM32/10-SPI-hal.png"></p></li><li><p>spi 基础函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_StatusTypeDef <span class="hljs-title function_">HAL_SPI_TransmitReceive</span><span class="hljs-params">(SPI_HandleTypeDef *hspi, </span><br><span class="hljs-params">                                          <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *pTxData, </span><br><span class="hljs-params">                                          <span class="hljs-type">uint8_t</span> *pRxData,</span><br><span class="hljs-params">                                          <span class="hljs-type">uint16_t</span> Size, </span><br><span class="hljs-params">                                          <span class="hljs-type">uint32_t</span> Timeout)</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="11-RTC-实时时钟"><a href="#11-RTC-实时时钟" class="headerlink" title="11 RTC 实时时钟"></a>11 RTC 实时时钟</h2><h3 id="11-1-Unix-时间戳"><a href="#11-1-Unix-时间戳" class="headerlink" title="11.1 Unix 时间戳"></a>11.1 Unix 时间戳</h3><ol><li><p><strong>Unix 时间戳(Timestamp): 从 UTC &#x2F; GMT 的 <code>1970年1月1日00:00:00</code> 开始经过的秒数</strong></p><ul><li>秒计数器为 32 &#x2F; 64bit 的整型变量</li><li>各时区的秒计数器相同,但不同时区通过偏移得到当地时间</li></ul></li><li><p>GMT(Greenwich Mean Time): 格林尼治标准时间,将地球自转一周的时间等分为24小时</p></li><li><p>UTC(Universal Time Coordinated): 协调世界时,以原子钟为基础的时间计量系统</p></li><li><p>时间戳与时间的转换: C语言的 <code>&lt;time.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> tm* <span class="hljs-title function_">gmtime</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">time_t</span>*)</span>;     <span class="hljs-comment">// 秒计数器转换为日期时间</span><br><span class="hljs-keyword">struct</span> tm* <span class="hljs-title function_">localtime</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">time_t</span>*)</span>;  <span class="hljs-comment">// 秒计数器转换为当地时间</span><br><span class="hljs-type">time_t</span> <span class="hljs-title function_">mktime</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tm*)</span>;            <span class="hljs-comment">// 日期时间转换为秒计数器</span><br></code></pre></td></tr></table></figure><p><img src="/2024/04/01/Embedded/STM32/11-timestamp-convert.png"></p></li></ol><h3 id="11-2-BKP-备份寄存器"><a href="#11-2-BKP-备份寄存器" class="headerlink" title="11.2 BKP 备份寄存器"></a>11.2 BKP 备份寄存器</h3><ol><li><p>BKP 可用于存储用户应用程序数据</p><ul><li>当 VDD(2.0 ~ 3.6V)电源被切断时,仍由 VBAT(1.8 ~ 3.6V)维持供电</li><li>就算系统复位,电源复位,BKP 也不会复位</li><li>用户数据存储容量: 20字节(中&#x2F;小容量), 84字节(大容量&#x2F;互联型)</li></ul></li><li><p><strong>TAMPER 引脚产生的侵入事件会将所有备份寄存器内容清除</strong></p></li><li><p>RTC 引脚可以输出: RTC 校准时钟, RTC 闹钟脉冲, 秒脉冲</p></li><li><p>BPK 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/11-BPK-struct.png"></p></li></ol><h3 id="11-3-RTC-实时时钟"><a href="#11-3-RTC-实时时钟" class="headerlink" title="11.3 RTC 实时时钟"></a>11.3 RTC 实时时钟</h3><ol><li><p><strong>RTC(Real Time Clock): 实时时钟,RTC是一个独立的定时器,可为系统提供时钟 &#x2F; 日历功能</strong></p><ul><li>RTC 和 时钟配置系统处于后备区域,系统复位时数据不清零</li><li>拥有32位可编程计数器,对应 Unix 时间戳的秒计数器</li><li>拥有20位可编程预分频器,适配不同频率的输入时钟.可选时钟源有<ul><li>HSE 时钟除以128(8MHz&#x2F;128)</li><li><strong>LSE 振荡器时钟(32.768KHZ)</strong></li><li>LSI 振荡器时钟(40KHz)</li></ul></li></ul></li><li><p>RTC 框图</p><p><img src="/2024/04/01/Embedded/STM32/11-RTC-block.png"></p></li><li><p>RTC 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/11-RTC-struct.png"></p></li></ol><h2 id="12-PWR-电源控制"><a href="#12-PWR-电源控制" class="headerlink" title="12 PWR 电源控制"></a>12 PWR 电源控制</h2><h3 id="12-1-PWR"><a href="#12-1-PWR" class="headerlink" title="12.1 PWR"></a>12.1 PWR</h3><ol><li><p><strong>PWR(Power Control, 电源控制): 负责 STM32 内部的电源供电部分,可实现可编程电压检测器和低功耗模式</strong></p></li><li><p>电源框图</p><p><img src="/2024/04/01/Embedded/STM32/12-power-block.png"></p></li><li><p>上电复位和掉电复位</p><p><img src="/2024/04/01/Embedded/STM32/12-reset.png"></p></li><li><p><strong>可编程电压检测器(PVD): 监控 VDD 电源电压,当 VDD 上升&#x2F;下降到 PVD 阈值时,触发中断,执行紧急关闭任务</strong></p><p><img src="/2024/04/01/Embedded/STM32/12-PVD-threshold.png"></p></li></ol><h3 id="12-2-低功耗模式"><a href="#12-2-低功耗模式" class="headerlink" title="12.2 低功耗模式"></a>12.2 低功耗模式</h3><ol><li><p><strong>低功耗模式: 在系统空闲时,降低 STM32 的功耗,延长设备的使用时间</strong></p><p><img src="/2024/04/01/Embedded/STM32/12-low-power-mode.png"></p></li><li><p><strong>芯片在低功耗模式下无法直接下载程序: 下载程序步骤:按住复位键,点击下载程序,然后及时松开复位键</strong></p></li><li><p>修改芯片主频(修改文件 <code>Start/system_stm32f10x.c</code>)</p><ul><li>外部可见变量 <code>SystemCoreClock</code>: 系统主频的值</li><li>搜索 <code>SYSCLK_FREQ_xxMHz</code>,在此处进行的宏定义将会决定运行哪个设置系统时钟的函数</li></ul></li><li><p>进入睡眠模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">__WFI();  <span class="hljs-comment">// 进入睡眠模式,等待中断唤醒.一般置于主循环的最后一行</span><br>__WFE();  <span class="hljs-comment">// 进入睡眠模式,等待唤醒事件</span><br></code></pre></td></tr></table></figure></li><li><p>进入停机 &#x2F; 待机模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);      <span class="hljs-comment">// 停机和待机模式需开启 PWR 的时钟</span><br><br>PWR_EnterSTOPMode(PWR_Regulator_ON, PWR_STOPEntry_WFI);  <span class="hljs-comment">// 进入停止模式,并等待外部中断唤醒</span><br>PWR_EnterSTANDBYMode();  <span class="hljs-comment">// 进入待机模式,并等待指定的唤醒事件.唤醒后程序从头执行</span><br><br>SystemInit();  <span class="hljs-comment">// 从停止模式唤醒后,需重新配置时钟为 HSE(72MHz).而待机模式不需要</span><br></code></pre></td></tr></table></figure></li><li><p>设置闹钟或 PA0 上升沿唤醒待机模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">PWR_WakeUpPinCmd(ENABLE);  <span class="hljs-comment">// 使能 WakeUp 引脚(PA0)唤醒待机的功能(默认下拉低电平,高电平有效)</span><br>RTC_SetAlarm(RTC_GetCounter() + <span class="hljs-number">10</span>);  <span class="hljs-comment">// 设置 RTC 闹钟的值.为 10s 后</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="13-WDG-看门狗"><a href="#13-WDG-看门狗" class="headerlink" title="13 WDG 看门狗"></a>13 WDG 看门狗</h2><h3 id="13-1-看门狗功能"><a href="#13-1-看门狗功能" class="headerlink" title="13.1 看门狗功能"></a>13.1 看门狗功能</h3><ol><li><p><strong>看门狗(WDG, Watchdog)</strong></p><ul><li>监测程序的运行状态,当程序卡死时复位程序.保证安全性和可靠性</li><li><strong>看门狗本质是定时器,在指定的时间范围内,若未重置计数器,则硬件电路将产生复位信号</strong></li></ul></li><li><p><strong>独立看门狗(Independent WDG)</strong></p><p><img src="/2024/04/01/Embedded/STM32/13-independent-wdg.png"></p><ul><li><p>键寄存器 IWDG_KR: 控制寄存器,用于控制硬件电路的工作,避免干扰发生</p><table><thead><tr><th>写入键寄存器的值</th><th>作用</th></tr></thead><tbody><tr><td>0xCCCC</td><td>启用独立看门狗</td></tr><tr><td>0xAAAA</td><td>IWDG_RLR 中的值重新加载到计数器(喂狗)</td></tr><tr><td>0x5555</td><td>解除 IWDG_PR, IWDG_RLR 的写保护</td></tr><tr><td>0x5555之外的值</td><td>启用 IWDG_PR, IWDG_RLR 的写保护</td></tr></tbody></table></li><li><p>超时时间</p><p><img src="/2024/04/01/Embedded/STM32/13-wdg-timeout.png"></p><ul><li>超时时间: $T_{IWDG}$ &#x3D; 时钟周期 * PR 预分频系数 * (重装计数值 + 1)</li><li>其中,时钟周期&#x3D;1&#x2F;40KHz, PR 预分频系数只能取表中限定的值, 重装计数值12位(0~4095)</li></ul></li></ul></li><li><p><strong>窗口看门狗(Window WDG): 要求看门狗在精确计时窗口时作用(过早过晚均不行)</strong></p><p><img src="/2024/04/01/Embedded/STM32/13-wdg-block.png"></p></li><li><p>对比独立看门狗与窗口看门狗</p><table><thead><tr><th></th><th>独立看门狗</th><th>窗口看门狗</th></tr></thead><tbody><tr><td>复位时机</td><td>计数器减到0</td><td>计数器T[5:0] 减到0 &#x2F; 过早重装计数器</td></tr><tr><td>中断</td><td>&#x2F;</td><td>早期唤醒中断</td></tr><tr><td>时钟源</td><td>LSI(40KHz)</td><td>PCLK1(36MHz)</td></tr><tr><td>预分频系数</td><td>4, 8, 32, 64, 128, 256</td><td>1, 2, 4, 8</td></tr><tr><td>计数器</td><td>12位</td><td>6位</td></tr><tr><td>超时时间</td><td>0.1ms ~ 26214.4ms</td><td>113us ~ 58.25ms</td></tr><tr><td>喂狗方式</td><td>写入键寄存器,重装固定值 RLR</td><td>直接写入计数器</td></tr><tr><td>防误操作</td><td>键寄存器和写保护</td><td>&#x2F;</td></tr><tr><td>用途</td><td>独立工作,对时间精度要求较低</td><td>要求看门狗在精确计时窗口起作用</td></tr></tbody></table></li></ol><h3 id="13-2-看门狗代码"><a href="#13-2-看门狗代码" class="headerlink" title="13.2 看门狗代码"></a>13.2 看门狗代码</h3><ol><li><p>判断复位信号来源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) == SET) &#123;  <span class="hljs-comment">// 成立说明是独立看门狗复位</span><br><span class="hljs-comment">//if (RCC_GetFlagStatus(RCC_FLAG_WWDGRST) == SET) &#123;  // 成立说明是窗口看门狗复位</span><br>RCC_ClearFlag();  <span class="hljs-comment">// 标志位不会自动清除,进入后需要手动清除</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>操作独立看门狗</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* IWDG 初始化.LSI 会在设置看门狗后自动配置,无需手动开启 */</span><br>IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);  <span class="hljs-comment">// 独立看门狗写使能</span><br>IWDG_SetPrescaler(IWDG_Prescaler_16);  <span class="hljs-comment">// 设置预分频为16</span><br>IWDG_SetReload(<span class="hljs-number">2499</span>);  <span class="hljs-comment">// 设置重装值为2499,独立看门狗的超时时间为 1/40000 * 16 * 2500=1s</span><br>IWDG_ReloadCounter();  <span class="hljs-comment">// 重装计数器,初始化喂狗. 主循环中每1秒都需要喂狗,否则复位</span><br>IWDG_Enable();  <span class="hljs-comment">// 独立看门狗使能</span><br><span class="hljs-comment">/* 主循环中喂狗 */</span><br>IWDG_ReloadCounter();  <span class="hljs-comment">//重装计数器</span><br></code></pre></td></tr></table></figure></li><li><p>操作窗口看门狗</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* WWDG 初始化.以窗口时长 30~50ms 为例 */</span><br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);  <span class="hljs-comment">// 开启 WWDG 的时钟</span><br>WWDG_SetPrescaler(WWDG_Prescaler_8);  <span class="hljs-comment">// 设置预分频为8</span><br>WWDG_SetWindowValue(<span class="hljs-number">0x40</span> | <span class="hljs-number">21</span>);  <span class="hljs-comment">// 设置窗口时长 1/36,000,000 * 4096 * 8 * (54-21) = 30ms</span><br>WWDG_Enable(<span class="hljs-number">0x40</span> | <span class="hljs-number">54</span>);  <span class="hljs-comment">// 使能并第一次喂狗,超时时间为 1/36,000,000 * 4096 * 8 * (54+1) = 50ms</span><br><span class="hljs-comment">/* 主循环中喂狗 */</span><br>WWDG_SetCounter(<span class="hljs-number">0x40</span> | <span class="hljs-number">54</span>);  <span class="hljs-comment">//重装计数器</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="14-Flash-闪存"><a href="#14-Flash-闪存" class="headerlink" title="14 Flash 闪存"></a>14 Flash 闪存</h2><h3 id="14-1-Flash-功能"><a href="#14-1-Flash-功能" class="headerlink" title="14.1 Flash 功能"></a>14.1 Flash 功能</h3><ol><li><p>STM32F1 系列中容量产品 Flash 闪存模块组织</p><p><img src="/2024/04/01/Embedded/STM32/14-flash.png"></p></li><li><p><strong>读写 Flash 的用途</strong></p><ul><li><strong>利用程序存储器的剩余空间,保存用户数据(掉电不丢失)</strong></li><li><strong>通过在程序中编程(In-Application Programming),实现程序自我更新</strong></li></ul></li><li><p>下载程序方式</p><ul><li><strong>在线编程(In-Circuit Programming)</strong>: 更新程序存储器的全部内容<ul><li>通过 JTAG, SWD 协议(ST Link)或系统加载程序(Bootloader)下载程序</li></ul></li><li><strong>在程序中编程(In-Application Programming)</strong>: 使用微控制器支持的任意通信接口下载程序<ul><li>需要自己编写 Bootloader 程序(存储于程序更新时不覆盖的地方)</li><li>需要更新程序时,控制程序跳转到 Bootloader,接收通信数据(程序信息)</li><li>然后通过控制 Flash 读写,将程序信息存储于程序正常运行的地方</li></ul></li></ul></li><li><p>Flash 基本结构</p><p><img src="/2024/04/01/Embedded/STM32/14-Flash-struct.png"></p></li><li><p><strong>指针访问存储器</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// #define __IO volatile  // STM32对__IO的宏定义</span><br><span class="hljs-type">uint16_t</span> Data = *((__IO <span class="hljs-type">uint16_t</span> *)(<span class="hljs-number">0x08000000</span>));  <span class="hljs-comment">// 读取0x8000 0000地址的数据</span><br>* ((__IO <span class="hljs-type">uint16_t</span> *)(<span class="hljs-number">0x80000000</span>)) = <span class="hljs-number">0x1234</span>;  <span class="hljs-comment">// 给0x8000 0000地址写入数据.需要先解锁,执行相应流程</span><br></code></pre></td></tr></table></figure></li><li><p><strong>器件电子签名: 存放于闪存的系统存储区域,不可更改</strong></p><ul><li>读取方式: 使用指针直接读取指定地址下的存储器获得</li><li>闪存容量(单位kb)寄存器(16位)基地址: <code>0x1FFF F7E0</code></li><li>产品唯一身份标识寄存器(96位)基地址: <code>0x1FFF F7E8</code></li></ul></li></ol><h3 id="14-2-Flash-烧录"><a href="#14-2-Flash-烧录" class="headerlink" title="14.2 Flash 烧录"></a>14.2 Flash 烧录</h3><ol><li><p>读取芯片 ID</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">*((__IO <span class="hljs-type">uint16_t</span> *)(<span class="hljs-number">0x1FFFF7E0</span>));  <span class="hljs-comment">// 闪存容量寄存器的值</span><br>*((__IO <span class="hljs-type">uint32_t</span> *)(<span class="hljs-number">0x1FFFF7E8</span>));  <span class="hljs-comment">// 产品唯一身份标识寄存器的值,共96位</span><br>*((__IO <span class="hljs-type">uint32_t</span> *)(<span class="hljs-number">0x1FFFF7E8</span> + <span class="hljs-number">0x04</span>));<br>*((__IO <span class="hljs-type">uint32_t</span> *)(<span class="hljs-number">0x1FFFF7E8</span> + <span class="hljs-number">0x08</span>));<br></code></pre></td></tr></table></figure></li><li><p><strong>指定烧录程序是的起始地址</strong>: 打开工程选项 -&gt; Target</p><p><img src="/2024/04/01/Embedded/STM32/14-start-addr.png"></p></li><li><p><strong>程序占用空间大小查看</strong></p><ul><li><p>编译完成后会出现提示信息: <code>Program Size: Code=2784 RO-data=1788 RW-data=4 ZI-data=2660</code></p><ul><li><code>Code + RO=-data + Rw-data = 4576</code>: ROM 使用空间</li><li><code>Rw-data + ZI-data = 2664</code>:  RAM 使用空间</li></ul><table><thead><tr><th>数据类型</th><th>存储位置</th><th>说明</th></tr></thead><tbody><tr><td>Code</td><td>Flash</td><td>代码</td></tr><tr><td>RO-Data</td><td>Flash</td><td>只读数据.如 const 修饰</td></tr><tr><td>RW-Data</td><td>Flash &amp; SRAM</td><td>初值非0 可读可写的数据</td></tr><tr><td>ZI-Data</td><td>SRAM</td><td>初值为0 可读可写数据</td></tr></tbody></table></li><li><p>双击 <code>Target 1</code> 出现 <code>Project.map</code> 文件,拉到文件底部,可以直接查看程序占用空间情况</p><p><img src="/2024/04/01/Embedded/STM32/14-total-process-size.png"></p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Crash Couser</title>
    <link href="/2023/07/01/Computer/Python-Crash-Course/"/>
    <url>/2023/07/01/Computer/Python-Crash-Course/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-Crash-Course"><a href="#Python-Crash-Course" class="headerlink" title="Python Crash Course"></a>Python Crash Course</h1><h2 id="0-Python-基础"><a href="#0-Python-基础" class="headerlink" title="0 Python 基础"></a>0 Python 基础</h2><h3 id="0-1-关键字"><a href="#0-1-关键字" class="headerlink" title="0.1 关键字"></a>0.1 关键字</h3><ol><li><p><strong>利用Python标准库提供的 <code>keyword</code>模块.输出当前版本的所有关键字</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> keyword<br><span class="hljs-built_in">print</span>(keyword.kwlist)<br></code></pre></td></tr></table></figure></li><li><p>Python 关键字</p><ul><li>基本类型: <code>False, True, None</code></li><li>控制流: <ul><li>分支结构: <code>if, elif, else[, match, case]</code></li><li>循环结构: <code>for, in, while, continue, break</code></li><li>逻辑判断: <code>and, or, not, is</code></li></ul></li><li>类,函数,对象: <code>class, def, return, pass ,lambda, del</code></li><li>异常处理: <code>assert, try, except, finally, raise</code></li><li>包: <code>import, from, as</code></li><li>线程: <code>async, yield, await</code></li><li>其他: <code>global, nonlocal, with</code></li></ul></li></ol><h3 id="0-2-特性"><a href="#0-2-特性" class="headerlink" title="0.2 特性"></a>0.2 特性</h3><ol><li><p><strong>易于学习</strong>: Python 关键字较少,结构简单, 代码定义清晰</p></li><li><p><strong>广泛的标准库</strong>: Python 的最大的优势之一是丰富的库.可跨平台</p></li><li><p><strong>互动模式</strong>: 可从终端输入执行代码并获得结果的语言,互动的测试和调试代码片断</p></li><li><p><strong>可移植</strong>: 基于其开放源代码的特性.Python 已经被移植到许多平台</p></li><li><p><strong>可扩展</strong>: 如果需要关键代码有性能要求,或者不想公开算法.可以使用 C&#x2F;C++ 完成,然后由 Python 调用</p></li><li><p><strong>数据库</strong>: Python 提供所有主要的商业数据库的接口</p></li><li><p><strong>GUI 编程</strong>: Python 支持 GUI 可以创建和移植到许多系统调用</p></li><li><p><strong>可嵌入</strong>: Python 可以嵌入到 C&#x2F;C++ 程序,让程序的用户获得”脚本化”的能力</p></li><li><p><strong>Python 之禅</strong>: <code>import this</code></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs applescript">The Zen <span class="hljs-keyword">of</span> Python, <span class="hljs-keyword">by</span> Tim Peters<br><br>Beautiful <span class="hljs-keyword">is</span> better than ugly.<br>Explicit <span class="hljs-keyword">is</span> better than implicit.<br>Simple <span class="hljs-keyword">is</span> better than complex.<br>Complex <span class="hljs-keyword">is</span> better than complicated.<br>Flat <span class="hljs-keyword">is</span> better than nested.<br>Sparse <span class="hljs-keyword">is</span> better than dense.<br>Readability counts.<br>Special cases aren&#x27;t special enough <span class="hljs-keyword">to</span> break <span class="hljs-keyword">the</span> rules.<br>Although practicality beats purity.<br>Errors should never pass silently.<br>Unless explicitly silenced.<br>In <span class="hljs-keyword">the</span> face <span class="hljs-keyword">of</span> ambiguity, refuse <span class="hljs-keyword">the</span> temptation <span class="hljs-keyword">to</span> guess.<br>There should be one<span class="hljs-comment">-- and preferably only one --obvious way to do it.</span><br>Although <span class="hljs-keyword">that</span> way may <span class="hljs-keyword">not</span> be obvious <span class="hljs-keyword">at</span> <span class="hljs-keyword">first</span> unless you&#x27;re Dutch.<br>Now <span class="hljs-keyword">is</span> better than never.<br>Although never <span class="hljs-keyword">is</span> often better than *right* now.<br>If <span class="hljs-keyword">the</span> implementation <span class="hljs-keyword">is</span> hard <span class="hljs-keyword">to</span> explain, <span class="hljs-keyword">it</span>&#x27;s a bad idea.<br>If <span class="hljs-keyword">the</span> implementation <span class="hljs-keyword">is</span> easy <span class="hljs-keyword">to</span> explain, <span class="hljs-keyword">it</span> may be a good idea.<br>Namespaces are one honking great idea <span class="hljs-comment">-- let&#x27;s do more of those!</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="0-3-注释"><a href="#0-3-注释" class="headerlink" title="0.3 注释"></a>0.3 注释</h3><ol><li><p><strong>单行注释</strong>: <code># text</code></p></li><li><p>文件编码声明注释(位于文件首行): <code># coding:utf-8</code></p></li><li><p><strong>多行注释</strong>: <code>&#39;&#39;&#39; text &#39;&#39;&#39; </code> or <code>&quot;&quot;&quot; text &quot;&quot;&quot;</code></p></li><li><p>文档注释:</p><ul><li>其本质是多行注释</li><li>位于方法体最前面</li><li><strong>方法的 <code>__doc__</code> 属性可以获取文档注释</strong></li></ul></li><li><p>行与缩进</p><ul><li><strong>python 使用缩进来表示代码块,不需要使用大括号</strong></li><li>缩进的空格数是可变的,但同一代码块的语句必须包含相同的缩进空格数</li><li>与 C 相同: Python 同样以在行尾加上续行转义符 <code>\</code> 来实现多行语句</li><li>在 <code>[], &#123;&#125;, ()</code> 中的多行语句自动续行.不需要使用反斜杠 <code>\</code> 续行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_hi</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param name: 被打印的字符串</span><br><span class="hljs-string">    :return: None</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Hi, <span class="hljs-subst">&#123;name&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="0-4-运算符"><a href="#0-4-运算符" class="headerlink" title="0.4 运算符"></a>0.4 运算符</h3><ol><li><p>算术运算符</p><ul><li>基本算术运算符: <code>+, -, *, /, %</code>.  <strong>整除: <code>//</code>. 乘方: <code>**</code></strong></li><li><strong>注意与 C 不同的是: Python 中 <code>/</code> 是实数除法,而非整数除法</strong></li></ul></li><li><p>赋值运算符</p><ul><li>基本赋值: <code>=, +=, -=, *=, /=, %=</code>. <code>**=</code>: 乘方后赋值. <code>//=</code>: 整除后赋值</li><li><code>:=</code> <strong>海象运算符(Python3.8 新增),可在表达式内部进行赋值</strong></li></ul></li><li><p><strong>逻辑运算符</strong>: <code>and, or, not</code></p></li><li><p><strong>成员运算符</strong>: <code>in, not in</code></p></li><li><p><strong>身份运算符</strong>: <code>is, is not</code></p></li><li><p>运算符优先级</p><table><thead><tr><th>优先级</th><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td>1</td><td align="left"><code>(expressions), [exp], &#123;exp&#125;, &#123;key: value&#125;</code></td><td align="left">括号内的表达式</td></tr><tr><td>2</td><td align="left"><code>x[index], x[:], x(arguments), x.attribute</code></td><td align="left">读取,切片,调用,属性引用</td></tr><tr><td>3</td><td align="left"><code>await x</code></td><td align="left"><code>await</code> 表达式</td></tr><tr><td>4</td><td align="left"><code>**</code></td><td align="left">乘方(指数)</td></tr><tr><td>5</td><td align="left"><code>+x, -x, ~x</code></td><td align="left">正,负,按位非 NOT</td></tr><tr><td>6</td><td align="left"><code>*, @, /, //, %</code></td><td align="left">乘,矩阵乘,除,整除,取余</td></tr><tr><td>7</td><td align="left"><code>+, -</code></td><td align="left">加,减</td></tr><tr><td>8</td><td align="left"><code>&lt;&lt;, &gt;&gt;</code></td><td align="left">移位</td></tr><tr><td>9</td><td align="left"><code>&amp;</code></td><td align="left">按位与 AND</td></tr><tr><td>10</td><td align="left"><code>^</code></td><td align="left">按位异或 XOR</td></tr><tr><td>11</td><td align="left">|</td><td align="left">按位或 OR</td></tr><tr><td>12</td><td align="left"><code>in, not in, is, is not, &lt;, &lt;=, &gt;, &gt;=, !=, ==</code></td><td align="left">成员检测, 比较运算</td></tr><tr><td>13</td><td align="left"><code>not x</code></td><td align="left">逻辑非 NOT</td></tr><tr><td>14</td><td align="left"><code>and</code></td><td align="left">逻辑与 AND</td></tr><tr><td>15</td><td align="left"><code>or</code></td><td align="left">逻辑或 OR</td></tr><tr><td>16</td><td align="left"><code>if - else</code></td><td align="left">条件表达式</td></tr><tr><td>17</td><td align="left"><code>lambda</code></td><td align="left">lambda 表达式</td></tr><tr><td>18</td><td align="left"><code>:=</code></td><td align="left">赋值表达式</td></tr></tbody></table></li></ol><h3 id="0-5-字符串"><a href="#0-5-字符串" class="headerlink" title="0.5 字符串"></a>0.5 字符串</h3><ol><li><p>表示形式: 用 <code>&#39;</code> 或 <code>&quot;</code> 或 <code>&#39;&#39;&#39;</code> 包围.特别地,<strong>三引号允许字符串跨行</strong></p></li><li><p><strong>Python 没有 <code>char</code> 类型.转而用长度为 1 的字符串代替</strong></p></li><li><p><strong>字符串的运算符重载</strong></p><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td><code>+</code></td><td>拼接字符串</td></tr><tr><td><code>*</code></td><td>重复字符串</td></tr><tr><td><code>[]</code></td><td>下标索引</td></tr><tr><td><code>in / not in</code></td><td>成员运算</td></tr><tr><td><code>r / R</code></td><td>raw string: 前缀 r 表示不进行字符转义</td></tr><tr><td><code>%</code></td><td>格式字符串.如 <code>print(&quot;%d&quot; % age)</code></td></tr></tbody></table></li><li><p>格式化输出: <code>.format</code> 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;age: &#123;&#125;, name: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(age, name))<br></code></pre></td></tr></table></figure></li><li><p><strong><code>f-string</code>(字面量格式化字符串,Python3.6添加)</strong></p><ul><li><p>以 f 作为字符串前缀,用 <code>&#123;&#125;</code> 包围表达式</p></li><li><p><code>&#123;&#125;</code> 的表达式将会被计算后的值替换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;age: <span class="hljs-subst">&#123;age&#125;</span>, name: <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>print()</code>: 默认换行输出.如果要实现不换行输出,需要在变量末尾加上 <code>end=&quot;&quot;</code> </p></li><li><p><code>input([prompt])</code></p><ul><li>格式: <code>str = input(&quot;prompt&quot;)</code> </li><li>作用: 从标准输入(默认是键盘)读入一行文本</li><li>先将 <code>&quot;prompt&quot;</code> 字符串进行标准输出,然后等待用户输入,并以 <code>string</code> 类型返回</li></ul></li><li><p><code>string</code> 的内建函数</p><ul><li><p>判断字符串内容形式</p><table><thead><tr><th>函数</th><th>说明(满足条件返回 true)</th></tr></thead><tbody><tr><td>isdecimal() &#x2F; <strong>isdigit()</strong></td><td>非空 &amp; 只包含十进制字符 &#x2F; <strong>只包含数字</strong></td></tr><tr><td>isalnum()</td><td>非空 &amp; 所有字符都是字母或数字</td></tr><tr><td>isalpha()</td><td>非空 &amp; 所有字符都是字母或中文</td></tr><tr><td>islower() &#x2F; isupper()</td><td>非空 &amp; 全为小&#x2F;大写</td></tr><tr><td>isnumeric()</td><td>非空 &amp; 只包含数字字符</td></tr><tr><td>isspace()</td><td>非空 &amp; 只包含空白</td></tr><tr><td>istitle()</td><td>是标题化的</td></tr><tr><td>endswith(suffix, beg&#x3D;0, end&#x3D;len(string))</td><td>字符串以 suffix 结束</td></tr><tr><td><strong>startswith(substr, beg&#x3D;0,end&#x3D;len(string))</strong></td><td><strong>字符串以 substr 开头</strong></td></tr></tbody></table></li><li><p>格式化字符串</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>capitalize()</td><td>首字母大写化</td></tr><tr><td><strong>title()</strong></td><td><strong>标题化</strong></td></tr><tr><td>lower()</td><td>小写化</td></tr><tr><td>upper()</td><td>大写化</td></tr><tr><td>lstrip([chars])</td><td>删除字符串左边的指定字符(默认空格)</td></tr><tr><td>rstrip([chars])</td><td>删除字符串末尾的指定字符(默认空格)</td></tr><tr><td><strong>strip([chars])</strong></td><td><strong>执行 lstrip(), rstrip()</strong></td></tr><tr><td>swapcase()</td><td>大小写反向</td></tr><tr><td><strong>center(width[, fillchar])</strong></td><td><strong>居中对齐</strong></td></tr><tr><td>ljust(width[, fillchar])</td><td>左对齐</td></tr><tr><td>rjust(width[, fillchar])</td><td>右对齐</td></tr><tr><td>expandtabs(tabsize&#x3D;8)</td><td>将 tab 符号转为空格(默认为8个)</td></tr></tbody></table></li><li><p>字符串处理</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><strong>split(str&#x3D;””, num&#x3D;string.count(str))</strong></td><td><strong>分割字符串</strong></td></tr><tr><td>splitlines([keepends])</td><td>按行 (<code>&#39;\r&#39;, &#39;\r\n&#39;, \n&#39;</code>) 分割字符串</td></tr><tr><td>count(str, beg&#x3D;0, end&#x3D;len(string))</td><td>计算 str 出现的次数</td></tr><tr><td><strong>find(str, beg&#x3D;0, end&#x3D;len(string))</strong></td><td><strong>查找</strong></td></tr><tr><td>rfind(str, beg&#x3D;0,end&#x3D;len(string))</td><td>反向查找</td></tr><tr><td>replace(old, new, max)</td><td>替换字符串. max 指定最大替换次数</td></tr><tr><td>encode(encoding&#x3D;’UTF-8’, errors&#x3D;’strict’)</td><td>指定编码的格式</td></tr></tbody></table></li></ul></li></ol><h3 id="0-6-内置函数"><a href="#0-6-内置函数" class="headerlink" title="0.6 内置函数"></a>0.6 内置函数</h3><ol><li><p>判断对象所属类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">type</span>(obj)                   <span class="hljs-comment"># 返回对象的类型</span><br><span class="hljs-built_in">isinstance</span>(obj, class_name)<span class="hljs-comment"># 判断对象是否是已知类型</span><br><span class="hljs-comment"># 区别在于 type 不认子类,而 isinstance 认为子类是父类类型</span><br></code></pre></td></tr></table></figure></li><li><p>数学函数(<code>import math</code>)</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>abs(x) &#x2F; fabs(x)</td><td>绝对值 &#x2F; 浮点绝对值</td></tr><tr><td>ceil(x) &#x2F; floor(x)</td><td>向上&#x2F;下取整</td></tr><tr><td>sqrt(x) &#x2F; exp(x) &#x2F; pow(x, y)</td><td>$\sqrt{x}$ &#x2F; $e^x$ &#x2F; $x^y$</td></tr><tr><td>log(x) &#x2F; log10(x)</td><td>$\mathrm{ln}x$ &#x2F; $\mathrm{log}_{10}x$</td></tr><tr><td><strong>max(x, y,…) &#x2F; min(x, y,…)</strong></td><td><strong>取最大&#x2F;小值,参数可以为序列</strong></td></tr><tr><td>modf(x)</td><td>返回x的整数部分与小数部分,符号与x相同</td></tr><tr><td><strong>round(x[, n])</strong></td><td><strong>4舍6进5看齐,奇进偶舍. n 指定位数</strong></td></tr></tbody></table></li><li><p>随机函数(<code>import random</code>)</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><strong>seed(x)</strong></td><td><strong>设定随机数种子</strong></td></tr><tr><td><strong>choice(seq)</strong></td><td><strong>从序列的元素中随机挑选一个元素</strong></td></tr><tr><td>randint(x, y)</td><td>随机生成一个整数.范围: <code>[x, y]</code></td></tr><tr><td><strong>random()</strong></td><td><strong>随机生成一个实数.范围: <code>[0, 1)</code></strong></td></tr><tr><td>uniform(x, y)</td><td>随机生成一个实数.范围: <code>[x, y]</code></td></tr><tr><td>shuffle(lst)</td><td>将序列的所有元素随机排序</td></tr></tbody></table></li></ol><div STYLE="page-break-after: always;"></div><h2 id="1-数据容器"><a href="#1-数据容器" class="headerlink" title="1 数据容器"></a>1 数据容器</h2><h3 id="1-1-list"><a href="#1-1-list" class="headerlink" title="1.1 list"></a>1.1 list</h3><ol><li><p><strong>元素类型: 可以有不同类型.允许嵌套列表.基本允许任何对象</strong></p></li><li><p>创建方式: 用 <code>[]</code> 包围元素.用 <code>,</code> 分隔元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">spam = [<span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;rat&quot;</span>]  <span class="hljs-comment"># spam 为列表,拥有3个元素</span><br></code></pre></td></tr></table></figure></li><li><p>获取列表元素</p><ul><li>使用 <code>l[index: int]</code> 获取列表 <code>l</code> 在索引为 <code>index</code> 处的元素</li><li>允许使用负数作为索引值,表示倒数.如 -1 表示最后一个元素</li><li>当索引(从0开始)越界时,将会抛出 <code>IndexError</code></li></ul></li><li><p><strong>切片: 获取列表的一部分,也是一个列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">list_name[start=<span class="hljs-number">0</span> : end=<span class="hljs-built_in">len</span>(list_name) : step=<span class="hljs-number">1</span>]<br><span class="hljs-comment"># start: 开始位置.默认为0</span><br><span class="hljs-comment"># end:   结束位置.默认为列表的长度</span><br><span class="hljs-comment"># step:  切片步长.默认为1,可省略.负数表示反向</span><br></code></pre></td></tr></table></figure></li><li><p><strong>运算符重载: 用 <code>+</code> 进行连接,用 <code>*</code> 运算符进行重复</strong>(与字符串类似)</p></li><li><p>删除部分元素: 使用 <code>del</code> 关键字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> list_name[:<span class="hljs-number">3</span>]  <span class="hljs-comment"># 删除前3个元素</span><br></code></pre></td></tr></table></figure></li><li><p>技巧: 在遍历列表的同时获取下标</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> index, obj <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(obj_list):<br>    <span class="hljs-built_in">print</span>(index, obj)<br></code></pre></td></tr></table></figure></li><li><p>list 常用方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>append(obj)</strong></td><td><strong>在列表末尾添加新的对象</strong></td></tr><tr><td>count(obj)</td><td>统计某个元素在列表中出现的次数</td></tr><tr><td>extend(seq)</td><td>将可迭代序列的内容拓展到列表末尾</td></tr><tr><td><strong>remove(obj) &#x2F; index(obj)</strong></td><td><strong>移除对象 &#x2F; 获取索引(只针对第一次匹配成功的)</strong></td></tr><tr><td><strong>reverse()</strong> &#x2F; clear() &#x2F; copy()</td><td><strong>原地翻转列表</strong> &#x2F; 清空列表 &#x2F; 复制列表</td></tr><tr><td><strong>pop(index&#x3D;-1)</strong></td><td><strong>移除列表中的一个元素并返回(默认最后一个)</strong></td></tr><tr><td><strong>insert(index, obj)</strong></td><td><strong>将对象插入列表的指定下标</strong></td></tr><tr><td><strong>sort(key&#x3D;None, reverse&#x3D;False)</strong></td><td><strong>原地排序. <code>key</code> 是关键字函数,指定排序规则</strong></td></tr></tbody></table></li></ol><h3 id="1-2-tuple"><a href="#1-2-tuple" class="headerlink" title="1.2 tuple"></a>1.2 tuple</h3><ol><li><p><strong><code>tuple</code> 与 <code>list</code> 类似,区别在于 <code>tuple</code> 不可更改</strong></p></li><li><p>创建方式: 用 <code>()</code> 包围.用 <code>,</code> 分隔元素(区别于列表使用 <code>[]</code>)</p></li><li><p>切片: 与 <code>list</code> 相同</p></li><li><p>当函数返回多个值时,其本质返回的是元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">return</span> width, height  <span class="hljs-comment"># 相当于返回 (width, height)</span><br></code></pre></td></tr></table></figure></li><li><p>字符串可看作一种特殊的 <code>tuple</code></p></li></ol><h3 id="1-3-dictionary"><a href="#1-3-dictionary" class="headerlink" title="1.3 dictionary"></a>1.3 dictionary</h3><ol><li><p>特点</p><ul><li><strong>无序的对象集合</strong>(在 Python 3.6 后变得有序)</li><li><strong>通过 <code>key</code> 存取 <code>value</code></strong> (<code>list</code> 通过下标偏移)</li><li><strong><code>key</code> 必须是不可变类型的,且必须唯一</strong>(常用数字,字符串,元组充当)</li></ul></li><li><p>字典元素访问</p><ul><li><p>元素形如: <code>key : value</code> </p></li><li><p>整体形如: <code>dict = &#123;key1 : value1, key2 : value2, ..., keyn : valuen&#125;</code> </p></li><li><p>访问方式: <code>dict[key]</code>.需注意若 <code>key</code> 不存在将会抛出 <code>KeyError</code></p></li><li><p><strong>添加元素: <code>dict[key] = value</code></strong> </p></li><li><p><strong>遍历字典: 当对字典进行遍历时,默认遍历所有的 <code>key</code></strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dictionary:<br>    <span class="hljs-built_in">print</span>(key, dictionary[key])<br></code></pre></td></tr></table></figure></li></ul></li><li><p>dictionary 常用方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>keys() &#x2F; values()</strong></td><td><strong>返回动态视图对象,具有所有的 key &#x2F; value 信息</strong></td></tr><tr><td><strong>items()</strong></td><td><strong>返回动态视图对象,具有所有的 key-value 信息</strong></td></tr><tr><td><strong>get(key, default&#x3D;None)</strong></td><td><strong>返回 value.若 key 不存在,返回 default</strong></td></tr><tr><td>setdefault(key, default&#x3D;None)</td><td>返回 value.若 key 不存在,添加 (key, value&#x3D;default)</td></tr><tr><td><strong>pop(key, default)</strong></td><td><strong>删除 key 所对应的值,返回 value</strong></td></tr><tr><td>popitem()</td><td>删除最后的 key-value,并返回</td></tr><tr><td>update(dict)</td><td>加入 dict 的 key-value</td></tr></tbody></table></li></ol><h3 id="1-4-set"><a href="#1-4-set" class="headerlink" title="1.4 set"></a>1.4 set</h3><ol><li><p><strong>特点: 无序,可变,元素唯一</strong></p></li><li><p>创建方式: </p><ul><li>用 <code>&#123;&#125;</code> 包围.用 <code>,</code> 分隔元素</li><li>创建空集合: <code>set()</code></li></ul></li><li><p>操作符重载: 并集(<code>|</code>), 交集(<code>&amp;</code>), 差集(<code>-</code>), 异或(<code>^</code>)</p></li><li><p>set 常用方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>add(element)</strong></td><td><strong>添加元素</strong></td></tr><tr><td><strong>pop</strong>()</td><td><strong>随机移除元素,并将其返回</strong></td></tr><tr><td>update(set)</td><td>添加元素,可以有多个</td></tr><tr><td>discard(element)</td><td>删除集合中指定的元素.若不存在,不会引发错误</td></tr><tr><td><strong>remove(element)</strong></td><td><strong>移除指定元素.若不存在会发生错误</strong></td></tr><tr><td>isdisjoint(set)</td><td>认为两个集合不包含相同的元素</td></tr><tr><td>issubset(set)</td><td>认为指定集合是子集</td></tr><tr><td>issuperset(set)</td><td>认为指定集合是超集</td></tr></tbody></table></li><li><p>list, tuple, dictionary, set 通用 方法&#x2F;函数</p><table><thead><tr><th>函数&#x2F;方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>len(object)</strong></td><td><strong>计算元素个数</strong></td></tr><tr><td>clear()</td><td>清空容器</td></tr><tr><td>copy()</td><td>(浅)复制容器</td></tr></tbody></table></li></ol><h3 id="1-5-bytes"><a href="#1-5-bytes" class="headerlink" title="1.5 bytes"></a>1.5 bytes</h3><ol><li>含义: 不可变的二进制序列</li><li>元素类型: 0 ~ 255 的整数</li><li>作用: 用于处理二进制数据(如图像, 音频, 视频)</li><li>创建方式: <ul><li>使用 <code>b</code> 前缀 (如 <code>x=b&quot;hello&quot;</code>)</li><li>使用 <code>bytes()</code> 函数将其他类型对象转换为 <code>bytes</code> 类型</li></ul></li></ol><h3 id="1-6-类型转换"><a href="#1-6-类型转换" class="headerlink" title="1.6 类型转换"></a>1.6 类型转换</h3><ol><li><p>Python 数据类型</p><ul><li><code>number(int, bool, float, complex), string, list, tuple, set, dictionary</code></li><li>其中 <code>number, string, tuple</code> 不可变; <code>list, dictionary, set</code> 可变</li></ul></li><li><p>复数形如 <code>a+bj</code> 或 <code>complex(a, b)</code></p></li><li><p>隐式类型转换</p><ul><li>运算时较低数据类型会自动转换为较高数据类型,以避免信息丢失</li><li><code>bool &lt; int &lt; float &lt; complex</code></li></ul></li><li><p>显式类型转换</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>int(x, base&#x3D;10)</strong></td><td align="left"><strong>返回整数</strong></td></tr><tr><td align="left">float(x)</td><td align="left">返回浮点数</td></tr><tr><td align="left">complex(real[, imag])</td><td align="left">返回复数</td></tr><tr><td align="left"><strong>str(object&#x3D;””)</strong></td><td align="left"><strong>将对象 object 转换为字符串</strong></td></tr><tr><td align="left"><strong>repr(object)</strong></td><td align="left"><strong>将对象 object 转换为表达式字符串</strong></td></tr><tr><td align="left"><strong>eval(str)</strong></td><td align="left"><strong>计算字符串中的有效 Python 表达式,并返回一个对象</strong></td></tr><tr><td align="left"><strong>list(iterable)</strong></td><td align="left"><strong>将可迭代序列转换为列表</strong></td></tr><tr><td align="left">tuple(iterable)</td><td align="left">将可迭代序列转换为元组</td></tr><tr><td align="left">set([iterable])</td><td align="left">将可迭代序列转换为可变集合</td></tr><tr><td align="left">dict(d)</td><td align="left">创建一个字典.其中 d是(key, value)元组序列</td></tr><tr><td align="left">frozenset([iterable])</td><td align="left">将可迭代序列转换为不可变集合</td></tr><tr><td align="left"><strong>chr(x)</strong></td><td align="left"><strong>将一个整数(0~255)转换为一个字符</strong></td></tr><tr><td align="left"><strong>ord(c)</strong></td><td align="left"><strong>将一个字符转换为整数值(与 chr 相对)</strong></td></tr><tr><td align="left"><strong>hex(x)</strong></td><td align="left"><strong>将一个整数转换为一个十六进制字符串</strong></td></tr><tr><td align="left">oct(x)</td><td align="left">将一个整数转换为一个八进制字符串</td></tr></tbody></table></li></ol><h2 id="2-程序控制"><a href="#2-程序控制" class="headerlink" title="2 程序控制"></a>2 程序控制</h2><h3 id="2-1-分支"><a href="#2-1-分支" class="headerlink" title="2.1 分支"></a>2.1 分支</h3><ol><li><p>与 C 的区别: 用 <code>elif</code> 代替了 <code>else if</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> &lt;condition_1&gt;:  <span class="hljs-comment"># 条件表达式的值为 True 时,则执行,且下面的判断不在执行</span><br>    &lt;statement_block_1&gt;<br><span class="hljs-keyword">elif</span> condition_2:  <span class="hljs-comment"># 当 condition_1 的值为 False,才会进行判断</span><br>    &lt;statement_block_2&gt;<br><span class="hljs-keyword">else</span>:              <span class="hljs-comment"># 当所有的条件表达式都为 False,才会执行</span><br>    &lt;statement_block_3&gt;<br></code></pre></td></tr></table></figure></li><li><p><code>match - case</code>(Python3.10添加)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">match</span> subject:         <span class="hljs-comment"># 类似于 C 中的 switch-case</span><br>    <span class="hljs-keyword">case</span> &lt;pattern_1&gt;:  <span class="hljs-comment"># 当成功匹配时,执行相应的语句</span><br>        &lt;action_1&gt;<br>    <span class="hljs-keyword">case</span> &lt;pattern_2&gt;:<br>        &lt;action_2&gt;<br>    <span class="hljs-keyword">case</span> _:             <span class="hljs-comment"># 可以匹配一切.该语句与 C 中的 &#x27;default:&#x27; 作用类似</span><br>        &lt;action_wildcard&gt;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-循环"><a href="#2-2-循环" class="headerlink" title="2.2 循环"></a>2.2 循环</h3><ol><li><p><code>while</code> 语句与 C 的区别: 没有 <code>do while</code> 语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> &lt;expr&gt;:       <span class="hljs-comment"># 当表达式的值为 True,则执行循环</span><br>    &lt;statement(s)&gt;  <span class="hljs-comment"># 可以使用 continue 和 break 语句</span><br><span class="hljs-keyword">else</span>:               <span class="hljs-comment"># 若循环语句未被 break 打断,则 else 语句将会被执行</span><br>    &lt;additional_statement(s)&gt;<br></code></pre></td></tr></table></figure></li><li><p><code>for</code> 经常用来遍历可迭代对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> &lt;variable&gt; <span class="hljs-keyword">in</span> &lt;sequence&gt;:  <span class="hljs-comment"># 当可以取到序列对象的元素时,则执行循环</span><br>    &lt;statements&gt;               <span class="hljs-comment"># 可以使用 continue 和 break 语句</span><br><span class="hljs-keyword">else</span>:                          <span class="hljs-comment"># 若循环语句未被 break 打断,则 else 语句将会被执行</span><br>    &lt;statements&gt;<br></code></pre></td></tr></table></figure><ul><li><code>for</code> 可与 <code>else</code> 进行匹配.当循环完成时,执行<code>else</code>语句块(遇到 <code>break</code> 不会执行)</li><li>遍历数字序列时,可用内置的 <code>range</code> 函数生成数列</li><li><strong><code>range(start=0, stop, step=1)</code> 返回一个整数序列对象,仅在迭代时返回数字</strong></li></ul></li><li><p><strong>不要在<code>for</code>循环遍历列表时修改列表,否则将导致Python难以追踪其中的元素.此时应使用<code>while</code></strong></p></li><li><p><code>pass</code> 语句: 用于占位,表示什么也不做</p></li></ol><h3 id="2-3-推导式"><a href="#2-3-推导式" class="headerlink" title="2.3 推导式"></a>2.3 推导式</h3><ol><li><p><strong>列表推导式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># [表达式 for 变量 in 列表 if 条件].其中条件语句是可选的</span><br><span class="hljs-comment"># 目的: 过滤出长度大于3的字符串,并将其全大写</span><br>names = [<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;Jerry&#x27;</span>, <span class="hljs-string">&#x27;Wendy&#x27;</span>, <span class="hljs-string">&#x27;Smith&#x27;</span>]<br>new_names = [name.upper() <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(name) &gt; <span class="hljs-number">3</span>]<br><br>[ out_exp_res <span class="hljs-keyword">for</span> out_exp <span class="hljs-keyword">in</span> input_list <span class="hljs-keyword">if</span> condition ]<br><span class="hljs-comment"># out_exp_res: 列表生成元素表达式,可以是有返回值的函数</span><br><span class="hljs-comment"># 迭代时: input_list 将 out_exp 传入到 out_exp_res 表达式中</span><br><span class="hljs-comment"># condition: 条件表达式</span><br></code></pre></td></tr></table></figure></li><li><p>字典推导式</p><ul><li>格式: <code>&#123; key_expr: value_expr for key, value in collection if condition &#125;</code> </li><li><code>key_expr : value_expr</code>: 字典生成元素表达式</li></ul></li><li><p>集合推导式</p><ul><li>格式: <code>&#123; expression for item in Sequence if condition &#125;</code></li></ul></li><li><p>元组推导式</p><ul><li>格式: <code>(expression for item in Sequence if condition )</code> </li><li><strong>注意: 元组推导式返回的结果是一个生成器对象,需要使用 <code>tuple()</code> 函数才会成为元组</strong></li></ul></li></ol><h3 id="2-4-迭代器"><a href="#2-4-迭代器" class="headerlink" title="2.4 迭代器"></a>2.4 迭代器</h3><ol><li><p>迭代器</p><ul><li>迭代器可以记住遍历的位置,只能往前不会后退</li><li>从第一个元素开始访问.直到所有的元素被访问完结束</li><li>当没有元素可以访问时, <code>next()</code> 函数将会抛出 <code>StopIteration</code> 异常</li><li>迭代器基础函数: <code>iter(), next()</code></li></ul></li><li><p>迭代器使用示例</p><ul><li><p>使用 <code>iter()</code> 函数创建迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">l = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]  <span class="hljs-comment"># string, list, tuple 均可创建迭代器</span><br>it = <span class="hljs-built_in">iter</span>(l)      <span class="hljs-comment"># 创建迭代器对象</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>next()</code> 函数获取值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">it = <span class="hljs-built_in">next</span>(it)  <span class="hljs-comment"># 获取当前元素,并将迭代器指向下一元素</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>for</code> 循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> it:<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>类的迭代器</p><ul><li>需要在类中实现 <code>__iter__, __next__</code> 方法  </li><li><code>StopIteration</code> 异常用于标识迭代的完成,防止出现无限循环的情况</li></ul></li></ol><h3 id="2-5-生成器"><a href="#2-5-生成器" class="headerlink" title="2.5 生成器"></a>2.5 生成器</h3><ol><li><p><strong>生成器: 使用了 <code>yield</code> 的函数</strong></p><ul><li>生成器函数是一种特殊的函数,可以在迭代过程中逐步产生值,而不是一次性返回所有结果</li><li>生成器是一个返回迭代器的函数,只能用于迭代操作</li></ul></li><li><p>生成器执行过程</p><ul><li>生成器函数中遇到 <code>yield</code> 语句时,函数的执行暂停,然后将 <code>yield</code> 后面的表达式作为当前迭代的值返回</li><li>每次调用生成器的 <strong>next</strong> 函数或使用 <code>for</code> 循环进行迭代时,函数会从上次暂停的地方继续执行,直到再次遇到 <code>yield</code> 语句</li></ul></li><li><p>生成器使用示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci</span>():<br>    before, after = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">yield</span> before<br>        before, after = after, before + after<br></code></pre></td></tr></table></figure><ul><li><p>对生成器使用 <code>next</code> 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">f = fibonacci()  <span class="hljs-comment"># 获取迭代器</span><br><span class="hljs-built_in">next</span>(f)          <span class="hljs-comment"># 使用迭代器产生值.每次调用 next 只会生成一个值,且不会回头</span><br></code></pre></td></tr></table></figure></li><li><p>对生成器使用 <code>for</code> 循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> f:  <span class="hljs-comment"># 注意,由于 fib 生成永远不会结束,会导致这是一个死循环</span><br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="2-6-函数"><a href="#2-6-函数" class="headerlink" title="2.6 函数"></a>2.6 函数</h3><ol><li><p>定义方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">paraList</span>):  <span class="hljs-comment"># 不带表达式的 return 相当于返回 None</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure></li><li><p><strong>参数传递</strong></p><ul><li>不可变对象: 类似 C++ 的值传递.如整数, 字符串, 元组</li><li>可变对象:类似 C++ 的引用传递.如字典, 列表(传递<code>listName[:]</code>则原列表不会被修改)</li><li>函数可以直接作为参数进行传递</li></ul></li><li><p>参数类型</p><ul><li><strong>位置参数</strong><ul><li>必须按顺序传入函数,调用时 给定的参数数量需与声明一致</li><li><strong>强制位置参数: 在函数定义中参数 <code>/</code> 左侧的必须是位置参数</strong></li></ul></li><li><strong>关键字参数</strong><ul><li>在调用时指出参数名并显式赋值.可以不按顺序书写</li><li><strong>强制关键字参数: 在函数定义中参数 <code>*</code> 右侧的必须时关键字参数</strong></li></ul></li><li>默认参数: 与 C++ 类似.在函数定义时直接指定参数的默认值</li><li><strong>收集参数</strong><ul><li>声明时不会对这些参数命名,因为长度未知</li><li>以 <code>*</code> 为前缀的参数将会以 <code>tuple</code> 的形式接受参数(常用 <code>*args</code>)</li><li>以 <code>**</code> 为前缀的参数将会以 <code>dictionary</code> 的形式接受参数(常用 <code>**kwargs</code>)</li></ul></li></ul></li><li><p><strong>匿名函数</strong></p><ul><li><p><code>lambda</code> 只是一个表达式,而非代码块,无法访问全局命名空间</p></li><li><p><code>lambda</code> 函数拥有自己的命名空间,仅能访问参数列表的参数.函数体只能有一行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> arg1 ,arg2, ..., argn : expression<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="2-7-模块"><a href="#2-7-模块" class="headerlink" title="2.7 模块"></a>2.7 模块</h3><ol><li><p><code>import</code>: 导包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> moudle1[, moudle2, ..., moudleN]<br></code></pre></td></tr></table></figure><ul><li>模块只会被导入1次, 无论执行了多少次 <code>import</code> </li><li>此时对模块中的内容进行调用需要 <code>.</code> 运算符: <code>moudle1.func</code></li></ul></li><li><p><code>from</code>: 简化调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> moudle_name <span class="hljs-keyword">import</span> name1[, name2, ..., nameN]<br></code></pre></td></tr></table></figure><ul><li>从模块中导入指定的部分到当前命名空间中.此时不需要使用<code>.</code>运算符调用</li><li><code>from moudle_name import *</code> 会将模块的全部内容导入到当前命名空间中(不推荐)</li></ul></li><li><p><code>as</code>: 为对象(模块,函数…)指定别名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-keyword">from</span> moudle_name] <span class="hljs-keyword">import</span> object_name [<span class="hljs-keyword">as</span> alias]  <span class="hljs-comment"># 导入模块完整语法</span><br></code></pre></td></tr></table></figure></li><li><p><code>__name__</code> 属性</p><ul><li><p>每个模块都有 <code>__name__</code> 属性</p></li><li><p><strong>当 <code>__name__</code> 的值为 <code>&#39;__main__&#39;</code> 时.表明该模块自身在运行.否则是被导入</strong></p></li><li><p>如需要模块的某块代码仅在其自身运行时执行,可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>: <br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>dir()</code> 函数: 模块内定义的所有名称.以字符串列表的形式返回</p></li><li><p><strong>包: 将模块以文件夹的形式组织到一起(包下面可以有子包)</strong></p><ul><li>注意当目录包含一个名为 <code>__init__.py</code> 的文件才会被认为是一个包</li></ul></li><li><p>导入包中的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">form packeage_name <span class="hljs-keyword">import</span> moudle_name  <span class="hljs-comment"># moudle_name 可以是子包, 模块, 函数, 类, 变量, *</span><br></code></pre></td></tr></table></figure></li><li><p><code>__all__</code>属性: 这是一个列表,以字符串的形式存放</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__all__ = [<span class="hljs-string">&quot;func1&quot;</span>, <span class="hljs-string">&quot;func2&quot;</span>]<br></code></pre></td></tr></table></figure><ul><li>该属性作用于 <code>from xx import *</code> 语句.对可以访问的内容进行了限制.只会包含列表内的功能</li><li>在模块中,该属性直接存在于该文件中</li><li>在包中,该属性存放在必需的文件<code>__init__.py</code>中</li></ul></li></ol><h2 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3 面向对象"></a>3 面向对象</h2><h3 id="3-1-面向对象"><a href="#3-1-面向对象" class="headerlink" title="3.1 面向对象"></a>3.1 面向对象</h3><ol><li><p>类成员</p><ul><li><strong>类命名空间中所有的命名都是有效属性名,而不需要特别声明</strong></li><li><strong>类的方法必须提供一个额外参数 <code>self</code>.指向实例本身</strong></li><li>类属性位于类中,方法外.而实例属性位于 <code>__init__</code> 方法中</li><li>私有属性(双下划线开头): <code>__private_atrrs</code> </li><li>私有方法(双下划线开头): <code>__private_methods()</code></li></ul></li><li><p>构造方法</p><ul><li>名称固定为 <code>__init__()</code>.在实例化时自动调用.且只允许存在一个构造方法</li><li>没有 <code>this</code> 指针.但可以使用 <code>self</code> 表示正在调用该方法的对象(<code>self</code> 名称只是惯例,不是规定)</li><li>调用父类的方法: 使用 <code>super()</code> 函数.获取父类</li></ul></li><li><p>继承: Python 允许多继承</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class_name</span>(BaseClass1, BaseClass2): <br></code></pre></td></tr></table></figure></li></ol><h3 id="3-2-异常处理"><a href="#3-2-异常处理" class="headerlink" title="3.2 异常处理"></a>3.2 异常处理</h3><ol><li><p><code>try - except - else - finally</code> </p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 可能出现异常的代码</span><br><span class="hljs-keyword">except</span> [异常 [<span class="hljs-keyword">as</span> 别名]]:  <span class="hljs-comment"># 如 Exception as e</span><br>    <span class="hljs-comment"># 发生异常时,执行的代码</span><br>[<span class="hljs-keyword">else</span>:]<br><span class="hljs-comment"># 没有发生异常时,执行的代码</span><br>[<span class="hljs-keyword">finally</span>:]<br>    <span class="hljs-comment"># 无论是否发生异常,都要执行的代码</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>若执行时发生异常. <code>try</code> 子句的剩余部分将被忽略</strong></p></li><li><p><strong>异常类型将与 <code>except</code> 提供名称进行匹配.匹配成功则将执行相应的 <code>expect</code> 子句</strong></p></li><li><p><strong>若没有匹配的 <code>expect</code>.则异常传递给 <code>try</code></strong> </p></li><li><p><code>except</code> 子句可以同时处理多个异常.以 tuple 的方式进行存放</p></li><li><p>最后一个 <code>except</code> 子句可以忽略异常的名称,将被当作通配符使用</p></li></ul></li><li><p><strong><code>raise</code>: 抛出一个指定的异常</strong></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">raise</span> [Exception [, args [, traceback]]]<br><span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;x 不能为负&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>raise</code> 指定了要被抛出的异常. 必须是一个异常的实例或者是异常的类(Exception 的子类)</li></ul></li><li><p><strong>异常传递: 如果一个异常发生,但没有捕获异常,则传递给调用者处理.若都没处理,最终由系统处理</strong></p></li><li><p><strong>取得原谅比许可更简单(EAFP: easier to ask for forgiveness than permission)</strong></p><ul><li><strong>即直奔主流程,而将意外情况放在异常处理中</strong></li><li>而不是 LBYL(look before you leap): 先进行数据检查,然后进行操作</li></ul></li><li><p><code>with</code>: 用于异常处理,封装了 <code>try - except - finally</code> 编码范式,提高易用性</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用 try</span><br>file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./hello.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br><span class="hljs-keyword">try</span>:<br>    file.write(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><span class="hljs-keyword">finally</span>:<br>    file.close()<br><br><span class="hljs-comment"># 使用 with</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./hello.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(<span class="hljs-string">&#x27;hello,world!&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><p><code>with</code> 语句的实现在于上下文管理器</p></li><li><p><strong>上下文管理器</strong>: 实现了<code>__enter__(), __exit__()</code>的类</p></li></ul></li></ol><h3 id="3-3-自定义异常"><a href="#3-3-自定义异常" class="headerlink" title="3.3 自定义异常"></a>3.3 自定义异常</h3><ol><li><p><strong>异常类继承自 <code>Exception</code> 类</strong></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyError</span>(<span class="hljs-title class_ inherited__">Exception</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):  <span class="hljs-comment"># Exception类默认的 __init__() 被重写</span><br>        <span class="hljs-variable language_">self</span>.value = value<br></code></pre></td></tr></table></figure></li><li><p>若创建一个模块有可能抛出多种不同的异常时</p><ul><li>通常为这个包建立一个基础异常类.然后基于这个基础类为不同的错误情况创建子类</li><li>大多数的异常的名字都以 <code>Error</code> 结尾,就像标准的异常命名</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Error</span>(<span class="hljs-title class_ inherited__">Exception</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InputError</span>(<span class="hljs-title class_ inherited__">Error</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Exception raised for errors in the input.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Attributes:</span><br><span class="hljs-string">        expression -- input expression in which the error occurred</span><br><span class="hljs-string">        message -- explanation of the error</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, expression, message</span>):<br>        <span class="hljs-variable language_">self</span>.expression = expression<br>        <span class="hljs-variable language_">self</span>.message = message<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransitionError</span>(<span class="hljs-title class_ inherited__">Error</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Raised when an operation attempts a state transition that&#x27;s not allowed.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Attributes:</span><br><span class="hljs-string">        previous -- state at beginning of transition</span><br><span class="hljs-string">        next -- attempted new state</span><br><span class="hljs-string">        message -- explanation of why the specific transition is not allowed</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, previous, <span class="hljs-built_in">next</span>, message</span>):<br>        <span class="hljs-variable language_">self</span>.previous = previous<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>        <span class="hljs-variable language_">self</span>.message = message<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-文件"><a href="#3-4-文件" class="headerlink" title="3.4 文件"></a>3.4 文件</h3><ol><li><p><strong><code>open()</code> 方法: 打开一个文件,并返回文件对象.若无法被打开,抛出 <code>OSError</code></strong></p></li><li><p><strong><code>close()</code> 方法: 关闭文件对象.使用 <code>open()</code> 方法打开的文件必须关闭</strong></p></li><li><p>常用 <code>with - as</code> 语句打开文件(此时无需手动关闭文件)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打开名为 &quot;pi_digits.txt&quot; 的文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;pi_digits.txt&#x27;</span>) <span class="hljs-keyword">as</span> fileObject:<br>    <span class="hljs-built_in">print</span>(fileObject.read().rstrip())<br></code></pre></td></tr></table></figure></li><li><p><code>open</code>的完整语法格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">open</span>(file, mode=<span class="hljs-string">&#x27;r&#x27;</span>, buffering=-<span class="hljs-number">1</span>, encoding=<span class="hljs-literal">None</span>, <br>     errors=<span class="hljs-literal">None</span>, newline=<span class="hljs-literal">None</span>, closefd=<span class="hljs-literal">True</span>, opener=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><ul><li><code>file</code>: 文件路径(必须指定)</li><li><code>mode</code>: 文件打开模式</li><li><code>buffering</code>: 设置缓冲</li><li><code>encoding</code>: 指定编码方式,一般为 ‘utf-8’</li><li><code>errors</code>: 报错级别</li><li><code>newline</code>: 区分换行符</li><li><code>closefd</code>: 传入的 <code>file</code> 参数类型</li><li><code>opener</code>: 设置自定义开启器.开启器的返回值必须是一个打开的文件描述符</li></ul></li><li><p><code>mode</code> 参数可以为</p><table><thead><tr><th align="left">模式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>t &#x2F; b</strong></td><td align="left"><strong>文本格式(默认) &#x2F; 二进制格式</strong></td></tr><tr><td align="left"><strong>r &#x2F; w</strong></td><td align="left"><strong>只读模式(默认) &#x2F; 只写模式(若文件已存在,则写入后会从头覆盖,若不存在则创建文件)</strong></td></tr><tr><td align="left"><strong>a</strong></td><td align="left"><strong>追加模式.若文件已存在,则写入内容追加到文件末尾,若不存在则创建文件</strong></td></tr><tr><td align="left">x</td><td align="left">写模式.需先新建文件,若该文件已存在则会报错</td></tr><tr><td align="left"><strong>+</strong></td><td align="left"><strong>打开一个文件进行更新(可读可写)</strong></td></tr></tbody></table><ul><li>打开格式(t, b) 可与 读写方式(r, w, a, x)进行组合,<code>+</code>也可以进行组合</li><li>如<code>wb+</code>: 用二进制格式打开文件进行读写.一般用于非文本文件,如图片</li></ul></li><li><p>file 对象的常用方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>read(size&#x3D;-1)</strong></td><td><strong>读取指定字节数的数据.默认读取整个文件</strong></td></tr><tr><td>readline(size)</td><td>读取整行,包括 <code>&quot;\n&quot;</code>.返回值为读取到的字节数</td></tr><tr><td><strong>readlines()</strong></td><td><strong>读取所有行(直到EOF)并以列表形式返回.可与<code>for - in</code>连用</strong></td></tr><tr><td><strong>write(str)</strong></td><td><strong>将字符串写入文件,返回值为写入的字符长度</strong></td></tr><tr><td>writelines(sequence)</td><td>向文件写入字符串序列(不会自行添加换行符)</td></tr><tr><td>flush()</td><td>刷新缓冲区,将缓冲区中的数据立即写入文件</td></tr><tr><td>tell()</td><td>获取文件指针的当前位置</td></tr><tr><td><strong>seek(offset, whence&#x3D;0)</strong></td><td><strong>移动文件指针到指定位置.并将其作为返回值,失败返回-1<br />whence: 基准位置(0: 文件头,1: 当前位置,2: 文件末尾)<br />offset: 偏移量(可为负数).</strong></td></tr></tbody></table></li><li><p>JSON 数据</p><ul><li><p>json 模块可以对 JSON 数据进行编解码,包含两个函数</p><ul><li><code>json.dumps()</code>: 对数据编码  Python string  -&gt;   JSON Object</li><li><code>json.loads()</code>: 对数据解码   JSON string   -&gt; Python Object</li></ul></li><li><p>Python 编解码为 JSON 对照表</p><table><thead><tr><th>Python</th><th>JSON</th></tr></thead><tbody><tr><td>int, float, int- &amp; float-derived Enums</td><td>number</td></tr><tr><td>True &#x2F; False &#x2F; None</td><td>true &#x2F; false &#x2F; null</td></tr><tr><td>list, tuple</td><td>array</td></tr><tr><td>dict &#x2F; str</td><td>object &#x2F; string</td></tr></tbody></table></li><li><p>示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 写入 JSON 数据.缩进2,可写入中文</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    json.dump(data, f, indent=<span class="hljs-number">2</span>, ensure_ascii=<span class="hljs-literal">False</span>)<br> <br><span class="hljs-comment"># 读取数据</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.json&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    data = json.load(f)<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="4-Python-库"><a href="#4-Python-库" class="headerlink" title="4 Python 库"></a>4 Python 库</h2><h3 id="4-1-标准库概括"><a href="#4-1-标准库概括" class="headerlink" title="4.1 标准库概括"></a>4.1 标准库概括</h3><ol><li><code>os</code> 模块: 提供与操作系统交互的函数</li><li><code>sys</code> 模块:提供与 Python 解释器和系统相关的功能</li><li><code>time</code> 模块: 提供处理时间的函数</li><li><code>datetime</code> 模块: 提供更高级的日期和时间处理函数</li><li><code>random</code> 模块: 提供生成随机数的函数</li><li><code>math</code> 模块: 提供数学函数</li><li><code>re</code> 模块: 提供正则表达式处理函数</li><li><code>json</code> 模块: 提供 JSON 编解码函数.可将 Python 对象转换为 JSON 格式,并从 JSON 格式解析出 Python 对象</li><li><code>urllib</code> 模块: 提供访问网页和处理 URL 的功能.包括下载文件,发送 POST 请求,处理 cookies 等</li></ol><h3 id="4-2-第三方库"><a href="#4-2-第三方库" class="headerlink" title="4.2 第三方库"></a>4.2 第三方库</h3><ol><li><p><strong><a href="https://pypi.org/project/pip/">pip</a>: Python 的包管理工具.提供对 Python 包的查找, 下载, 安装, 卸载功能</strong></p><ul><li><p>配置 <code>pip</code> 从清华源下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure></li><li><p>更新 <code>pip</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pip<br></code></pre></td></tr></table></figure></li><li><p>安装 &#x2F; 升级 &#x2F; 卸载包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install SomePackage            # 最新版本<br>pip install SomePackage==1.0.4     # 指定版本<br>pip install &#x27;SomePackage&gt;=1.0.4&#x27;   # 最小版本<br>pip install --upgrade SomePackage  # 升级包<br>pip uninstall SomePackage          # 卸载包<br></code></pre></td></tr></table></figure></li><li><p>升级 pip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install -U pip               # Linux 环境<br>sudo easy_install --upgrade pip  # 若上一条命令出错可使用<br>python -m pip install -U pip     # Windows 环境<br></code></pre></td></tr></table></figure></li><li><p>其他功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip list                 # 显示已安装的包<br>pip list -o              # 查看可升级的包<br>pip show                 # 显示安装包信息<br>pip show -f SomePackage  # 查找指定包的信息<br>pip search SomePackage   # 搜索包<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>pytest</code>: Python 测试框架.用于代码测试</p></li><li><p><code>pygame</code>: 基于 Python 的游戏开发库</p></li><li><p><code>Matplotlib</code>: Python 2D-绘图领域使用最广泛的套件</p></li><li><p><code>Plotly</code>: 创建漂亮的基于 web 的交互式可视化</p></li></ol><h3 id="4-3-pytest"><a href="#4-3-pytest" class="headerlink" title="4.3 pytest"></a>4.3 pytest</h3><ol><li><p>安装 <code>pytest</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m pip install --user pytest<br></code></pre></td></tr></table></figure></li><li><p>测试函数</p><ul><li><p><strong>文件名必须用 <code>test_</code> 开头或 <code>_test</code> 结尾.而测试函数只能用 <code>test_</code> 开头</strong></p></li><li><p>测试中 <code>pytest</code> 将找出这些文件,并运行其中需要进行测试的函数</p></li><li><p>考虑到测试函数会被 pytest 自动调用.其名称可以起得很长.便于阅读</p></li><li><p>作出断言(<code>assert</code>): 在测试函数中应成立的条件语句,一个函数可以有多个 <code>assert</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_add</span>(): <span class="hljs-comment"># 测试函数</span><br>    <span class="hljs-keyword">assert</span> add(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure></li><li><p>常用的 <code>assert</code> 形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">assert</span> xx：     <span class="hljs-comment"># 判断 xx 为真</span><br><span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> xx： <span class="hljs-comment"># 判断 xx 不为真</span><br><span class="hljs-keyword">assert</span> a <span class="hljs-keyword">in</span> b： <span class="hljs-comment"># 判断 b 包含 a</span><br><span class="hljs-keyword">assert</span> a == b： <span class="hljs-comment"># 判断 a 等于 b</span><br><span class="hljs-keyword">assert</span> a != b： <span class="hljs-comment"># 判断 a 不等于 b</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>在终端窗口执行 <code>pytest</code>.将自动完成测试,并在终端输出测试信息</p><p><img src="/2023/07/01/Computer/Python-Crash-Course/4-Pytest.png"></p></li><li><p>为管理测试函数,还可以将其封装在类中</p></li><li><p>测试类方法时需实例化对象.然后测试过程与测试函数相似</p></li><li><p>夹具(fixture)</p><ul><li><p>使用 <code>@pytest.fixture</code> 装饰函数,使得该函数可以成为其他测试函数的参数</p></li><li><p>其他测试函数可接收该参数(被装饰的函数名)继续测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-string">&quot;&quot;&quot; Dog类有2个属性: name, age.以及对应的 setter 方法 &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-variable language_">self</span>.age = age<br>        <span class="hljs-variable language_">self</span>.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setAge</span>(<span class="hljs-params">self, age</span>):<br>        <span class="hljs-variable language_">self</span>.age = age<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test_class_Dog</span>:<br>    <span class="hljs-string">&quot;&quot;&quot; 将测试函数封装在类中 &quot;&quot;&quot;</span><br><span class="hljs-meta">    @pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;class&quot;</span></span>)</span><br>    <span class="hljs-comment"># scope可为 session -&gt; module(默认) -&gt; class -&gt; function</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dog_object_test</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot; 实例化一个 Dog 对象,将其作为测试用例 &quot;&quot;&quot;</span><br>        dog = Dog(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">return</span> dog<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_set_name</span>(<span class="hljs-params">self, dog_object_test</span>):<br>        <span class="hljs-string">&quot;&quot;&quot; 测试 setName 方法&quot;&quot;&quot;</span><br>        dog_object_test.setName(<span class="hljs-string">&quot;Jerry&quot;</span>)<br>        <span class="hljs-keyword">assert</span> dog_object_test.name == <span class="hljs-string">&quot;Jerry&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_set_age</span>(<span class="hljs-params">self, dog_object_test</span>):<br>        <span class="hljs-string">&quot;&quot;&quot; 测试 setAge 方法 &quot;&quot;&quot;</span><br>        dog_object_test.setAge(<span class="hljs-number">5</span>)<br>        <span class="hljs-keyword">assert</span> dog_object_test.age == <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="5-可视化项目"><a href="#5-可视化项目" class="headerlink" title="5 可视化项目"></a>5 可视化项目</h2><h3 id="5-1-折线图-plot"><a href="#5-1-折线图-plot" class="headerlink" title="5.1 折线图(plot)"></a>5.1 折线图(plot)</h3><ol><li><p>安装 <code>Matplotlib</code>: 在命令行中执行<code>python -m pip install --user matplotlib</code></p></li><li><p>简单折线图(以平方数序列为例)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt  <span class="hljs-comment"># 导包</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_square</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;绘制 x^2 的图像.自变量范围为[0, n]&quot;&quot;&quot;</span><br>    values = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>))          <span class="hljs-comment"># x轴数据</span><br>    squares = [i * i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> values]  <span class="hljs-comment"># y轴数据</span><br>    plt.style.use(<span class="hljs-string">&#x27;seaborn-v0_8&#x27;</span>)      <span class="hljs-comment"># 设置绘图风格</span><br>    fig, ax = plt.subplots(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">9</span>), dpi=<span class="hljs-number">300</span>)<br>    <span class="hljs-comment"># subplots(): 获取绘图对象.绘制 a figure and a set of subplots</span><br>    <span class="hljs-comment"># fig: 生成的整个图形  ax: 图形中的 plot</span><br>    <span class="hljs-comment"># figsize: 指定图像比例  dpi: 指定图像 dpi</span><br>    <br>    ax.set_title(<span class="hljs-string">&quot;Square&quot;</span>, fontsize=<span class="hljs-number">24</span>)   <span class="hljs-comment"># 设置图题</span><br>    ax.set_xlabel(<span class="hljs-string">&quot;x&quot;</span>, fontsize=<span class="hljs-number">14</span>)       <span class="hljs-comment"># 设置 x 轴标签</span><br>    ax.set_ylabel(<span class="hljs-string">&quot;y&quot;</span>, fontsize=<span class="hljs-number">14</span>)       <span class="hljs-comment"># 设置 y 轴标签</span><br>    ax.tick_params(labelsize=<span class="hljs-number">14</span>)          <span class="hljs-comment"># 设置 刻度标记的样式</span><br>    ax.ticklabel_format(style=<span class="hljs-string">&#x27;plain&#x27;</span>)    <span class="hljs-comment"># 使用常规表示法,而非科学计数法</span><br>    ax.axis([<span class="hljs-number">0</span>, n, <span class="hljs-number">0</span>, n*n])               <span class="hljs-comment"># 指定刻度的最大,最小值</span><br>    <span class="hljs-comment"># ax.set_aspect(&#x27;equal&#x27;)              # 保持两轴刻度间距相等</span><br>    <span class="hljs-comment"># 隐藏坐标轴.get_xaxis()获取坐标轴,然后链式调用set_visible()使其隐藏</span><br>    <span class="hljs-comment"># ax.get_xaxis().set_visible(False)</span><br>    <span class="hljs-comment"># ax.get_yaxis().set_visible(False)</span><br>    ax.plot(values, squares, linewidth=<span class="hljs-number">3</span>, color=(<span class="hljs-number">0.8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) <br>    <span class="hljs-comment"># 指定绘图采用的横/纵坐标,线条宽度,线条颜色(0~1的三元组,值越小颜色越深)</span><br>    <span class="hljs-comment"># color 可以直接赋值为 &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;</span><br>    <br>    plt.show()  <span class="hljs-comment"># 打开 Matplotlib 查看器显示绘图</span><br></code></pre></td></tr></table></figure></li><li><p>内置样式</p><ul><li><p>在 Python控制台输入<code>plt.style.available</code>即可查看所有样式</p></li><li><p>运行<code>plot_all_style()</code>,可以绘制出所有的样式.挑选一个顺眼的样式即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_all_style</span>():<br>    squares = [i*i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>)]<br>    <span class="hljs-keyword">for</span> style <span class="hljs-keyword">in</span> plt.style.available:<br>        plt.style.use(style)<br>        fig, ax = plt.subplots()<br>        ax.set_title(style, fontsize=<span class="hljs-number">24</span>)<br>        ax.plot(squares)<br>        plt.show()<br></code></pre></td></tr></table></figure></li></ul></li><li><p>执行 <code>plot_square(5)</code> 将会得到</p><p><img src="/2023/07/01/Computer/Python-Crash-Course/5-plot_square.png"></p></li></ol><h3 id="5-2-散点图-scatter"><a href="#5-2-散点图-scatter" class="headerlink" title="5.2 散点图(scatter)"></a>5.2 散点图(scatter)</h3><ol><li><p>散点图调整样式的方式与折线图一致</p></li><li><p>折线图绘图使用<code>plot()</code>方法,散点图使用<code>scatter()</code>方法.且可以画在同一张图中</p></li><li><p>保存图形</p><ul><li><p>若需要将绘图存储到文件中,只需将<code>plt.show()</code>替换为<code>plt.savefig()</code></p></li><li><p>使用<code>Path</code>对象,可将图片保存到任意地方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.savefig(<span class="hljs-string">&#x27;square_plot.png&#x27;</span>, bbox_inches=<span class="hljs-string">&#x27;tight&#x27;</span>, dpi=<span class="hljs-number">400</span>)<br><span class="hljs-comment"># bbox_inches=&#x27;tight&#x27;: 裁剪掉多余的空白部分</span><br><span class="hljs-comment"># dpi: 提高图片质量</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>散点图可以指定颜色映射: 从起始颜色到结束颜色的颜色序列,突出数据的规律</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">ax.scatter(values, squares, c=squares, cmap=plt.cm.Blues, edgecolors=<span class="hljs-string">&#x27;none&#x27;</span>, s=<span class="hljs-number">3</span>)<br><span class="hljs-comment"># c: 指定染色的依据   # s: 指定点的大小</span><br><span class="hljs-comment"># cmap=plt.cm.Blues: 指定颜色映射的样式</span><br><span class="hljs-comment"># edgecolors=&#x27;none&#x27;: 删除点的轮廓</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="5-3-交互式图形"><a href="#5-3-交互式图形" class="headerlink" title="5.3 交互式图形"></a>5.3 交互式图形</h3><ol><li><p>安装<code>Plotly</code>: 在命令行中执行<code>python -m pip install --user ployly</code></p></li><li><p><code>Plotly</code>可以用于生成交互式图形</p><ul><li>生成的图形可以自动缩放,适合显示在浏览器中</li><li>当用户的鼠标指向特定元素时,将显示有关信息</li></ul></li><li><p>绘制直方图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px<br><br>value = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]  <span class="hljs-comment"># 横轴取值</span><br>frequency = [<span class="hljs-number">155</span>, <span class="hljs-number">167</span>, <span class="hljs-number">168</span>, <span class="hljs-number">170</span>, <span class="hljs-number">159</span>, <span class="hljs-number">181</span>]  <span class="hljs-comment"># 对应的频率</span><br><br>title = <span class="hljs-string">&quot;Results of Rolling One D6 1,000 Times&quot;</span>  <span class="hljs-comment"># 标题信息</span><br>labels = &#123;<span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-string">&#x27;Result&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>: <span class="hljs-string">&#x27;Frequency of Result&#x27;</span>&#125;  <span class="hljs-comment"># 坐标轴标签</span><br>fig = px.bar(x=value, y=frequency, title=title, labels = labels)  <span class="hljs-comment"># 绘制直方图</span><br>fig.update_layout(xaxis_dtick=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 为每个条形都加上标签</span><br>fig.show()  <span class="hljs-comment"># 将直方图渲染成 HTML 文件,并在浏览器中展示</span><br></code></pre></td></tr></table></figure><p><img src="/2023/07/01/Computer/Python-Crash-Course/5-Plotly_Bar_Chart.png"></p></li><li><p><code>Plotly</code> 同样可以绘制折线图和散点图.只需将<code>bar</code>改为<code>line</code>或<code>scatter</code></p></li><li><p>保存图形: 将<code>fig.show()</code>替换为<code>fig.write_html(&#39;filename.html&#39;)</code>即可</p></li></ol><h3 id="5-4-CSV-文件"><a href="#5-4-CSV-文件" class="headerlink" title="5.4 CSV 文件"></a>5.4 CSV 文件</h3><ol><li><p>CSV(comma-separated values): 将数据组织为一系列以<code>,</code>分隔的值<br>如: <code>&quot;USW00025333&quot;,&quot;SITKA AIRPORT, AK US&quot;,&quot;2021-01-01&quot;,,&quot;44&quot;,&quot;40&quot;</code></p></li><li><p>解析 CSV 文件头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">import</span> csv  <span class="hljs-comment"># csv 模块包含于 Python标准库</span><br><br><span class="hljs-comment"># 创建Path对象,指向待使用的文件</span><br>path = Path(<span class="hljs-string">&#x27;weather_data/sitka_weather_2021_simple.csv&#x27;</span>)  <br>lines = path.read_text().splitlines()  <span class="hljs-comment"># 读取文件并按行分隔</span><br>reader = csv.reader(lines)  <span class="hljs-comment"># 创建reader对象</span><br>header_row = <span class="hljs-built_in">next</span>(reader)   <span class="hljs-comment"># 获取第一行的数据,即 CSV 文件头</span><br><span class="hljs-comment"># header_row = [&#x27;STATION&#x27;, &#x27;NAME&#x27;, &#x27;DATE&#x27;, &#x27;TAVG&#x27;, &#x27;TMAX&#x27;, &#x27;TMIN&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p>提取并读取数据.经过对CSV文件头的解析,明晰了每列存储的数据内容(根据下标获取)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br>dates, highs, lows = [], [], []   <span class="hljs-comment"># 用于存储待读取的数据,本例中是最高温度 TMAX</span><br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader:      <span class="hljs-comment"># 在每行中循环读取</span><br>    <span class="hljs-comment"># 读取日期信息 并将其由字符串转化为数据</span><br>    current_date = datetime.strptime(row[<span class="hljs-number">2</span>], <span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>)<br>    dates.append(current_date)  <span class="hljs-comment"># 将读取到的数据加入存储数据的列表</span><br>    high = <span class="hljs-built_in">int</span>(row[<span class="hljs-number">4</span>])  <span class="hljs-comment"># 待读取的数据位于每行的第5列,因而下标为4</span><br>    highs.append(high)  <br>    low = <span class="hljs-built_in">int</span>(row[<span class="hljs-number">5</span>])<br>    lows.append(low)<br></code></pre></td></tr></table></figure></li><li><p>绘制温度图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.style.use(<span class="hljs-string">&#x27;seaborn-v0_8&#x27;</span>)<br>fig, ax = plt.subplots()<br><span class="hljs-comment"># 绘制最低及最高温度的曲线图,alpha指定透明度(0为完全透明)</span><br>ax.plot(dates, highs, color=<span class="hljs-string">&#x27;red&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)<br>ax.plot(dates, lows, color=<span class="hljs-string">&#x27;blue&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)<br>ax.fill_between(dates, highs, lows, facecolor=<span class="hljs-string">&#x27;blue&#x27;</span>, alpha=<span class="hljs-number">0.1</span>)<br><span class="hljs-comment"># 设置图题,坐标轴信息</span><br>ax.set_title(<span class="hljs-string">&quot;Daily High and Low Temperatures,2021&quot;</span>, fontsize=<span class="hljs-number">24</span>)<br>ax.set_xlabel(<span class="hljs-string">&quot;&quot;</span>, fontsize=<span class="hljs-number">14</span>)<br>ax.set_ylabel(<span class="hljs-string">&quot;Temperature(F)&quot;</span>, fontsize=<span class="hljs-number">14</span>)<br>ax.tick_params(labelsize=<span class="hljs-number">14</span>)<br>fig.autofmt_xdate()<br>plt.show()<br></code></pre></td></tr></table></figure></li><li><p>最终效果</p><p><img src="/2023/07/01/Computer/Python-Crash-Course/5-CSV_Line_Chart.png"></p></li></ol><h3 id="5-5-JSON-文件"><a href="#5-5-JSON-文件" class="headerlink" title="5.5 JSON 文件"></a>5.5 JSON 文件</h3><ol><li><p>GeoJSON 格式基于 JSON 的地理空间信息数据交换格式存储.使用 json 模块处理</p></li><li><p>解析 GeoJSON 数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-comment"># 将数据作为字符串读取并转换为 Python 对象</span><br>path = Path(<span class="hljs-string">&#x27;eq_data/eq_data_1_day_m1.geojson&#x27;</span>)<br>contents = path.read_text()<br>all_eq_data = json.loads(contents)<br><span class="hljs-comment"># 将数据文件转换为更易于阅读的版本</span><br><span class="hljs-comment"># path = Path(&#x27;eq_data/eq_data_1_day_m1.geojson&#x27;)</span><br><span class="hljs-comment"># readable_contents = json.dumps(all_eq_data, indent=4)</span><br><span class="hljs-comment"># path.write_text(readable_contents)</span><br></code></pre></td></tr></table></figure></li><li><p>提取数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">all_eq_dicts = all_eq_data[<span class="hljs-string">&#x27;features&#x27;</span>]<br>mags, titles, lons, lats = [], [], [], []  <span class="hljs-comment"># 存储数据的列表</span><br><span class="hljs-comment"># 地震震级 mag 存储于 properties部分的 mag键下</span><br><span class="hljs-keyword">for</span> eq_dict <span class="hljs-keyword">in</span> all_eq_dicts:<br>    mags.append(eq_dict[<span class="hljs-string">&#x27;properties&#x27;</span>][<span class="hljs-string">&#x27;mag&#x27;</span>])<br>    titles.append(eq_dict[<span class="hljs-string">&#x27;properties&#x27;</span>][<span class="hljs-string">&#x27;title&#x27;</span>])<br>    lons.append(eq_dict[<span class="hljs-string">&#x27;geometry&#x27;</span>][<span class="hljs-string">&#x27;coordinates&#x27;</span>][<span class="hljs-number">0</span>])<br>    lats.append(eq_dict[<span class="hljs-string">&#x27;geometry&#x27;</span>][<span class="hljs-string">&#x27;coordinates&#x27;</span>][<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure></li><li><p>绘制震级散点图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>data = pd.DataFrame(<br>    data=<span class="hljs-built_in">zip</span>(lons,lats,titles,mags), columns=[<span class="hljs-string">&#x27;经度&#x27;</span>,<span class="hljs-string">&#x27;纬度&#x27;</span>,<span class="hljs-string">&#x27;位置&#x27;</span>,<span class="hljs-string">&#x27;震级&#x27;</span>]<br>)<br>data.head()<br>fig = px.scatter(<br>    data, x=<span class="hljs-string">&#x27;经度&#x27;</span>, y=<span class="hljs-string">&#x27;纬度&#x27;</span>,<br>    range_x=[-<span class="hljs-number">200</span>, <span class="hljs-number">200</span>], range_y=[-<span class="hljs-number">90</span>, <span class="hljs-number">90</span>],  <span class="hljs-comment"># x,y的取值范围</span><br>    width=<span class="hljs-number">800</span>, height=<span class="hljs-number">800</span>,  <span class="hljs-comment"># 图像的尺寸</span><br>    title=<span class="hljs-string">&quot;全球地震散点图&quot;</span>,<br>    size_max=<span class="hljs-number">10</span>,  <span class="hljs-comment"># 默认标记尺寸为20</span><br>    size=<span class="hljs-string">&#x27;震级&#x27;</span>,  <span class="hljs-comment"># 点的尺寸</span><br>    color=<span class="hljs-string">&#x27;震级&#x27;</span>,  <span class="hljs-comment"># 点的颜色.视觉映射图默认渐变色为 蓝-&gt;红-&gt;黄</span><br>    <span class="hljs-comment"># px.colors.named_colorscales() 可以查看所有的颜色映射</span><br>    color_continuous_scale=<span class="hljs-string">&#x27;bluered&#x27;</span>,  <span class="hljs-comment"># 配置颜色映射. 蓝-&gt;紫-&gt;红</span><br>    hover_name=<span class="hljs-string">&#x27;位置&#x27;</span>,  <span class="hljs-comment"># 设置鼠标悬停时的显示信息</span><br>)<br><span class="hljs-comment"># fig.write_html(&quot;global_earthquakes.html&quot;)</span><br>fig.show()<br></code></pre></td></tr></table></figure></li><li><p>最终效果</p><p><img src="/2023/07/01/Computer/Python-Crash-Course/5-JSON_Scatter_Chart.png"></p></li></ol><h3 id="5-5-可视化仓库"><a href="#5-5-可视化仓库" class="headerlink" title="5.5 可视化仓库"></a>5.5 可视化仓库</h3><ol><li><p>API(application program interface,应用程序接口)是网站的一部分,用于与程序进行交互<br>API 调用: 程序使用具体的 URL 请求特定的信息(这些数据以JSON 或 CSV 的形式返回)<br>使用外部数据源的应用程序大多依赖API调用</p></li><li><p>Git 与 Github</p><ul><li>Git: 分布式版本控制系统.可以跟踪对每个文件的修改,也可以回退到任意一个版本</li><li>Github: 一个让程序员可以协作开发项目的网站,其中的项目都存储于仓库(repository)</li></ul></li><li><p>安装<code>Requests</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m pip install --user requests<br></code></pre></td></tr></table></figure></li><li><p>执行 API 调用并查看响应</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px<br><br><span class="hljs-comment"># url的主要部分: 让api搜索Github上的所有仓库</span><br>url = <span class="hljs-string">&quot;https://api.github.com/search/repositories&quot;</span><br>url += <span class="hljs-string">&quot;?q=language:python+sort:stars+stars:&gt;10000&quot;</span><br><br>headers = &#123;<span class="hljs-string">&quot;Accept&quot;</span>: <span class="hljs-string">&quot;application/vnd.github.v3+json&quot;</span>&#125;  <span class="hljs-comment"># 指定api的版本</span><br>r = requests.get(url, headers=headers)  <span class="hljs-comment"># 调用 api</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Status code: <span class="hljs-subst">&#123;r.status_code&#125;</span>&quot;</span>)  <span class="hljs-comment"># 打印状态码,200表示成功</span><br><br>response_dict = r.json()  <span class="hljs-comment"># 将返回的 JSON 对象转换为 python字典</span><br><span class="hljs-comment"># print(response_dict.keys())  # dict_keys([&#x27;total_count&#x27;, &#x27;incomplete_results&#x27;, &#x27;items&#x27;])</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Complete results: <span class="hljs-subst">&#123;<span class="hljs-keyword">not</span> response_dict[<span class="hljs-string">&#x27;incomplete_results&#x27;</span>]&#125;</span>&quot;</span>)  <span class="hljs-comment"># 查看是否响应完成</span><br><br><span class="hljs-comment"># 处理返回的结果.提取项目链接(包含项目名),stars数</span><br>repo_dicts = response_dict[<span class="hljs-string">&#x27;items&#x27;</span>]<br>repo_links, stars, hover_texts = [], [], []<br><span class="hljs-keyword">for</span> repo_dict <span class="hljs-keyword">in</span> repo_dicts:<br>    repo_name = repo_dict[<span class="hljs-string">&#x27;name&#x27;</span>]  <span class="hljs-comment"># 提取项目名</span><br>    repo_url = repo_dict[<span class="hljs-string">&#x27;html_url&#x27;</span>]  <span class="hljs-comment"># 提取项目链接</span><br>    repo_link = <span class="hljs-string">f&quot;&lt;a href=&#x27;<span class="hljs-subst">&#123;repo_url&#125;</span>&#x27;&gt;<span class="hljs-subst">&#123;repo_name&#125;</span>&lt;/a&gt;&quot;</span>  <span class="hljs-comment"># 格式化链接</span><br>    repo_links.append(repo_link)  <span class="hljs-comment"># 添加链接信息</span><br>    stars.append(repo_dict[<span class="hljs-string">&#x27;stargazers_count&#x27;</span>])  <span class="hljs-comment"># 添加 stars信息</span><br>    <span class="hljs-comment"># 创建悬停文本</span><br>    owner = repo_dict[<span class="hljs-string">&#x27;owner&#x27;</span>][<span class="hljs-string">&#x27;login&#x27;</span>]  <span class="hljs-comment"># 添加拥有者信息</span><br>    description = repo_dict[<span class="hljs-string">&#x27;description&#x27;</span>]  <span class="hljs-comment"># 创建描述信息</span><br>    hover_text = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;owner&#125;</span>&lt;br /&gt;<span class="hljs-subst">&#123;description&#125;</span>&quot;</span>  <span class="hljs-comment"># 格式化提示文本</span><br>    hover_texts.append(hover_text)  <span class="hljs-comment"># 添加描述信息</span><br><br><span class="hljs-comment"># 可视化处理.指定标题,横纵坐标,字体大小,颜色</span><br>title = <span class="hljs-string">&quot;Most-Starred Python Project on Github&quot;</span><br>labels = &#123;<span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-string">&#x27;Repository&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>: <span class="hljs-string">&#x27;Stars&#x27;</span>&#125;<br>fig = px.bar(x=repo_links, y=stars, title=title,<br>             labels=labels, hover_name=hover_texts)<br>fig.update_layout(title_font_size=<span class="hljs-number">28</span>, xaxis_title_font_size=<span class="hljs-number">20</span><br>                  yaxis_title_font_size=<span class="hljs-number">20</span>)<br>fig.update_traces(marker_color=<span class="hljs-string">&#x27;SteelBlue&#x27;</span>, marker_opacity=<span class="hljs-number">0.6</span>)<br>fig.show()<br></code></pre></td></tr></table></figure></li><li><p>最终效果</p><p><img src="/2023/07/01/Computer/Python-Crash-Course/5-Most-Starred_Python_Project_on_Github.png"></p></li></ol><h2 id="附录A-Python-环境"><a href="#附录A-Python-环境" class="headerlink" title="附录A Python 环境"></a>附录A Python 环境</h2><ol><li><p>Windows 环境(<code>pip</code> 会随着 Python 一起安装)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip --version                        # 查看 pip 版本<br>python -m pip install --upgrade pip  # 更新 pip<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一个 .venv 的虚拟环境文件夹.并使用 --upgrade-deps 自动升级 pip 和 setuptools</span><br>python -m venv .venv --upgrade-deps<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">激活指定的虚拟环境, 此时终端(cmd)提示符前会显示 (.venv)</span><br>.\.venv\Scripts\activate<br><span class="hljs-meta prompt_"># </span><span class="language-bash">若出现 Execution Policy 报错,使用 管理员身份打开 PowerShell,运行下面命令</span><br>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force<br></code></pre></td></tr></table></figure></li><li><p>linux 环境: 在 Ubuntu 20.04.6 LTS 中,默认安装 Python2 (<code>python</code>) 和 Python3 (<code>python3</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">python --version   # Python 2.7.18<br>python3 --version  # Python 3.8.10<br><br>sudo apt update<br>sudo apt install python3-pip  # 安装官方仓库的 pip<br>pip3 --version                # 验证安装<br><br>pip3 install virtualenv       # 安装 virtualenv<br>python3 -m virtualenv .venv   # 创建虚拟环境<br>source .venv/bin/activate     # 激活虚拟环境<br></code></pre></td></tr></table></figure></li><li><p>虚拟环境的使用与删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入虚拟环境后安装的第三方库不会影响到其他环境</span><br>pip install numpy<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">退出虚拟环境. 将会退出到默认全局 Python 环境</span><br>deactivate<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除虚拟环境. 只需删除对应的目录文件即可</span><br>rm -rf .venv<br></code></pre></td></tr></table></figure></li><li><p>在 VS Code 中使用虚拟环境</p><ul><li>安装 <code>python</code> 拓展.在状态栏中直接选择 python 虚拟环境</li><li>或 <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>P</kbd> 搜索 <code>Python: Select Interpreter</code>. 选择虚拟环境</li><li>后续 <kbd>Ctrl</kbd><kbd>`</kbd> 打开的终端直接会进入虚拟环境</li></ul></li><li><p>在 PyCharm 中使用虚拟环境: <code>设置</code> -&gt; <code>Python</code> 解释器中进行选择</p><p><img src="/2023/07/01/Computer/Python-Crash-Course/6-virtualenv.png"></p></li></ol><h2 id="附录B-Pycharm-使用"><a href="#附录B-Pycharm-使用" class="headerlink" title="附录B Pycharm 使用"></a>附录B Pycharm 使用</h2><ol><li><p>新建 Python 项目</p><ul><li><p><kbd>新建项目</kbd> -&gt; 在<kbd>位置</kbd>栏选择项目所存放的位置</p></li><li><p>Python 解释器选中 <kbd>先前配置的解释器</kbd>(注意不要选择上面的虚拟环境,导包可能出现问题)</p></li><li><p>若<kbd>解释器</kbd>栏中显示<code>无解释器</code>,点击<kbd>添加解释器</kbd> -&gt; <kbd>系统解释器</kbd>选择合适的解释器</p></li><li><p><kbd>创建 main.py 欢迎脚本</kbd>可以取消勾选</p><p><img src="/2023/07/01/Computer/Python-Crash-Course/5-PyCharm_Create_Project.png"></p></li></ul></li><li><p>Pycharm 基础操作</p><ul><li>新建 Python 文件: 右键左侧的<kbd>pythonProject</kbd> -&gt; <kbd>新建</kbd> -&gt; <kbd>Python 文件</kbd> -&gt; 输入文件名并确认</li><li>运行 Python 代码: 右键文本区域,执行<kbd>运行&#39;main&#39;</kbd>即可执行当前代码</li><li><strong>万能快捷键</strong>: <kbd>Alt</kbd><kbd>Enter</kbd>.可以在不同的场景下实现不同的操作</li><li><strong>随处搜索</strong>: <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>A</kbd>  or  双击<kbd>Shift</kbd>  or  右上角的<kbd>随处搜索</kbd></li><li><kbd>Python 控制台</kbd>: 可以直接输入代码运行,直接与 Python 交互</li></ul></li><li><p>开启&#x2F;关闭 Pycharm 速度太慢的解决方案</p><ul><li>关闭 Pycharm 时一直显示 <strong>正在关闭项目…</strong><br>在<kbd>随处搜索</kbd>中搜索注册表,找到 <code>ide.await.scope.completion</code>,取消勾选即可</li><li>打开 Pycharm 时一直显示 <strong>正在扫描要建立索引的文件</strong><br>设置中的<kbd>工具</kbd> -&gt; <kbd>共享索引</kbd>.将<code>Python 软件包</code>改为<code>不下载,使用本地索引</code></li></ul></li><li><p>调整编辑区字体</p><ul><li><p>右上角的齿轮 -&gt; <kbd>设置</kbd> -&gt; <kbd>编辑器</kbd> -&gt; <kbd>字体</kbd>.调整字体为 <kbd>Consolas</kbd></p></li><li><p>在<kbd>编辑器</kbd> -&gt; <kbd>常规</kbd>中,勾选 <kbd>使用 Ctrl + 鼠标滚轮改动字号</kbd>.方便调整字体大小</p></li></ul></li><li><p>Pycharm 主界面</p><p><img src="/2023/07/01/Computer/Python-Crash-Course/5-PyCharm_Main_Interface.png"></p></li><li><p><strong>安装第三方库</strong></p><ul><li><p>点击左下角的<kbd>终端</kbd>,即可使用 pip 安装第三方库([参考 4.2 第三方库](# 4.2 第三方库))</p></li><li><p>在<kbd>Python软件包</kbd>可以更方便的管理 Python 包,在设置图标(管理仓库)点击<kbd>+</kbd>新建即可</p><p><img src="/2023/07/01/Computer/Python-Crash-Course/5-PyCharm_Python_Package.png"></p><ul><li>由于 pip 下载需要连接国外的网站,下载缓慢.可以找一个国内的镜像网站作为下载源</li><li>清华源: <code>https://pypi.tuna.tsinghua.edu.cn/simple</code></li><li>阿里源: <code>http://mirrors.aliyun.com/pypi/simple</code></li></ul></li><li><p>若出现 <code>Error: Python packaging tool &#39;setuptools&#39; not found</code></p><ul><li>在终端中执行 <code>pip install setuptools</code> 即可</li></ul></li></ul></li><li><p><strong>在左侧的<kbd>学习</kbd>中,可以学习 Python 的 IDE 功能</strong></p><table><thead><tr><th>代码段操作</th><th>操作方式</th></tr></thead><tbody><tr><td>扩展 &#x2F; 收缩代码选区</td><td><kbd>Ctrl</kbd><kbd>W</kbd> &#x2F; <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>W</kbd></td></tr><tr><td>注释 &#x2F; 复制 &#x2F; 删除行</td><td><kbd>Ctrl</kbd><kbd>/</kbd> &#x2F; <kbd>D</kbd> &#x2F; <kbd>Y</kbd></td></tr><tr><td>移动代码段</td><td><kbd>Alt/Ctrl</kbd><kbd>Shift</kbd><kbd>箭头</kbd></td></tr><tr><td>收起 &#x2F; 展开</td><td><kbd>Ctrl</kbd><kbd>-</kbd> &#x2F; <kbd>=</kbd>.<kbd>Shift</kbd>可以增强为选中所有</td></tr><tr><td>包围 &#x2F; 解包</td><td><kbd>Ctrl</kbd><kbd>Alt</kbd><kbd>T</kbd> &#x2F; <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>Delete</kbd></td></tr></tbody></table><table><thead><tr><th>代码补全</th><th>操作方式</th></tr></thead><tbody><tr><td>显式代码补全</td><td><kbd>Ctrl</kbd><kbd>Space</kbd>在选择时按<kbd>Tab</kbd>可以覆盖后面的内容<br /><kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>Space</kbd>调用智能补全</td></tr><tr><td>后缀补全</td><td>键入的内容将自动转换为某种表达式<br />如<code>.ifnn</code>将转换为<code>if XX is not None:</code></td></tr><tr><td><code>F-String</code>补全</td><td>键入<kbd>{</kbd>后再输入变量,可以按 F-String 的形式补全</td></tr></tbody></table><table><thead><tr><th>重构</th><th>操作方式</th></tr></thead><tbody><tr><td>显示所有可用的重构</td><td><kbd>Ctrl</kbd><kbd>Alt</kbd><kbd>Shift</kbd><kbd>T</kbd></td></tr><tr><td>重命名字段</td><td><kbd>Shift</kbd><kbd>F6</kbd></td></tr><tr><td>提取局部变量 &#x2F; 方法</td><td><kbd>Ctrl</kbd><kbd>Alt</kbd><kbd>V</kbd> &#x2F; <kbd>M</kbd></td></tr><tr><td>就地重构</td><td>要给局部变量重命名或给方法添加参数时<br /><kbd>Alt</kbd><kbd>Enter</kbd>展示出 Pycharm 的猜测</td></tr></tbody></table><table><thead><tr><th>代码辅助</th><th>操作方式</th></tr></thead><tbody><tr><td>还原移除的代码</td><td>在编辑器右键,选择<kbd>本地历史记录</kbd>.即可浏览历史修改</td></tr><tr><td>更正代码格式</td><td><kbd>Ctrl</kbd><kbd>Alt</kbd><kbd>L</kbd>.<kbd>Shift</kbd>增强为显示重新格式化设置</td></tr><tr><td>显示形参信息 &#x2F; 文档内容</td><td><kbd>Ctrl</kbd><kbd>P</kbd> &#x2F; <kbd>Q</kbd></td></tr><tr><td>转到下一个高亮显示的错误</td><td><kbd>F2</kbd></td></tr><tr><td>展开警告说明</td><td><kbd>Ctrl</kbd><kbd>F1</kbd></td></tr><tr><td>高亮显示符号的所有用法</td><td><kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>F7</kbd></td></tr></tbody></table><table><thead><tr><th>导航</th><th>操作方式</th></tr></thead><tbody><tr><td>打开<code>在文件中查找 / 替换</code>窗口</td><td><kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>F</kbd> &#x2F; <kbd>R</kbd></td></tr><tr><td>跳转到方法的声明 &#x2F; 查看器所有的用法</td><td><kbd>Ctrl</kbd><kbd>B</kbd></td></tr><tr><td>显示最近打开的文件</td><td><kbd>Ctrl</kbd><kbd>E</kbd>.<kbd>Delete</kbd>可以删除文件历史记录</td></tr></tbody></table></li><li><p>调试程序</p><ul><li><p>若程序并未按照预期执行,可以通过设置断点(点击行号即可)的方式调试程序</p><p><img src="/2023/07/01/Computer/Python-Crash-Course/5-PyCharm_Debug.png"></p></li><li><p>执行代码的方式</p><ul><li>步过 <kbd>F8</kbd>: 执行并越过该行的子函数</li><li>步入 <kbd>F7</kbd>: 进入该行的子函数的源码继续执行</li><li>步出 <kbd>Shift</kbd><kbd>F8</kbd>: 跳出函数体,回到调用该函数的地方</li><li>恢复程序 <kbd>F9</kbd>: 继续执行代码,直到下一断点</li><li>单步执行 <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>F7</kbd>: 步入,但忽略 libraries 的语句</li><li>执行到光标处 <kbd>Alt</kbd><kbd>F9</kbd></li></ul></li><li><p>对表达式求值: 在监视窗口可以对<kbd>表达式求值</kbd>,以及<kbd>添加监视</kbd><br><kbd>Ctrl</kbd><kbd>Alt</kbd><kbd>F8</kbd>可以对光标所在位置的表达式快速求值.还可以结合控制台的输出进行判断<br>找出错误的表达式并进行修改,然后重新运行代码,排除问题</p></li></ul></li><li><p>设置文件模板: <code>编辑器</code> -&gt; <code>文件和代码模板</code> -&gt; <code>Python Script</code></p><p><img src="/2023/07/01/Computer/Python-Crash-Course/5-Python_Script.png"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>Code</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2023/06/02/Tool/Git/"/>
    <url>/2023/06/02/Tool/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1-Git-基础"><a href="#1-Git-基础" class="headerlink" title="1 Git 基础"></a>1 <a href="https://www.bilibili.com/video/BV1HM411377j/?spm_id_from=333.1387.favlist.content.click">Git 基础</a></h2><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><ol><li><p>git 安装</p><ul><li><p>在 <a href="https://git-scm.com/download">git 官网</a> 下载对应系统的安装包.一直下一步安装即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git --version  <span class="hljs-comment"># 验证安装</span><br></code></pre></td></tr></table></figure></li><li><p>在 Windows 中,会自动安装 <code>Git Bash</code>(在文件夹中右键即可看到)</p></li></ul></li><li><p>git 的使用方式分为</p><ul><li>命令行(最基本,最常见)</li><li>图形化界面(GUI)</li><li>IDE 插件&#x2F;扩展(推荐使用 VS Code 中的 git 插件)</li></ul></li><li><p>初始化操作</p><ul><li><p><strong>git 的所有命令均以 <code>git</code> 开头,后面再接具体的命令.如: <code>git init</code> 表示初始化仓库</strong></p></li><li><p>git 安装后需要进行配置用户名和邮箱,以便查看代码提交者(只需设置一次)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;user&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;email&quot;</span><br>git config --list  <span class="hljs-comment"># 检查配置是否成功</span><br></code></pre></td></tr></table></figure></li><li><p>如果用户名参数包含空格,则需要使用双引号包裹</p></li><li><p><code>--global</code> 表示全局配置,对所有仓库有效.如果省略则表示本地配置,只对本地仓库有效</p></li></ul></li><li><p>新建仓库</p><ul><li><p>仓库 &#x2F; 版本库(Repository, 简称 Reop): 是一个文件目录,其中的文件被 <code>git</code> 管理</p></li><li><p>对仓库中文件的 修改, 删除, 添加操作都将被 <code>git</code> 追踪</p></li><li><p><strong>本地创建仓库</strong>: 此时 <code>git</code> 将会创建一个 <code>.git</code> 的隐藏目录.用于存放仓库的数据(不要自己更改其中的内容)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure></li><li><p><strong>从服务器克隆仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> url<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-2-概念"><a href="#1-2-概念" class="headerlink" title="1.2 概念"></a>1.2 概念</h3><ol><li><p>工作区域</p><ul><li><p><strong>工作目录(Working Directory)</strong>: 实际操作的目录</p></li><li><p><strong>暂存区(Staging Area&#x2F;Index)</strong>: 临时存储区域.保存即将提交到 <code>git</code> 仓库的修改内容</p></li><li><p><strong>本地仓库(Local Repository)</strong>: 存储代码和版本信息的主要位置.包含完整的项目历史和元数据</p><p><img src="/2023/06/02/Tool/Git/1-Git-workingArea.png"></p></li></ul></li><li><p>提交流程</p><ul><li><p>在对工作目录的文件进行修改后,需要先提交到暂存区,然后将暂存区的修改提交到本地仓库</p></li><li><p>在上述过程中,可以使用 <code>git</code> 命令进行查看, 比较, 撤销修改</p></li><li><p><strong>添加(git add): 从工作目录 -&gt; 暂存区</strong></p></li><li><p><strong>提交(git commit): 从暂存区 -&gt; 本地仓库</strong></p></li><li><p>在多次添加到暂存区后,到达需要增加版本的地步,就可以进行提交(push)</p></li></ul></li><li><p>文件状态</p><ul><li><p><strong>未跟踪(Untrack)</strong>: 新创建的,未被 <code>git</code> 管理的文件</p></li><li><p><strong>未修改(Unmodified)</strong>: 已经被 <code>git</code> 管理,但内容没有变化</p></li><li><p><strong>已修改(Modified)</strong>: 修改了文件,但未添加到暂存区</p></li><li><p><strong>已暂存(Staged)</strong>: 修改后,并添加到暂存区的文件</p><p><img src="/2023/06/02/Tool/Git/1-Git-fileState.png"></p></li></ul></li></ol><h3 id="1-3-提交"><a href="#1-3-提交" class="headerlink" title="1.3 提交"></a>1.3 提交</h3><ol><li><p>查看状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log    # 查看提交记录.包含: 提交 ID, 作者, 时间, 备注信息<br>git status # 查看目录中的文件的状态<br></code></pre></td></tr></table></figure></li><li><p>添加: 将指定的文件添加到暂存区(会排除 <code>.gitignore</code> 中匹配的文件)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add &lt;filename&gt; # 添加指定文件(无论是修改, 新建, 删除均使用 add 暂存)<br>git add .          # 添加当前目录及其所有子目录下的所有新文件和已修改文件<br></code></pre></td></tr></table></figure></li><li><p>提交: 将暂存区中的修改提交到本地仓库(注意不会提交工作目录的文件)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m &quot;message&quot; # 提交并直接在命令行中提供提交信息的标题<br>git commit --amend      # 修改提交信息 或 添加遗漏的文件<br></code></pre></td></tr></table></figure></li><li><p>版本穿梭</p><p><img src="/2023/06/02/Tool/Git/1-Git-Reset.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --&lt;mode&gt; &lt;commit&gt; # 穿梭到指定的 commit 版本<br></code></pre></td></tr></table></figure><ul><li><p><strong><code>git reset</code> 本质上是移动当前分支所指向的提交(即 <code>HEAD</code> 指针)到指定的历史提交</strong></p><table><thead><tr><th>mode 参数</th><th>效果</th></tr></thead><tbody><tr><td><code>soft</code></td><td>自 <code>&lt;commit&gt;</code> 后的提交在提交历史中暂时消失(可以通过 <code>git relog</code> 找回).<br />之前提交的所有修改(相对于 <code>&lt;commit&gt;</code> 的改动)都变成了 <strong>已暂存的更改</strong>.<br />不影响暂存区,也不影响工作目录</td></tr><tr><td><code>mixed</code>(默认参数)</td><td>自 <code>&lt;commit&gt;</code> 后的提交在提交历史中暂时消失.<br />之前提交的所有修改(相对于 <code>&lt;commit&gt;</code> 的改动)都变成了 <strong>未暂存的更改</strong>.<br />重置暂存区,但不影响工作目录</td></tr><tr><td><code>hard</code>(极其危险)</td><td>自 <code>&lt;commit&gt;</code> 以来的所有后续提交在提交历史中暂时消失.<br />暂存区被清空,工作目录中所有未提交(包括未暂存和已暂存)的更改都会被永久丢弃</td></tr></tbody></table></li><li><p><code>commit</code> 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset a1b2c3d # 提交的哈希值.通常只需要前 7 个字符就足够唯一标识<br>git reset main    # 分支名.表示重置到该分支当前指向的提交<br>git reset v1.0    # 标签名.表示重置到该标签指向的提交<br>git reset HEAD    # 表示当前提交<br>git reset HEAD~n  # 表示当前提交的第 n 个提交<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>soft</code> 最佳实践: 多次 <code>commit</code> 后,想要将其合并为一次 <code>commit</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --soft &lt;commit&gt; # 先回退到修改前的 commit,此时所有的改动都回到暂存区<br>git add                   # 如果存在遗漏继续添加,否则不需要该步骤<br>git commit -m &quot;message&quot;   # 再次提交,此时先前的多个提交变成一次提交<br></code></pre></td></tr></table></figure></li><li><p><code>mixed</code> 最佳实践: 提交了不需要的东西,想撤销这些提交,但工作目录中实际修改的代码仍需保留</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset HEAD~1 # 撤销最新一次 commit.但提交的修改以未暂存的状态保留到工作目录<br>git reset file   # 撤销特定文件的 add.但保留文件在工作目录的修改<br></code></pre></td></tr></table></figure></li><li><p><code>hard</code> 最佳实践: 确保不需要工作目录和暂存区中未提交的修改情况下使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard HEAD # 丢弃所有未提交修改<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-4-差异"><a href="#1-4-差异" class="headerlink" title="1.4 差异"></a>1.4 差异</h3><ol><li><p><strong>查看差异</strong>: 后续可以使用 IDE 更美观地查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff           <span class="hljs-comment"># 工作目录 vs 暂存区</span><br>git diff HEAD      <span class="hljs-comment"># 工作目录 + 暂存区 vs 本地仓库</span><br>git diff --cached  <span class="hljs-comment"># 暂存区 vs 本地仓库</span><br>git diff --staged  <span class="hljs-comment"># 暂存区 vs 本地仓库</span><br><br>git diff &lt;commit_hash&gt; &lt;commit_hash&gt;  <span class="hljs-comment"># 比较指定两次提交的差异</span><br>git diff HEAD~ HEAD                   <span class="hljs-comment"># 上一次提交 vs 本地仓库</span><br>git diff &lt;branch_hash&gt; &lt;branch_hash&gt;  <span class="hljs-comment"># 比较两个分支的差异</span><br></code></pre></td></tr></table></figure><p><img src="/2023/06/02/Tool/Git/1-Git-diff.png"></p></li><li><p><strong>删除文件</strong>: 删除工作目录和暂存区中的指定文件.但版本库不变</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> &lt;filename&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>忽略文件</strong>: 通过 <code>.gitignore</code> 文件来指定忽略特定的文件</p><p><img src="/2023/06/02/Tool/Git/1-Gitignore.png"></p><ul><li>新建一个 <code>.gitignore</code> 文件,在其中存储想要被忽略的文件名</li><li>会从上往下逐行匹配,每行表示一个忽略模式</li></ul></li><li><p><strong><code>.gitignore</code> 匹配规则: 使用标准的 Blob 模式匹配</strong></p><ul><li>文件可以使用通配符.如 <code>*.log</code> 表示忽略所有后缀为 log 的文件</li><li>文件夹需要以 <code>/</code> 结尾</li><li>以 <code>#</code> 开头的行表示注释</li></ul></li></ol><h3 id="1-5-分支"><a href="#1-5-分支" class="headerlink" title="1.5 分支"></a>1.5 分支</h3><ol><li><p>分支(Branch): 代码的不同版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch           # 查看分支信息.结果中 * 表示当前所处的分支<br>git branch &lt;name&gt;    # 创建新分支.创建新分支后并不会自动切换分支<br>git branch -d &lt;name&gt; # 删除指定的已合并分支(安全删除,因为必须已合并到其他分支才能被删除)<br>git switch &lt;name&gt;    # 切换分支.同时工作目录的文件会被自动替换为目标分支的状态<br>git merge &lt;name&gt;     # 将指定分支合并到当前分支.该指令会执行一次提交,因此需要输入提交信息<br>git log --graph --oneline --decorate --all # 查看分支图<br></code></pre></td></tr></table></figure></li><li><p>合并冲突</p><ul><li><strong>当合并分支时,出现同一文件被不同分支修改时,会出现冲突,需要手动解决冲突</strong></li><li>此时,使用 <code>git status</code> 命令查看冲突文件的列表.<code>git diff</code> 可以查看冲突的具体内容</li></ul></li><li><p>变基(Rebase)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rebase main # 将当前分支变基到 main 分支<br></code></pre></td></tr></table></figure><ul><li>每个分支都有一个 <code>HEAD</code> 指针,指向当前分支的最新提交记录</li><li>当执行变基时,将寻找两个分支的共同的祖先节点</li><li>然后将当前分支的祖先节点之后的提交移植到目标分支的后面</li><li>变基使得分支始终保持简单的线性结构.但破坏了原分支的提交记录.不要在公共分支 <code>rebase</code></li><li>分支合并不会破坏提交记录,方便回溯.但产生了额外的节点</li></ul></li></ol><h3 id="1-6-最佳实践"><a href="#1-6-最佳实践" class="headerlink" title="1.6 最佳实践"></a>1.6 最佳实践</h3><ol><li><p>保证 <code>master</code> 分支中的代码是可发布的.不允许直接修改,只能合并,每当合并时生成一个版本号</p><p><img src="/2023/06/02/Tool/Git/1-Git-GitHubFlow.png"></p></li><li><p>case1: 接到开发 cpu 的需求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout &lt;main&gt;                 # 1.确保在待开发的分支上.以 main 分支为例<br>git pull origin &lt;main&gt;              # 2.确保更新到最新版本<br>git checkout -b &lt;feature/cpu-test&gt;  # 3.创建 cpu 开发分支<br><br>git add .                           # 4.进行开发工作.修改文件,添加功能等<br>git commit -m &quot;update cpu&quot;          # 5.测试完成后在本地提交<br><br>git checkout &lt;main&gt;                 # 6.完成对 cpu 的开发后,返回 main 分支<br>git pull origin &lt;main&gt;              # 7.再次更新 main 分支到最新.如果存在冲突需手动解决<br>git merge --squash feature/cpu-test # 8.将 cpu 分支的所有变更压缩成一个提交合并到 main 分支<br>git commit -m &quot;complete cpu test&quot;   # 9.提交到本地 main 分支<br>git push origin main                # 10.推送到远程仓库<br></code></pre></td></tr></table></figure></li><li><p>case2: 在上面开发 cpu 的第 4 或 5 步时可能接收到紧急任务,如需要开发 gpu 驱动.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">git stash push -u -m &quot;cpu developing&quot; # 1. 暂存所有未提交的修改(包括已跟踪和未跟踪文件)<br>git stash list                        # 2. 验证暂存列表<br>git checkout &lt;main&gt;                   # 3. 切换到 main 分支<br>git pull origin &lt;main&gt;                # 4. 确保更新到最新版本<br>git checkout -b &lt;feature/gpu-test&gt;    # 5. 创建并切换到干净的 gpu 开发分支<br><br>git add drivers/gpu/                  # 6.模拟本地对文件的修改<br>git commit -m &quot;update gpu&quot;            # 7.测试完成后在本地提交<br>git checkout &lt;main&gt;                   # 8.完成对 gpu 的开发后,返回 main 分支<br>git pull origin &lt;main&gt;                # 9.更新 main 分支到最新<br>git merge --squash feature/gpu-test   # 10.将 gpu 分支的所有变更压缩成一个提交合并到 main 分支<br>git commit -m &quot;complete cpu test&quot;     # 11.提交到本地 main 分支<br>git push origin main                  # 12.推送到远程仓库<br>git branch -d feature/gpu-test        # 13.删除已合并的本地 gpu 开发分支<br><br>git checkout feature/cpu-test         # 14.回到 cpu 开发分支,继续开发<br>git stash pop                         # 15.恢复工作现场<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-GitHub-Pages"><a href="#2-GitHub-Pages" class="headerlink" title="2 GitHub Pages"></a>2 GitHub Pages</h2><h3 id="2-1-关联-github"><a href="#2-1-关联-github" class="headerlink" title="2.1 关联 github"></a>2.1 关联 github</h3><ol><li><p>要关联本地仓库与远程仓库,首先需要设置 SSH 密钥</p><ul><li><p>检查主机是否已经存在 ssh key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls ~/.ssh/id_rsa.pub  # 查看是否已经生成过密钥 id_rsa(私钥) id_rsa.pub(公钥)<br>cat ~/.ssh/id_rsa.pub # 查看生成的密钥(复制输出的内容.以 ssh-rsa AAA... 开头)<br></code></pre></td></tr></table></figure></li><li><p>如果没有 ssh key.则需要先生成(如果有 ssh key.则直接获取)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~/.ssh                 # 切换到.ssh目录<br>ssh-keygen -t rsa -b 4096 # 生成 rsa 密钥,大小为 4096<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在 GitHub 账号中添加公钥</p><ul><li><p>回到 GitHub,点击头像 -&gt; <code>Settings</code> -&gt; <code>SSH and GPG keys</code> -&gt; <code>New SSH key</code></p><p><img src="/2023/06/02/Tool/Git/1-Git-github-sshkey.png"></p></li><li><p>将 <code>id_rsa.pub</code> 文件中的内容复制到 Key 中即可</p></li><li><p>验证设置是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br><span class="hljs-meta prompt_"># </span><span class="language-bash">成功将显示: Hi Fxs21! You<span class="hljs-string">&#x27;ve successfully authenticated...</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>完成 SSH 的设置后,可以直接使用 SSH 进行 <code>git clone</code> 操作</p></li><li><p>本地仓库和远程仓库是不同的仓库.想要将两者的文件同步.需要 <code>git pull, git push</code> 指令</p><p><img src="/2023/06/02/Tool/Git/1-Git-push.png"></p></li><li><p>此时,完成了关联本地仓库与远程仓库的准备工作</p></li><li><p>在 github 上创建一个新仓库.然后进行操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add &lt;shortname&gt; &lt;url&gt; # 将本地仓库关联到远程仓库.同时创建了远程库的别名<br>git remote -v # 查看当前仓库对应的远程仓库的别名和地址(默认 shortname == origin)<br>git branch -M main # 指定分支名为 main<br>git push -u origin main # 将本地的 main 分支与远程仓库 origin 的 main 分支关联.并推送<br>git pull # 拉取远程仓库中的分支.默认为 origin 的 main 分支<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-创建-Pages"><a href="#2-2-创建-Pages" class="headerlink" title="2.2 创建 Pages"></a>2.2 创建 Pages</h3><ol><li><p><a href="https://github.com/">github</a>: 代码托管平台</p></li><li><p>创建仓库: 名称格式为 <code>username.github.io</code></p><p><img src="/2023/06/02/Tool/Git/1-Git-githubCreateRepo.png"></p></li><li><p>在 <code>settings</code> 中找到 <code>Pages</code>.此时 <code>Source</code> 为空.因此需要上传静态页面</p></li><li><p>拉取代码到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone git@github.com:Fxs21/Fxs21.github.io.git<br></code></pre></td></tr></table></figure></li><li><p>上传代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加 git@github.com:Fxs21/Fxs21.github.io.git 远程仓库. 别名为 origin</span><br>git remote add origin git@github.com:Fxs21/Fxs21.github.io.git<br><br>git remote -v             # 检查是否已经添加了远程仓库<br>ssh -T git@github.com     # 测试 SSH 连接<br>git push -u origin master # 提交代码.并建立本地分支与远程分支的跟踪关系<br>git pull                  # 等同于 git pull origin master<br></code></pre></td></tr></table></figure></li><li><p>此时再次进入 github. 在 <code>settings</code> 中找到 <code>Pages</code>.此时 <code>Source</code> 就有了 <code>master</code> 分支</p><p><img src="/2023/06/02/Tool/Git/2-Git-githubSource.png"></p></li><li><p>显示 Your site is live at <a href="https://fxs21.github.io/">https://fxs21.github.io/</a>: 表示成功部署可以在网页中打开</p></li></ol><h2 id="3-hexo"><a href="#3-hexo" class="headerlink" title="3 hexo"></a>3 hexo</h2><h3 id="3-1-安装-hexo"><a href="#3-1-安装-hexo" class="headerlink" title="3.1 安装 hexo"></a>3.1 安装 <a href="https://hexo.io/zh-cn/">hexo</a></h3><ol><li><p>安装 <code>git</code> 并配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;fxs&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;yshuang68@163.com&quot;</span><br>git config --list<br></code></pre></td></tr></table></figure></li><li><p>安装 NodeJS: <a href="https://nodejs.org/en">官网下载</a>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">node -v  # 验证安装<br>npm config set prefix &quot;D:\code\npm_path&quot;  # 配置 npm 的全局安装路径<br></code></pre></td></tr></table></figure></li><li><p>安装 <code>hexo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g  <span class="hljs-comment"># 安装 hexo</span><br>hexo -v                  <span class="hljs-comment"># 验证安装</span><br></code></pre></td></tr></table></figure></li><li><p>初始化 <code>hexo</code>(新建一个空目录,然后使用 <code>git bash</code> 打开)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init  <span class="hljs-comment"># 从 github 拉取代码</span><br>git init   <span class="hljs-comment"># 初始化 git 仓库</span><br></code></pre></td></tr></table></figure></li><li><p><code>hexo</code> 的 hello world</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s<br></code></pre></td></tr></table></figure><ul><li><p>打开网址 <a href="http://localhost:4000/">http://localhost:4000/</a>. 能看到 hello world 网页表示配置成功</p><p><img src="/2023/06/02/Tool/Git/3-hexo-hello-world.png"></p></li></ul></li></ol><h3 id="3-2-hexo-部署"><a href="#3-2-hexo-部署" class="headerlink" title="3.2 hexo 部署"></a>3.2 hexo 部署</h3><ol><li><p>配置 SSH 免密登录</p><ul><li><p>先检查是否已经生成过密钥(<code>PowerShell </code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls ~/.ssh/id_rsa.pub  # 查看是否已经生成过密钥 id_rsa(私钥) id_rsa.pub(公钥)<br>cat ~/.ssh/id_rsa.pub # 查看生成的密钥(复制输出的内容.以 ssh-rsa AAA... 开头)<br></code></pre></td></tr></table></figure></li><li><p>若没有生成过则生成密钥(默认保存路径为 <code>C:\Users\你的用户名\.ssh\id_rsa</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -b 4096<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在 GitHub 上添加公钥(参考 [1.7章](# 1.7 关联 github 仓库))</p></li><li><p>安装部署插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li><li><p>配置 hexo 上传的地址(打开 <code>_config.yml</code> 文件,在最后添加内容.<strong>注意这里的配置决定了仓库地址</strong>)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">&#x27;git&#x27;</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:Fxs21/Fxs21.github.io.git</span><br></code></pre></td></tr></table></figure></li><li><p>使用 hexo 命令将代码部署到远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl <span class="hljs-comment"># 清除文件</span><br>hexo g  <span class="hljs-comment"># 生成静态文件.路径为 ./public/</span><br>hexo d  <span class="hljs-comment"># 上传到服务器</span><br></code></pre></td></tr></table></figure></li><li><p>对于调试不需要生成静态文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo cl &amp;&amp; hexo s<br></code></pre></td></tr></table></figure></li><li><p>hexo 文章按照 <code>date</code> 字段(建立日期)排序.下面是 Windows 中修改创建日期的指令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">(<span class="hljs-built_in">Get-Item</span> <span class="hljs-string">&quot;文件路径&quot;</span>).CreationTime = <span class="hljs-string">&quot;新时间&quot;</span>  <span class="hljs-comment"># 修改单个文件的创建时间</span><br>(<span class="hljs-built_in">Get-Item</span> <span class="hljs-string">&quot;文件路径&quot;</span>).CreationTime.ToString(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>) <span class="hljs-comment"># 查看创建时间</span><br><br><span class="hljs-comment"># 示例: 将 D:\blog\post.md 创建时间设为 2023-01-01 12:00</span><br>(<span class="hljs-built_in">Get-Item</span> <span class="hljs-string">&quot;D:\blog\post.md&quot;</span>).CreationTime = <span class="hljs-string">&quot;2023-01-01 12:00&quot;</span><br><br><span class="hljs-comment"># 批量修改文件夹内所有文件</span><br><span class="hljs-built_in">Get-ChildItem</span> <span class="hljs-string">&quot;文件夹路径&quot;</span> | <span class="hljs-built_in">ForEach-Object</span> &#123; <span class="hljs-variable">$_</span>.CreationTime = <span class="hljs-string">&quot;新时间&quot;</span> &#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-3-hexo-配置"><a href="#3-3-hexo-配置" class="headerlink" title="3.3 hexo 配置"></a>3.3 hexo 配置</h3><ol><li><p><strong>更换主题</strong>: 在 <a href="https://hexo.io/themes/">Themes | Hexo</a> 选择合适的主题.这里以 <code>Fluid</code> 为例,根据 <a href="https://github.com/fluid-dev/hexo-theme-fluid">参考文档</a> 安装</p><ul><li><p>安装 <code>Fluid</code> 主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure></li><li><p>在博客目录下创建 <code>_config.fluid.yml</code> 文件</p></li><li><p>将 <code>./node_modules/hexo-theme-fluid/_config.yml</code> 的内容复制到 <code>_config.fluid.yml</code> 文件</p></li><li><p>更改默认的主题: 打开 <code>_config.yml</code> 文件,修改 <code>theme, language</code> 项</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>     <span class="hljs-comment"># 指定主题</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CH</span>  <span class="hljs-comment"># 指定语言</span><br></code></pre></td></tr></table></figure></li><li><p>创建关于页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about<br></code></pre></td></tr></table></figure></li><li><p>在 <code>./source/about/index.md</code> 文件中添加一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">layout: about<br></code></pre></td></tr></table></figure></li></ul></li><li><p>工作目录(初始化之后的目录)</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br><span class="hljs-string">|   ├── _drafts</span><br><span class="hljs-string">|   └── _posts</span><br>└── themes<br></code></pre></td></tr></table></figure><ul><li><strong><code>_config.yml</code>: 网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 文件.可以在此配置大部分的参数</strong></li><li><code>package.json</code>: 应用程序的信息. <a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> 渲染引擎 已默认安装</li><li><code>scaffolds</code>: 模板文件夹.新建文章时根据此文件创建</li><li><strong><code>source</code>: 存放用户资源</strong><ul><li>除 <code>_posts</code> 文件夹之外,开头命名为 <code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略</li><li>Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹,而其他文件会被拷贝过去</li></ul></li><li><code>themes</code>: 主题文件夹.Hexo 会根据主题来生成静态页面</li></ul></li><li><p><strong>站点配置</strong>: Hexo 博客目录下的 <code>_config.yml</code> 文件</p><ul><li><p>站点名称</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Shuang</span> <span class="hljs-string">blog</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">&#x27;Shuang blog&#x27;</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;Shuang blog&#x27;</span><br><span class="hljs-attr">keywords:</span> <span class="hljs-string">Shuang</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">Shuang</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">&#x27;Asia/Shuanghai&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>资源文件夹</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ul><li>启用后,资源图片将会被自动解析为其对应文章的路径</li><li>如: <code>image.jpg</code> 位置为 <code>/2020/01/02/foo/image.jpg</code>.表示是 <code>/2020/01/02/foo/</code> 文章的一张图片</li><li><code>![](image.jpg)</code> 将会被解析为 <code>&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt;</code></li></ul></li></ul></li></ol><h3 id="3-4-Fluid-主题"><a href="#3-4-Fluid-主题" class="headerlink" title="3.4 Fluid  主题"></a>3.4 <a href="https://hexo.fluid-dev.com/docs/start/">Fluid </a> 主题</h3><ol><li><p>配置文件的修改</p><ul><li><strong>主题配置</strong>: <code>theme/fluid/_config.yml</code> 或者 <code>_config.fluid.yml</code> 文件</li></ul></li><li><p>Fluid 主题默认总体概览</p><p><img src="/2023/06/02/Tool/Git/3-fluid-appearance.png"></p></li><li><p>主题字体</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 主题字体配置</span><br><span class="hljs-attr">font:</span><br>  <span class="hljs-attr">font_size:</span> <span class="hljs-string">16px</span><br>  <span class="hljs-attr">font_family:</span> <span class="hljs-string">consolas</span>  <span class="hljs-comment"># 使用 consolas 字体</span><br>  <span class="hljs-attr">letter_spacing:</span> <span class="hljs-number">0.</span><span class="hljs-string">02em</span><br>  <span class="hljs-attr">code_font_size:</span> <span class="hljs-number">85</span><span class="hljs-string">%</span><br></code></pre></td></tr></table></figure></li><li><p>导航栏左侧标题(默认为 <code>Fluid</code>)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">blog_title:</span> <span class="hljs-string">&quot;windsand&quot;</span>  <span class="hljs-comment"># 将会以文本的形式显示</span><br></code></pre></td></tr></table></figure></li><li><p>首页背景图以及 slogan 文本</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">index:</span><br>  <span class="hljs-comment"># 首页 Banner 头图,可以是相对路径或绝对路径,以下相同</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/train.png</span>  <span class="hljs-comment"># 首页背景图.注意要自己存放图片资源到路径</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">100</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br>  <span class="hljs-comment"># 首页副标题的独立设置</span><br>  <span class="hljs-attr">slogan:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">text:</span> <span class="hljs-string">&quot;人生如逆旅,我亦是行人&quot;</span>  <span class="hljs-comment"># 首页 slogan</span><br></code></pre></td></tr></table></figure></li><li><p>文章页背景图(归档页, 分类页, 标签页, 关于页, 自定义页, 404 页, 友链页 同理)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/train.png</span>  <span class="hljs-comment"># 与上面的首页背景图配置方法相同</span><br></code></pre></td></tr></table></figure></li><li><p>文章内数学公式</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">math:</span><br>  <span class="hljs-comment"># 开启后文章默认可用,自定义页面如需使用,需在 Front-matter 中指定 math: true</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>   <br>  <span class="hljs-comment"># 开启后,只有在文章 Front-matter 里指定 math: true 才会在文章页启动公式转换</span><br>  <span class="hljs-comment"># 以便在页面不包含公式时提高加载速度</span><br>  <span class="hljs-attr">specific:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-5-文章属性"><a href="#3-5-文章属性" class="headerlink" title="3.5 文章属性"></a>3.5 文章属性</h3><ol><li><p>以本文为例,在 <code>front-matter</code> 中编写内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">typora-root-url:</span> <span class="hljs-string">./Git</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Git</span> <span class="hljs-string">使用</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Git</span>, <span class="hljs-string">工具箱</span>, <span class="hljs-string">笔记</span>, <span class="hljs-string">Code</span>]<br><span class="hljs-attr">categories:</span> <span class="hljs-string">工具箱</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">|</span><br><span class="hljs-string">  - Git 的使用方式介绍;</span><br><span class="hljs-string">  - GitHub Pages 页面的配置方法;</span><br><span class="hljs-string">  - 在 IDE 中使用 Git;</span><br><span class="hljs-string">  - hexo 的安装使用;</span><br><span class="hljs-string">  * typora 的配置;</span><br><span class="hljs-string">  * MarkDown 语法.</span><br><span class="hljs-string"></span><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/Git.svg</span><br><span class="hljs-attr">math:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><img src="/2023/06/02/Tool/Git/3-Hexo-front-matter.png"></p></li><li><p><code>typora-root-url</code>: typora 中图片的根目录</p></li><li><p><code>title</code>: 文章的标题.将会在主页中显示</p></li><li><p><code>tags</code>: 文章的标签.将会在主页中显示,点击可以跳转.一篇文章可以有多个 tag</p></li><li><p><code>categories</code>: 文章的类别.分类下面可以有多篇文章</p></li><li><p><code>excerpt</code>: 文章的摘要</p></li><li><p><code>index_img</code>: 文章封面图的路径.本示例的路径为 <code>./source/img/Git.svg</code></p></li></ol><h2 id="4-typora"><a href="#4-typora" class="headerlink" title="4 typora"></a>4 typora</h2><h3 id="4-1-typora-配置"><a href="#4-1-typora-配置" class="headerlink" title="4.1 typora 配置"></a>4.1 typora 配置</h3><ol><li><p><strong>为了与 hexo 部署兼容(主要是图片存放路径),对 typora 进行配置</strong></p><ul><li><p>文件 -&gt; 偏好设置 -&gt; 图像 -&gt; 插入图片时 -&gt; 复制到指定路径 <code>./$&#123;filename&#125;</code></p><p><img src="/2023/06/02/Tool/Git/5-typora-image-setting.png"></p></li><li><p>格式 -&gt; 图像 -&gt; 设置图片根目录 -&gt; 将 <code>./$&#123;filename&#125;</code> 目录设置为根目录</p></li></ul></li><li><p>图片命令不要包含中文或空格.否则可能显示异常</p></li><li><p>为了更好的结构化管理,图片命名时前缀加上图片所在的章节</p></li></ol><h3 id="4-2-MarkDown"><a href="#4-2-MarkDown" class="headerlink" title="4.2 MarkDown"></a>4.2 MarkDown</h3><h3 id="待完成"><a href="#待完成" class="headerlink" title="&#x3D;&#x3D;待完成&#x3D;&#x3D;"></a>&#x3D;&#x3D;待完成&#x3D;&#x3D;</h3><p>1. </p>]]></content>
    
    
    <categories>
      
      <category>工具箱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Code</tag>
      
      <tag>Git</tag>
      
      <tag>工具箱</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2023/06/01/Tool/Linux/"/>
    <url>/2023/06/01/Tool/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-使用"><a href="#Linux-使用" class="headerlink" title="Linux 使用"></a>Linux 使用</h1><h2 id="0-环境搭建"><a href="#0-环境搭建" class="headerlink" title="0 环境搭建"></a>0 环境搭建</h2><h3 id="0-1-VMware"><a href="#0-1-VMware" class="headerlink" title="0.1 VMware"></a>0.1 VMware</h3><ol><li>Linux 环境搭建目标: 在 Windows 中创建一个虚拟机,然后安装 <code>CentOS</code>(wsl 更方便)</li><li>安装 <code>VMware</code><ul><li>先在 BIOS 中开启 <code>虚拟化设备支持</code></li><li>安装只需一直下一步即可</li></ul></li><li>安装 <code>CentOS</code><ul><li>将界面修改为中文: 在快捷方式的目标栏添加 <code> --locale zh_CN</code></li></ul></li><li>如果遇到打开虚拟机就蓝屏: 在 Windows 功能中打开 <code>虚拟机监控程序平台, 虚拟机平台</code></li><li><strong>网络连接模式</strong><ul><li>桥接模式: 虚拟系统可和外部系统通讯,但容易造成 IP 冲突</li><li>NAT 模式: 网络地址转化模式.可和外部系统通讯,而不造成 IP 冲突</li><li>主机模式: 独立的系统.不进行通讯</li></ul></li><li>虚拟机功能<ul><li>克隆: 直接复制文件,系统也是文件,复制文件即可克隆系统</li><li>快照: 保存快照后,可以在快照管理回到之前的状态</li><li>删除和迁移: 与克隆类似,直接操作文件</li></ul></li></ol><h3 id="0-2-远程登陆"><a href="#0-2-远程登陆" class="headerlink" title="0.2 远程登陆"></a>0.2 远程登陆</h3><ol><li>Xshell &amp; Xftp 安装(Xshell 用于执行指令.Xftp 用于文件传输)</li><li>Linux 终端输入 <code>ifconfig</code> 查询 ip 地址(inet 后面即为 ip 地址)</li><li>Windows 中命令行输入 <code>ping ip</code>,检查是否联通</li><li>进入 Xshell -&gt; 新建会话 -&gt; 主机输入 Linux 的 ip -&gt; 完成</li><li>双击左侧主机名 -&gt; 接收并保存 -&gt; 输入用户名和密码.即可登录</li></ol><h3 id="0-3-wsl"><a href="#0-3-wsl" class="headerlink" title="0.3 wsl"></a>0.3 wsl</h3><ol><li><p>先在 BIOS 中开启 <code>虚拟化设备支持</code>(任务管理器中显示 <code>虚拟化已开启</code> 即可)</p><p><img src="/2023/06/01/Tool/Linux/0-Virtualization.png"></p></li><li><p>win + R 输入 control 进入控制面板 -&gt; 程序和功能 -&gt; 启用或关闭 Windows 功能.<br>开启 <code>Virtual Machine Platform</code> 和 <code>适用于 Linux 的 Windos 子系统</code>(完成该步骤后需要重启电脑)</p><p><img src="/2023/06/01/Tool/Linux/0-Windows-feature.png"></p></li><li><p>打开终端,执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">wsl --update                # 更新 wsl<br>wsl --version               # 检查版本信息<br>wsl --list --online         # 列出可以在线安装的版本 <br>wsl --install Ubuntu-24.04  # 安装 Ubuntu 24.04<br>wsl                         # 启动 wsl.然后根据提示新建用户<br>cat /etc/os-release         # 查看发行版信息.Ubuntu 24.04.2 LTS<br></code></pre></td></tr></table></figure></li><li><p>更新软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update     # 拉取可更新软件列表<br>sudo apt upgrade -y # 更新所有软件<br></code></pre></td></tr></table></figure></li><li><p>安装(非必需) neofetch, htop</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install neofetch htop  # 安装 neofetch, htop<br>neofetch                        # 运行 neofetch.显示系统信息<br>htop                            # 交互式界面显示系统资源使用情况<br></code></pre></td></tr></table></figure></li><li><p>图形界面应用(非必需).以一些图形操作密集的软件为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install gimp blender kdenlive krita -y<br></code></pre></td></tr></table></figure><ul><li>gimp: GNU Image Manipulation Program(GNU 图像处理程序)</li><li>blender: 开源的 3D 建模, 动画, 渲染和视频编辑软件</li><li>kdenlive: 免费开源的非线性视频编辑软件</li><li>krita: 免费开源的专业绘画软件</li></ul></li><li><p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/connect-usb">访问 USB 设备</a></p><ul><li><p>在 Windows 安装 <a href="https://github.com/dorssel/usbipd-win">usbipd-win</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">winget install <span class="hljs-literal">--interactive</span> <span class="hljs-literal">--exact</span> dorssel.usbipd<span class="hljs-literal">-win</span><br></code></pre></td></tr></table></figure></li><li><p>查看 USB 设备</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">usbipd list<br><span class="hljs-comment"># 输出结果形如</span><br><span class="hljs-comment"># Connected:</span><br><span class="hljs-comment"># BUSID  VID:PID    DEVICE                              STATE</span><br><span class="hljs-comment"># 1-1    1a86:55d3  USB-Enhanced-SERIAL CH343 (COM5)    Not shared</span><br></code></pre></td></tr></table></figure></li><li><p>这里需要共享的是 <code>1-1</code> 设备</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">usbipd bind <span class="hljs-literal">--busid</span> <span class="hljs-number">1</span><span class="hljs-literal">-1</span> <span class="hljs-comment"># 需要管理员权限.只需共享一次</span><br></code></pre></td></tr></table></figure></li><li><p>附加 USB 设备到 wsl2</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">usbipd attach <span class="hljs-literal">--wsl</span> <span class="hljs-literal">--busid</span> <span class="hljs-number">1</span><span class="hljs-literal">-1</span><br></code></pre></td></tr></table></figure></li><li><p>在 wsl 命令行查看设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsusb<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Bus 001 Device 002: ID 1a86:55d3 QinHeng Electronics USB Single Serial</span><br></code></pre></td></tr></table></figure></li><li><p>断开 USB 设备</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">usbipd detach <span class="hljs-literal">--busid</span> &lt;busid&gt;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-Linux-基础"><a href="#1-Linux-基础" class="headerlink" title="1 Linux 基础"></a>1 Linux 基础</h2><h3 id="1-1-目录结构"><a href="#1-1-目录结构" class="headerlink" title="1.1 目录结构"></a>1.1 目录结构</h3><ol><li><p><strong>Linux 一切皆文件</strong></p><p><img src="/2023/06/01/Tool/Linux/1-Linux-Struct.jpg"></p></li><li><p><code>/</code>: 根目录,包含整个文件系统</p><ul><li><code>/bin</code>: 二进制文件目录.包含一些常用的命令和工具.如 ls, cp, mv…</li><li><code>/sbin</code>: 系统二进制文件目录.包含一些系统管理命令和工具.如 shutdown, reboot…</li><li><code>/boot</code>: 启动目录.包含启动 Linux 系统所需的文件,如内核文件和引导程序</li><li><strong><code>/dev</code>: 设备目录.包含系统中的设备文件.如 硬盘, 光驱, 键盘…</strong></li><li><code>/etc</code>: 配置文件目录.包含系统和应用程序的配置文件.如网络配置, 用户配置…</li><li><strong><code>/home</code>: 用户主目录.包含系统中所有用户的主目录</strong></li><li><code>/lib</code>: 库文件目录.包含系统和应用程序所需的共享库文件</li><li><code>/media</code>: 挂载目录.包含可移动设备的挂载点,如 U盘, 光盘…</li><li><strong><code>/mnt</code>: 挂载目录.包含临时挂载的文件系统</strong></li><li><strong><code>/opt</code>: 可选目录.包含第三方应用程序的安装目录</strong></li><li><code>/proc</code>: 进程目录.包含系统和进程的信息.如 内存使用, CPU使用…</li><li><code>/root</code>: root 用户主目录</li><li><code>/tmp</code>: 临时目录.包含系统和应用程序的临时文件</li><li><code>/usr</code>: 用户程序目录.包含系统和用户安装的应用程序和文件</li><li><code>/var</code>: 可变目录.包含系统和应用程序的可变数据.如日志文件, 缓存文件…</li></ul></li></ol><h3 id="1-2-vim"><a href="#1-2-vim" class="headerlink" title="1.2 vim"></a>1.2 vim</h3><ol><li><p>vim 键盘图</p><p><img src="/2023/06/01/Tool/Linux/1-vi-vim-cheat-sheet-sch.gif"></p></li><li><p>vim 的工作模式: 命令模式, 输入模式, 命令行模式</p><p><img src="/2023/06/01/Tool/Linux/1-vim-vi-workmodel.png"></p></li><li><p>命令模式: 当启动 vi &#x2F; vim 时,默认为命令模式</p><ul><li><kbd>x</kbd>: 删除当前光标所在处的字符</li><li><kbd>G</kbd>: 定位到最后一行, <kbd>gg</kbd> 定位到首行</li><li><strong><kbd>yy</kbd>: 复制当前行,在前面加一个数字可以选定行数,如 5yy</strong></li><li><strong><kbd>dd</kbd>: 剪切当前行,在前面加一个数字可以选定行数,如 3dd</strong></li><li><strong><kbd>p</kbd>: 粘贴复制的内容</strong></li><li><kbd>u</kbd>: 撤销操作</li><li><kbd>Ctrl</kbd><kbd>r</kbd>: 重做上一次的撤销</li><li>定位到指定行: 输入行数然后 <kbd>Shif</kbd><kbd>g</kbd></li></ul></li><li><p>插入模式: 可以直接输入文本</p><ul><li><strong><kbd>ESC</kbd>: 进入命令行模式</strong></li><li><kbd>Page Up</kbd> &#x2F; <kbd>Page Down</kbd>: 上下翻页</li></ul></li><li><p>命令行模式: 保存或退出文件,设置编辑环境</p><ul><li><code>:w</code>: 保存文件</li><li><code>:q</code>: 退出编辑器</li><li><code>:q!</code>: 强制退出,且不保存</li><li><code>:set nu</code>: 显示行号.<code>:set nonu</code>: 隐藏行号. <code>:整数</code>:跳转到某行</li><li><strong><code>/text</code>: 查找文本信息.此时输入 <kbd>n</kbd> 查找下一个. <kbd>N</kbd> 查找下一个</strong></li><li><code>?text</code>: 向上查找文本信息</li></ul></li></ol><h2 id="2-Linux-命令"><a href="#2-Linux-命令" class="headerlink" title="2. Linux 命令"></a>2. Linux 命令</h2><h3 id="2-1-用户"><a href="#2-1-用户" class="headerlink" title="2.1 用户"></a>2.1 用户</h3><ol><li><p>linux 的命令格式为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">command [-options] [parameter]<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">command</span>: 命令名称也可以是 Shell 脚本</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">options: 长格式(man --<span class="hljs-built_in">help</span>) / 短格式(man -h)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">parameter: 通常是命令的指向目标.如文件, 目录等资源</span><br></code></pre></td></tr></table></figure></li><li><p>开 &#x2F; 关机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">shutdown -h now # 立即关机<br>shutdown -h 1   # 1分钟后关机.是 shutdown 的默认形式<br>shutdown -r now # 立即重启<br><br>halt   # 立即关机<br>reboot # 立即重启<br>sync   # 把内存里的数据同步到磁盘(建议在关机前先执行该指令)<br></code></pre></td></tr></table></figure></li><li><p>登录 Linux(一般仅使用普通用户登录,而非 root)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">su &lt;username&gt; # 切换到指定用户<br>logout        # 注销当前登录用户.Ubuntu 使用 exit<br></code></pre></td></tr></table></figure></li><li><p>用户管理(要想使用 Linux 系统资源,需要向管理员申请账号)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd &lt;username&gt; # 添加用户.登陆后将默认进入 /home/username 目录<br>userdel &lt;username&gt; # 删除用户,但保留目录<br>passwd &lt;username&gt;  # 指定 / 修改 用户密码<br>id &lt;username&gt;      # 查询用户信息<br>whoami             # 查看当前登录用户<br></code></pre></td></tr></table></figure></li><li><p>用户组(对具有相似权限的用户分组管理)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupadd &lt;groupname&gt; # 创建用户组(若创建用户时未指定组,默认创建同名组)<br>groupdel &lt;groupname&gt; # 删除用户组<br><br>groupmod -n &lt;newname&gt; &lt;oldname&gt;   # 更改用户组名<br>usermod -g &lt;groupname&gt; &lt;username&gt; # 修改用户的组别<br>gpasswd -d &lt;groupname&gt; &lt;username&gt; # 从组中删除用户<br></code></pre></td></tr></table></figure></li><li><p>帮助指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">man &lt;command&gt;  # 获取帮助信息.如 man ls<br>help &lt;command&gt; # 获取 shell 内置命令的帮助信息.如 help cd<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-文件目录"><a href="#2-2-文件目录" class="headerlink" title="2.2 文件目录"></a>2.2 文件目录</h3><ol><li><p>路径切换</p><ul><li><p><strong><code>pwd</code>: 显示当前目录的绝对路径</strong></p></li><li><p><strong><code>ls &lt;path&gt;</code>: 列出文件和目录.默认显示当前目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -a # 显示所有文件和目录(包括隐藏文件,即以 . 开头的文件)<br>ls -l # 以列表形式显示<br>ls -h # 以易于阅读的形式,列出文件大小<br></code></pre></td></tr></table></figure></li><li><p><strong><code>cd &lt;path&gt;</code>: 切换到指定目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~  # 回到 home 目录<br>cd .. # 回到上一级目录<br>cd -  # 返回上一次目录<br></code></pre></td></tr></table></figure></li></ul></li><li><p>目录与文件</p><ul><li><p>创建 &#x2F; 删除目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir &lt;directory&gt; # 创建目录(默认只能创建一级目录)<br>rmdir &lt;directory&gt; # 删除目录(只能删除空目录)<br><br>mkdir -p &lt;directory1/directory2&gt; # 创建多级目录<br></code></pre></td></tr></table></figure></li><li><p>删除文件 &#x2F; 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm &lt;path&gt;    # 删除文件或目录<br>rm -r &lt;path&gt; # 递归删除整个文件夹<br>rm -f &lt;path&gt; # 强制删除不提示<br></code></pre></td></tr></table></figure></li><li><p>拷贝文件 &#x2F; 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp    &lt;src_path&gt; &lt;dst_path&gt; # 将文件 / 目录复制到指定路径<br>\cp   &lt;src_path&gt; &lt;dst_path&gt; # 直接覆盖同名文件,不进行提示<br>cp -r &lt;src_path&gt; &lt;dst_path&gt; # 递归复制整个目录<br></code></pre></td></tr></table></figure></li><li><p>移动文件 &#x2F; 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv &lt;src_path&gt; &lt;dst_path&gt; # 移动文件或目录到指定路径<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果位于同一目录,则作用为重命名</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo             # 输出内容到控制台(如 echo $PATH)<br>touch &lt;filename&gt; # 创建空文件<br>cat   &lt;filename&gt; # 查看文件内容.不能修改.(-n: 显示行号)<br>more  &lt;filename&gt; # 分批显示文件内容.Space 翻页, Enter 下一行, Q 离开<br>less  &lt;filename&gt; # 分批查看文件内容<br>tail  &lt;filename&gt; # 查看文件尾部内容(-f实时追踪文件的所有更新)<br><br>diff &lt;path1&gt; &lt;path2&gt; # 比较文件 / 目录的差异.(-c: 查看具体信息)<br></code></pre></td></tr></table></figure></li><li><p><strong>指令 <code>&gt;</code> 和 <code>&gt;&gt;</code>: 重定向和追加</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat file1 &gt; file2         # 将 file1 内容覆盖到 file2<br>echo &quot;string&quot; &gt;&gt; filename # 将内容追加到文件中<br></code></pre></td></tr></table></figure></li><li><p><strong>创建软链接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s &lt;path&gt; &lt;linkname&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong><code>history</code>: 查看 &#x2F; 执行历史指令</strong></p></li></ol><h3 id="2-3-查找"><a href="#2-3-查找" class="headerlink" title="2.3 查找"></a>2.3 查找</h3><ol><li><p><strong><code>find</code>: 从指定目录向下递归遍历各个子目录,将满足条件的文件 &#x2F; 目录显示在终端</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">find &lt;path&gt; &lt;options&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-name: 按文件名查找</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-user: 按用户所属查找</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-size: 按文件大小查找(+n 大于, -n 小于, n 等于)</span><br></code></pre></td></tr></table></figure></li><li><p><code>find</code> 使用示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /home -name hello.txt # 查找 /home 目录的 hello.txt 文件<br>find /opt -user nobody     # 查找 /opt 目录中拥有者为 nobody 的文件<br>find / -size +200M         # 查找整个系统中大于 200M 的文件<br></code></pre></td></tr></table></figure></li><li><p><strong><code>locate</code>: 事先建立系统中所有文件名称及路径的 <code>locate</code> 数据库</strong></p><ul><li>第一次运行时,必须先使用 <code>updatedb</code> 指令创建 <code>locate</code> 数据库</li><li>查询速度快,但需要及时更新 <code>locate</code> 时刻</li></ul></li><li><p><strong><code>which command</code>: 查看 command 所在的路径</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">which python3 # 查看 python3 命令所在的路径. /usr/bin/python3<br></code></pre></td></tr></table></figure></li><li><p><strong><code>grep</code>: 过滤查找(实际常和 | 结合使用)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep &quot;content&quot; &lt;path&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-n: 显示匹配行及行号</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-i: 忽略大小</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-r: 递归查找</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-v: 反向过滤</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-压缩解压"><a href="#2-4-压缩解压" class="headerlink" title="2.4 压缩解压"></a>2.4 压缩解压</h3><ol><li><p><strong><code>gzip filename</code>: 压缩为 <code>*.gz</code> 文件</strong></p></li><li><p><strong><code>gunzip 文件名</code>: 解压 <code>*.gz</code> 解压文件</strong></p></li><li><p>zip 格式压缩解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zip -r file.zip &lt;path&gt;   # 递归的压缩 path 目录<br>unzip file.zip -d &lt;path&gt; # 解压 file.zip 到 path 目录<br></code></pre></td></tr></table></figure></li><li><p><strong><code>tar</code>: 打包指令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -cvf file.tar file1 file2 ...     # 将文件打包为 file.tar<br>tar -zcvf file.tar.gz file1 file2 ... # 将文件压缩到 file.tar.gz<br><br>tar -xvf file.tar -C &lt;path&gt;           # 解包 file.tar 到 path 目录<br>tar -zxvf file.tar.gz -C &lt;path&gt;       # 解包 file.tar.gz 到 path 目录<br></code></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>打包.产生 <code>.tar</code> 打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后文件名</td></tr><tr><td>-z</td><td>gzip 模式</td></tr><tr><td>-x</td><td>解包 <code>.tar</code> 文件</td></tr></tbody></table></li></ol><h3 id="2-5-运行级别"><a href="#2-5-运行级别" class="headerlink" title="2.5 运行级别"></a>2.5 运行级别</h3><ol><li><p>运行级别一般为 3 或 5</p><ul><li>0: 系统停机状态,即关机状态</li><li>1: 单用户模式,只有 root 用户可以登录.用于系统维护和修复</li><li>2: 多用户模式,没有 NFS 服务.但可以使用网络</li><li>3: <strong>多用户模式,完全启动系统.可以使用所有服务</strong></li><li>4: 保留,未使用</li><li>5: <strong>多用户模式,与运行级别3相同.但是在此级别下启动X Window系统,即图形界面</strong></li><li>6: 系统重启级别</li></ul></li><li><p>运行级别指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">init 1   # 切换到运行级别1<br>runlevel # 查看当前运行级别<br></code></pre></td></tr></table></figure></li><li><p>时间与日期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">date     # 显示当前日期<br>date +%Y # 显示当前年份<br>date +%m # 显示当前月份<br>date +%d # 显示当前天数<br><br>date &quot;+%Y-%m-%d %H:%M:%S&quot;     # 显示时间.年-月-日 时:分:秒<br>date -s &quot;2021-06-18 08:00:00&quot; # 设置时间<br><br>cal      # 显示本月日历<br>cal 2025 # 显示 2025年日历<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-权限管理"><a href="#3-权限管理" class="headerlink" title="3 权限管理"></a>3 权限管理</h2><h3 id="3-1-组"><a href="#3-1-组" class="headerlink" title="3.1 组"></a>3.1 组</h3><ol><li><p><strong>Linux 每个用户都属于某个组.每个文件有 所有者, 所在组, 其他组</strong></p></li><li><p>所有者: 文件的创建者自然成为文件的所有者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -ahl # 查看文件 / 目录的所有者<br>chown username filename           # 修改文件 / 目录的所有者<br>chown username:groupname filename # 修改所有者以及所在组<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-R: 将目录的子目录和文件进行递归修改</span><br></code></pre></td></tr></table></figure></li><li><p>所在组: 文件 &#x2F; 目录的所在组 为 所有者的所在组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chgrp &lt;groupname&gt; &lt;filename&gt; # 修改文件 / 目录所在组<br></code></pre></td></tr></table></figure></li><li><p>其他组: 除所有者和所在组之外的用户</p></li></ol><h3 id="3-2-文件权限"><a href="#3-2-文件权限" class="headerlink" title="3.2 文件权限"></a>3.2 文件权限</h3><ol><li><p><strong>文件所属分为 拥有者(owner), 所属群组(group), 其他人(other).</strong><br><strong>而三种身份各有 读(read), 写(write), 执行(execute)权限</strong></p></li><li><p>考虑 <code>ls -l</code> 命令,显示的信息形如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">文件权限, 链接数, 文件拥有者, 文件所属用户组, 文件大小(Bytes), 最后被修改的时间, 文件名</span><br>-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc<br></code></pre></td></tr></table></figure></li><li><p>文件权限共 9位.其含义为</p><ul><li><strong>第 0 位: 文件类型(d ,-, l, c, b)</strong><ul><li><code>d</code>: 目录.相当于文件夹</li><li><code>-</code>: 普通文件</li><li><code>l</code>: 链接.相当于快捷方式</li><li><code>c</code>: 字符设备.如鼠标键盘</li><li><code>b</code>: 块设备.如硬盘</li></ul></li><li><strong>1 ~ 3位: 文件所有者的权限.如 rwx 表示可读可写可执行</strong></li><li><strong>4 ~ 6位: 所在组用户的权限.如 rw- 表示可读可写,但不能执行</strong></li><li><strong>7 ~ 9位: 其他用户对该文件的权限.如 r– 表示仅能读</strong></li></ul></li><li><p><strong>目录权限表示方式</strong></p><ul><li><code>r</code>: 可读.可以查看文件 或 可用 <code>ls</code> 查看目录内容</li><li><code>w</code>: 可写.可创建, 删除, 重命名, 移动其中的文件或目录</li><li><code>x</code>: 可执行.可以执行文件 或 可进入该目录(成为工作目录)</li><li><code>-</code>: 对应位置如果出现 <code>-</code>,表示没有该类型权限</li><li><code>rwx</code> 还可以用数字形式表示(<code>r = 4, w = 2, x = 1</code>).如 rwx &#x3D; 4 + 2 +1 &#x3D; 7</li></ul></li><li><p><strong><code>chmod</code>: 修改文件 &#x2F; 目录的权限</strong></p><ul><li><p><code>u</code>: 所有者, <code>g</code>: 所在组, <code>o</code>: 其他人, <code>a</code>: 所有人. 使用 <code>+, -, =</code>赋予权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod u=rwx,g=rx,o=x filename # 对文件设置权限<br>chmod o+w filename # 对其他组增加 w 可写权限<br>chmod a-x filename # 对所有人取消 x 可执行权限<br>chmod 751 filename # 与 chmod u=rwx,g=rx,o=x filename 等价<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="3-3-环境变量"><a href="#3-3-环境变量" class="headerlink" title="3.3 环境变量"></a>3.3 环境变量</h3><ol><li><p><code>env</code>: 查看系统中记录的环境变量(以 key-value 的形式存储)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">env # 结果形如 SHELL=/bin/bash<br></code></pre></td></tr></table></figure></li><li><p><code>PATH</code> 变量中记录了系统执行命令的搜索路径(使用 <code>:</code> 分隔)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">env | grep PATH # 结果形如 PATH=/usr/local/sbin:/usr/local/bin<br></code></pre></td></tr></table></figure></li><li><p><code>$</code> 用于取值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo $PATH # 结果与 env | grep PATH 相同<br></code></pre></td></tr></table></figure></li><li><p>设置环境变量</p><ul><li><p>临时设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=$PATH:&lt;path&gt;  # 将 path 追加到 PATH 中.仅当前终端有效<br></code></pre></td></tr></table></figure></li><li><p>永久设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim ~/.bashrc  # 将 export 语句追加到末行<br>source .bashrc # 使 .bashrc 生效<br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意 .bashrc 仅对当前用户生效.对所有用户生效需要修改 /etc/profile 文件</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="3-4-定时任务"><a href="#3-4-定时任务" class="headerlink" title="3.4 定时任务"></a>3.4 定时任务</h3><ol><li><p>任务调度: 系统在某个时间执行的特定命令或程序</p><ul><li>系统工作.需要周期性的执行,如病毒扫描</li><li>用户工作.如对 mysql 数据库的备份</li></ul></li><li><p><code>crond</code> 定时任务</p><ul><li>基础语法: <code>crontab [选项]</code><ul><li><code>-e</code>: 编辑 <code>crontab</code> 任务</li><li><code>-l</code>: 查询 <code>crontab</code> 任务</li><li><code>-r</code>: 删除当前用户的所有 <code>crontab</code> 任务</li></ul></li><li>示例: <code>*/1**** ls -l /etc &gt; /tmp/to.txt</code> 将会每分钟都执行一次</li></ul></li><li><p>时间规则</p><ul><li><p>5个占位符的含义</p><table><thead><tr><th>序号</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>1</td><td>每小时的分钟数</td><td>0 ~ 59</td></tr><tr><td>2</td><td>每天的小时数</td><td>0 ~ 23</td></tr><tr><td>3</td><td>每月的天数</td><td>1 ~ 31</td></tr><tr><td>4</td><td>每天的月份</td><td>1 ~ 12</td></tr><tr><td>5</td><td>每周星期数</td><td>0 ~ 7(0和7均为星期天)</td></tr></tbody></table></li><li><p>特殊符号</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>通配符,表示任意时间</td></tr><tr><td>,</td><td>分隔不连续的时间.如 <code>08,17***</code> 表示每天的8时0分,17时0分</td></tr><tr><td>-</td><td>连续的时间范围.如 <code>05**1-6</code> 表示周一到周六的5时0分</td></tr><tr><td>*&#x2F;n</td><td>每次的间隔时间.如 <code>*/10****</code> 表示每次间隔10分钟</td></tr></tbody></table></li></ul></li></ol><h3 id="3-5-进程"><a href="#3-5-进程" class="headerlink" title="3.5 进程"></a>3.5 进程</h3><ol><li><p>进程</p><ul><li>Linux 中每个执行的程序都是一个进程.每个进程都会分配一个ID号(pid)</li><li>每个进程可以以前台或后台的形式存在</li><li>一般系统服务均以后台进程形式存在,且常驻于系统,直到关机才结束</li></ul></li><li><p><strong><code>ps</code>: 查看当前系统中正在执行的进程</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -a # 显示当前终端的所有进程信息<br>ps -u # 以用户的格式显示进程信息<br>ps -x # 显示后台进程运行的参数<br></code></pre></td></tr></table></figure></li><li><p>父子进程</p><ul><li><strong><code>ps -ef</code>: 全格式显示当前所有进程</strong></li><li>显示的 ppid 指出该进程的父进程</li><li>搭配 <code>| grep</code> 可以进行过滤</li></ul></li><li><p>终止进程</p><ul><li><strong><code>kill [选项] 进程号</code>: 通过进程号终止进程</strong></li><li><code>killall 进程名称</code>: 通过进程名称终止进程,同时会终止其所有子进程</li></ul></li><li><p><code>pstree</code>: 查看进程树</p><ul><li><code>-p</code>: 显示进程的 pid</li><li><code>-u</code>: 显示进程的用户</li></ul></li><li><p>服务(service): 其本质仍然是进程.通常会监听某个端口,等待其他程序的请求</p><ul><li><code>service 服务名 [start | stop | restart | reload | status]</code></li><li>CentOS7.0后,很多服务不再使用 <code>service</code> 指令管理,而使用 <code>systemctl</code></li><li><code>systemctl [start | stop | restart | status] 服务名</code></li><li><code>systemctl</code> 管理的服务在 <code>/user/lib/systemd/system</code> 查看</li></ul></li></ol><h2 id="4-开发环境"><a href="#4-开发环境" class="headerlink" title="4 开发环境"></a>4 开发环境</h2><h3 id="4-1-rpm"><a href="#4-1-rpm" class="headerlink" title="4.1 rpm"></a>4.1 rpm</h3><ol><li><p><strong>rpm(RedHat Package Manager) 用于互联网下载包的打包,安装.生成 <code>.RPM</code> 的文件</strong></p></li><li><p>查询软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -qa                # 查询所有安装的 rpm 软件包<br>rpm -qa | grep firefox # 查询具体的某个软件包<br>rpm -qi firefox        # 查询软件包的具体信息<br></code></pre></td></tr></table></figure></li><li><p>安装与删除软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -ivh &lt;path&gt; # 安装软件包需要有全路径<br>rpm -e firefox  # 删除软件包<br></code></pre></td></tr></table></figure></li><li><p>yum: Shell 前端软件包管理器</p><ul><li>yum 基于 rpm 包管理.能从指定服务器自动下载 rpm 包并安装</li><li>yum 将会自动处理依赖性关系,并一次安装所有依赖的软件包</li></ul></li><li><p>yum 指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum list | grep firefox # 查询 yum 服务器中的相关软件包信息<br>yum install firefox     # 下载安装软件包及依赖<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-2-Ubuntu"><a href="#4-2-Ubuntu" class="headerlink" title="4.2 Ubuntu"></a>4.2 Ubuntu</h3><ol><li><p><strong>Ubuntu: 一个以桌面应用为主的开源 GNU&#x2F;Linux 操作系统</strong></p><ul><li>基于 GNU&#x2F;Linux.支持 x86, amd64, ppc 架构.由 Canonical 打造</li><li>Python 开发者一般选择 Ubuntu 作为生产平台</li><li>下载桌面版: <a href="https://cn.ubuntu.com/download">Ubuntu系统下载 | Ubuntu</a></li></ul></li><li><p>中文支持</p><ul><li>Ubuntu 默认只有英文.需要安装中文语言包(需要联网)</li><li>打开 Language Support 菜单 -&gt; Language Support 选项卡 -&gt; Install</li><li>选中 Chinese(Simplified) -&gt; Apply Changes 提交.此时系统将会自动下载</li><li>默认显示中文需要将 <code>汉语(中国)</code> 拖动到第一位</li></ul></li><li><p>root 权限</p><ul><li><strong>Ubuntu 安装后只有普通用户权限.若需要 root 权限,应在命名前加上 <code>sudo</code></strong></li><li>当使用 <code>su root</code> 切换到 root 用户时,因还未设置密码,将会抛出 <code>error</code></li><li>设置 root 用户的密码并使用<ul><li><code>sudo password</code>: 给 root 用户设置密码</li><li><code>su root</code>: 切换到 root 用户</li><li>提示符 <code>$</code> 表示一般用户.<code>#</code> 表示 root 用户</li><li><code>exit</code>: 退出 root 用户</li></ul></li></ul></li><li><p>python</p><ul><li>Ubuntu 默认安装 python 的开发环境</li><li><code>python3</code> 将会展示版本信息</li></ul></li><li><p><strong>apt(Advanced Packaging Tool): 安装包管理工具</strong></p><ul><li><p>Ubuntu 使用 <code>apt</code> 命令进行软件包的安装, 删除, 清理…</p></li><li><p><code>/etc/apt/sources.list</code> 文件中存放着 apt 服务器的地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update              # 更新源<br>sudo apt install &lt;package&gt;   # 安装 package<br>sudo apt remove &lt;package&gt;    # 删除 package<br><br>sudo apt search &lt;package&gt;    # 搜索软件包<br>sudo apt show &lt;package&gt;      # 获取包的相关信息<br>sudo apt install &lt;package&gt; --reinstall  # 重新安装包<br><br>sudo apt --fix-broken install # 修复安装<br>sudo apt purge &lt;package&gt;      # 删除包，包括配置文件<br>sudo apt build-dep &lt;package&gt;  # 安装相关编译环境<br><br>sudo apt upgrade             # 更新已安装的包<br>sudo apt full-upgrade        # 升级系统<br>sudo apt depends &lt;package&gt;   # 查看该包所依赖的包<br>sudo apt rdepends &lt;package&gt;  # 查看该包被哪些包依赖<br>sudo apt source &lt;package&gt;    # 下载软件包的源代码<br></code></pre></td></tr></table></figure></li></ul></li><li><p>修改 apt 更新源(镜像网站: 因为服务器位于美国,连接缓慢,由镜像网站获取其资源)</p><ul><li><p>备份文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cp /ect/apt/sources.list /etc/apt/sources.list.backup # Ubuntu 24.04 之前<br>sudo cp /etc/apt/sources.list.d/ubuntu.sources /etc/apt/sources.list.d/ubuntu.sources.backup # Ubuntu 24.04 之后<br></code></pre></td></tr></table></figure></li><li><p>使用 root 用户,清空源文件中的所有内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;&#x27; &gt; source.list<br></code></pre></td></tr></table></figure></li><li><p>将需要的<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">镜像地址(清华源)</a>拷贝到 <code>source.list</code> 文件中</p></li></ul></li><li><p>远程登录</p><ul><li><p>SSH(Secure Shell): 建立于应用层和传输层基础上的安全协议</p></li><li><p>与 CentOS 不同,Ubuntu 默认没有安装 SSHD 服务</p></li><li><p>安装 SSH</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install openssh-server<br></code></pre></td></tr></table></figure></li><li><p>启动 SSH</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service sshd restart<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Linux 登录到 Ubuntu</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh 目标主机的用户名@目标主机IP地址 # 登录<br>logout # 退出<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-Shell"><a href="#5-Shell" class="headerlink" title="5 Shell"></a>5 Shell</h2><h3 id="5-1-Shell-概念"><a href="#5-1-Shell-概念" class="headerlink" title="5.1 Shell 概念"></a>5.1 Shell 概念</h3><ol><li><p><strong>Shell: 命令行解释器.为用户提供一个向 Linux 内核发送请求以便运行程序的界面系统级程序</strong></p><ul><li>运维工程师对服务器集群进行管理时,需要编写 Shell 程序进行服务器管理</li><li>JavaEE, Python程序员需要编写 Shell 维护程序和服务器</li><li>大数据程序员需要编写 Shell 程序管理集群</li></ul></li><li><p>Shell 脚本</p><ul><li><p>文件内容需要以 <code>#!/bin/bash</code> 开头,一般后缀为 <code>.sh</code></p></li><li><p>文件本身需要有可执行权限.赋予权限: <code>chmod u+x hello.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>echo &quot;Hello,world!&quot;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>执行脚本</p><ul><li><code>脚本的绝对路径或相对路径</code>: 即可执行(需要有 <code>+x</code> 权限)</li><li><code>sh 脚本路径</code>: 这样执行无需 <code>+x</code> 执行权限</li></ul></li><li><p>注释</p><ul><li>单行注释: <code># content</code></li><li>多行注释: <code>:&lt;&lt;! content !</code></li></ul></li></ol><h3 id="5-2-变量"><a href="#5-2-变量" class="headerlink" title="5.2 变量"></a>5.2 变量</h3><ol><li><p>系统变量</p><ul><li>如: <code>$HOME, $PWD, $SHELL, $USER</code>.可使用 <code>echo $HOME</code> 打印当前用户的家目录</li><li>显示当前 Shell 的所有系统变量</li></ul></li><li><p>自定义变量</p><ul><li>语法: <code>变量名=value</code>.注意语句中不要加入空格.变量名的命名限制与C相同</li><li>销毁变量: <code>unset 变量名</code>.Shell 编程变量名一般大写</li><li>声明静态变量: <code>readonly 变量名</code>.不能使用 <code>unset</code> 销毁</li><li>打印变量: <code>echo $变量名</code>.注意需要加上 <code>$</code> 符号</li></ul></li><li><p>将命令的返回值赋给变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">A=`command` # 将 command 作为一个命令执行,然后将结果赋值给变量 A<br>A=$(date)   # 与上述写法等价.变量 A 将会存储当前时间信息<br></code></pre></td></tr></table></figure></li><li><p>环境变量</p><ul><li><code>export 变量名=值</code>: 将 Shell 变量输出为环境变量 &#x2F; 全局变量</li><li><code>export 配置文件</code>: 使修改后的配置信息立即生效</li><li><code>echo $变量</code>: 查询环境变量的值</li></ul></li><li><p>位置参数</p><ul><li><code>$0</code>: 表示命令本身,<code>$1 ~ $9</code>表示第1 ~ 9个参数.对于超过10的,要用 <code>&#123;&#125;</code> 包裹</li><li><code>$*</code>: 表示所有的参数.且将所有参数当作整体处理</li><li><code>$@</code>: 表示所有的参数.但将每个参数分开处理</li><li><code>$#</code>: 获取命令行中所有参数的个数</li></ul></li><li><p>预定义变量: Shell 已定义的变量,可以直接在 Shell 脚本中使用</p><ul><li><code>$$</code>: 当前进程的进程号 pid</li><li><code>$!</code>: 后台运行的最后一个进程的进程号 pid</li><li><code>#?</code>: 最后一次执行的命令的返回状态.0表示正确执行</li></ul></li><li><p>运算</p><ul><li>语法: <code>$((运算式))</code> 或 <code>$[运算式]</code></li></ul></li></ol><h3 id="5-3-控制流"><a href="#5-3-控制流" class="headerlink" title="5.3 控制流"></a>5.3 控制流</h3><ol><li><p>条件表达式: <code>[ condition ]</code>.注意两端的空格,非空返回 true</p></li><li><p>分支语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ condition1 ]<br>then<br>code block1<br>elif [ condition2 ]<br>then<br>code block2<br>fi<br></code></pre></td></tr></table></figure></li><li><p>case</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $变量名 in<br>&quot;value1&quot;)<br>code block1<br>;;<br>&quot;value2&quot;)<br>code block2<br>*)<br>code block<br>esac<br></code></pre></td></tr></table></figure></li><li><p>for</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for 变量名 in value1 value2...<br>do<br>code block<br>done<br></code></pre></td></tr></table></figure></li><li><p>while</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">while [ condition ]<br>do<br>code block<br>done<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-4-函数"><a href="#5-4-函数" class="headerlink" title="5.4 函数"></a>5.4 函数</h3><ol><li><p>读取控制台输入</p><ul><li>基础语法: <code>read 选项 参数</code></li><li>选项: <code>-p</code> 指定读取值时的提示符. <code>-t</code> 指定等待的秒数</li><li>参数: 指定存储输入值的变量名</li></ul></li><li><p>系统函数</p><ul><li><code>basename</code>: 返回完整路径最后一个 <code>/</code> 后的内容,常用于获取文件名</li><li><code>basename [pathname] [suffix]</code></li><li><code>dirname</code>: 返回完整路径最后一个 <code>/</code> 前的内容,常用于获取路径</li></ul></li><li><p>自定义函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ function ] funname[()]<br>&#123;<br>Action;<br>[return int;]<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具箱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Code</tag>
      
      <tag>工具箱</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Language Data Structures</title>
    <link href="/2023/05/04/Computer/C-Language-Data-Structures/"/>
    <url>/2023/05/04/Computer/C-Language-Data-Structures/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法分析"><a href="#数据结构与算法分析" class="headerlink" title="数据结构与算法分析"></a>数据结构与算法分析</h1><h2 id="0-算法分析"><a href="#0-算法分析" class="headerlink" title="0 算法分析"></a>0 算法分析</h2><h3 id="0-1-基础概念"><a href="#0-1-基础概念" class="headerlink" title="0.1 基础概念"></a>0.1 基础概念</h3><ol><li>概念<ul><li>数据结构: 组织大量数据的方法</li><li>算法分析: 对算法运行时间的评估</li><li><strong>算法(algorithm)</strong>: 为求解一个问题所需遵循的,被清楚指定的简单指令集合</li><li>当某种算法被给定时,则需要确定该算法所需的时间和空间等资源量</li></ul></li><li><strong>抽象数据类型(Abstract Data Type,ADT)</strong>: 是一些操作的集合,是数学上的抽象<ul><li>例如表,集合,图以及它们的操作可看作抽象数据类型</li><li>例如集合ADT,可以有 并(union), 交(intersection), 补(complement), 求大小(size)等操作</li><li>基本思路: 只在程序中编写一次,其他地方需要运行 ADT 上的操作时,可通过调用函数实现</li></ul></li><li>定义: 建立无穷大量之间的相对级别<ul><li>$\mathrm{if} \quad \exists c,n_0\in N_+,N\geq n_0\quad\mathrm{s.t.} T(N)\leq cf(N), \mathrm{then} \quad T(N)&#x3D;O(f(N))$</li><li>$\mathrm{if} \quad \exists c,n_0\in N_+,N\geq n_0  \quad  \mathrm{s.t.} T(N)\geq cg(N),\mathrm{then} \quad T(N)&#x3D;\Omega(g(N))$</li><li>$T(N)&#x3D;O(h(N))  \quad and\quad T(N)&#x3D;\Omega(h(N)) \iff T(N)&#x3D;\Theta(h(N))$</li><li>$T(N)&#x3D;O(p(N)) \quad and \quad T(N)\neq \Theta(p(N)), \mathrm{then} \quad T(N)&#x3D;o(f(N))$</li></ul></li><li>简要说明<ul><li>$O$: 高阶无穷大</li><li>$\Omega$: 低阶无穷大</li><li>$\Theta$: 同阶无穷大</li><li>$o$: 严格的高阶无穷大</li></ul></li><li><strong>一般采用大$O$记法</strong>.例如 $T(N)&#x3D;2N^2+N&#x3D;O(N^2)$<ul><li>不要将常数或低阶项放入大$O$,直接忽略即可</li><li>典型的增长率(递增排列): $C, \mathrm{log}N, \mathrm{log}^2N, N, N\mathrm{log}N, N^2, N^3, 2^N$</li><li>可以使用洛必达法则确定两个函数的相对级别</li></ul></li></ol><h3 id="0-2-计算方式"><a href="#0-2-计算方式" class="headerlink" title="0.2 计算方式"></a>0.2 计算方式</h3><ol><li>为在正式的框架中分析算法,需要一个计算模型<ul><li>假定一个标准计算机,它顺序执行指令.拥有简单的指令系统(如加减乘除,赋值等)</li><li>特别地,该模型机执行任意一条简单指令都恰好花费一个时间单元</li><li>该模型机具有无限内存</li></ul></li><li>待分析的问题<ul><li>最重要的资源一般为运行时间</li><li>在这里分析对运行时间的影响因素有: 使用的算法, 对该算法的输入(主要方面)</li><li>考虑两个函数<ul><li>$T_{avg}(N)$: 输入为 N 时算法所花费的平均时间</li><li>$T_{worst}(N)$: 输入为 N 时算法在最坏情况下花费的时间</li><li><strong>主要考虑 $T_{worst}(N)$.因为它为所有的输入提供了一个运行时间上界</strong></li></ul></li><li>当两个程序花费的时间大致相同时,判断运行速度的方法是将其编码并运行</li><li>为简化分析,系数,低阶项,常数项直接抛弃.只计算其上界: 大$O$</li></ul></li></ol><h3 id="0-3-运行时间计算"><a href="#0-3-运行时间计算" class="headerlink" title="0.3 运行时间计算"></a>0.3 运行时间计算</h3><ol><li><p>分析案例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 计算 1~n 的立方和 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> partialSum = <span class="hljs-number">0</span>;<span class="hljs-comment">// 声明不计时间,赋值计1个时间单元</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i &lt;= n, i++) &#123;<span class="hljs-comment">// 初始化赋值计1次,判断循环条件计n+1次,自增计n次</span><br>        partialSum += i * i * i;<span class="hljs-comment">// 乘法2次,加法1次,赋值1次.重复n次,共计4n个时间单元</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> partialSum;<span class="hljs-comment">// 返回计1个时间单元</span><br>&#125;  <span class="hljs-comment">// 本算法共计6n+4个时间单元,即 O(N)</span><br></code></pre></td></tr></table></figure></li><li><p>一般法则</p><ul><li><code>for</code>: 运行时间最多为循环语句的运行时间乘以迭代次数</li><li>嵌套 <code>for</code>: 由里向外分析循环.嵌套循环内部一条语句总运行时间为: 该语句运行时间乘以<code>for</code>循环大小的乘积</li><li>顺序语句: 对各语句的运行时间求和(事实上,只需考虑运行时间最长的语句)</li><li><code>if/else</code>: 判断语句运行时间加上分支语句中最长的运行时间</li><li><strong>分析的基本策略为从内部向外扩展.如果有函数调用,则应该首先分析</strong></li></ul></li><li><p>考虑 Fibonacci 数列递归求和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-1</span>) + fib(n<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>运行时间为: $T(N)&#x3D;T(N-1)+T(N-2)\quad (n\geq2)$.这是一个指数级增长</li><li>运行效率低下的原因为: 进行了大量的重复计算,且计算结果被抛弃</li><li>改进: 用一个数组将计算结果存储起来,将可以大大提高运行效率</li></ul></li><li><p>最大子序列和问题的四种算法</p></li></ol><ul><li><p>问题: 给定整数 $A_1,A_2,\dots,A_n$, 求  $\sum\limits^j_{k&#x3D;i}A_k$ 的最大值(假定数组中均为负数,则最大子序列和为0)</p></li><li><p>穷举所有的可能 $\Theta(n^3)$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumN3</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i; j&lt;n; j++) &#123;<br>            <span class="hljs-type">int</span> thisSum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i; k&lt;=j; k++) &#123;<br>                thisSum += a[k];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(thisSum &gt; maxSum)<br>                maxSum = thisSum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分析可知,最内层的 for 冗余,将其去掉 $O(N^2)$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumN2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-type">int</span> thisSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i; j&lt;n; j++) &#123;<br>            thisSum += a[j];<br>            <span class="hljs-keyword">if</span>(thisSum &gt; maxSum)<br>                maxSum = thisSum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>递归 $O(N\mathrm{logN})$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumNlogN</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left == right) <span class="hljs-comment">// 参数为数组,左边界,右边界</span><br>        <span class="hljs-keyword">return</span> a[left] &gt; <span class="hljs-number">0</span> ? a[left] : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> center = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> maxLeftSum, maxRightSum;<br>    maxLeftSum = maxSubseqSumNlogN(a, left, center);  <span class="hljs-comment">// 递归调用</span><br>    maxRightSum = maxSubseqSumNlogN(a, center + <span class="hljs-number">1</span>, right);<br><br>    <span class="hljs-type">int</span> maxLeftBrdSum,  maxRightBrdSum,     leftBrdSum,     rightBrdSum;<br>    maxLeftBrdSum = <span class="hljs-number">0</span>;  maxRightBrdSum = <span class="hljs-number">0</span>; leftBrdSum = <span class="hljs-number">0</span>; rightBrdSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=center; i&gt;=left; i--) &#123;  <span class="hljs-comment">// 计算中值到左边界的最大和</span><br>        leftBrdSum += a[i];<br>        <span class="hljs-keyword">if</span>(leftBrdSum &gt; maxLeftBrdSum)<br>            maxLeftBrdSum = leftBrdSum;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=center+<span class="hljs-number">1</span>; i&lt;=right; i++) &#123;  <span class="hljs-comment">// 计算中值到右边界的最大和</span><br>        rightBrdSum += a[i];<br>        <span class="hljs-keyword">if</span>(rightBrdSum &gt; maxRightBrdSum)<br>            maxRightBrdSum = rightBrdSum;<br>    &#125;<br>    <span class="hljs-comment">// 返回三者的最大值</span><br>    <span class="hljs-keyword">if</span> (maxLeftSum &gt;= maxRightSum)<br>        <span class="hljs-keyword">return</span> maxLeftSum &gt;= maxLeftBrdSum + maxRightBrdSum ? maxLeftSum : maxLeftBrdSum + maxRightBrdSum;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> maxRightSum &gt;= maxLeftBrdSum + maxRightBrdSum ? maxRightSum : maxLeftBrdSum + maxRightBrdSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>线性算法 $O(N)$</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumN</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> thisSum, maxSum;<br>    thisSum = <span class="hljs-number">0</span>; maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++) &#123;<br>        thisSum += a[j];<br>        <span class="hljs-keyword">if</span>(thisSum &gt; maxSum)<br>            maxSum = thisSum;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(thisSum &lt; <span class="hljs-number">0</span>)<br>            thisSum = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行代码(将上述代码置于一个文件下即可运行)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">-2</span>&#125;;<br>    <span class="hljs-type">int</span> arrLength = <span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(N^3)   = %d\n&quot;</span>,maxSubseqSumN3(a, arrLength));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(N^2)   = %d\n&quot;</span>,maxSubseqSumN2(a, arrLength));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(NlogN) = %d\n&quot;</span>,maxSubseqSumNlogN(a, <span class="hljs-number">0</span>, arrLength - <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(N)     = %d\n&quot;</span>,maxSubseqSumN(a, arrLength));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li><p>运行时间中的对数</p><ul><li><p>对数经常出现的场景有</p><ul><li>若算法利用 $O(1)$ ,即在常数时间里将问题的规模削减一部分(如50%).则该算法为 $O(\mathrm{log}N)$</li><li>若算法利用 $O(1)$ ,即在常数时间里将问题的规模消减一个常数(如 -1).则该算法为 $O(N)$</li></ul></li><li><p>考虑到仅仅是将 N 个数据读入耗费的时间即为 $\Theta(N)$ .当谈及$O(\mathrm{log}N)$ 时均假定数据已读入</p></li></ul></li><li><p>下面三个算法均为 $O(\mathrm{log}N)$</p><ul><li><p>二分查找(给定整数$X$,已排序数组 $A_0,A_1,\dots,A_{n-1}$ ,求满足$A_i&#x3D;X$的下标 $i$)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">float</span> elementType;<br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> elementType arr[], elementType x, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> low, mid, high;<br>    low = <span class="hljs-number">0</span>; high =n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>        mid = (low+high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(arr[mid] &lt; x)<br>            low = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; x)<br>            high = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>欧几里得算法(计算最大公因数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> m,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rem;<br>    <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>) &#123;<br>        rem = m % n;<br>        m = n;<br>        n = rem;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>幂运算</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">int</span> x,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == n)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> == n % <span class="hljs-number">2</span> ? <span class="hljs-built_in">pow</span>(x * x, n / <span class="hljs-number">2</span>) : <span class="hljs-built_in">pow</span>(x * x, n / <span class="hljs-number">2</span>) * x;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1 线性表"></a>1 线性表</h2><h3 id="1-1-单链表"><a href="#1-1-单链表" class="headerlink" title="1.1 单链表"></a>1.1 单链表</h3><ol><li><p>表: 形如 $a_1, a_2,\dots ,a_n$ 的有限序列.其中 $a_i$ 为数据元素 </p><ul><li>其大小为 n (当 n&#x3D;&#x3D;0 称为空表,empty list)</li><li>表的操作: 创建空表(makeEmpty), 插入元素(Insert), 删除元素(Delete), 查找元素(find), 打印表(printList)</li><li>由于数组对于插入和删除元素的运行太慢,一般不用简单数组实现表</li></ul></li><li><p>链表: 由一系列的无需在内存中相连的结构组成</p><ul><li>每个结构含有表元素以及指向该元素后继元结构的指针(next 指针)</li><li>最后一个元素的 next 指针 指向 NULL</li><li><strong>预留一个标志节点作为表头(head).其位置为0</strong></li></ul></li><li><p>链表接口(具体实现见 <code>single_linked_list</code>.不考虑数组实现方式)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SINGLE_LINKED_LIST_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SINGLE_LINKED_LIST_H</span><br><br><span class="hljs-comment">/*********************************************************/</span><br><span class="hljs-comment">/* node:        结构体类型名,链表结点</span><br><span class="hljs-comment">** ptr2node:    结构体指针,指向链表结点的指针</span><br><span class="hljs-comment">** list:        结构体指针,一般将头结点声明为 list 类型</span><br><span class="hljs-comment">** position:    结构体指针,一般将其它结点声明为 position 类型</span><br><span class="hljs-comment">** elementType: 元素类型名 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr2node</span>;</span><br><span class="hljs-keyword">typedef</span> ptr2node <span class="hljs-built_in">list</span>;<br><span class="hljs-keyword">typedef</span> ptr2node position;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    elementType element;<br>    position next;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(elementType x, elementType y)</span>;<br><br><span class="hljs-comment">/*********************************************************/</span><br><span class="hljs-comment">/* 链表相关函数.除了创建空链表,其它函数都需要参数 list l,以指明操作对象 */</span><br><span class="hljs-comment">/********** 1.创建与销毁 **********/</span><br><span class="hljs-built_in">list</span> <span class="hljs-title function_">makeList</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">clearList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deleteList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><br><span class="hljs-comment">/********** 2.获取长度 **********/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmptyList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isLast</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, position p)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">lenList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><br><span class="hljs-comment">/********** 3.增删改查 **********/</span><br>position <span class="hljs-title function_">findPosition</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x)</span>;<br>position <span class="hljs-title function_">findPrevious</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">findIndex</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x, compare func)</span>;<br>elementType *<span class="hljs-title function_">findElem</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, <span class="hljs-type">int</span> index)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x, position p)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* SINGLE_LINKED_LIST_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p>常见错误</p><ul><li>未初始化指针: 如果不知道应将指针初始化为什么,则将其初始化为 NULL</li><li><code>malloc</code> 函数的使用<ul><li>声明一个结构体指针是并不创建该结构.仅留出足够容纳结构的空间</li><li>若只需要一个结构体指针沿着表前进(例: <code>printList</code> 函数中的 <code>tmp</code>),则不需要使用 <code>malloc</code></li><li>当空间不再需要时.应使用 <code>free</code> 函数回收</li><li>若链表未执行过删除操作,则 <code>malloc</code> 调用次数应等于表的大小.若有表头,调用次数会多一次</li></ul></li></ul></li></ol><h3 id="1-2-链表使用"><a href="#1-2-链表使用" class="headerlink" title="1.2 链表使用"></a>1.2 链表使用</h3><ol><li><p>双链表: 在数据结构中增加一个域,使其指向前一个单元</p><ul><li><p>增加空间需求.因为需要额外存储一个指针</p></li><li><p>使得插入和删除的开销增加一倍.因为需要对增加的指针进行定位</p></li><li><p>简化删除操作.因为不再需要定位前驱元</p></li></ul></li><li><p>循环链表: 令最后一个单元指向第一个单元(可以存在表头,令最后一个单元指向表头)</p></li><li><p><strong>桶排序(bucket sort)</strong></p><ul><li>问题: 存在 $n$ 个整数 $a_i(0\leq x_i\leq M-1,1\leq i\leq n)$ 需要排序</li><li>预留一个大小为 $M$ 的 count 数组.即 count 有 $M$ 个单元(桶).初始情况下 count 内元素为空</li><li>当 $a_i$ 被读入时,$\mathrm{count}[a_i]$ 自增1;所有的输入被读入后,扫描数组 count,打印排好序的表</li><li>该算法的时间花费为 $O(M+N)$</li></ul></li><li><p><strong>基数排序(radix sort)是桶式排序的推广</strong></p><ul><li><p>考虑当桶的数量远大于数的个数时.桶排序便不再适合</p></li><li><p>若存在 $n$ 个整数 $a_i(0\leq x_i\leq n^p-1,1\leq i\leq n)$ 需要排序.进行多次桶式排序</p></li><li><p>第一步以最低位进行桶式排序,依次按位数桶式排序,直到最高位完成进行桶式排序</p></li><li><p>该算法的时间花费为 $O(p(n+b))$.其中 p 为趟数,n 为元素个数,b 为桶数</p></li><li><p>例: 对 0~9 的立方进行基数排序</p><ul><li>原始数组: [0, 1, 512, 343, 64, 125, 216, 27, 8, 729]</li><li>第一次排序结果: [0, 1, 512 ,343, 64, 125, 216, 27, 8, 729]</li><li>第二次排序结果: [8, 1, 0], [216, 512], [729,27,125],  [343], [64]</li><li>第三次排序结果: [64,27,8,1,0], [125], [216], [343], [512], [729]</li></ul></li></ul></li></ol><h3 id="1-3-栈"><a href="#1-3-栈" class="headerlink" title="1.3 栈"></a>1.3 栈</h3><ol><li><p>栈(stack): 限制插入和删除只能在一个位置(栈顶, top)进行的表</p><ul><li>栈的基本操作有: 入栈(push),出栈(pop)</li><li>栈的特点: 后进先出(LIFO),且只有栈顶元素可访问</li><li>栈的链表实现及其操作不涉及栈的大小,因此均为常数时间开销.缺点在于需要承担 <code>malloc,free</code> 的开销</li><li>当栈采用头插法进行入栈,则头节点的后继元即为栈顶,因此出栈只需删除头节点的后继元</li></ul></li><li><p>栈接口(具体实现见 <code>stack</code>.不考虑数组实现方式)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STACK_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr2node</span>;</span><br><span class="hljs-keyword">typedef</span> ptr2node <span class="hljs-built_in">stack</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    elementType element;<br>    ptr2node next;<br>&#125;;<br><br><span class="hljs-built_in">stack</span> <span class="hljs-title function_">makeStack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deleteStack</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s, elementType x)</span>;<br>elementType <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* STACK_H */</span></span><br></code></pre></td></tr></table></figure></li></ol><h3 id="1-4-队列"><a href="#1-4-队列" class="headerlink" title="1.4 队列"></a>1.4 队列</h3><ol><li><p>队列(queue): 限制插入(队尾, rear)和删除(队头, front)只能在两端分别进行的表</p><ul><li>队列的基本操作有入队(enqueue),出队(dequeue)</li><li>队列的特点: 先进先出(FIFO);只有队头元素可访问</li></ul></li><li><p>队列的链表实现的注意事项</p><ul><li>队列需要指向队头(front)和队尾(rear)的两个指针</li><li>当进行入队操作时,采用尾插法,且需要将 rear 指针向后移动一位</li><li>当进行出队操作时,需要先判断队列是否为空(front &#x3D;&#x3D; rear),然后删除 front 指针的后继元</li></ul></li><li><p>队列接口(具体实现见 <code>queue</code>.不考虑数组实现方式)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> QUEUE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUEUE_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr2node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    elementType element;<br>    ptr2node next;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ptr2node front;<br>    ptr2node rear;<br>&#125; *<span class="hljs-built_in">queue</span>;<br><br><span class="hljs-built_in">queue</span> <span class="hljs-title function_">makeQueue</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deleteQueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q, elementType e)</span>;<br>elementType <span class="hljs-title function_">dequeue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* QUEUE_H */</span></span><br></code></pre></td></tr></table></figure></li></ol><h2 id="2-树"><a href="#2-树" class="headerlink" title="2 树"></a>2 树</h2><h3 id="2-1-树的实现"><a href="#2-1-树的实现" class="headerlink" title="2.1 树的实现"></a>2.1 树的实现</h3><ol><li><p>树的递归定义: 一棵<strong>树</strong>是一些节点的集合(可以是空集).若非空,则一棵树由称为<strong>根</strong>(root)的节点 r,以及0个或多个非空的(子)树 $T_1,T_2,\dots,T_k$ 组成,这些<strong>子树</strong>中的每一颗的根都被来自根 r 的一条有向边所连接</p><ul><li><strong>叶</strong>(leaf): 没有子节点的节点</li><li><strong>兄弟</strong>(sibling): 具有相同父节点的节点</li><li><strong>路径</strong>(path): 从节点 $n_1$ 到 $n_k$ 的路径为 $n_1, n_2,\dots,n_k$ 的一个序列.且对于 $1\leq i&lt;k$,有 $n_i$ 是 $n_{i+1}$ 的父节点</li><li><strong>路径的长</strong>(length): 路径上 边的条数,即 $k-1$.每一节点到自身的路径长为0</li><li><strong>深度</strong>(depth): 对于任意节点 $n_i$,其深度为从根到 $n_i$ 的唯一路径的长</li></ul></li><li><p>树的实现</p><ul><li><p>在每一个节点除数据外,还需要的两个指针指向它的第一子节点(向下)及下一个兄弟节点(向右)</p></li><li><p>树的节点声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">prtToNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> &#123;</span><br>    elementType element;<br>    prtToNode firstChild;<br>    prtToNode nextSibling;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>树的遍历</p><ul><li><p>树经常用于操作系统中的目录结构</p><ul><li>例如 Unix 系统中的文件 <code>/usr/mark/book/ch1.r</code></li><li>第一个 &#x2F; 后的每个 &#x2F; 都表示一条边</li></ul></li><li><p>考虑以下述格式打印目录中的所有文件: 深度为 $d_i$ 的文件的名称前有 $d_i$ 个 <kbd>tab</kbd> 进行缩进,然后打印</p></li><li><p>实现思路: 以递归的方式打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">listDir</span><span class="hljs-params">(directoryOrFile d, <span class="hljs-type">int</span> depth)</span> &#123;<br>    <span class="hljs-keyword">if</span>(d is a legitimate entry) &#123;<br>        printName(d, depth);<br>        <span class="hljs-keyword">if</span>(d is a directory) &#123;<br>            <span class="hljs-keyword">for</span> each child, c, of d<br>                <span class="hljs-title function_">listDir</span><span class="hljs-params">(c, depth + <span class="hljs-number">1</span>)</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">listDirectory</span><span class="hljs-params">(directoryOrFile d)</span> &#123;<br>    listDir(d, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>算法核心函数 <code>listDir</code>: 参数为目录树的引用.如果是目录,则递归的处理子节点,文件名则被缩进后打印</li><li>驱动函数 <code>listDirectory</code>: 考虑到 <code>listDir</code> 的参数 <code>depth</code> 为内部递归变量.<br>因此需要驱动函数(这里赋值为0)</li></ul></li></ul></li></ol><h3 id="2-2-二叉树"><a href="#2-2-二叉树" class="headerlink" title="2.2 二叉树"></a>2.2 二叉树</h3><ol><li><p><strong>二叉树</strong>: 每个节点的子节点都不超过2个的树</p><ul><li>平均二叉树的深度通常比节点数 N 小得多,平均深度为 $O(\sqrt N)$</li><li><strong>二叉查找树</strong>(binary search tree)的平均深度为 $O(\log N)$.但在最坏的情况下可以为 N-1</li></ul></li><li><p>二叉树的实现</p><ul><li><p>由于二叉树最多有两个子节点,因此可以直接用指针指向它们</p></li><li><p>二叉树的节点声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">ptrToNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ptrToNode</span> <span class="hljs-title">tree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> &#123;</span><br>    elementType element;<br>    tree left;<br>    tree right;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="2-3-二叉查找树"><a href="#2-3-二叉查找树" class="headerlink" title="2.3 二叉查找树"></a>2.3 二叉查找树</h3><ol><li><p>二叉树经常用于查找.给树中的每个节点指定一个关键字值(假定为整数,且唯一)</p></li><li><p><strong>二叉查找树</strong>: 对于树中的每个节点 X,其左子树所有关键字值小于X关键字值,右子树所有关键字值大于X关键字值</p><ul><li>考虑到树的递归定义,对二叉查找树的操作通常采用递归处理</li><li>考虑到所有的元素都是有序的,因此假定运算符 <code>&lt;, =, &gt;</code> 均可用于这些元素</li></ul></li><li><p>二叉查找树的声明(<code>searchTree.h</code>文件中)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SEARCH_TREE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEARCH_TREE_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">position</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">searchTree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> &#123;</span><br>    elementType element;<br>    searchTree left;<br>    searchTree right;<br>&#125;<br><br>searchTree <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">(searchTree t)</span>;  <span class="hljs-comment">// 创建空树</span><br>position <span class="hljs-title function_">find</span><span class="hljs-params">(elementType x, searchTree t)</span>;  <span class="hljs-comment">// 查找元素位置</span><br>position <span class="hljs-title function_">findMin</span><span class="hljs-params">(searchTree t)</span>;  <span class="hljs-comment">// 查找最小值位置</span><br>position <span class="hljs-title function_">findMax</span><span class="hljs-params">(searchTree t)</span>;  <span class="hljs-comment">// 查找最大值位置</span><br>searchTree <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, searchTree t)</span>;  <span class="hljs-comment">// 插入元素</span><br>searchTree <span class="hljs-title function_">delete</span><span class="hljs-params">(elementType x, searchTree t)</span>;  <span class="hljs-comment">// 删除元素</span><br>elementType <span class="hljs-title function_">retrieve</span><span class="hljs-params">(position p)</span>;  <span class="hljs-comment">// 检索位置信息</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* SEARCH_TREE_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p>源文件 <code>searchTree.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c">searchTree <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">(searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t != <span class="hljs-literal">NULL</span>) &#123;<br>        makeEmpty(t-&gt;left);<br>        makeEmpty(t-&gt;right);<br>        <span class="hljs-built_in">free</span>(t);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>position <span class="hljs-title function_">find</span><span class="hljs-params">(elementType x, searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(x &lt; t-&gt;element)<br>        <span class="hljs-keyword">return</span> find(x, t-&gt;left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t-&gt;element)<br>        <span class="hljs-keyword">return</span> find(x, t-&gt;right);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> t;<br>&#125;<br><br>position <span class="hljs-title function_">findMin</span><span class="hljs-params">(searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;left == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> t;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> findMin(t-&gt;left);<br>&#125;<br><br>position <span class="hljs-title function_">findMax</span><span class="hljs-params">(searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t != <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">while</span>(t-&gt;right != <span class="hljs-literal">NULL</span>)<br>            t = t-&gt;right;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br>searchTree <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>) &#123;<br>        t = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> treeNode));<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">NULL</span>)<br>            fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            t-&gt;element = x;<br>            t-&gt;left = t-&gt;right = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; t-&gt;element)<br>        t-&gt;left = insert(x, t-&gt;left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t-&gt;element)<br>        t-&gt;right = insert(x, t-&gt;right);<br>    <span class="hljs-comment">/* else x已经在树中,不在执行任何操作 */</span><br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br>searchTree <span class="hljs-title function_">delete</span><span class="hljs-params">(elementType x, searchTree t)</span> &#123;<br>    position tmp;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)  <span class="hljs-comment">/* 空树 */</span><br>        Error(<span class="hljs-string">&quot;Element not found&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; t-&gt;element)  <span class="hljs-comment">/* 向左 */</span><br>        t-&gt;left = delete(x, t-&gt;left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t-&gt;element)  <span class="hljs-comment">/* 向右 */</span><br>        t-&gt;right = delete(x, t-&gt;right);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;left &amp;&amp; t-&gt;right) &#123; <span class="hljs-comment">/* 2个子节点 */</span><br>        tmp = findMin(t-&gt;right);<br>        t-&gt;element = tmp-&gt;element;<br>        t-&gt;right = delete(t-&gt;element, t-&gt;right);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        tmp = t;<br>        <span class="hljs-keyword">if</span>(t-&gt;left == <span class="hljs-literal">NULL</span>)<br>            t = t-&gt;right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;right == <span class="hljs-literal">NULL</span>)<br>            t = t-&gt;left;<br>        <span class="hljs-built_in">free</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-AVL-树"><a href="#2-4-AVL-树" class="headerlink" title="2.4 AVL 树"></a>2.4 AVL 树</h3><ol><li><strong>AVL树</strong>(Adelson-Velskii Landis): 带有平衡条件(需易保持)的二叉查找树.且保证树的深度为$O(\log N)$<ul><li>AVL 树要求每个节点的左子树和右子树的高度最多差1(空树的高度定义为-1)</li><li>AVL 树的高度最多为$1.44\log (N+2)-1.328$. 因此可以保证除插入外的操作(删除为惰性)均为 $O(\log N)$</li></ul></li><li><strong>旋转</strong>: AVL 树的插入操作可能会破坏平衡条件,因此隐含着困难.但总是可以经过修正使得性质恢复<ul><li>插入后,只有插入点到根节点路径上的节点的平衡可能被改变.沿着此路径向上找到一个破坏了 AVL 条件的节点,调整该节点重新平衡该树,将会使得整棵树满足 AVL 条件</li><li>设需要重新平衡的节点为 $\alpha$.导致不平衡出现的插入位置共有4种情况<ol><li>左子节点的左子树</li><li>左子节点的右子树</li><li>右子节点的左子树</li><li>右子节点的右子树</li></ol></li><li>情形1,4 与 情形2,3 为关于 $\alpha$节点的对称.分别通过单旋转和双旋转进行处理</li></ul></li></ol><h2 id="3-散列"><a href="#3-散列" class="headerlink" title="3 散列"></a>3 散列</h2><h3 id="3-1-散列函数"><a href="#3-1-散列函数" class="headerlink" title="3.1 散列函数"></a>3.1 散列函数</h3><ol><li><p>散列表(hash table)ADT: 仅支持二叉查找树所允许的一部分操作,其实现常称为<strong>散列</strong>(hashing)</p><ul><li>散列以常数平均时间执行 插入,删除,查找,但需要元素间任何排序信息的操作不会得到有效支持</li><li>理想的散列表数据结构是一个含有<strong>关键字</strong>的具有固定大小的数组</li><li>关键字的典型是带有信息的字符串,而表的大小记为 Table-Size</li></ul></li><li><p><strong>映射函数</strong>(hash function): 将关键字映射到 [0, Table-Size) 区间中的某个数,且放到适当的单元中</p><ul><li>理想的映射函数应运算简单,且保证不同的关键字映射到不同的单元</li><li>实际上不可能,因为关键字是无穷的,而单元的数量是有限的</li><li>因此要找一个散列函数,能在单元间均匀的分配关键字</li><li><strong>冲突</strong>(collision): 两个关键字散列到同一个值</li></ul></li><li><p>散列函数</p><ul><li><p>若输入的关键字为整数,一般采用返回 <code>key mod tableSize</code>.保证表的大小为素数时效果较好</p></li><li><p>若输入的关键字为字符串</p><ol><li><p>可以将字符串中的字符的 ASCII 码值之和作为关键字(简单,但当表很大时将会分配不均)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index;<br>index <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">int</span> tableSize)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashVal = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*key != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        hashVal += *key++;<br>    <span class="hljs-keyword">return</span> hashVal % tableSize;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>考虑计算 $\mathrm{\sum\limits_{i&#x3D;0}^{keySize&#x3D;1}key[keySize-i-1]}\cdot 32^i$(根据 Horner 法则计算 32 的多项式函数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">index <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">int</span> tableSize)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashVal = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*key != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        hashVal = (hashVal &lt;&lt; <span class="hljs-number">5</span>) + *key++;<br>    <span class="hljs-keyword">return</span> hashVal % tableSize;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如计算 $h_k &#x3D; k_1 + 32k_2 + 32^2k_3$ 的方式为 $h_k &#x3D; ((k_3) \times 32 + k_2) \times 32+k_1$ </li><li>关键行中的 <code>&lt;&lt; 5</code> 即为乘以32, 且其中的加法还可以使用按位异或 <code>^</code> 代替</li><li>该算法的优点在于极其简单,当允许溢出时速度很也快</li><li>如果关键字特别长,不仅时间花费大,而且前面的字符还会被移出.此时通常不采用全部字符</li></ul></li></ol></li></ul></li></ol><h3 id="3-2-消除冲突"><a href="#3-2-消除冲突" class="headerlink" title="3.2 消除冲突"></a>3.2 消除冲突</h3><ol><li><p>当一个元素被插入处已存在另一个元素(即不同关键字的散列值相同),此时将产生冲突</p><ul><li>解决冲突的方式有: 分离链接法(separate chaining), 开放定址法(open addressing)</li></ul></li><li><p>分离链接法: 将散列到同一个值的所有元素保存到一个表中</p><ul><li><p>示例: 关键字为前10个数的平方(0, 1, 4, 9, 16, 25, 36, 49, 64, 81).散列函数为 $hash(x) &#x3D; x \space mod \space 10$</p></li><li><p>则分离链接散列表形如</p><p><img src="/2023/05/04/Computer/C-Language-Data-Structures/3-Detach-link-hash-tables.png"></p></li><li><p>插入操作: 遍历相应的表以检查该元素是否以处于适当的位置.如果是新元素,则将其插入到表的前端&#x2F;末尾</p></li><li><p>分离链接散列表的的实现</p><ul><li><p>头文件 <code>hashSeq.h</code> 中(其中 listNode 的结构与链表相同)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HASH_SEQ_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HASH_SEQ_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTbl</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">position</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTbl</span> *<span class="hljs-title">hashTable</span>;</span><br><br>hashTable <span class="hljs-title function_">initializeTable</span><span class="hljs-params">(<span class="hljs-type">int</span> tableSize)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">destroyTable</span><span class="hljs-params">(hashTable h)</span>;<br>position <span class="hljs-title function_">find</span><span class="hljs-params">(elementType key, hashTable h)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType key, hashTable h)</span>;<br>elementType <span class="hljs-title function_">retrieve</span><span class="hljs-params">(position p)</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br>    elementType element;<br>    position next;<br>&#125;<br><span class="hljs-keyword">typedef</span> position <span class="hljs-built_in">list</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTbl</span> &#123;</span><br>    <span class="hljs-type">int</span> tableSize;<br>    <span class="hljs-built_in">list</span> *theLists;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>源文件 <code>hashSeq.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">hashTable <span class="hljs-title function_">initializeTable</span><span class="hljs-params">(<span class="hljs-type">int</span> tableSize)</span> &#123;<br>    hashTable h;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>(tableSize &lt; minTableSize) &#123;<br>        error(<span class="hljs-string">&quot;Table size too small&quot;</span>);<br>        retrun <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>    h = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> hashTbl));<br>    <span class="hljs-keyword">if</span>(h == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    h-&gt;tableSize = nextPrime(tableSize);<br>    <br>    h-&gt;theLists = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">list</span>) * h-&gt;tableSize);<br>    <span class="hljs-keyword">if</span>(h-&gt;theLists == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; h-&gt;tableSize; i++) &#123;<br>        h-&gt;theLists[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> listNode));<br>        <span class="hljs-keyword">if</span>(h-&gt;theLists[i] == <span class="hljs-literal">NULL</span>)<br>            fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            h-&gt;theLists[i]-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType key, hashTable h)</span> &#123;<br>    position pos, newCell;<br>    <span class="hljs-built_in">list</span> l;<br>    pos = find(key, h);<br>    <span class="hljs-keyword">if</span>(pos == <span class="hljs-literal">NULL</span>) &#123;<br>        newCell = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> listNode));<br>        <span class="hljs-keyword">if</span>(newCell == <span class="hljs-literal">NULL</span>)<br>            fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            l = h-&gt;thelists[hash(key, h-&gt;tableSize)];<br>            newCell-&gt;next = l-&gt;next;<br>            newCell-&gt;element = key;<br>            l-&gt;next = newCell;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>开放定址法: 当冲突发生时,尝试选择另外的单元,知道找出空的单元为止</p><ul><li>考虑单元 $h_0(X),h_1(X),h_2(X), \cdots,$相继试选.其中 $h_i(X) &#x3D; (hash(x)+F(i))\mod \mathrm{tableSize}$</li><li>函数 $F$ 是冲突解决方法,且 $F(0) &#x3D; 0$ </li><li>开放地址法需要将所有数据置于表内,因此散列表较大.但省去了给新单元分配地址的时间</li></ul></li></ol><h3 id="3-3-再散列"><a href="#3-3-再散列" class="headerlink" title="3.3 再散列"></a>3.3 再散列</h3><ol><li><p><strong>再散列</strong>(rehashing): 对于开放定址法,如果表的元素太满,则操作时间消耗增长,且插入可能失败.此时可以建立另外一个约两倍大的表(同时使用一个相关的新散列函数),扫描整个原始散列表,计算每个元素的新散列值并将其插入到新表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">hashTable <span class="hljs-title function_">rehash</span><span class="hljs-params">(hashTable h)</span> &#123;<br>    <span class="hljs-type">int</span> i, oldSize;<br>    cell *oldCell;<br>    oldCells = h-&gt;theCells;<br>    oldSize = h-&gt;tableSize;<br>    h = initializeTable(<span class="hljs-number">2</span> * oldSize);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; oldSize; i++) &#123;<br>        <span class="hljs-keyword">if</span>(oldCells[i].info == legitimate)<br>            insert(oldCells[i].element, h);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(oldCells);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-优先队列"><a href="#4-优先队列" class="headerlink" title="4 优先队列"></a>4 优先队列</h2><h3 id="4-1-优先队列"><a href="#4-1-优先队列" class="headerlink" title="4.1 优先队列"></a>4.1 优先队列</h3><ol><li><strong>优先队列</strong>(priority queue): 是允许至少插入(入队)和删除最小(出队:找出,返回,删除优先队列中的最小元素)的数据结构</li><li>优先队列的简单实现方式<ul><li>使用简单链表: 在表头进行插入$O(1)$,遍历链表以实现删除最小元$O(n)$</li><li>始终让表保持排序状态: 进行顺序插入$O(n)$和删除操作$O(1)$</li><li>二叉查找树: 对插入和删除操作均为 $O(\log n)$</li></ul></li></ol><h3 id="4-2-二叉堆"><a href="#4-2-二叉堆" class="headerlink" title="4.2 二叉堆"></a>4.2 二叉堆</h3><ol><li><p>二叉堆(binary heap) 具有两个性质: 结构性和堆序性.因此堆的操作需要堆的所有性质都被满足才终止</p></li><li><p>结构性质: <strong>堆</strong>(heap): 一颗被完全填满的二叉树(完全二叉树, complete binary tree),底层可以例外(从左到右填入)</p><ul><li>高为 h 的完全二叉树节点数为: $[2^h, 2^{h+1})$.因而完全二叉树的高是 $\lfloor \log N \rfloor$</li><li>完全二叉树可以用数组进行表示,而不需要指针</li><li>考虑位置为 i 的元素,其左子节点位于 2i,右子节点位于左子节点后的 2i+1,父节点位于 $\lfloor i&#x2F;2 \rfloor$ </li><li>堆数据结构将由 一个数组(无论关键为什么类型),一个代表最大值的整数,当前堆大小的整数 组成</li></ul></li><li><p>堆序性质: 使操作快速执行</p><ul><li>考虑需要找出最小元,因此最小元应该在根上</li><li>将任意子树也视为一个堆,则任意节点应小于其所有后裔</li><li><strong>堆序性质</strong>: 在一个堆中,对于任意节点 X, X父节点的关键字小于X的关键字(根节点除外)</li></ul></li><li><p>优先队列的声明(<code>binaryHeap.h</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BIN_HEAP_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIN_HEAP_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapStruct</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapStruct</span> *<span class="hljs-title">priorityQueue</span>;</span><br><br>priorityQueue <span class="hljs-title function_">initialize</span><span class="hljs-params">(<span class="hljs-type">int</span> maxElements)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, priorityQueue h)</span>;<br>elementType <span class="hljs-title function_">deleteMin</span><span class="hljs-params">(priorityQueue h)</span>;<br>elementType <span class="hljs-title function_">findMin</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">(priorityQueue h)</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapStruct</span> &#123;</span><br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> size;<br>    elementType *elements;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>优先队列的操作(<code>binaryHeap.c</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">priorityQueue <span class="hljs-title function_">initialize</span><span class="hljs-params">(<span class="hljs-type">int</span> maxElements)</span> &#123;<br>    priorityQueue h;<br>    <span class="hljs-keyword">if</span>( maxElements &lt; minPQSize )<br>        error(<span class="hljs-string">&quot;Priority queue size is too small&quot;</span>);<br>    h = <span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>( <span class="hljs-keyword">struct</span> heapStruct ) );<br>    <span class="hljs-keyword">if</span>(h == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    h-&gt;elements = <span class="hljs-built_in">malloc</span>( ( maxElements + <span class="hljs-number">1</span> ) * <span class="hljs-keyword">sizeof</span>(elementsType) );<br>    <span class="hljs-keyword">if</span>( h-&gt;elements == <span class="hljs-literal">NULL</span> )<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    h-&gt;capacity = maxElements;<br>    h-&gt;size = <span class="hljs-number">0</span>;<br>    h-&gt;elements[<span class="hljs-number">0</span>] = minData;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, priorityQueue h)</span> &#123;<br>    <span class="hljs-keyword">if</span>(isFull(h)) &#123;<br>        error(<span class="hljs-string">&quot;Priority queue is full&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = ++h-&gt;size; h-&gt;elements[ i / <span class="hljs-number">2</span> ] &gt; x; i /= <span class="hljs-number">2</span>)<br>        h-&gt;elements[ i ] = h-&gt;elements[ i / <span class="hljs-number">2</span> ];<br>    h-&gt;elements[i] = x;<br>&#125;<br><br>elementType <span class="hljs-title function_">deleteMin</span><span class="hljs-params">(priorityQueue h)</span> &#123;<br>    <span class="hljs-type">int</span> child;<br>    elementType minElement, lastElement;<br>    <span class="hljs-keyword">if</span>( isEmpty(h) ) &#123;<br>        error(<span class="hljs-string">&quot;Priority queue is full&quot;</span>);<br>        <span class="hljs-keyword">return</span> h-&gt;elements[<span class="hljs-number">0</span>];<br>    &#125;<br>    minElement = h-&gt;elements[<span class="hljs-number">1</span>];<br>    lastElement = h-&gt;elements[h-&gt;size--];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i * <span class="hljs-number">2</span> &lt;=  h-&gt;size; i = child) &#123;<br>        child = i * <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(child != h-&gt;size &amp;&amp; h-&gt;elements[child+<span class="hljs-number">1</span>] &lt; h-&gt;elements[child])<br>            child++;<br>        <span class="hljs-keyword">if</span>(lastElement &gt; h-&gt;elements[child])<br>            h-&gt;elements[i] = h-&gt;elements[child];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    h-&gt;elements[i] = lastElement;<br>    <span class="hljs-keyword">return</span> minElement;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-排序"><a href="#5-排序" class="headerlink" title="5 排序"></a>5 排序</h2><ol><li>排序算法接受的参数为: 数组首地址, 及一个表示数组元素个数的整数</li><li>基于比较的排序: 假定对于元素而言,运算符 <code>&lt;, &gt;</code> 是存在的</li><li>逆序(inversion): 与线性代数中的关于排列的逆序数定义类似<ul><li>n 个互异数的数组的平均逆序数为 $\frac{n(n-1)}4$</li><li>通过交换相邻元素进行排序的任何算法平均需要 $\Omega(N^2)$</li><li>排序算法通过删除逆序进行,为了有效运行,必须每次删除不止一个逆序</li></ul></li><li>间接排序(indirect sorting): 由于交换结构的操作是昂贵的,因而可以创建数组(其元素为指向结构的指针).通过比较指针指向的关键字,并在必要时交换指针来进行排序</li><li>排序的一般下界<ul><li>任何只用到比较的算法在最坏的情况下需要 $\Omega(N\log N)$ 次比较,因而归并排序和堆排序最优</li><li>任何只用到比较的算法在平均的情况下需要 $\Omega(N\log N)$ 次比较,因而快速排序是最优的</li></ul></li></ol><h3 id="5-1-插入排序"><a href="#5-1-插入排序" class="headerlink" title="5.1 插入排序"></a>5.1 插入排序</h3><ol><li><p>插入排序(insert sort)</p><ul><li><p>将数组假想为两部分: 前面的为已排序数组,后面的为待排序数组</p></li><li><p>初始状态为已排序数组只有第一个元素,剩余为待排序数组</p></li><li><p>遍历待排序数组,将每个未排序元素插入到已排序数组中恰当的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    elementType tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>; p &lt; n; ++p) &#123;<br>        tmp = arr[p];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = p; j&gt;<span class="hljs-number">0</span> &amp;&amp; arr[j<span class="hljs-number">-1</span>] &gt; tmp; --j)<br>            arr[j] = arr[j<span class="hljs-number">-1</span>];<br>        arr[j] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>时间复杂度: $O(N^2)$</p><ul><li>当输入数据为逆序时,达到此上界</li><li>当输入数据已排序时,运行时间为 $O(N)$</li><li><strong>对于几乎已经排序的数据(逆序数 I 较小),插入排序很快,其时间为 $O(I+N)$</strong></li></ul></li></ol><h3 id="5-2-希尔排序"><a href="#5-2-希尔排序" class="headerlink" title="5.2 希尔排序"></a>5.2 希尔排序</h3><ol><li><p>希尔排序(缩小增量排序, diminishing increment sort): 先将整个待排序的序列分割为若干子序列分别进行直接插入排序,待整个序列中的记录基本有序时,在对全体进行直接插入排序</p><ul><li><p>增量序列: $h_1, h_2, \dots,h_t$,其中 $h_1 &#x3D; 1$</p></li><li><p>$h_k$-排序数组: $\forall i,arr[i] \leq arr[i+h_k]$</p></li><li><p>希尔增量通常取 $h_t &#x3D; \lfloor n&#x2F;2 \rfloor, h_k &#x3D; \lfloor h_{k+1}&#x2F;2 \rfloor$ </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    elementType tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> increment = n/<span class="hljs-number">2</span>; increment &gt; <span class="hljs-number">0</span>; increment /= <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = increment; i &lt; n; ++i) &#123;<br>            tmp = arr[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &gt;= increment; j -= increment)<br>                <span class="hljs-keyword">if</span>(tmp &lt; arr[j - increment])<br>                    a[j] = a[j - increment];<br>            <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">break</span>;<br>                arr[j] = tmp;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>时间复杂度(希尔排序算法简单,但分析极其困难)</p><ul><li>希尔增量下的希尔排序的最坏情形运行时间 $\Theta(N^2)$</li><li>Hibbard 增量: 形如 $1, 3, 7, \dots , 2^k-1$.最坏情形运行时间 $\Theta(N^\frac32)$</li></ul></li></ol><h3 id="5-3-堆排序"><a href="#5-3-堆排序" class="headerlink" title="5.3 堆排序"></a>5.3 堆排序</h3><ol><li><p>堆排序(heap sort): 考虑建立二叉堆 $O(N)$,执行 N 次 <code>deleteMin</code> $O(N\log N)$.按照顺序,最小的元素将会先离开堆,将这些元素记录到第二个数组即可得到排序数组</p></li><li><p>上述算法需要额外的数组空间,可以每次在 <code>deleteMin</code> 操作后,将最后空出来的单元用于存放元素.此时得到的将是逆序的排序数组,因而可以构建具有 <code>deleteMax</code> 操作的二叉堆</p></li><li><p>堆排序是非常稳定的算法: 平均使用的比较只比最坏情形略少</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> leftChild(i) (2 * (i) + 1)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">percDown</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> child;<br>    <span class="hljs-keyword">for</span>(elementType tmp = arr[i]; leftChild(i) &lt; n; i = child) &#123;<br>        <span class="hljs-keyword">if</span>(child != n - <span class="hljs-number">1</span> &amp;&amp; arr[child + <span class="hljs-number">1</span>] &gt; arr[child])<br>            child++;<br>        <span class="hljs-keyword">if</span>(tmp &lt; a[child])<br>            arr[i] = arr[child];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    arr[i] = tmp;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        percDown(arr, i, n);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>        swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[i]);<br>        percDown(arr, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-4-归并排序"><a href="#5-4-归并排序" class="headerlink" title="5.4 归并排序"></a>5.4 归并排序</h3><ol><li><p>考虑合并2个已排序的数组: 设定2个指针分别指向数组的起始位置.比较2个指针指向的元素,将较小的元素放入输出数组,并移动指针.重复这一过程,直到某一指针到达末尾</p></li><li><p>归并排序(merge sort): 以分治递归的形式合并已排序数组 $O(N\log N)$.使用的比较次数几乎最优</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mSort</span><span class="hljs-params">(elementType arr[], elementType tmpArr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> center;<br>    <span class="hljs-keyword">if</span>(left &lt; right) &#123;<br>        center = (left + right) / <span class="hljs-number">2</span>;<br>        mSort(arr, tmpArr, left, center);<br>        mSort(arr, tmpArr, center + <span class="hljs-number">1</span>, right);<br>        merge(arr, tmpArr, left, center + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mergeSord</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    elementType *tmpArr = <span class="hljs-built_in">malloc</span>( n * <span class="hljs-keyword">sizeof</span>(elementType) );<br>    <span class="hljs-keyword">if</span>(tmpArr != <span class="hljs-literal">NULL</span>) &#123;<br>        mSort(arr, tmpArr, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">free</span>(tmpArr);<br>    &#125; <span class="hljs-keyword">else</span><br>        fatalError(<span class="hljs-string">&quot;No space for tmp array!&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(elementType arr[], elementType tmpArr[], <span class="hljs-type">int</span> lpos, <span class="hljs-type">int</span> rpos, <span class="hljs-type">int</span> rightEnd)</span> &#123;<br>    <span class="hljs-type">int</span> leftEnd = rpos - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> tmpPos = lpos;<br>    <span class="hljs-type">int</span> numElements = rightEnd - lpos + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(lpos &lt;= leftEnd &amp;&amp; rpos &lt;= rightEnd)<br>        <span class="hljs-keyword">if</span>(arr[lpos] &lt;= arr[rpos])<br>            tmpArr[tmpPos++] = arr[lpos++];<br>    <span class="hljs-keyword">else</span><br>            tmpArr[tmpPos++] = arr[rpos++];<br>    <span class="hljs-keyword">while</span>(lpos &lt;= leftEnd)<br>        tmpArr[tmpPos++] = arr[lpos++];<br>    <span class="hljs-keyword">while</span>(rpos &lt;= rightEnd)<br>        tmpArr[tmpPos++] = arr[rpos++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numElements; ++i, --rightEnd) &#123;<br>        arr[rightEnd] = tmpArr[rightEnd];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-5-快速排序"><a href="#5-5-快速排序" class="headerlink" title="5.5 快速排序"></a>5.5 快速排序</h3><ol><li><p>快速排序(quick sort): 实践中最快的已知排序算法,平均运行时间 $O(N\log N)$</p><ul><li>若 S 中元素个数为 0 或 1,则直接返回</li><li>选取 S 中的任意元素 v,其称为基准(pivot)</li><li>分区并排序: 将 $S-{v}$ 分为两个不相交集合: $S_1 &#x3D;{x\in S-{v}|x\leq v},S_2 &#x3D;{x\in S-{v}|x\geq v} $ </li><li>递归地将小于基准元素的子数列和大于基准值元素的子数组排序</li></ul></li><li><p>选取基准</p><ul><li>错误的方式: 选取第一个元素作为基准.若输入是预排序或反序的,将会产生劣质的分割</li><li>安全的方式: 随机选取基准.但考虑到生成随机数是昂贵的,因而无法减少算法其余部分的平均运行时间</li><li>数中值分割法: 基准的最好选择是数组的中值,但这很难算出.因而可以考虑三个元素(左侧,中心,右侧位置)的中值作为基准.消除了预排序输入的坏情形,并减少约 5% 的时间</li></ul></li><li><p>分割策略</p><ul><li>将基准元与最后的元素进行交换,使得基准元离开要被分割的数据段</li><li>设置双指针 i, j. 初始时刻分别指向数组的第一个元素和倒数第二个元素(因为最后一个元素为基准)</li><li>当 i &lt; j 时,将 i 右移,直到遇到大于基准元的数.同理,将 j 左移,直到遇到小于基准元的数</li><li>若停止后的仍满足 i &lt; j,则将 i, j 指向的两个元素互换.重复该过程,直到 i, j 彼此交错</li><li>当 i, j 交错后,将基准元与 i 所指向的元素互换,即可完成分割</li></ul></li><li><p>对于小数组(n &lt; 20),快速排序不如插入排序好</p><ul><li>由于快速排序是递归的,因此小数组排序的情况经常发生</li><li>对小数组不进行递归排序,而进行插入排序将会节约15%的时间.截至范围可选择 n&#x3D;10</li></ul></li><li><p>快速排序的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    qSort(arr, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>&#125;<br><br>elementType <span class="hljs-title function_">median3</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> center = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(arr[left] &gt; arr[center])<br>        swap(&amp;arr[left], &amp;arr[center]);<br>    <span class="hljs-keyword">if</span>(arr[left] &gt; arr[right])<br>        swap(&amp;arr[left], &amp;arr[right]);<br>    <span class="hljs-keyword">if</span>(arr[center] &gt; arr[right])<br>        swap(&amp;arr[center], &amp;arr[right]);<br>    swap(&amp;arr[center], &amp;arr[right - <span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> arr[right - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">qSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    elementType pivot;<br>    <span class="hljs-keyword">if</span>(left + cutOff &lt;= right) &#123;<br>        pivot = median3(arr, left, right);<br>        <span class="hljs-type">int</span> i = left;<br>        <span class="hljs-type">int</span> j = right - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(;;) &#123;<br>            <span class="hljs-keyword">while</span>(arr[++i] &lt; pivot) &#123;&#125;<br>            <span class="hljs-keyword">while</span>(arr[--j] &lt; pivot) &#123;&#125;<br>            <span class="hljs-keyword">if</span>(i &lt; j)<br>                swap(&amp;arr[i], &amp;arr[j]);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        swap(&amp;arr[i], &amp;arr[right - <span class="hljs-number">1</span>]);<br>        qSort(arr, left, i - <span class="hljs-number">1</span>);<br>        qSort(arr, i + <span class="hljs-number">1</span>, right);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        insertSort(arr + left, right - left + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-图论算法"><a href="#6-图论算法" class="headerlink" title="6 图论算法"></a>6 图论算法</h2><h3 id="6-1-图的定义"><a href="#6-1-图的定义" class="headerlink" title="6.1 图的定义"></a>6.1 图的定义</h3><ol><li>图(graph): 由顶点(vertex)的集合 V,边(edge)的集合 E 组成<ul><li>每条边都是点对(v, w), 其中 $v,w\in V$</li><li>若点对是有序的,则图是有向(directed)的,称为有向图(digraph)</li><li>顶点 v, w 邻接等价于当 $(v,w)\in E$</li><li>边可以有第三种成分: 权(weight) 或 值(cost)</li></ul></li><li>图中的路径(path)<ul><li>路径是顶点序列: $w_1, w_2, \dots, w_N \space\space \mathrm{s.t.}(w_i,w_{i+1})\in E,1\leq i&lt;E$ </li><li>路径的长(length): 边的数量,即 N-1</li><li>环(loop): 从一个顶点到自身的边</li><li>简单路径: 所有的顶点都互异,但第一个和最后一个顶点可以相同</li></ul></li><li>图中的圈(cycle)<ul><li>有向图中的圈: 满足 $w_1 &#x3D; w_N$ 且长至少为1的一条路径</li><li>无向图中的圈则额外要求边是互异的</li></ul></li><li>连通(connected)<ul><li>在无向图中从每一个顶点到每个其他顶点都存在一条路径</li><li>在有向图中,这种性质称为强连通(strongly connected)</li><li>若有向图不是强连通的,但其基础图(underlying graph, 即去掉弧的方向)是连通的,则称为弱连通(weakly connected)</li><li>完全图(complete graph): 每个顶点间都存在一条边</li></ul></li><li>图的表示(有向图)<ul><li>使用一个二维数组,即**邻接矩阵(adjacent matrix)**表示<ul><li>对于每条边(u, v),置 <code>A[u][v] = 1</code>.其他元素为0</li><li>若该边有一个权,则可置 <code>A[u][v]</code> 等于该权.使用很大&#x2F;小的数表示不存在的边</li><li>若图是稀疏的(sparse), 该方法所需求的空间 $\Theta(|V|^2)$ 过大了</li></ul></li><li><strong>邻接表(adjacent list)</strong>: 对每一个顶点,使用一个表存放所有的邻接点<ul><li>空间需求为 $O(|E|+|V|)$</li><li>邻接表是图的标准表示方法</li></ul></li><li>考虑到实际中顶点都有名字,因此需要使用散列表建立名字到数字的映射<ul><li>散列表中对每个顶点存储一个名字和一个内部编号( 1 ~ |V| 之间)</li></ul></li></ul></li></ol><h3 id="6-2-最短路径算法"><a href="#6-2-最短路径算法" class="headerlink" title="6.2 最短路径算法"></a>6.2 最短路径算法</h3><ol><li><p>输入一个赋权图: 与每条边 $(v_i, v_j)$ 联系的是穿越该弧的代价 $c_{i,j}$</p><ul><li>赋权路径长(weighted path length): $v_1v_2\dots v_N$ 路径的值为 $\sum\limits^{N-1}<em>{i&#x3D;1}c</em>{i,j}$</li></ul></li><li><p>单源最短路径问题: 给定赋权图 $G&#x3D;(V,E)$ 和特定顶点 s 作为输入,找出 s 到 G 每个点的最短赋权路径</p></li><li><p>无权最短路径</p><ul><li><p>广度优先搜索(breadth-first search): 按层处理顶点,距离最近的先辈赋值,最远的最后赋值</p></li><li><p>显然顶点s到自身距离为0,然后考察与s邻接的点,其距离为1.然后考察邻接的邻接,直到完成所有点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unWeigted</span><span class="hljs-params">(table t)</span> &#123;<br>    vertex v, w;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> currDist = <span class="hljs-number">0</span>; currDist &lt; numVetex; ++currDist)<br>        <span class="hljs-keyword">for</span> each vertex v<br>            <span class="hljs-title function_">if</span><span class="hljs-params">(!t[v].known &amp;&amp; t[v].dist == currDist)</span> &#123;<br>                t[v].known = True;<br>                <span class="hljs-keyword">for</span> each w adjacent to v<br>                    <span class="hljs-title function_">if</span><span class="hljs-params">(t[w].dist == infinity)</span> &#123;<br>                        t[w].dist = currDist + <span class="hljs-number">1</span>;<br>                        t[w].path = v;<br>                    &#125;<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Dijkstra 算法: 考虑赋权图的单源最短路径问题.仍借鉴无权时的思路</p><ul><li>顶点 s 到自身的距离为0,将其标记为已知,因为此时多了一个已知点,则可以获得其到达邻接点的距离</li><li>选取距离最小的点(贪心法,greedy algorithm)标记为已知,则有可以更新其到达邻接点的距离</li><li>重复该过程,直到获得到达目标点的最短距离</li><li>对于没有负值边的图,该算法总能完成.一旦出现负值边,则可能出现错误的答案</li></ul></li></ol><h2 id="7-算法设计技巧"><a href="#7-算法设计技巧" class="headerlink" title="7 算法设计技巧"></a>7 算法设计技巧</h2><h3 id="7-1-贪婪算法"><a href="#7-1-贪婪算法" class="headerlink" title="7.1 贪婪算法"></a>7.1 贪婪算法</h3><ol><li>贪婪算法分阶段工作.在每一个阶段,认为所作的决定是最好的,而不考虑将来的后果(即局部最优)<ul><li>当算法终止时,若局部最优就是全局最优,则算法正确.否则将得到一个次优解(suboptimal solution)</li><li>若不要求绝对最佳答案,也可通过简单的贪婪算法生成近似答案</li></ul></li><li>Huffman 编码<ul><li>ASCII 编码有约100个可打印字符和控制字符组成,需要 $\lceil \log 128\rceil&#x3D;7$ 位表示,可添加第8位作为校验位<ul><li>现实中,许多文件都含有大量的数字,空格和换行,而 q, x 很少</li><li>采用非等长编码,使经常出现的字符代码较短,可以节约磁盘空间</li></ul></li><li>对于代表字符的二进制代码,可以用二叉树来表示<ul><li>只在树叶上有数据.且每个字符从根节点开始,用0指示向左分支,用1指示向右分支</li><li>若字符 $c_i$ 在深度 $d_i$ 处,且出现 $f_i$ 次.则该字符代码的值(cost)为 $\sum d_i f_i$</li></ul></li></ul></li><li>Huffman 算法<ul><li>假设字符数量为 C.算法开始时存在 C 棵单节点树(每个字符一颗)</li><li>任意选取有最小权(树的权等于其树叶频率的和)的两棵树,任意形成以这两棵树为子树的新树</li><li>将这样的过程进行 C-1 次.即可得到最优 Huffman 编码树</li></ul></li></ol><h3 id="7-2-分治算法"><a href="#7-2-分治算法" class="headerlink" title="7.2 分治算法"></a>7.2 分治算法</h3><ol><li>分治(divide and conquer)算法<ul><li>分: 递归解决较小的问题(基本情况除外)</li><li>治: 从子问题的解 构建原问题的解</li></ul></li><li>最近点问题: 找出平面上点列中最近(欧几里得距离)的一对点<ul><li>暴力算法: 计算每个点对之间的距离,找出最小值 $O(N^2)$</li><li>分治算法思路<ul><li>将平面上的点分为两半,最近点对存在三种可能: 均在左, 均在右, 一个在左一个在右</li><li>记不同情况的最近点对的最小距离为: 左侧点集 $d_l$,右侧点集 $d_r$,两侧点间的距离 $d_c$</li><li>对于 $d_l, d_r$,可以递归的进行计算.关键在于如何计算 $d_c$</li></ul></li><li>$d_c$ 的计算<ul><li>令 $\delta &#x3D; \min(d_l, d_r)$.如果 $d_c$ 对 $\delta$ 有改进,则只需计算 $d_c$</li><li>若 $d_c$ 是这样的距离,则定义 $d_c$ 的两个点必然在分割线的 $\delta$ 邻域内(一个带状区域).限制考察点的数量</li><li>对于均匀分布的点集,则平均有 $O(\sqrt N)$ 个点位于邻域内,此时可采用暴力求解 $O(N)$</li></ul></li></ul></li><li>选择问题: 找出含有 N 个元素的表 S 中的第 k 个最小的元素(对于中位数 $k &#x3D; \lceil N&#x2F;2 \rceil$ 特别关注)<ul><li>通过对元素的快速排序,此问题以 $O(N\log N)$ 的最坏情形时间解决</li><li>五分化中项的中项 选择快速排序的基准<ul><li>将 N 个元素分为 $\lfloor N&#x2F;5 \rfloor$ 组,每5个元素一组,最多忽略4个元素</li><li>找出每组的中项,得到 $\lfloor N&#x2F;5 \rfloor$ 个中项的表 M,找出 M 的中项并返回</li></ul></li><li>使用五分化中项的中项的快速选择算法的运行时间为 $O(N)$.但实践中该算法并不实用</li></ul></li></ol><h3 id="7-3-动态规划"><a href="#7-3-动态规划" class="headerlink" title="7.3 动态规划"></a>7.3 动态规划</h3><ol><li><p>动态规划(dynamic programming)</p><ul><li>数学递归公式均可直接翻译为递归算法,但现实中编译器往往不发正确对待递归算法,而导致低效</li><li>当这种情况发生时,便需要给编译器提供帮助.改写为非递归的算法,并将子问题的答案记录在一个表内</li></ul></li><li><p>使用表代替递归</p><ul><li><p>计算 Fibonacci 数的自然递归效率非常低,是指数级别的</p></li><li><p>使用一个表将中间的计算结果存储起来,则可避免大量的冗余计算,下面计算 $c_n &#x3D; \frac2n\sum\limits_{i&#x3D;0}^{n-1}c_i+n,\space c_0 &#x3D; 1$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">double</span> *c = <span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>( <span class="hljs-type">double</span> ) * ( n + <span class="hljs-number">1</span> ) );<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    c[<span class="hljs-number">0</span>] = <span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j)<br>            sum += c[j];<br>        c[i] = <span class="hljs-number">2.0</span> * sum / i + i;<br>    &#125;<br>    <span class="hljs-type">int</span> answer = c[n];<br>    <span class="hljs-built_in">free</span>(c);<br>    <span class="hljs-keyword">return</span> answer;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C 语言</tag>
      
      <tag>计算机</tag>
      
      <tag>Code</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Language Advanced</title>
    <link href="/2023/05/03/Computer/C-Language-Advanced/"/>
    <url>/2023/05/03/Computer/C-Language-Advanced/</url>
    
    <content type="html"><![CDATA[<h1 id="C-语言进阶"><a href="#C-语言进阶" class="headerlink" title="C 语言进阶"></a>C 语言进阶</h1><h2 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1 内存管理"></a>1 内存管理</h2><h3 id="1-1-内存布局"><a href="#1-1-内存布局" class="headerlink" title="1.1 内存布局"></a>1.1 内存布局</h3><ol><li><p>C 程序在运行时,内存分为以下几个主要区域(Segments)</p><table><thead><tr><th align="left"><strong>内存区域</strong></th><th align="left"><strong>存储内容</strong></th><th align="left"><strong>特点</strong></th></tr></thead><tbody><tr><td align="left"><strong>代码段(Text)</strong></td><td align="left">存放编译后的机器指令(二进制代码)</td><td align="left">只读.程序运行时不可修改</td></tr><tr><td align="left"><strong>数据段(Data)</strong></td><td align="left"><strong>已初始化全局变量 &amp; 静态变量</strong></td><td align="left">程序启动时分配.生命周期直到程序结束</td></tr><tr><td align="left"><strong>BSS 段(BSS)</strong></td><td align="left"><strong>未初始化全局变量 &amp; 静态变量</strong></td><td align="left">程序启动时清零.生命周期直到程序结束</td></tr><tr><td align="left"><strong>堆(Heap)</strong></td><td align="left">动态分配(<code>malloc, calloc, realloc, free</code>)</td><td align="left">手动管理.增长方向从低地址向高地址</td></tr><tr><td align="left"><strong>栈(Stack)</strong></td><td align="left">局部变量,函数参数,返回地址等</td><td align="left">自动管理(函数调用时入栈,返回时出栈).<br />增长方向从高地址向低地址,大小有限</td></tr></tbody></table></li><li><p>内存布局图示(Linux 64bit)</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss">高地址<br>┌─────────────────────┐<br>│        Stack        │ ← 由高地址向低地址增长<br>├─────────────────────┤<br>│          ↓          │<br>│          ↑          │<br>├─────────────────────┤<br>│        Heap         │ ← 由低地址向高地址增长<br>├─────────────────────┤<br>│        BSS          │ (未初始化全局变量)<br>├─────────────────────┤<br>│        Data         │ (已初始化全局变量)<br>├─────────────────────┤<br>│        <span class="hljs-selector-tag">Text</span>         │ (程序指令)<br>低地址<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-2-动态内存分配"><a href="#1-2-动态内存分配" class="headerlink" title="1.2  动态内存分配"></a>1.2  动态内存分配</h3><ol><li><p>需要使用到 <code>&lt;stdlib.h&gt;</code> 头文件中的库函数</p></li><li><p><code>malloc</code>: 向系统申请分配 <code>size</code> 个字节的内存空间,返回一个指向该空间的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-comment">// 调用成功返回一个申请的内存空间指针,类型为 void *</span><br><span class="hljs-comment">// 调用失败返回 NULL.若设置 size = 0,同样返回 NULL</span><br></code></pre></td></tr></table></figure></li><li><p><code>calloc</code>: 在内存中动态的申请 <code>nmemb</code> 个长度为 <code>size</code> 的连续内存空间,并全部初始化为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> nmemb, <span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-comment">// 调用成功返回一个申请的内存空间指针,类型为 void *</span><br><span class="hljs-comment">// 调用失败返回 NULL.若设置 size = 0,同样返回 NULL</span><br></code></pre></td></tr></table></figure></li><li><p><code>realloc</code>: 重新分配内存空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><ul><li>可以增大或减小已分配内存的大小</li><li>其实现通常为新分配内存,然后复制内容,最后释放原内存.注意新内存仍不会初始化</li><li><code>ptr</code> 指向先前分配的内存空间.当参数 <code>ptr==NULL</code> 时,等同于调用 <code>malloc</code></li></ul></li><li><p><code>free</code>: 释放动态空间内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>free</code> 释放的内存空间必须是由 <code>malloc, calloc, realloc</code> 函数申请.否则会导致未定义行为</li><li>若参数 <code>ptr==NULL</code>,则不执行任何操作.多次对同一指针调用 <code>free</code>,将导致未定义行为</li><li><code>free</code> 函数不改变参数 <code>ptr</code> 的值.为避免悬空指针,释放空间后需将指针的值置为 <code>NULL</code></li></ul></li></ol><h3 id="1-3-动态内存管理"><a href="#1-3-动态内存管理" class="headerlink" title="1.3 动态内存管理"></a>1.3 动态内存管理</h3><ol><li><p>内存泄漏</p><ul><li>C 语言不具备垃圾回收机制,需要手动释放内存.<code>malloc</code> 和 <code>free</code> 应该成对编写</li><li><code>malloc</code> 可以申请任意尺寸的内存空间.得到的空间是连续的,经常使用数组索引</li></ul></li><li><p>内存池</p><ul><li>频繁使用 <code>malloc</code> 和 <code>free</code> 手动分配和释放内存很容易产生大量的内存碎片</li><li>调用 <code>malloc</code> 函数向操作系统申请堆内存经历了从应用层切入系统内核层的过程.造成时间浪费</li><li>内存池: 让程序额外维护一个缓存区域.当一块内存将要释放时,不调用 <code>free</code>,而将其放入内存池,下次需要分配内存空间时直接从内存池中获取</li></ul></li><li><p>内存池的维护方式</p><ul><li>当用户申请一个内存块时,先在内存池中查找是否有合适的内存块<ul><li>若有: 则直接从内存池中取出使用</li><li>若无: 调用 <code>malloc</code> 函数申请</li></ul></li><li>当用户释放一个内存块时,先检查内存池是否已满<ul><li>不满: 则将指向内存块的指针存放到内存池</li><li>已满: 调用 <code>free</code> 函数释放</li></ul></li></ul></li><li><p>内存池实现思路</p><ul><li>使用单链表维护一个简单的内存池<ul><li>将没用到的内存空间地址用单链表记录</li><li>需要使用时从单链表获取</li></ul></li></ul></li></ol><h2 id="2-文件-IO"><a href="#2-文件-IO" class="headerlink" title="2 文件 IO"></a>2 文件 IO</h2><h3 id="2-1-打开和关闭文件"><a href="#2-1-打开和关闭文件" class="headerlink" title="2.1 打开和关闭文件"></a>2.1 打开和关闭文件</h3><ol><li><p><code>fopen</code>: 打开一个文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *<span class="hljs-title function_">fopen</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode )</span>;  <span class="hljs-comment">// fopen 函数原型</span><br><span class="hljs-comment">/* filename: 指定将要打开的文件路径以及文件名</span><br><span class="hljs-comment">** mode: 指定文件的打开模式 */</span><br></code></pre></td></tr></table></figure><ul><li><p>调用成功返回一个指向 <code>FILE</code> 结构的文件指针.通过该指针对文件进行操作.失败返回 <code>NULL</code></p></li><li><p>打开模式</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>“r”</td><td>只读模式打开;  从文件头读取;  该文本文件必须存在</td></tr><tr><td>“w”</td><td>只写模式打开;  从文件头写入;  文本不存在时则先创建;  重新写入内容会覆盖所有内容</td></tr><tr><td>“a”</td><td>追加模式打开;  从文件末追加;  文本不存在时则先创建</td></tr><tr><td>“r+”</td><td>读写模式打开;  从文件头读写;  该文本文件必须存在; 只覆盖重写入内容,原有内容保留</td></tr><tr><td>“w+”</td><td>读写模式打开;  从文件头读写;  文本不存在时则先创建; 重新写入内容会覆盖所有内容</td></tr><tr><td>“a+”</td><td>读和追加模式打开;  读从头开始,写从末尾追加;  文本不存在时则先创建</td></tr><tr><td>b</td><td>可与以上6种模式结合(如 “rb, “r+b”); 含义相同,但操作对象为二进制文件</td></tr></tbody></table></li></ul></li><li><p><code>fclose</code> 函数: 关闭一个文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fclose</span><span class="hljs-params">( FILE *fp )</span>;  <span class="hljs-comment">// fclose 函数原型</span><br><span class="hljs-comment">/* fp: 使用 fopen 获取的文件指针</span><br><span class="hljs-comment">** 调用成功返回0,失败返回 EOF</span><br><span class="hljs-comment">** 调用 fopen 后系统才会将缓冲区的数据写入文件,并释放该文件的相关资源*/</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-顺序读写文件"><a href="#2-2-顺序读写文件" class="headerlink" title="2.2 顺序读写文件"></a>2.2 顺序读写文件</h3><ol><li><p>读取单个字符(下列函数均声明于 <code>&lt;stdio.h&gt;</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fgetc, getc 函数: 从文件流中读取下一个字符,并推进文件的位置指示器 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fgetc</span><span class="hljs-params">(FILE *stream)</span>;  <span class="hljs-comment">// 函数原型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getc</span><span class="hljs-params">(FILE *stream)</span>;   <span class="hljs-comment">// 通常实现为宏</span><br><span class="hljs-comment">/* stream: 指向一个待读取的文件流 */</span><br></code></pre></td></tr></table></figure></li><li><p>写入单个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fputc, putc 函数: 向文件流写入单个字符 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *stream)</span>;  <span class="hljs-comment">// 函数原型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *stream)</span>;   <span class="hljs-comment">// 通常实现为宏</span><br><span class="hljs-comment">/* c: 待写入的字符</span><br><span class="hljs-comment">** stream: 指向一个待写入的文件流</span><br><span class="hljs-comment">** 返回值: 遇到错误或文件结束时返回 EOF.否则返回已写入的字符本身 */</span><br></code></pre></td></tr></table></figure></li><li><p>读取字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fgets 函数: 从指定的文件中读取字符串 */</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> size, FILE *stream)</span>;<br><span class="hljs-comment">/* s: 指向存放读取得到字符串的位置</span><br><span class="hljs-comment">** size: 指定读取的字符数(包括自动添加的 &#x27;\0&#x27;).想读取10个字符,应令 size = 11</span><br><span class="hljs-comment">** stream: 指定一个待操作的数据流</span><br><span class="hljs-comment">** 返回值: 调用成功,返回 s 指向的地址.若发生错误,返回 NULL</span><br><span class="hljs-comment">** 当遇到换行符 &#x27;\n&#x27; 就会停止本次字符串的读取</span><br><span class="hljs-comment">** 注意 gets 函数不安全,已被 C99 弃用并从 C11 除名 */</span><br></code></pre></td></tr></table></figure></li><li><p>写入字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fputs 函数: 将字符串写入到指定的文件中,结尾的 &#x27;\0&#x27; 不会被写入 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, FILE *stream)</span>;<br><span class="hljs-comment">/* s: 指向存放待写入字符串的位置</span><br><span class="hljs-comment">** stream: 指定一个待操作的数据流 */</span><br><br><span class="hljs-comment">/* puts 函数: 将字符串写入 stdout 并自动追加换行符.方便打印消息 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">puts</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;<br></code></pre></td></tr></table></figure></li><li><p>格式化读写文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* fscanf 函数: f 表示 file,对文件进行读取 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fscanf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br><br><span class="hljs-comment">/* fprintf 函数: f 表示 file,对文件进行写入 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br></code></pre></td></tr></table></figure></li><li><p>二进制读写文件</p><ul><li><code>fopen</code> 函数可以指定文件的打开模式(文本, 二进制).但后续对文件的操作并不一定是对应的形式</li><li>无论以哪种模式打开文件,都不能决定写入数据的形式.它们只是影响换行符的表现形式.</li><li>真正决定数据写入模式的是 相关的文件读写函数</li></ul></li><li><p><code>fread</code> 函数: 从指定文件中读取指定尺寸的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">fread</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span>;<br><span class="hljs-comment">/* ptr:指向存放数据的内存块地址</span><br><span class="hljs-comment">** size:待读取的每个元素的尺寸 </span><br><span class="hljs-comment">** nmemb:指定待读取的元素个数</span><br><span class="hljs-comment">** stream:指向一个待读取的文件流</span><br><span class="hljs-comment">** 返回值:   调用成功返回实际读取到的元素个数,即 nmemb</span><br><span class="hljs-comment">** 如果返回值小于 nmemb,说明读取到文件末尾或发生错误 */</span><br></code></pre></td></tr></table></figure></li><li><p><code>fwrite</code> 函数: 将指定数据写入到指定文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">fwrite</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span>;<br><span class="hljs-comment">/* ptr:指向存放数据的内存块地址</span><br><span class="hljs-comment">** size:待写入的每个元素的尺寸</span><br><span class="hljs-comment">** nmemb:指定待写入的元素个数</span><br><span class="hljs-comment">** stream:指向一个待写入的文件流 */</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-随机读写文件"><a href="#2-3-随机读写文件" class="headerlink" title="2.3 随机读写文件"></a>2.3 随机读写文件</h3><ol><li><p>系统为每个打开的文件设置了一个位置指示器,用于表示当前的读写位置</p></li><li><p><code>ftell</code> 函数: 返回当前的读写位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">ftell</span><span class="hljs-params">(FILE *stream)</span>;<br><span class="hljs-comment">/* stream: 指定待操作的文件流</span><br><span class="hljs-comment">** 返回值: 指定文件的当前读写位置</span><br><span class="hljs-comment">** 如果将文件看作一个数组,那么 ftell 的返回值就是&quot;数组&quot;的下标 */</span><br></code></pre></td></tr></table></figure></li><li><p><code>fseek</code> 函数: 设置文件位置指示器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">long</span> <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> whence)</span>;<br><span class="hljs-comment">/* stream: 指定待操作的文件流</span><br><span class="hljs-comment">** offset: 指定偏移的字节数量</span><br><span class="hljs-comment">** whence: 指定开始偏移的位置 */</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>whence 的值</th><th>说明</th></tr></thead><tbody><tr><td>SEEK_SET</td><td>文件开头</td></tr><tr><td>SEEK_CUR</td><td>当前位置</td></tr><tr><td>SEEK_END</td><td>文件末尾</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">fseek(fp, <span class="hljs-number">100</span>, SEEK_SET);<span class="hljs-comment">// 定位到文件的第100字节位置</span><br>fseek(fp, <span class="hljs-number">-5</span>, SEEK_END);<span class="hljs-comment">// 定位到文件的倒数第5个字节位置</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>fseek</code> 需要考虑可移植性</p><ul><li>不同操作系统对换行符的处理不同,导致定位会出现误差</li><li>对于二进制模式打开的文件, <code>fseek</code> 在某些操作系统中可能不支持 SEEK_END</li><li>对于文本模式打开的文件, <code>whence</code> 参数只有取 SEEK_SET 才有意义.传递给 offset 的参数值要么为 0,要么是上一次对同一文件调用 <code>ftell</code> 函数获得的返回值</li></ul></li></ol><h3 id="2-4-标准流"><a href="#2-4-标准流" class="headerlink" title="2.4 标准流"></a>2.4 标准流</h3><ol><li><p>标准 输入 &#x2F; 输出 &#x2F; 错误输出</p><ul><li><p>当一个程序被执行时, C 语言自动为其打开3个面向终端的文件流(在 <code>&lt;stdio.h&gt;</code> 中声明)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stdin</span>;   <span class="hljs-comment">// 标准输入(standard input)</span><br><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stdout</span>;  <span class="hljs-comment">// 标准输出(standard output)</span><br><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stderr</span>;  <span class="hljs-comment">// 标准错误输出(standard error output)</span><br></code></pre></td></tr></table></figure></li><li><p>C 语言对应提供3种文件指针: <code>stdin, stdout, stderr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 若打开文件失败,则输出 &quot;打开文件失败\n&quot;,并退出 */</span><br>FILE *fp;<br><span class="hljs-keyword">if</span>((fp = open(<span class="hljs-string">&quot;nonexistent.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>)) == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;打开文件失败\n&quot;</span>, <span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT FALLURE);<br>&#125;<br>fclose(fp);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>错误处理</p><ul><li><p>每个流对象内部都有2个指示器</p><ul><li><p><strong>文件结束指示器</strong>: 遇到文件末尾时被设置</p></li><li><p><strong>错误指示器</strong>: 当读写文件出错时被设置</p></li><li><p>使用 <code>feof, ferror</code> 函数检查这两个指示器是否被设置(置1)</p></li><li><p>使用 <code>clearerr</code> 函数可以人为清除文件末尾指示器和错误指示器的状态</p></li><li><p><code>ferror</code> 函数只能检测是否出错,并不能提供出现错误的原因</p></li><li><p>大多数系统函数在出错时会将错误原因记录在 <code>errno</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开文件失败: %d\n&quot;</span>, errno);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>各种错误原因都有对应的错误码记录在 <code>errno</code> 中,但仅打印 <code>errno</code> 的值很不直观</p></li><li><p>C 语言将各种错误码对应信息打包在 <code>perror</code> 函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">perror</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;<br><span class="hljs-comment">/* s: 指定在错误信息前输出的自定义内容.然后自动添加一个冒号 */</span><br></code></pre></td></tr></table></figure></li><li><p>如果只想要系统返回错误信息的本体.可使用 <code>stderror</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> errnum)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>errnum</code>: 指定的 <code>errno</code> 值</li><li>返回值: 错误码对应的错误信息</li></ul></li></ul></li></ol><h3 id="2-5-I-O缓冲区"><a href="#2-5-I-O缓冲区" class="headerlink" title="2.5 I&#x2F;O缓冲区"></a>2.5 I&#x2F;O缓冲区</h3><ol><li><p>对于写入操作,程序会先将数据写入缓冲区,直到缓冲区被写满或文件关闭时才一次性写入设备中</p></li><li><p>对于读取操作,如果数据已经在缓冲区中,则立即返回给程序.否则,系统会将一大块数据从设备读入缓冲区</p></li><li><p>如果需要立即将数据写入设备中,可使用 <code>fflush</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fflush</span><span class="hljs-params">(FILE *stream)</span>;<br></code></pre></td></tr></table></figure></li><li><p>标准 I&#x2F;O 提供三种类型的缓冲模式</p><ul><li>按块缓存(全缓存): 在缓冲区填满后才进行实际的设备读写</li><li>按行缓存: 接受到换行符之前,数据缓存在缓冲区</li><li>不缓存: 允许直接读写设备上的数据</li></ul></li><li><p>可以通过 <code>setvbuf</code> 函数自定义缓存的模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">setvbuf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> mode, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>stream</code>: 待操作的文件流</p></li><li><p><code>buf</code>: 指定一个用户分配的缓冲区.设置为 <code>NULL</code> 时,由函数自动分配</p></li><li><p><code>mode</code>: 缓存模式</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>_IOFBF</td><td>按块缓存</td></tr><tr><td>_IOLBF</td><td>按行缓存</td></tr><tr><td>_IONBF</td><td>不缓存</td></tr></tbody></table></li><li><p><code>size</code>: 缓冲区的实际尺寸</p></li></ul></li></ol><h2 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3 面向对象"></a>3 面向对象</h2><h3 id="3-1-封装"><a href="#3-1-封装" class="headerlink" title="3.1 封装"></a>3.1 封装</h3><ol><li><p>封装: 隐藏实现细节,仅暴露必要接口</p></li><li><p>实现方式: 使用 <code>struct</code> 存储数据,使用头文件(<code>.h</code>)声明公共接口,而源文件(<code>.c</code>)隐藏私有实现</p></li><li><p><code>person.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> <span class="hljs-title">Person</span>;</span>  <span class="hljs-comment">// 不透明指针(不完整类型)</span><br><br><span class="hljs-comment">// 构造函数 / 析构函数</span><br>Person* <span class="hljs-title function_">person_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">person_destroy</span><span class="hljs-params">(Person *p)</span>;<br><br><span class="hljs-comment">// 公共方法(接口)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_name</span><span class="hljs-params">(Person *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">person_get_name</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_age</span><span class="hljs-params">(Person *p, <span class="hljs-type">int</span> age)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">person_get_age</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">person_greet</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>person.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span></span><br><br><span class="hljs-comment">// 完整定义 Person(仅在此文件可见)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">// 实现构造函数</span><br>Person* <span class="hljs-title function_">person_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age)</span> &#123;<br>    Person *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Person));<br>    p-&gt;name = strdup(name);<br>    p-&gt;age = age;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_destroy</span><span class="hljs-params">(Person *p)</span> &#123;<br>    <span class="hljs-built_in">free</span>(p-&gt;name);<br>    <span class="hljs-built_in">free</span>(p);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_greet</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, I&#x27;m %s, age %d!\n&quot;</span>, p-&gt;name, p-&gt;age);<br>&#125;<br><br><span class="hljs-comment">// 其他方法实现</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_name</span><span class="hljs-params">(Person *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span> &#123;<br>    <span class="hljs-built_in">free</span>(p-&gt;name);<br>    p-&gt;name = strdup(name);<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">person_get_name</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span> &#123;<br>    <span class="hljs-keyword">return</span> p-&gt;name;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_age</span><span class="hljs-params">(Person *p, <span class="hljs-type">int</span> age)</span> &#123;<br>    p-&gt;age = age;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">person_get_age</span><span class="hljs-params">(<span class="hljs-type">const</span> Person *p)</span> &#123;<br>    <span class="hljs-keyword">return</span> p-&gt;age;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;student.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    Person *p = person_create(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>);<br>    person_greet(p);  <span class="hljs-comment">// 输出: Hello, I&#x27;m Alice, age 25!</span><br>    person_set_age(p, <span class="hljs-number">10</span>);<br>    person_set_name(p, <span class="hljs-string">&quot;Bob&quot;</span>);<br>    person_greet(p);  <span class="hljs-comment">// 输出: Hello, I&#x27;m Bob, age 10!</span><br>    person_destroy(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-2-继承"><a href="#3-2-继承" class="headerlink" title="3.2 继承"></a>3.2 继承</h3><ol><li><p>继承: 子类继承父类的属性和方法</p></li><li><p>实现方式: 结构体嵌套(父结构体作为子结构体的第一个成员),通过类型转换模拟继承</p></li><li><p><code>student.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">Student</span>;</span><br><br>Student* <span class="hljs-title function_">student_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *university)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">student_destroy</span><span class="hljs-params">(Student *s)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">student_study</span><span class="hljs-params">(<span class="hljs-type">const</span> Student *s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *subject)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>student.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;student.h&quot;</span></span><br><br><span class="hljs-comment">// Student 的私有定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> &#123;</span><br>    Person *base;  <span class="hljs-comment">// 通过指针持有 Person(避免不完整类型问题)</span><br>    <span class="hljs-type">char</span> *university;<br>&#125;;<br><br>Student* <span class="hljs-title function_">student_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *university)</span> &#123;<br>    Student *s = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Student));<br>    s-&gt;base = person_create(name, age);  <span class="hljs-comment">// 调用 Person 的构造函数</span><br>    s-&gt;university = strdup(university);<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">student_study</span><span class="hljs-params">(<span class="hljs-type">const</span> Student *s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *subject)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s is studying %s at %s.\n&quot;</span>,<br>           person_get_name(s-&gt;base), subject, s-&gt;university);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">student_destroy</span><span class="hljs-params">(Student *s)</span> &#123;<br>    person_destroy(s-&gt;base);  <span class="hljs-comment">// 调用 Person 的析构函数</span><br>    <span class="hljs-built_in">free</span>(s-&gt;university);<br>    <span class="hljs-built_in">free</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;student.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// 创建 Student 对象(完全隐藏 Person 的细节)</span><br>    Student *s = student_create(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Stanford&quot;</span>);<br><br>    <span class="hljs-comment">// 只能通过公共接口访问数据</span><br>    student_study(s, <span class="hljs-string">&quot;Computer Science&quot;</span>);<br><br>    <span class="hljs-comment">// 释放资源</span><br>    student_destroy(s);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-3-多态"><a href="#3-3-多态" class="headerlink" title="3.3 多态"></a>3.3 多态</h3><ol><li><p>多态: 同一接口,不同实现</p></li><li><p>实现: 使用 <strong>函数指针</strong> 实现动态绑定.类似 C++ 的虚函数表(vtable)</p></li><li><p><code>shape.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Shape</span> <span class="hljs-title">Shape</span>;</span><br><br><span class="hljs-comment">// 定义虚函数表(模拟 C++ 的 vtable)</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">void</span> (*draw)(<span class="hljs-type">const</span> Shape *);<br>    <span class="hljs-type">double</span> (*area)(<span class="hljs-type">const</span> Shape *);<br>&#125; ShapeVTable;<br><br><span class="hljs-comment">// 基类结构体(对外不透明)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Shape</span> &#123;</span><br>    <span class="hljs-type">const</span> ShapeVTable *vtable; <span class="hljs-comment">// 每个对象绑定自己的虚表</span><br>&#125;;<br><br><span class="hljs-comment">// 公共接口(多态方法)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">shape_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">shape_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>shape.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><br><span class="hljs-comment">// 多态方法: 通过虚表调用具体实现</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">shape_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    shape-&gt;vtable-&gt;draw(shape);<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">shape_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-keyword">return</span> shape-&gt;vtable-&gt;area(shape);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>circle.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> <span class="hljs-title">Circle</span>;</span><br>Circle *<span class="hljs-title function_">circle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>circle.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;circle.h&quot;</span></span><br><br><span class="hljs-comment">// Circle 的私有定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> &#123;</span><br>    Shape base;  <span class="hljs-comment">// 继承 Shape(必须放在首位！)</span><br>    <span class="hljs-type">double</span> radius;<br>&#125;;<br><br><span class="hljs-comment">// Circle 的 draw 实现</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">circle_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Circle *circle = (<span class="hljs-type">const</span> Circle *)shape; <span class="hljs-comment">// 向下转型</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;○ Circle (radius=%.2f)\n&quot;</span>, circle-&gt;radius);<br>&#125;<br><br><span class="hljs-comment">// Circle 的 area 实现</span><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">circle_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Circle *circle = (<span class="hljs-type">const</span> Circle *)shape;<br>    <span class="hljs-keyword">return</span> M_PI * circle-&gt;radius * circle-&gt;radius;<br>&#125;<br><br><span class="hljs-comment">// Circle 的虚表</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> ShapeVTable circle_vtable = &#123;<br>    .draw = circle_draw,<br>    .area = circle_area<br>&#125;;<br><br><span class="hljs-comment">// 构造函数</span><br>Circle *<span class="hljs-title function_">circle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br>    Circle *circle = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Circle));<br>    circle-&gt;base.vtable = &amp;circle_vtable; <span class="hljs-comment">// 绑定虚表</span><br>    circle-&gt;radius = radius;<br>    <span class="hljs-keyword">return</span> circle;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>rectangle.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span> <span class="hljs-title">Rectangle</span>;</span><br>Rectangle *<span class="hljs-title function_">rectangle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>rectangle.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rectangle.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span> &#123;</span><br>    Shape base;  <span class="hljs-comment">// 继承 Shape</span><br>    <span class="hljs-type">double</span> width, height;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rectangle_draw</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Rectangle *rect = (<span class="hljs-type">const</span> Rectangle *)shape;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;□ Rectangle (%.2f x %.2f)\n&quot;</span>, rect-&gt;width, rect-&gt;height);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">rectangle_area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape *shape)</span> &#123;<br>    <span class="hljs-type">const</span> Rectangle *rect = (<span class="hljs-type">const</span> Rectangle *)shape;<br>    <span class="hljs-keyword">return</span> rect-&gt;width * rect-&gt;height;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> ShapeVTable rectangle_vtable = &#123;<br>    .draw = rectangle_draw,<br>    .area = rectangle_area<br>&#125;;<br><br>Rectangle *<span class="hljs-title function_">rectangle_create</span><span class="hljs-params">(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height)</span> &#123;<br>    Rectangle *rect = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Rectangle));<br>    rect-&gt;base.vtable = &amp;rectangle_vtable;<br>    rect-&gt;width = width;<br>    rect-&gt;height = height;<br>    <span class="hljs-keyword">return</span> rect;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shape.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;circle.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rectangle.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// 创建不同子类对象,但用基类指针存储</span><br>    Shape *shapes[] = &#123;<br>            (Shape *)circle_create(<span class="hljs-number">3.0</span>),<br>            (Shape *)rectangle_create(<span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>),<br>    &#125;;<br><br>    <span class="hljs-comment">// 多态调用</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>        shape_draw(shapes[i]);  <span class="hljs-comment">// 调用实际类型的 draw()</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Area: %.2f\n\n&quot;</span>, shape_area(shapes[i]));<br>    &#125;<br><br>    <span class="hljs-comment">// 释放内存(实际项目应更严谨)</span><br>    <span class="hljs-built_in">free</span>(shapes[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">free</span>(shapes[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-重载"><a href="#3-4-重载" class="headerlink" title="3.4 重载"></a>3.4 重载</h3><ol><li><p><code>_Generic</code> 是 C11 标准引入的 <strong>编译时类型选择机制</strong>,允许根据表达式的类型在编译期选择不同的代码分支.常用于模拟 <strong>函数重载</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">_Generic</span>(控制表达式,         \<br>         类型<span class="hljs-number">1</span>: 返回值<span class="hljs-number">1</span>,     \<br>         类型<span class="hljs-number">2</span>: 返回值<span class="hljs-number">2</span>,     \<br>         ...,               \<br>         <span class="hljs-keyword">default</span>: 默认返回值 \<br>)<br></code></pre></td></tr></table></figure></li><li><p>根据类型返回不同的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> type_name(X) _Generic((X), \</span><br><span class="hljs-meta">    int: <span class="hljs-string">&quot;int&quot;</span>, \</span><br><span class="hljs-meta">    double: <span class="hljs-string">&quot;double&quot;</span>, \</span><br><span class="hljs-meta">    char*: <span class="hljs-string">&quot;string&quot;</span>, \</span><br><span class="hljs-meta">    default: <span class="hljs-string">&quot;unknown&quot;</span> \</span><br><span class="hljs-meta">)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, type_name(<span class="hljs-number">10</span>));      <span class="hljs-comment">// 输出 &quot;int&quot;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, type_name(<span class="hljs-number">3.14</span>));    <span class="hljs-comment">// 输出 &quot;double&quot;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, type_name(<span class="hljs-string">&quot;hello&quot;</span>)); <span class="hljs-comment">// 输出 &quot;string&quot;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, type_name(<span class="hljs-string">&#x27;A&#x27;</span>));     <span class="hljs-comment">// 输出 &quot;unknown&quot;(char 未定义)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>模拟函数重载</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">print_int</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;int: %d\n&quot;</span>, x); &#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">print_double</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;double: %f\n&quot;</span>, x); &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> print(X) _Generic((X), \</span><br><span class="hljs-meta">    int: print_int,            \</span><br><span class="hljs-meta">    double: print_double       \</span><br><span class="hljs-meta">)(X) <span class="hljs-comment">/* 注意: 这里的 (X) 是进行函数调用 */</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    print(<span class="hljs-number">10</span>);   <span class="hljs-comment">// 调用 print_int</span><br>    print(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// 调用 print_double</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li><code>_Generic</code> 仅检查类型,不计算控制表达式的值</li><li><code>_Generic</code> 可以返回任意类型.如函数指针(然后立即进行函数调用,实现函数重载)</li><li><code>_Generic</code> 支持匹配各种类型.如指针, 数组, 结构体</li><li><code>_Generic</code> 会将 <code>const, volatile</code> 也作为区别类型的依据</li><li>必须有匹配到的类型. 若没有匹配到的类型且没有 <code>default</code>, 将会编译报错</li></ul></li></ol><h2 id="4-架构设计"><a href="#4-架构设计" class="headerlink" title="4 架构设计"></a>4 架构设计</h2><h3 id="4-1-solid"><a href="#4-1-solid" class="headerlink" title="4.1 solid"></a>4.1 solid</h3><ol><li><strong>单一职责原则(Single Responsibility Principle): 一个类应该只负责一项职责</strong><ul><li>避免”上帝类”(承担过多功能的类),将功能拆分到多个类中</li><li>每个类只关注自己的核心职责,降低修改带来的风险</li></ul></li><li><strong>开闭原则(Open Closed Principle): 软件实体(类, 模块, 函数等)应对扩展开放,对修改关闭</strong><ul><li>通过抽象(接口, 继承)实现新功能,而不是直接修改现有代码</li><li>减少对已有代码的影响,提高稳定性</li></ul></li><li><strong>里氏替换原则(Liskov Substitution Principle): 子类必须能够替换其父类,且不影响程序的正确性</strong><ul><li>子类不应破坏父类的行为契约(如方法参数, 返回值, 异常等)</li><li>避免滥用继承,确保 “is-a” 关系合理</li></ul></li><li><strong>接口隔离原则(Interface Segregation Principle): 客户端不应被迫依赖它不需要的接口</strong><ul><li>将庞大的接口拆分为更小,更具体的接口</li><li>减少 “胖接口” 导致的冗余依赖</li></ul></li><li><strong>依赖倒置原则(Dependence Inversion Principle): 高层模块不应依赖低层模块二者都应依赖抽象</strong><ul><li>通过抽象(接口)解耦,避免直接依赖具体实现</li><li>依赖注入(DI)是实现 DIP 的常见方式</li></ul></li></ol><h3 id="4-2-设计模式"><a href="#4-2-设计模式" class="headerlink" title="4.2 设计模式"></a>4.2 设计模式</h3><ol><li>观测者模式: 通知链</li><li>工厂方法: socket</li><li>模板方法: 内核调度器</li><li>策略模式: 内存压缩算法</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C 语言</tag>
      
      <tag>计算机</tag>
      
      <tag>Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Language Environment</title>
    <link href="/2023/05/02/Computer/C-Language-Environment/"/>
    <url>/2023/05/02/Computer/C-Language-Environment/</url>
    
    <content type="html"><![CDATA[<h2 id="0-开发环境"><a href="#0-开发环境" class="headerlink" title="0 开发环境"></a>0 开发环境</h2><h3 id="0-1-Windows-环境"><a href="#0-1-Windows-环境" class="headerlink" title="0.1 Windows 环境"></a>0.1 Windows 环境</h3><ol><li><p>下载安装 <a href="https://www.mingw-w64.org/downloads/#mingw-w64-builds">MinGW</a></p><ul><li><p>将 <code>x86_64-15.1.0-release-win32-seh-ucrt-rt_v12-rev0.7z</code> 解压得到 <code>mingw64</code> 目录</p></li><li><p>配置环境变量: 在系统 <code>path</code> 中添加 <code>mingw64</code> 路径. 形如: <code>D:\code\mingw64\bin</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc --version # 检查安装<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Windows 可以通过<a href="https://cmake.org/download/">官网下载安装 CMake</a>(如 <code>cmake-4.0.2-windows-x86_64.msi</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake --version # 检查安装<br></code></pre></td></tr></table></figure></li><li><p>配置环境使得可以使用 CMake 构建项目, gdb 进行调试</p><ul><li><p>在 VS Code 中安装 <code>CMake, CMake Tools, Code Runner</code> 插件</p></li><li><p>创建 <code>.vscode/tasks.json</code> 文件内容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake-configure&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake -B build -DCMAKE_BUILD_TYPE=Debug&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$gcc&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake-build&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake --build build --parallel&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$gcc&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Full Build&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;dependsOn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;cmake-configure&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;cmake-build&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;isDefault&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>创建 <code>.vscode/launch.json</code> 文件.内容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;GDB Debug&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;command:cmake.launchTargetPath&#125;&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 需要 CMake Tools 插件</span><br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Enable pretty-printing for gdb&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Set disassembly flavor to Intel&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-comment">// 调试前自动构建.注意与 tasks.json 匹配</span><br>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Full Build&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>创建 <code>CmakeLists.txt</code> 文件(在项目根目录下创建)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.20</span>)<br><br><span class="hljs-comment"># 项目设置</span><br><span class="hljs-keyword">project</span>(HelloCMake)<br><br><span class="hljs-comment"># 严格编译器设置</span><br><span class="hljs-keyword">set</span>(CMAKE_C_STANDARD <span class="hljs-number">17</span>)          <span class="hljs-comment"># 使用 C17 标准</span><br><span class="hljs-keyword">set</span>(CMAKE_C_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>) <span class="hljs-comment"># 强制要求编译器必须严格支持指定的 C 语言标准</span><br><span class="hljs-keyword">set</span>(CMAKE_C_EXTENSIONS <span class="hljs-keyword">OFF</span>)       <span class="hljs-comment"># 禁用编译器扩展(模拟-pedantic)</span><br><br><span class="hljs-comment"># 启用编译数据库生成.配合 clangd</span><br><span class="hljs-keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-comment"># 强制启用所有警告</span><br><span class="hljs-keyword">add_compile_options</span>(<br>    -Wall     <span class="hljs-comment"># 开启所有警告</span><br>    -Wextra   <span class="hljs-comment"># 启用额外警告</span><br>    -Werror   <span class="hljs-comment"># 将警告视为错误</span><br>    -pedantic <span class="hljs-comment"># 严格遵循标准</span><br>)<br><br><span class="hljs-comment"># 根据构建类型设置优化级别</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">NOT</span> CMAKE_BUILD_TYPE)<br>  <span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE <span class="hljs-string">&quot;Debug&quot;</span>) <span class="hljs-comment"># 默认 Debug 模式(自动包含-g)</span><br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># 显式包含当前目录(确保头文件能找到)</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)<br><br><span class="hljs-comment"># 添加可执行文件(推荐显式列出文件)</span><br><span class="hljs-keyword">add_executable</span>(<br>    <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span><br>    main.c<br>)<br></code></pre></td></tr></table></figure></li><li><p>至此即可点击状态栏的 <code>CMake Tool</code> 相关图标进行构建, 运行项目</p></li></ul></li><li><p><code>clangd</code> 插件</p><ul><li><p>需要下载安装包含 <code>clangd</code> 可执行文件的 LLVM&#x2F;Clang 工具链(直接使用 VS Code 提示安装)</p></li><li><p>解决标准库标红(在项目根目录下创建 <code>.clangd</code> 文件)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">CompileFlags:<br>  Add: [<br>    --target=x86_64-w64-mingw32,<br>    -isystem, D:/code/mingw64/x86_64-w64-mingw32/include,<br>    -isystem, D:/code/mingw64/include,<br>  ]<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-2-Linux-环境"><a href="#0-2-Linux-环境" class="headerlink" title="0.2 Linux 环境"></a>0.2 Linux 环境</h3><ol><li><p>在 Linux(发行版为 windows 的 wsl, Ubuntu 24.04) 使用 C 语言开发</p></li><li><p>在 Linux 安装必要的工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install build-essential gdb gcc g++ make<br></code></pre></td></tr></table></figure></li><li><p>Windows 远程连接到 Linux(需要先确保 Linux 服务器已开启 SSH 服务)</p><ul><li><p>在 PowerShell 中生成密钥(默认保存路径为 <code>C:\Users\你的用户名\.ssh\id_rsa</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -b 4096<br></code></pre></td></tr></table></figure></li><li><p>查看生成的密钥(复制输出的内容.以 <code>ssh-rsa AAA...</code> 开头)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat ~\.ssh\id_rsa.pub<br></code></pre></td></tr></table></figure></li><li><p>在 Linux 上添加公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p ~/.ssh  # 如果目录不存在则创建<br>echo &quot;&lt;复制 Windows 中输出的公钥内容&gt;&quot; &gt;&gt; ~/.ssh/authorized_keys<br>chmod 600 ~/.ssh/authorized_keys  # 设置权限<br></code></pre></td></tr></table></figure></li><li><p>在 PowerShell 中测试 ssh 连接(若能够直接连接而无需密码,表示配置正确)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh username@linux_server_ip # 格式为 用户名@ip地址<br>logout                       # 退出 ssh<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在 VS Code 安装 <code>remote</code> 扩展</p><ul><li><p>按 <kbd>F1</kbd> 或 <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>P</kbd> -&gt; <code>Remote-SSH: Connect to Host...</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh username@linux_server_ip<br></code></pre></td></tr></table></figure></li><li><p>VS Code 会提示选择 SSH 配置文件(默认是 <code>C:\Users\你的用户名\.ssh\config</code>),确认保存</p></li><li><p>ssh 连接 <code>config</code> 文件的含义(非必需项,仅了解含义)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host mylinux  # 自定义别名<br>    HostName linux_server_ip<br>    User username<br>    IdentityFile ~/.ssh/id_rsa<br>    Port 22  # 默认端口,如果修改过请调整<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>CMake</code> 使用(<code>.vscode/tasks.json, .vscode/launch.json, CmakeLists.txt</code> 文件内容同上)</p></li><li><p><code>clangd</code> 使用</p><ul><li><p>VS Code 中需安装 <code>clangd</code> 插件</p></li><li><p>Ubuntu 中下载, 验证安装 <code>clangd</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install clangd<br>clangd --version<br></code></pre></td></tr></table></figure></li><li><p>在 <code>.vscode/setting.json</code> 中添加配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;clangd.path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/clangd&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;clangd.arguments&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;--background-index&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;--clang-tidy&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;--completion-style=detailed&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;--header-insertion=never&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;C_Cpp.intelliSenseEngine&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;disabled&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 禁用微软引擎</span><br>  <span class="hljs-attr">&quot;C_Cpp.codeFolding&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;disabled&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-comment">// 避免冲突</span><br>  <span class="hljs-attr">&quot;editor.semanticHighlighting.enabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><code>clangd</code> 依赖 <code>compile_commands.json</code> 来获取项目的编译信息.CMake 生成该文件位于 <code>build</code> 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s build/compile_commands.json .  # 创建软连接供 clangd 使用<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>clang-format</code> 使用</p><ul><li><p>格式化代码(VS Code 快捷键 <kbd>Shift</kbd><kbd>Alt</kbd><kbd>F</kbd>)</p></li><li><p>安装 <code>clang-format</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install clang-format<br></code></pre></td></tr></table></figure></li><li><p>在项目根目录新建 <code>.clang-format</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">BasedOnStyle: Google  # 使用 Google 风格<br>IndentWidth: 4        # 覆盖为 4 空格缩进<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-3-GCC-编译器"><a href="#0-3-GCC-编译器" class="headerlink" title="0.3 GCC 编译器"></a>0.3 GCC 编译器</h3><ol><li><p>GCC(GNU Compiler Collection): gcc &#x2F; g++ 分别是 GNU 的 C &#x2F; C++ 编译器</p></li><li><p>gcc &#x2F; g++ 在执行编译工作的步骤</p><ul><li>预处理器 cpp: 预处理,生成 <code>.i</code> 的文件</li></ul><ul><li>编译器 egcs: 将预处理后的文件转换成汇编语言, 生成 <code>.s</code> 文件</li><li>汇编器 as: 有汇编变为目标代码(机器代码)生成 <code>.o</code> 的文件</li><li>链接器 ld: 连接目标代码, 生成可执行程序</li></ul></li><li><p>查看版本信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc --version<br></code></pre></td></tr></table></figure></li><li><p>gcc 编译选项(gcc 会按照后缀名进行编译.对于 C 程序,应当保持后缀名为 <code>.c</code>)</p><ul><li><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -E hello.c &gt; hello.i  # 只激活预处理,不生成文件.但可以重定向到一个输出文件<br>gcc -S hello.i -o hello.s # 只激活预处理和编译.将文件编译成汇编代码<br>gcc -c hello.s -o hello.o # 只激活预处理, 编译, 汇编.生成 obj 文件<br>gcc hello.o -o hello      # 完整地编译文件(默认生成的可以执行文件名为 a.out)<br></code></pre></td></tr></table></figure></li><li><p>调试, 优化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -g hello.c -o hello  # 生成可供 gdb 调试可执行文件<br>gcc -O2 hello.c -o hello # 优化级别2<br></code></pre></td></tr></table></figure></li><li><p>标准, 警告</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -Wall hello.c    # 打印 gcc 的警告信息<br>gcc -w hello.c       # 关闭 gcc 的警告信息<br>gcc -std=c11 hello.c # 使用 C11 标准<br></code></pre></td></tr></table></figure></li><li><p>编译时定义宏</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -D宏名 hello.c<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-4-GDB-调试器"><a href="#0-4-GDB-调试器" class="headerlink" title="0.4 GDB 调试器"></a>0.4 GDB 调试器</h3><ol><li><p>GDB(GNU Project Debugger) 功能</p><ul><li>指定参数</li><li>设置断点</li><li>分析 crash 现场</li><li>直接修改程序,观测结果</li></ul></li><li><p>下载, 验证安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install gbd<br>gdb --version<br></code></pre></td></tr></table></figure></li><li><p>启动 gdb(注意: 在 gcc 编译时需要加上 <code>-g</code> 选项才能生成可供调试的可执行文件)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gdb filename       # 从头运行程序并调试<br>gdb filename core  # 调试 crash 的程序<br>gdb -p 进程号      # 调试运行中的程序<br></code></pre></td></tr></table></figure></li><li><p>gdb 命令(<kbd>Enter</kbd> 表示重复上一命令)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">run         # 运行<br>start       # 单步执行.停在第一行<br>quit(q)     # 退出<br>list(l)     # 查看代码<br>break(b)    # 设置断点,行数<br>delete(d)   # 删除断点<br>next(n)     # 单步执行,逐过程<br>step(s)     # 单步执行,逐语句<br>finish      # 结束当前函数,跳出<br>continue(c) # 继续运行<br>display     # 追踪变量<br>undisplay   # 取消追踪<br>watch       # 观察点修改时进行打印<br><br>print(p) # 查看变量<br>set var  # 设置变量<br>info(i)  # 查看信息<br>x 0x...  # 查看内存信息<br>!clear   # 清屏<br>thread   # 线程<br>disass   # 汇编<br></code></pre></td></tr></table></figure></li></ol><h3 id="0-5-CMake-构建"><a href="#0-5-CMake-构建" class="headerlink" title="0.5 CMake 构建"></a>0.5 CMake 构建</h3><ol><li><p><strong>CMake: 开源的 跨平台构建工具,用于管理软件编译过程</strong></p><ul><li>CMake 不直接构建项目,而是生成标准的构建文件(如 Makefile)</li><li>再由底层工具(如 <code>make, ninja</code>)完成实际编译</li><li>使用 <code>CMakeLists.txt</code> 文件定义构建规则,语法类似脚本语言</li></ul></li><li><p>CMake 构建流程</p><ul><li><p>Windows 可以通过<a href="https://cmake.org/download/">官网下载安装 <code>CMake</code></a>(如 <code>cmake-4.0.2-windows-x86_64.msi</code>)</p></li><li><p>Ubuntu 使用如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update         # 更新软件包列表<br>sudo apt install cmake  # 安装 CMake<br>cmake --version         # 验证安装<br></code></pre></td></tr></table></figure></li><li><p>源码安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装编译依赖.下载 CMake 源码</span><br>sudo apt update &amp;&amp; sudo apt install -y build-essential libssl-dev<br>wget https://github.com/Kitware/CMake/releases/download/v4.0.3/cmake-4.0.3.tar.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压并编译安装 CMake</span><br>tar -zxvf cmake-4.0.3.tar.gz<br>cd cmake-4.0.3<br>./bootstrap --prefix=/usr/local --parallel=$(nproc) # 指定安装路径并启用多核编译<br>make -j$(nproc)   # 并行编译加速<br>sudo make install # 安装 CMake<br>cmake --version   # 验证安装<br></code></pre></td></tr></table></figure></li><li><p>卸载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt remove cmake # 通过 apt 卸载<br><br>cd cmake-4.0.3/build<br>sudo make uninstall   # 手动编译卸载<br></code></pre></td></tr></table></figure></li><li><p>编写 <code>CMakeLists.txt</code> 文件.下面是最基础的配置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.20</span>)   <span class="hljs-comment"># CMake 最低版本要求</span><br><span class="hljs-keyword">project</span>(hello)                         <span class="hljs-comment"># 配置项目名称为 hello</span><br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> main.c) <span class="hljs-comment"># 为生成可执行文件所使用到的源文件</span><br></code></pre></td></tr></table></figure></li><li><p>CMake 手动构建命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake -B build      # 创建 build 目录,编译 CMakeList.txt<br>cmake --build build # 构建项目,生成可执行文件<br></code></pre></td></tr></table></figure></li><li><p>若修改了 <code>CMakeLists.txt</code> 文件但并未及时生效,可以删除 <code>./build</code> 目录后重新构建</p></li></ul></li><li><p>CMake 语法</p><ul><li><p>CMake 项目基于 CMakeLists.txt 构建,其中(或 <code>*.cmake</code> 文件)使用的就是 CMake Language</p></li><li><p>cmake 命令行工具由5个可执行文件构成: <code>cmake, ctest, cpack, cmake-gui, ccmake</code></p></li><li><p>不通过 CMakeLists.txt 运行 CMake 的方法(该方法仅学习语法,实际并不会用到)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake -P *.cmake<br></code></pre></td></tr></table></figure></li><li><p>获取 CMake 变量</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>(<span class="hljs-variable">$&#123;CMAKE_VERSION&#125;</span>)  <span class="hljs-comment"># 打印版本号</span><br></code></pre></td></tr></table></figure><ul><li>CMake 的变量(区分大小写)分为: CMake 提供 和 自定义的</li><li>CMake 的变量存储时均为字符串</li></ul></li></ul></li><li><p>CMake 构建项目的方式</p><ul><li><code>add_executable</code> 中直接写入相对路径.此时在源码中引入头文件也需要写相对路径</li></ul></li><li><p>生成静态库和动态库</p><ul><li>静态库: 在连接阶段,将汇编的 <code>.o</code> 文件与引用到的库一起打包到可执行文件中</li><li>动态库: 不会在编译时连接,而是在运行时才载入</li></ul></li><li><p>调用静态库和动态库</p></li></ol><h2 id="1-库函数"><a href="#1-库函数" class="headerlink" title="1 库函数"></a>1 库函数</h2><h3 id="1-1-字符处理"><a href="#1-1-字符处理" class="headerlink" title="1.1 字符处理"></a>1.1 字符处理</h3><ol><li><p>字符分类(返回值非零时表示真,函数声明于 <code>&lt;ctype.h&gt;</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">isalnum</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 字母或数字</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isalpha</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 字母</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isblank</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 空白字符(空格或\t)(C99新增)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">iscntrl</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 控制字符</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isdigit</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 十进制数字</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isgraph</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 可显示字符(除空格)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">islower</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 小写字母</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isprint</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 可打印字符(包括空格)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ispunct</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 标点符号</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isspace</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 空白字符(空格、\f、\n、\r、\t、\v)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isupper</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 大写字母</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isxdigit</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>; <span class="hljs-comment">// 十六进制数字</span><br></code></pre></td></tr></table></figure></li><li><p>字符转换(声明于 <code>&lt;ctype.h&gt;</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">tolower</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 转换为小写</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">toupper</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;  <span class="hljs-comment">// 转换为大写</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="1-2-字符串处理"><a href="#1-2-字符串处理" class="headerlink" title="1.2 字符串处理"></a>1.2 字符串处理</h3><ol><li><p>下列函数声明于 <code>&lt;string.h&gt;</code></p></li><li><p>字符串操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 复制</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span>;<br><span class="hljs-type">char</span> *<span class="hljs-title function_">strncpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">size_t</span> n)</span>;<br><br><span class="hljs-comment">// 连接</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">strcat</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span>;<br><span class="hljs-type">char</span> *<span class="hljs-title function_">strncat</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">size_t</span> n)</span>;<br><br><span class="hljs-comment">// 比较</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">strcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s1, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s2)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">strncmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s1, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s2, <span class="hljs-type">size_t</span> n)</span>;<br><br><span class="hljs-comment">// 长度</span><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">strlen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;<br></code></pre></td></tr></table></figure></li><li><p>内存操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 按照指定的字节数进行 copy</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> n)</span>;<br><br><span class="hljs-comment">// 将 copy 过程扩展为内存重叠时仍可正确执行</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">memmove</span><span class="hljs-params">(<span class="hljs-type">void</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> n)</span>;<br><br><span class="hljs-comment">// 按照指定的字节数初始化内存区域</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *s, <span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> n)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">memcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *s1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *s2, <span class="hljs-type">size_t</span> n)</span>;<br></code></pre></td></tr></table></figure></li><li><p>搜索函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">strchr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> c)</span>;    <span class="hljs-comment">// 查找字符首次出现</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">strrchr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> c)</span>;   <span class="hljs-comment">// 查找字符最后出现</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">strstr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *haystack, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *needle)</span>; <span class="hljs-comment">// 查找子串</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">strtok</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *delim)</span>;  <span class="hljs-comment">// 字符串分割</span><br><br><span class="hljs-comment">// 在字符串中查找指定字符集合中任意字符的首次出现位置</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">strpbrk</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *accept)</span>;<br><br><span class="hljs-comment">// 在指定内存区域中查找特定字符的首次出现</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">memchr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">int</span> value, <span class="hljs-type">size_t</span> num)</span>;<br></code></pre></td></tr></table></figure></li><li><p>其他</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 计算字符串开头连续包含指定字符集合中字符的字符数</span><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">strspn</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *accept)</span>;<br><br><span class="hljs-comment">// 计算字符串开头连续不包含指定字符集合中字符的字符数</span><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">strcspn</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *reject)</span>;<br><br><span class="hljs-comment">// 将错误号转换为可读的错误描述字符串</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> errnum)</span>;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-3-输入输出"><a href="#1-3-输入输出" class="headerlink" title="1.3 输入输出"></a>1.3 输入输出</h3><ol><li><p>字符 IO(函数声明于 <code>stdio.h</code>.且通常实现为宏)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">getchar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <span class="hljs-comment">// 从 stdin 读取一个字符.通常对应键盘输入</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">putchar</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>; <span class="hljs-comment">// 向 stdout 写入一个字符.通常输出到屏幕</span><br></code></pre></td></tr></table></figure><ul><li><code>getchar</code> 成功时返回读取的字符; 失败 &#x2F; 文件结束返回 <code>EOF</code>(在 <code>stdio.h</code> 中定义)</li><li><code>putchar</code> 成功时返回输出的字符; 失败时返回 <code>EOF</code></li></ul></li><li><p>报告错误信息(函数声明于 <code>stdio.h</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">perror</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;  <span class="hljs-comment">// 向标准错误流 (stderr) 输出错误信息</span><br></code></pre></td></tr></table></figure><ul><li><code>perror</code> 内部会检查 <code>errno</code> 的值.根据 <code>errno</code> 查找对应的错误描述字符串</li><li>错误描述来自 <code>errno</code> 宏(定义在 <code>&lt;errno.h&gt;</code>).表示最近一次错误的错误码</li><li>输出格式为 <code>&quot;自定义字符串: 错误描述\n&quot;</code></li><li>多线程环境中需注意 <code>errno</code> 是线程局部的,每个线程有自己的 <code>errno</code></li></ul></li><li><p><code>printf</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将字符串进行格式化转换,然后进行标准化输出.等价于 fprintf(stdout, ...)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br><span class="hljs-comment">// format: 格式化字符串, 包含普通字符和格式说明符</span><br><span class="hljs-comment">// ...: 可变参数列表, 对应格式字符串中的格式说明符</span><br><span class="hljs-comment">// 返回值: 成功时返回输出的字符数, 失败时返回负值</span><br></code></pre></td></tr></table></figure><ul><li><p>格式化字符串结构分为</p><ul><li><p>普通字符: 原样输出</p></li><li><p>转义序列: 如 <code>\n, \t</code></p></li><li><p>格式说明符: 以 <code>%</code> 开头,形式为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">%[flags][width][.precision][length]specifier<br></code></pre></td></tr></table></figure></li></ul></li><li><p>基本格式说明符(若<code>%</code>后的字符不是转换字符,则为未定义行为)</p><table><thead><tr><th>specifier</th><th>参数类型 &amp; 转换结果</th></tr></thead><tbody><tr><td>d, i</td><td>int. 有符号十进制表示</td></tr><tr><td>u</td><td>int. 无符号十进制表示</td></tr><tr><td>o</td><td>unsigned int. 无符号八进制表示(无前导0)</td></tr><tr><td>x, X</td><td>unsigned int. 无符号十六进制表示(无前导0x&#x2F;0X),区分大小写</td></tr><tr><td>f</td><td>double. 形式为: [-]mmm.ddd 的十进制表示</td></tr><tr><td>e, E</td><td>double. 形式为: [-]m.dddddd e&#x2F;E xx 的十进制表示</td></tr><tr><td>g, G</td><td>double. 自动选择科学计数法(%e &#x2F; %E)或 %f</td></tr><tr><td>c</td><td>int. 转换为 unsigned char 类型后的单个字符</td></tr><tr><td>s</td><td>char *. 打印字符串.直到 <code>&#39;\0&#39;</code> 或 达到精度指定的字符数</td></tr><tr><td>p</td><td>void *. 打印指针值</td></tr><tr><td>%</td><td>不进行参数转化.打印 <code>%</code></td></tr></tbody></table></li><li><p>标志(flags 出现顺序不限): 用于修改转换说明</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>-</td><td>左对齐</td></tr><tr><td>+</td><td>强制显示正负号</td></tr><tr><td><kbd>space</kbd></td><td>正数前加空格代替加号</td></tr><tr><td>0</td><td>用0填充而非空格(配合 width 使用)</td></tr><tr><td>#</td><td>%0: 加前导0<br />%x &#x2F; %X: 加前导 0x &#x2F; 0X<br />%f &#x2F; %e &#x2F; %E &#x2F; %g &#x2F; %G: 强制带小数点</td></tr></tbody></table></li><li><p>宽度(width): 最小输出宽度(可以使用 <code>*</code> 来用参数指定)</p></li><li><p>精度(.precision): 不同转换类型含义不同(可以使用 <code>*</code> 来用参数指定)</p><table><thead><tr><th>转换类型</th><th>精度的含义</th></tr></thead><tbody><tr><td>整数</td><td>最小数字位数(不足补0)</td></tr><tr><td>浮点数(<code>e/E/f</code>)</td><td>小数点后的位数</td></tr><tr><td>科学计数法(<code>g/G</code>)</td><td>有效数字位数</td></tr><tr><td>字符串</td><td>最大输出字符数</td></tr></tbody></table></li><li><p>长度修饰符(length): 用于将参数指定为某种类型</p><table><thead><tr><th align="left">修饰符</th><th align="left">适用类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">hh</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">signed &#x2F; unsigned char</td></tr><tr><td align="left">h</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">short</td></tr><tr><td align="left">l</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">long</td></tr><tr><td align="left">ll</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">long long</td></tr><tr><td align="left">L</td><td align="left">%f, %e, %E, %g, %G</td><td align="left">long double</td></tr><tr><td align="left">z</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">size_t</td></tr><tr><td align="left">t</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">ptrdiff_t</td></tr></tbody></table></li></ul></li><li><p><code>scanf</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 从标准输入读取输入,根据 format 进行匹配, 匹配到赋给后续的各个参数</span><br><span class="hljs-comment">// 后续的参数必须是指针. 等价于 scanf(stdout, ...)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">scanf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br><span class="hljs-comment">// format: 格式化字符串,指定输入数据的预期格式</span><br><span class="hljs-comment">// ...: 可变参数列表, 对应格式字符串中的格式说明符</span><br><span class="hljs-comment">// 返回实际被转换并赋值的输入项的数目</span><br><span class="hljs-comment">// 若到达文件的末尾或在转换输入前出错,则返回 EOF</span><br></code></pre></td></tr></table></figure><ul><li><p>格式串字符串结构</p><ul><li><p>空白字符: 空格, 制表符, 换行符</p></li><li><p>非空白字符: 必须与输入精确匹配的字符</p></li><li><p>格式说明符: 以 <code>%</code> 开头,形式为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">%[*][width][length]specifier<br></code></pre></td></tr></table></figure></li></ul></li><li><p>基本格式说明符</p><table><thead><tr><th>specifier</th><th>参数类型 &amp; 输入数据</th></tr></thead><tbody><tr><td>d</td><td>int *. 十进制整型数</td></tr><tr><td>i</td><td>int *. 整数(自动检测进制)</td></tr><tr><td>u</td><td>unsigned int *. 无符号十进制整型数</td></tr><tr><td>o</td><td>unsigned int *. 无符号八进制整型数</td></tr><tr><td>x, X</td><td>unsigned int *. 十六进制整型数</td></tr><tr><td>e &#x2F; f &#x2F; g</td><td>float *. 格式为: \pm(可选), 数字串(可能有小数), 指数字段(可选)</td></tr><tr><td>c</td><td>char *. 字符</td></tr><tr><td>s</td><td>char *. 由非空白符组成的字符串(不包含引号).自动在数组末尾增加 <code>&#39;\0&#39;</code></td></tr><tr><td>p</td><td>void **. 指针地址.无实用价值</td></tr><tr><td>[…]</td><td>char *.与方括号中的字符集. 匹配的输入字符中 最长的非空字符串<br />如 <code>[]...]</code> 表示集合中包含字符<code>]</code>. 会自动在数组末尾增加 <code>&#39;\0&#39;</code></td></tr><tr><td>[^…]</td><td>char *.与方括号中的字符集. <strong>不匹配</strong>的输入字符中 最长的非空字符串<br />如 <code>[^]...]</code> 表示集合中<strong>不包含</strong>字符<code>]</code>. 自动在数组末尾增加 <code>&#39;\0&#39;</code></td></tr><tr><td>%</td><td>表示 <code>%</code>,不进行赋值</td></tr></tbody></table></li><li><p><code>*</code>: 赋值抑制.匹配但不存储输入</p></li><li><p><code>width</code>: 指定最大输入宽度</p></li><li><p><code>length</code>: 用于将参数指定为某种类型</p><table><thead><tr><th align="left">修饰符</th><th align="left">适用类型</th><th align="left">参数类型</th></tr></thead><tbody><tr><td align="left">hh</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">signed &#x2F; unsigned char *</td></tr><tr><td align="left">h</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">short *</td></tr><tr><td align="left">l</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">long *</td></tr><tr><td align="left"></td><td align="left">%f, %e, %g</td><td align="left">double *</td></tr><tr><td align="left">ll</td><td align="left">%d, %i, %o, %u, %x</td><td align="left">long long *</td></tr><tr><td align="left">L</td><td align="left">%f, %e, %g</td><td align="left">long double *</td></tr></tbody></table></li></ul></li></ol><h3 id="1-4-整型函数"><a href="#1-4-整型函数" class="headerlink" title="1.4 整型函数"></a>1.4 整型函数</h3><ol><li><p>算术(下列整型函数均声明于 <code>&lt;stdlib.h&gt;</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">abs</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>;             <span class="hljs-comment">// 绝对值</span><br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">labs</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">int</span> value)</span>;  <span class="hljs-comment">// abs 的 long int 形式</span><br><span class="hljs-type">div_t</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> numerator, <span class="hljs-type">int</span> denominator)</span>;<br><span class="hljs-type">ldiv_t</span> <span class="hljs-title function_">ldiv</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">int</span> numerator, <span class="hljs-type">long</span> <span class="hljs-type">int</span> denominator)</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>div</code> 函数进行带余整数除法,返回一个 <code>div_t</code> 的结构.包含两个字段:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> quot; <span class="hljs-comment">// 商</span><br><span class="hljs-type">int</span> rem;  <span class="hljs-comment">// 余数</span><br></code></pre></td></tr></table></figure></li><li><p><code>ldiv</code> 函数处理的对象为 <code>long int</code> 类型,而返回 <code>ldiv_t</code> 结构</p></li></ul></li><li><p>随机数</p><ul><li><p>用于产生伪随机数的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">rand</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">srand</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seed)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>rand</code> 返回一个范围在 0~RAND_MAX(至少为32767) 的伪随机数</p></li><li><p>可以用对 <code>rand</code> 返回值取模,然后加上一个偏移量的方式获取一个固定区间的随机数</p></li><li><p><code>srand</code> 函数可以设置随机数种子.根据参数对随机数发生器初始化</p></li><li><p>可以用时间作为随机数产生器的种子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">srand( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) time(<span class="hljs-number">0</span>) );<br></code></pre></td></tr></table></figure></li></ul></li><li><p>字符串转换</p><ul><li><p>字符串转换函数将 字符串转换为数值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">atoi</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>)</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">atol</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>)</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strtol</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">char</span> **unused, <span class="hljs-type">int</span> base)</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strtoul</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">char</span> **unused, <span class="hljs-type">int</span> base)</span>; <br><span class="hljs-type">double</span> <span class="hljs-title function_">atof</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">strtod</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">char</span> **unused)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>atoi,atol</code> 函数进行基数为10的转换</li><li><code>strtol,strtoul</code> 函数允许指定基数,还允许访问字符串的剩余部分</li><li>如果参数 <code>string</code> 中包含了前导空白字符 以及非法缀尾字符,将会被忽略</li><li>参数 <code>base</code> 的取值范围为 2<del>36,此时字母 A</del>Z 分别表示 10~35</li><li>特别的,当 <code>base</code> 的值为0时,表示接受 程序中任何可书写的整型字面值</li></ul></li><li><p><code>strol</code> 函数示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">x = strol(<span class="hljs-string">&quot;   590bear&quot;</span>, next, <span class="hljs-number">12</span>);<br></code></pre></td></tr></table></figure><ul><li>该指令的返回值为 9947,由于 e 在基数为12时非法,转换终止</li><li><code>next</code> 是一个指向指针的指针,指向的内容为: 指向字母 e 的指针</li></ul></li><li><p>如果参数 <code>string</code> 中不包含任何一个合法数值,返回0</p></li><li><p>如果被转换的值无法表示,函数将在 <code>errno</code> 中存储值 <code>ERANGE</code>.并返回下表中的一个值</p><table><thead><tr><th>函数</th><th>返回值</th></tr></thead><tbody><tr><td>strol</td><td>若值过大且为负,返回 <code>LONG_MIN</code>. 若值过大且为正,返回 <code>LONG_MAX</code></td></tr><tr><td>stroul</td><td>若值过大,返回 <code>ULONG_MAX</code></td></tr></tbody></table></li></ul></li></ol><h3 id="1-5-浮点型函数"><a href="#1-5-浮点型函数" class="headerlink" title="1.5 浮点型函数"></a>1.5 浮点型函数</h3><ol><li><p>下列函数声明于 <code>&lt;math.h&gt;</code>.绝大多数的参数和返回值类型为 <code>double</code></p><ul><li>若函数的参数不在定义域内,出现<code>定义域错误</code>.函数返回一个由编译器提供的错误值,并置 <code>errno</code> 值为 <code>EDOM</code></li><li>若函数的结果值过大&#x2F;小,超出 <code>double</code> 的范围,出现返回错误.<ul><li>若过大,函数返回 <code>HUGE_VAL</code>(在<code>math.h</code>中定义)</li><li>若过小,函数返回 0,事实上也是范围错误</li></ul></li></ul></li><li><p>三角函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 参数为弧度制的角度值 */</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">sin</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">cos</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">tan</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><br><span class="hljs-comment">/* 返回值为弧度制的角度值 */</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">asin</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">acos</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">atan</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span>;<br><br><span class="hljs-comment">/* 返回值为 y/x 的反正切值,利用参数的符号决定象限 */</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">atan2</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br></code></pre></td></tr></table></figure></li><li><p>双曲函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 参数为弧度制的角度值 */</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">sinh</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">cosh</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">tanh</span><span class="hljs-params">(<span class="hljs-type">double</span> angle)</span>;<br></code></pre></td></tr></table></figure></li><li><p>对数和指数函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">exp</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">log</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">log10</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>exp</code> 返回 $e^x$</li><li><code>log</code> 返回 $\mathrm{ln}x$</li><li><code>log10</code> 返回 $\mathrm{log}_{10} x$</li><li>利用换底公式 $\mathrm{log}_b x&#x3D;\frac{\mathrm{ln} x}{\mathrm{ln} b}$ 可计算任意底数的对数</li></ul></li><li><p>浮点表示形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">frexp</span><span class="hljs-params">(<span class="hljs-type">double</span> value, <span class="hljs-type">int</span> *exponent)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">ldexp</span><span class="hljs-params">(<span class="hljs-type">double</span> fraction, <span class="hljs-type">int</span> exponent)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">modf</span><span class="hljs-params">(<span class="hljs-type">double</span> value, <span class="hljs-type">double</span> *ipart)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>frexp</code> 函数返回值 <code>fraction</code>,取值范围为 [0.5, 1).满足 $\mathrm{fraction}\cdot2^\mathrm{exponent} &#x3D; \mathrm{value}$</li><li><code>ldexp</code> 函数相对地返回 <code>value</code>: $\mathrm{value}&#x3D;\mathrm{fraction}\cdot2^\mathrm{exponent}$</li><li><code>modf</code> 函数将浮点值分成整数和小数两部分,它们拥有与原值相同的符号</li></ul></li><li><p>幂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">pow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>pow</code> 函数返回 $x^y$. 计算时可能会用到对数</li><li><code>sqrt</code> 函数返回 $\sqrt{x}$</li></ul></li><li><p>底数, 顶数, 绝对值, 余数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">floor</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">ceil</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">fabs</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">fmod</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>floor</code> 函数返回不大于参数的最大整数值,即向下取整</li><li><code>ceil</code> 函数返回不小于参数的最小整数值,即向上取整</li><li><code>fabs</code> 函数返回参数的绝对值</li><li><code>fmod</code> 函数返回 <code>x / y</code> 的余数,符号与 <code>x</code> 相同</li></ul></li></ol><h3 id="1-6-日期时间"><a href="#1-6-日期时间" class="headerlink" title="1.6 日期时间"></a>1.6 日期时间</h3><ol><li><p>处理器时间(下列时间&#x2F;日期函数均声明于 <code>&lt;time.h&gt;</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">clock_t</span> <span class="hljs-title function_">clock</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>clock</code> 函数返回程序开始起处理去所消耗的时间,可能是个近似值</li><li>若需要精确时间,可在<code>main</code>函数开始调用一次<code>clock</code>,随后的调用进行减法来获取时间</li><li>若时间值过大,或机器无法获得时间,返回 -1</li><li><code>clock</code> 函数返回的数字由编译器定义,一般为处理器时钟滴答的次数</li><li>若需要将返回值换算成秒,应将其除以 <code>CLOCKS_PER_SEC</code></li></ul></li><li><p>当天时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">time_t</span> <span class="hljs-title function_">time</span><span class="hljs-params">(<span class="hljs-type">time_t</span> *returned_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>若参数为非NULL指针,则时间值将通过这个指针存储</li><li>若时间值太大,或机器无法提供日期和时间,返回 -1</li><li>标准并未规定时间的编码方式,因此不应使用字面值常量</li></ul></li><li><p>日期和时间的转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">ctime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> <span class="hljs-type">const</span> *time_value)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">difftime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> time1, <span class="hljs-type">time_t</span> time2)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>ctime</code> 函数的参数为 指向 <code>time_t</code> 的指针,返回一个指向字符串的指针<ul><li>返回的字符串格式为: <code>Sun Jul 4 04:02:48 1976\n\0</code></li><li>字符串内部的空格是固定的</li></ul></li><li><code>difftime</code> 函数计算 <code>time2 - time1</code> 的值,并将结果转换为秒</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> tm *<span class="hljs-title function_">gmtime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> <span class="hljs-type">const</span> *time_value)</span>;<br><span class="hljs-keyword">struct</span> tm *<span class="hljs-title function_">localtime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> <span class="hljs-type">const</span> *time_value)</span>;<br></code></pre></td></tr></table></figure></li><li><p>将一个 <code>time_t</code> 的值转换为一个 <code>tm</code> 结构,可以方便地访问各组成部分</p><ul><li><p><code>gmtime</code> 函数转换为世界协调时间</p></li><li><p><code>localtime</code> 函数转换为当地时间</p></li><li><p><code>tm</code> 结构的字段</p><table><thead><tr><th>类型 &amp; 名称</th><th>范围</th><th>含义</th></tr></thead><tbody><tr><td><code>int tm_sec</code></td><td>0~61</td><td>分之后的秒数</td></tr><tr><td><code>int tm_min</code></td><td>0~59</td><td>小时后的分数</td></tr><tr><td><code>int tm_hour</code></td><td>0~23</td><td>午夜后的小时数</td></tr><tr><td><code>int tm_mday</code></td><td>1~31</td><td>当月的日期</td></tr><tr><td><code>int tm_mon</code></td><td>0~11</td><td>1月后的月数</td></tr><tr><td><code>int tm_year</code></td><td>0~?</td><td>1900年后的年数</td></tr><tr><td><code>int tm_wday</code></td><td>0~6</td><td>星期天之后的天数</td></tr><tr><td><code>int tm_yday</code></td><td>0~365</td><td>1月1日后的天数</td></tr><tr><td><code>int tm_isdat</code></td><td></td><td>夏令时标志</td></tr></tbody></table></li></ul></li><li><p>将 <code>tm</code> 结构转换为字符串格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">asctime</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tm <span class="hljs-type">const</span> *tm_ptr)</span>;<br><span class="hljs-type">size_t</span> <span class="hljs-title function_">strftime</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">size_t</span> maxsize, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *format, <span class="hljs-keyword">struct</span> tm <span class="hljs-type">const</span> *tm_str)</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>asctime</code> 转换为字符串的格式与 <code>ctime</code> 一致</p><ul><li><p><code>strftime</code> 格式化的非常灵活</p></li><li><p>若转换的结果字符串长度小于 <code>maxsize</code>,则该字符串将被复制到 <code>string</code> 中</p></li><li><p><code>strftime</code> 的返回值为字符串的长度.若返回的是 -1,则 <code>string</code> 内容未定义</p></li><li><p><code>strftime</code> 格式代码</p><table><thead><tr><th>代码</th><th>被 … 替代</th></tr></thead><tbody><tr><td>%%</td><td><code>%</code></td></tr><tr><td>%a(%A)</td><td>星期中的某天,用当地的简写(全写)表示</td></tr><tr><td>%b(%B)</td><td>月份,用当地的简写(全写)表示</td></tr><tr><td>%c</td><td>日期和时间,使用 <code>%x %X</code></td></tr><tr><td>%d</td><td>月份中的某天(01~31)</td></tr><tr><td>%H</td><td>小时,24小时制(00~23)</td></tr><tr><td>%I</td><td>小时,12小时制(00~12)</td></tr><tr><td>%J</td><td>一年中的某天(001~366)</td></tr><tr><td>%m</td><td>月份(01~12)</td></tr><tr><td>%M</td><td>分钟(00~59)</td></tr><tr><td>%P</td><td>AM&#x2F;PM</td></tr><tr><td>%S</td><td>秒(00~61)</td></tr><tr><td>%U(%W)</td><td>一年中的第几个星期(00~53),以星期日&#x2F;星期一为第一天</td></tr><tr><td>%w</td><td>一星期的第几天,星期日为 0</td></tr><tr><td>%x(%X)</td><td>日期&#x2F;时间,本地格式</td></tr><tr><td>%y(%Y)</td><td>当前世纪的年份(00~99)&#x2F;年份的全写(如2023)</td></tr><tr><td>%z</td><td>时区的简写,无法判断时为空</td></tr></tbody></table></li></ul></li><li><p>将 <code>tm</code> 结构转化为 <code>time_t</code> 值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">time_t</span> <span class="hljs-title function_">mktime</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tm *tm_ptr)</span>;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-7-排序查找"><a href="#1-7-排序查找" class="headerlink" title="1.7 排序查找"></a>1.7 排序查找</h3><ol><li><p>排序 <code>&lt;stdlib.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">qsort</span><span class="hljs-params">(<span class="hljs-type">void</span> *base, <span class="hljs-type">size_t</span> n_elements, <span class="hljs-type">size_t</span> el_size, \</span><br><span class="hljs-params">           <span class="hljs-type">int</span> (*compare)(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *) )</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>qsort</code> 函数是类型无关的,对任意数据类型的,固定长度的数组进行升序排序</p></li><li><p><code>base</code> 参数: 指向待排序的数组</p></li><li><p><code>n_elements</code> 参数: 指定数组中的元素数目</p></li><li><p><code>el_size</code> 参数: 指定每个元素的长度(单位为 字符)</p></li><li><p><code>compare</code> 是一个函数指针,对需要排序的元素类型进行比较.在排序时,调用该函数进行大小比较</p></li><li><p>比较函数接受2个参数,指向待比较的值.返回一个整数,表示参数的大小关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">// 定义一个结构,根据 key 排序</span><br> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>     <span class="hljs-type">char</span> key[<span class="hljs-number">10</span>];<br>     <span class="hljs-type">int</span> otherData;<br> &#125; Record;<br><br><span class="hljs-comment">// 比较函数,直接返回 strcmp 的计算结果</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">recordCompare</span><span class="hljs-params">(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *a, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *b)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>( (Record *)a-&gt;key, (Record *)b-&gt;key );<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Record <span class="hljs-built_in">array</span>[<span class="hljs-number">50</span>];<br>    qsort(<span class="hljs-built_in">array</span>, <span class="hljs-number">50</span>, <span class="hljs-keyword">sizeof</span>(Record), recordCompare);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>二分查找 <code>&lt;stdlib.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">bsearch</span><span class="hljs-params">(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *key, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *base, <span class="hljs-type">size_t</span> n_elements,\</span><br><span class="hljs-params">             <span class="hljs-type">size_t</span> el_size, <span class="hljs-type">int</span> (*compare)(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *) )</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>key</code> 参数: 待查找的值,必须和目标数组元素的类型相同</p></li><li><p><code>base</code> 参数: 指向目标数组</p></li><li><p><code>n_elements</code> 参数: 数组的元素数目</p></li><li><p><code>el_size</code> 参数: 每个元素的长度(以字符为单位)</p></li><li><p><code>compare</code> 参数: 指向比较参数.与 <code>qsort</code> 函数相同</p></li><li><p><code>bsearch</code> 函数: 返回一个指针,指向查找到的数组元素.若不存在,返回 <code>NULL</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">// 定义一个结构,根据 key 排序</span><br> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>     <span class="hljs-type">char</span> key[<span class="hljs-number">10</span>];<br>     <span class="hljs-type">int</span> otherData;<br> &#125; Record;<br><br><span class="hljs-comment">// 比较函数,直接返回 strcmp 的计算结果</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">recordCompare</span><span class="hljs-params">(<span class="hljs-type">void</span> <span class="hljs-type">const</span> *a, <span class="hljs-type">void</span> <span class="hljs-type">const</span> *b)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>( (Record *)a-&gt;key, (Record *)b-&gt;key );<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Record <span class="hljs-built_in">array</span>[<span class="hljs-number">50</span>];<br>    Record key; <span class="hljs-comment">// 待查找的对象</span><br>    Record *ans;<br>    <br>    <span class="hljs-built_in">strcpy</span>(key.key, <span class="hljs-string">&quot;value&quot;</span>); <span class="hljs-comment">// 比较函数中用到的 key 字段必须填充</span><br>    qsort(<span class="hljs-built_in">array</span>, <span class="hljs-number">50</span>, <span class="hljs-keyword">sizeof</span>(Record), recordCompare); <span class="hljs-comment">// 注意: 二分查找需要先排序</span><br>    ans = bsearch(&amp;key, <span class="hljs-built_in">array</span>, <span class="hljs-number">50</span>, <span class="hljs-keyword">sizeof</span>(Record, recordCompare));<br>    <span class="hljs-comment">/* 现在 ans指向查找到的目标 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-8-信号"><a href="#1-8-信号" class="headerlink" title="1.8 信号"></a>1.8 信号</h3><ol><li><p>信号</p><ul><li>程序中绝大部分事件由其本身引发.但对于外部中断等事件,程序需要预备对这类时间作出反应</li><li><strong>信号表示一种事件,可能会异步发生.程序可设置一个信号处理函数,当信号发生,就调用它</strong></li><li>下面的函数位于 <code>&lt;signal.h&gt;</code></li></ul></li><li><p>信号名</p><table><thead><tr><th>信号</th><th>说明</th></tr></thead><tbody><tr><td>SIGABRT</td><td>程序请求异常终止</td></tr><tr><td>SIGFPE</td><td>发生一个算术错误</td></tr><tr><td>SIGILL</td><td>检测到非法指令</td></tr><tr><td>SIGSEGV</td><td>检测到对内存的非法访问</td></tr><tr><td>SIGINT</td><td>收到一个交互性注意信号</td></tr><tr><td>SIGTERM</td><td>收到一个终止程序的请求</td></tr></tbody></table><ul><li><code>SIGABRT</code> 是由 <code>abort</code> 函数引发的信号,用于终止程序</li><li><code>SIGILL</code> 提示 CPU 试图执行一条非法指令</li><li><code>SIGINT</code> 和 <code>SIGTERM</code> 是异步的,由程序外部产生</li></ul></li><li><p>处理信号</p><ul><li><p>显式的引发一个信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">raise</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span>;<br></code></pre></td></tr></table></figure></li><li><p>当一个信号发生时,程序可以有3种反应: 缺省方式(终止程序); 将其忽略; 设置信号处理函数对其反应</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*signal(<span class="hljs-type">int</span> sig, <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">int</span>))) (<span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><ul><li><code>signal</code> 是一个函数.返回一个函数指针,指向一个参数为 <code>int</code> 的无返回值函数</li><li><code>sig</code> 参数是<code>信号名</code>中列举的信号之一</li><li><code>handler</code> 参数是希望为该信号设置的处理函数,是一个函数指针,指向一个参数为 <code>int</code> 的无返回值函数</li><li>当信号发生时,信号的代码作为参数传递给 <code>handler</code> 指向的信号处理函数</li><li><code>signal</code> 返回一个指向该信号以前的处理函数的指针</li><li><code>signal.h</code> 定义了宏 <code>SIG_DFL, SIG_IGN</code>,可作为 <code>handler</code> 参数的值.分别表示缺省处理&#x2F;忽略信号</li></ul></li></ul></li><li><p>信号处理函数</p><ul><li>当一个已设置的信号处理函数的信号发生时,系统恢复对该信号的缺省行为(防止处理函数内部再次发生该信号而引起无限循环),然后,信号处理函数被调用,信号代码作为参数传入</li><li>信号处理函数可能执行的工作非常有限.对于异步信号,不应调用除 <code>signal.h</code> 以外的库函数</li><li>信号处理函数仅能向一个类型为 <code>volatile sig_atomic_t</code> 的静态变量赋值,其他静态数据可能无法访问</li><li>从一个信号处理函数返回,将导致执行流从信号发生的地点恢复执行(除了<code>SIGFPE</code>,无法完成计算)</li><li>若希望将来再次捕获同类型信号,需要在处理函数返回前,调用 <code>signal</code> 函数进行设置</li></ul></li></ol><h3 id="1-9-非本地跳转"><a href="#1-9-非本地跳转" class="headerlink" title="1.9 非本地跳转"></a>1.9 非本地跳转</h3><ol><li><p>类似于 <code>goto</code> 语句,但作用域并非局限于函数作用域</p></li><li><p>需要包含头文件 <code>&lt;setjump.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">setjump</span><span class="hljs-params">(jmp_buf state)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">longjump</span><span class="hljs-params">(jmp_buf state, <span class="hljs-type">int</span> value)</span>;<br></code></pre></td></tr></table></figure><ul><li>调用方式: 声明一个 <code>jmp_buf</code> 变量,使用 <code>setjump</code> 函数进行初始化,返回值为0</li><li><code>setjump</code> 会将程序信息保存到缓冲区.调用 <code>sejump</code> 时所处的函数成为 <code>顶层函数</code></li><li>在<code>顶层函数</code>或其他被它调用的函数处 调用 <code>longjump</code> 时,被保存的程序信息将会恢复.跳回 <code>顶层函数</code></li><li>当 <code>setjump</code> 函数第一次被调用返回0.当 <code>setjump</code> 作为 <code>longjump</code> 的执行结果时,返回 <code>value</code></li></ul></li></ol><h3 id="1-10-执行环境"><a href="#1-10-执行环境" class="headerlink" title="1.10 执行环境"></a>1.10 执行环境</h3><ol><li><p>终止执行 <code>&lt;stdlib.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">atexit</span><span class="hljs-params">(<span class="hljs-type">void</span> (func)(<span class="hljs-type">void</span>))</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>abort</code> 函数用于不正常地终止一个正在执行的程序.它将引发 <code>SIGABRT</code>,可为它设置信号处理函数</li><li><code>atexit</code> 函数可将一些函数注册为 <code>退出函数</code>.当程序要正常终止时,退出函数将被调用</li><li><strong><code>exit</code> 函数用于正常终止程序.当它被调用时,所有被 <code>atexit</code> 注册为退出函数按被注册顺序逆序依次调用.然后所有用于流的缓冲区被刷新,所有打开的文件被关闭,用<code>tempfile</code>函数创建的文件被删除.退出状态返回给宿主环境.程序停止执行</strong></li><li><code>exit</code> 函数的<code>status</code> 参数将会返回给操作系统</li><li><code>exit</code> 函数没有返回值: 当 <code>exit</code> 结束时,程序已经消失,它已无处可返</li></ul></li><li><p><strong>断言: 声明某事应该为真</strong> <code>&lt;assert.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">assert</span><span class="hljs-params">(<span class="hljs-type">int</span> expression)</span>; <span class="hljs-comment">// 实际上这是不是函数,而是一个宏</span><br><span class="hljs-comment">/* expression 若为假,向标准错误打印一条诊断信息并终止程序.若为真,程序继续执行 */</span><br></code></pre></td></tr></table></figure></li><li><p>断言一般用于程序调试.当程序被完整地测试完毕,可在包含头文件 <code>aseert.h</code> 之前增加:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDEBUG</span><br><span class="hljs-comment">/* 定义了 NDEBUG 之后,预处理将丢弃所有的断言,而不必在源文件中实际将其删除 */</span><br></code></pre></td></tr></table></figure></li><li><p>执行系统命令 <code>&lt;stdlib.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">system</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *command)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>system</code> 函数将字符串参数传递给宿主操作系统</li><li><code>system</code> 函数可用 <code>NULL</code> 参数进行调用,用于询问命令处理器是否存在.若存在,返回一个非零值</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C 语言</tag>
      
      <tag>计算机</tag>
      
      <tag>Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Language Basic</title>
    <link href="/2023/05/01/Computer/C-Language-Basic/"/>
    <url>/2023/05/01/Computer/C-Language-Basic/</url>
    
    <content type="html"><![CDATA[<h2 id="0-编译链接"><a href="#0-编译链接" class="headerlink" title="0 编译链接"></a>0 编译链接</h2><h3 id="0-1-源代码处理"><a href="#0-1-源代码处理" class="headerlink" title="0.1 源代码处理"></a>0.1 源代码处理</h3><ol><li><strong>预处理(Preprocessing)</strong>: 对源代码(source code file)进行文本替换(宏定义, 条件编译, 文件包含)<ul><li>删除所有注释 <code>//, /* */</code></li><li>展开所有宏定义 <code>#define</code></li><li>处理所有的条件编译指令 <code>#if, #ifdef, #endif...</code></li><li>添加行号和文件名标识</li><li>保留所有的 <code>#pragma</code> 编译器指令,留给编译器</li></ul></li><li><strong>编译(Compilation)</strong>: 将经过预处理之后的程序转换成特定汇编代码(assembly code).生成文本文<ul><li><strong>词法分析</strong>: 将代码的字符序列转化为一系列 token(如关键字, 标识符, 特殊符号…)</li><li><strong>语法分析</strong>: 生成以表达式为节点的语法树</li><li><strong>语义分析</strong>: 进行静态语义分析(如类型转换).此时语法树有了类型</li></ul></li><li><strong>汇编(Assemble)</strong>: 将汇编代码转换成机器码(machine code),生成的文件称目标文件(二进制格式)</li><li><strong>链接(Linking)</strong>: 将多个目标文件以及所需的库文件(.so等)链接成最终的可执行文件(executable file)<ul><li><strong>符号解析</strong>: 链接器扫描所有目标文件收集所有符号,为每个符号引用找到对应的定义</li><li><strong>地址空间分配</strong>: 将目标文件的段信息进行合并</li><li><strong>重定位</strong>: 程序中调用的函数, 全局变量在编译并未确定其地址.此时修正它们的地址</li></ul></li></ol><h3 id="0-2-宏定义"><a href="#0-2-宏定义" class="headerlink" title="0.2 宏定义"></a>0.2 宏定义</h3><ol><li><p>程序扩展 <code>#define</code> 的步骤</p><ul><li>调用宏时,对参数进行检查.如果包含了 <code>#define</code>  定义的符号,将其替换(双引号中的除外)</li><li>替换文本被插入到程序原来的位置.对于带参数的宏,参数名会被值替换</li><li>再次对结果文本进行扫描.如果还有由 <code>#define</code> 定义的符号,重复上述步骤</li></ul></li><li><p>编译器预定义宏</p><table><thead><tr><th>符号</th><th>示例值</th><th>含义</th></tr></thead><tbody><tr><td><code>__FILE__</code></td><td>“name.c”</td><td>进行编译的源文件名</td></tr><tr><td><code>__LINE__</code></td><td>25</td><td>文件当前行号</td></tr><tr><td><code>__DATE__</code></td><td>“Aug 24 2023”</td><td>文件被编译的日期</td></tr><tr><td><code>__TIME__</code></td><td>“18:04:30”</td><td>文件被编译的时间</td></tr><tr><td><code>__STDC__</code></td><td>1</td><td>若编译器遵循 ANSI C,其值为1.否则未定义</td></tr></tbody></table></li><li><p><strong>无参宏定义</strong>: <code>#define name stuff</code> </p><ul><li><p>作用: 在该指令后面内容中,每当 <code>name</code> 出现,预处理器将其替换为 <code>stuff</code> </p></li><li><p>若 <code>stuff</code> 很长,可以将其分为几行,在行尾加上 <code>\</code> 表示下一行是上一行的延续</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG_PRINT print(<span class="hljs-string">&quot;File %s line %d: x=%d, y=%d, z=%d&quot;</span> \</span><br><span class="hljs-meta">__FILE__, __LINE__, x, y, z)</span><br>x *= <span class="hljs-number">2</span>; y += x; z = x * y;<br>DEBUG_PRINT; <span class="hljs-comment">// 将打印出 文件名, 行号, x, y, z的值</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>含参数宏定义</strong>: <code>#dedine name(parameter-list) stuff</code> </p><ul><li><p>其中参数列表 <code>parameter-list</code> 是由逗号分隔的符号列表,可能会出现在 <code>stuff</code> 中</p></li><li><p>作用: 在该指令后面内容中,每当 <code>name(parameter-list)</code> 出现,预处理器将其替换为 <code>stuff</code>,且每个参数均对应地被替换.注意在参数上加上括号,避免参数与操作符的相互作用而产生不可预料的后果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(x) ((x) * (x))</span><br>SQUARE(<span class="hljs-number">5</span>); <span class="hljs-comment">// 将被预处理器替换为 ((5) * (5))</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>可变参数宏定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHOWLIST(...) printf(__VA_ARGS__)</span><br>SHOWLIST(Clang, <span class="hljs-number">520</span>, pi); <span class="hljs-comment">// 输出为 Clang, 520, pi</span><br></code></pre></td></tr></table></figure><ul><li><code>...</code> 表示可变参数.可变参数允许空参数</li><li><code>__VA_ARGS__</code> 在预处理中被实际的参数集替换</li></ul></li><li><p><code>#</code>: <strong>记号字符串化运算符</strong></p><ul><li><p>带参数的宏定义中,<code>#</code> 运算符后面应该跟一个参数</p></li><li><p><code>#argument</code> 会被预处理器翻译为字符串 <code>&quot;argument&quot;</code> </p></li><li><p>多个空白字符将被替换为一个空格</p></li><li><p><code>&quot;</code>将被替换为<code>\&quot;</code>,<code>\</code>将被替换为<code>\\</code>.即<code>&quot;</code> 和<code>\</code>被自动转义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT(FORMAT, VALUE) printf(<span class="hljs-string">&quot;The value of &quot;</span> #VALUE <span class="hljs-string">&quot; is &quot;</span> FORMAT <span class="hljs-string">&quot;\n&quot;</span>, VALUE)</span><br> <br>PRINT(<span class="hljs-string">&quot;%d&quot;</span>, x+<span class="hljs-number">3</span>);<br><span class="hljs-comment">/* 上面将会被替换为 printf(&quot;The value of x+3 is %d\n&quot;, x+3); */</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>##</code>: <strong>标记粘贴运算符</strong>: 将两侧的符号连接为一个符号.可用于宏定义中从分离的文本片段创建标识符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADD_TO_SUM(sum_number, value)\</span><br><span class="hljs-meta">   sum ## sum_number += value</span><br> <br>ADD_TO_SUM(<span class="hljs-number">5</span>,<span class="hljs-number">25</span>);<br><span class="hljs-comment">/* 上面将被替换为 sum5 += 25; */</span><br></code></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li><p><strong>宏定义中的空格不能忽视</strong></p></li><li><p><strong><code>#define</code> 定义的符号可以嵌套,但不能递归</strong></p></li><li><p>预处理在编译之前,因此编译器不会对宏定义进行语法检查</p></li><li><p>预处理器搜索 <code>#define</code> 定义的符号时不检查字符串常量的内容</p></li><li><p><strong>利用 C 语言 <code>临近字符串自动连接</code> 的特性, 可将宏参数插入字符串常量</strong></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT(FORMAT, VALUE)\</span><br><span class="hljs-meta">   printf(<span class="hljs-string">&quot;The value is &quot;</span> FORMAT <span class="hljs-string">&quot;\n&quot;</span>, VALUE)</span><br><br>PRINT(<span class="hljs-string">&quot;%d&quot;</span>, x+<span class="hljs-number">3</span>);<br><span class="hljs-comment">/* 上面将会被替换为 printf(&quot;The value is &quot; &quot;%d&quot; &quot;\n&quot;, x+3); */</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>宏不是语句.因此不需要分号</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> assert(e) ((void)(e) || _assert_error(__FILE__,__LINE__))</span><br></code></pre></td></tr></table></figure><ul><li><code>e</code>: 一个表达式. 当 <code>e==0</code> 时, <code>_assert_error(__FILE__,__LINE__)</code> 函数将被调用</li><li>由于 <code>||</code> 顺序求值.当  <code>e!=0</code>,右侧不会被计算</li></ul></li><li><p><strong>宏不是类型定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 宏常用于多个不同变量的类型在一处说明.修改变量类型时仅需修改宏定义.提高可移植性 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOOTYPE struct foo</span><br>FOOTYPE a,b;<br><br><span class="hljs-comment">/* 类型定义更加通用 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> <span class="hljs-title">FOOTYPE</span>;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>宏不是函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> abs(x) (((x) &gt;= 0) ? (x) : -(x))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(a,b) ((a) &gt; (b)) ? (a) : (b)</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>宏定义只会被机械地替换.括号是为了保证不会因运算优先级出错</strong></p></li><li><p>在带参数的宏定义中,若一个操作数在多处用到,则会被求值多次</p><ul><li>例如 <code>max</code> 中,若 <code>a[i] &gt; b</code>,则 <code>max(a[i++], b)</code> 被展开为<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">((a[i++]) &gt; (b)) ? (a[i++]) : (b)  <span class="hljs-comment">// 使得 i 自增2次</span><br></code></pre></td></tr></table></figure></li><li>解决方法: 确保宏中的参数没有副作用 或 使用函数的方法实现</li></ul></li><li><p>如果宏参数在定义中出现的次数超过1次,且具有副作用.则使用时可能出现危险</p></li><li><p>带副作用的操作符和函数:</p><ul><li><code>++, --</code> 运算符</li><li><code>getchar()</code> 函数</li></ul></li></ul></li><li><p>宏与函数</p><ul><li><p>函数调用有压栈,弹栈的额外开销</p></li><li><p>命名约定: 使用宏的语法和函数完全一致,为进行区别.<strong>宏名一般全大写</strong></p></li><li><p>函数只需出现在代码的某一处.而每个宏出现的地方都会被替换,导致代码变长</p></li><li><p><strong>函数声明时需要指出参数的类型,宏不用</strong></p></li><li><p><strong>函数无法传递将 <code>类型</code> 作为函数参数传递,宏可以</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MALLOC(n, type) ( (type *)malloc( (n) * sizeof(type) ) )</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-3-条件编译"><a href="#0-3-条件编译" class="headerlink" title="0.3 条件编译"></a>0.3 条件编译</h3><ol><li><p><strong>预处理指令</strong></p><table><thead><tr><th align="left">指令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">#define</td><td align="left">定义宏</td></tr><tr><td align="left">#include</td><td align="left">包含一个源代码文件</td></tr><tr><td align="left">#undef</td><td align="left">取消已定义的宏</td></tr><tr><td align="left">#ifdef</td><td align="left">如果宏已经定义返回真</td></tr><tr><td align="left">#ifndef</td><td align="left">如果宏没有定义返回真</td></tr><tr><td align="left">#if</td><td align="left">如果给定条件为真,则编译下面代码</td></tr><tr><td align="left">#else</td><td align="left">#if 的替代方案</td></tr><tr><td align="left">#elif</td><td align="left">如果 #if 的条件不为真,且当前条件为真.则编译下面代码</td></tr><tr><td align="left">#endif</td><td align="left">结束一个 <code>#if……#else</code> 条件编译块</td></tr><tr><td align="left">#error</td><td align="left">当遇到标准错误时,输出错误消息</td></tr><tr><td align="left">#pragma</td><td align="left">使用标准化方法,向编译器发布特殊的命令到编译器中</td></tr></tbody></table></li><li><p><strong>条件编译的常量表达式一般为字面值 ,或是一个由 <code>#define</code> 定义的符号.必须在程序执行前确定该值</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> constant-expression    <span class="hljs-comment">// 常量表达式,由预处理器进行求值</span></span><br>    statements             <span class="hljs-comment">// constant-expression 为真(非零),则 statements 被编译.否则删除</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> constant-expression  <span class="hljs-comment">// #elif 子句出现的次数不限</span></span><br>    other statements1      <span class="hljs-comment">// #elif 后面的语句,只有前面的所有常量表达式全为假时,才会被编译</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    other statements2      <span class="hljs-comment">// #else 后面的语句,只有前面的所有常量表达式全为假时,才会被编译</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>检查是否被定义的指令</strong>(<code>defined</code> 的作用在于可以使用 <code>&amp;&amp;, ||</code> 逻辑运算符对多个符号进行判断)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span>     defined(symbol)   <span class="hljs-comment">// 如果定义了符号 symbol ...</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  symbol            <span class="hljs-comment">// 如果定义了符号 symbol ...</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span>     !defined(symbol)  <span class="hljs-comment">// 如果未定义符号 symbol ...</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> symbol            <span class="hljs-comment">// 如果未定义符号 symbol ...</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>指令嵌套</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined( OS_UNIX )</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OPTION1</span><br>        unix_version_of_option1();<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* OPTION1 */</span></span><br>            <br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OPTION2</span><br>        unix_version_of_option2();<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* OPTION2 */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined( OS_MSDOS )</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OPTION2</span><br>        msdos_version_of_option2();<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* OPTION2 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* defined( OS_UNIX ) */</span></span><br></code></pre></td></tr></table></figure><ul><li><code>#endif</code> 语句后加上一条注释标签,帮助阅读</li><li>上述代码的用意为: 在不同的操作系统中根据选项决定使用不同的方案</li></ul></li></ol><h3 id="0-4-文件包含"><a href="#0-4-文件包含" class="headerlink" title="0.4 文件包含"></a>0.4 文件包含</h3><ol><li><p>头文件(约定后缀为 <code>.h</code>)中通常会包含以下内容</p><ul><li><p>明示常量, 宏函数, 函数声明, 结构体模板定义, 类型定义</p></li><li><p>在头文件中声明外部变量,可实现与其他文件共享变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> status = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 该变量声明于源代码文件中(.c),且具有文件作用域</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> status; <span class="hljs-comment">// 该语句声明于头文件中(.h).则包含了该头文件的代码均可访问 status 变量</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>#include</code> 指令</strong></p><ul><li>预处理器将会删除此指令,然后用包含的文件内容取代</li><li>当头文件被包含时,位于头文件内的所有内容都要被编译</li><li>每个头文件仅需包含一组函数 &#x2F; 数据的声明</li></ul></li><li><p><strong>包含库函数的头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filename.h&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li><code>filename</code> 命令并不存在限制.但约定标准库文件以 <code>.h</code> 结尾</li></ul></li><li><p><strong>包含本地文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;filename&quot;</span></span><br></code></pre></td></tr></table></figure><ul><li>处理方式: 先在源文件的当前位置查找,若没有,则用查找函数库头文件的方式查找</li></ul></li><li><p>避免文件重复包含</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __HEADER_NAME_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __HEADER_NAME_H__ 1</span><br><span class="hljs-comment">/* All the stuff that you want in the header file */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li><strong>使用条件编译可以避免多重包含</strong></li><li>当第一次包含该文件时, <code>#define __HEADER_NAME_H__ 1</code> 被执行,再次包含时将被忽略</li><li>定义可以省略<code>1</code>. 即: <code>#define __HEADER_NAME_H__ </code>.该符号被定义为一个空字符,也是被定义的</li></ul></li><li><p><strong><code>#error</code>: 生成错误信息</strong></p><ul><li><p>语法: <code>#error text of error message</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span>defined(OPTION_A)</span><br><span class="hljs-comment">/* stuff needed for option A */</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span>defined(OPTION_B)</span><br><span class="hljs-comment">/* stuff needed for option B */</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span>defined(OPTION_C)</span><br><span class="hljs-comment">/* stuff needed for option C */</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">error</span> NO option selected!</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>#line</code> 指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">line</span> number <span class="hljs-string">&quot;string&quot;</span></span><br></code></pre></td></tr></table></figure><ul><li>作用: 通知编译器 <code>number</code> 是下一行输入的行号.<code>&quot;string&quot;</code> 为可选部分.表示将其作为当前文件的名字</li><li><strong><code>#line</code> 将会修改 <code>__LINE__</code> 和 <code>__FILE__</code> 的值</strong></li><li>常用于将其他语言代码转化为 C代码的程序</li></ul></li><li><p>无效指令</p><ul><li>语法: 以 <code>#</code> 开头,但后面没有内容的行</li><li>处理方式: 被预处理器简单地删除</li><li>用法: 凸显某一行<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">#<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>#<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="0-5-词法分析"><a href="#0-5-词法分析" class="headerlink" title="0.5 词法分析"></a>0.5 词法分析</h3><ol><li><p><code>token</code>: 程序的一个基本组成单元</p></li><li><p>词法分析器: 编译器中负责将程序分解为一个一个符号的部分</p><ul><li>符号之间的空白(空格符,制表符,换行符)将会被忽略</li></ul></li><li><p>词法分析的贪心法</p><ul><li>C 语言分为单字符符号和多字符符号</li><li><strong>编译器在读取符号时的规则为: 每一个符号应包含尽可能多的字符</strong></li><li>编译器将程序分解为符号的方法: 从左往右读入字符,如果该字符可能成为一个符号,那么再读入下一个字符.判断已读入的2个字符是否可能组成一个符号,如果可能继续读入,重复步骤,直到不可能组成一个有意义的符号</li><li>除了字符串和字符常量,符号的中间不能嵌入空白(空格符,制表符,换行符)</li></ul></li></ol><h3 id="0-6-链接"><a href="#0-6-链接" class="headerlink" title="0.6 链接"></a>0.6 链接</h3><ol><li><p>编译与链接</p><ul><li><strong>C 程序可由多个部分分别编译组成,连接器可以将其合并成一个整体</strong></li><li>编译器一般只处理一个文件,因此无法检测出需要了解多个文件才能察觉的错误</li><li>连接器在许多系统独立于 C 语言实现,因而如果错误与 C 语言相关,连接器是无法察觉的</li></ul></li><li><p>链接器</p><ul><li><strong><code>分别编译</code>是 C 语言的一个重要思想: 多个源程序分别编译,在恰当的时候整合</strong></li><li>连接器并不需要理解 C 语言.它理解机器语言和内存布局.而编译器将源程序翻译给连接器</li><li>连接器读入目标模块,同时生成载入模块</li><li>对于目标模块的每个外部对象,连接器需要检查载入模块中是否有同名的外部对象<ul><li>若没有,则将该外部对象添加到载入模块</li><li>若有,则处理命名冲突</li></ul></li><li>除了外部对象,目标模块还可能包含对其他模块中外部对象的引用<ul><li>如调用了 <code>printf</code> 函数的程序,包含一个对 <code>printf</code> 函数的引用</li><li>该引用指向一个位于某个库文件中的外部对象</li></ul></li></ul></li><li><p><strong>声明与定义: 每个外部对象必须在程序的某个地方定义</strong></p><ul><li><p>将语句声明于函数外部</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a; <span class="hljs-comment">// 定义 a 成为一个外部整型变量,且会为 a 分配存储空间.默认初始化为0</span><br></code></pre></td></tr></table></figure></li><li><p>下面声明语句并非是对 a 的定义(但仍是外部变量)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> a; <span class="hljs-comment">// 连接器认为这是对外部变量 a 的引用,而非定义</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-数据"><a href="#1-数据" class="headerlink" title="1 数据"></a>1 数据</h2><h3 id="1-1-基本数据类型"><a href="#1-1-基本数据类型" class="headerlink" title="1.1 基本数据类型"></a>1.1 基本数据类型</h3><ol><li><p><strong>C 语言中的所有类型,要么是对象类型,要么是函数类型</strong></p><ul><li><strong>对象</strong>: 可以在其中表示值的一块存储区域(注意并非面向对象的对象)</li><li><strong>函数</strong>: 并非对象,且其类型由 返回值类型, 参数的数量, 类型 共同决定</li></ul></li><li><p>C 语言的5种基本数据类型</p><ul><li>整型(<code>short, int, long, long long</code>)</li><li>浮点型(<code>float, double, long double</code>)</li><li>字符型(<code>char</code>)</li><li>布尔型(<code>_Bool</code>)</li><li>枚举(<code>enum</code>)</li></ul></li><li><p><strong>C 语言并未给定 int 的具体尺寸为多少字节,只需满足: <code>short &lt;= int &lt;= long &lt;= long int</code></strong><br><strong>因此需要 sizeof 运算符获取数据类型或表达式的尺寸</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">sizeof</span>(type_name);<br><span class="hljs-keyword">sizeof</span>(object);<br><span class="hljs-keyword">sizeof</span> object;<br></code></pre></td></tr></table></figure></li><li><p>ANSI C规定的整型的最小范围</p><table><thead><tr><th align="left">类型</th><th align="left">最小值</th><th>最大值</th></tr></thead><tbody><tr><td align="left">char</td><td align="left">0</td><td>127</td></tr><tr><td align="left">signed char</td><td align="left">-127</td><td>127</td></tr><tr><td align="left">unsigned char</td><td align="left">0</td><td>255</td></tr><tr><td align="left">short</td><td align="left">-32767</td><td>32767</td></tr><tr><td align="left">unsigned short</td><td align="left">0</td><td>65535</td></tr><tr><td align="left">int</td><td align="left">-32767</td><td>32767</td></tr><tr><td align="left">unsigned int</td><td align="left">0</td><td>65535</td></tr><tr><td align="left">long</td><td align="left">-2147483647</td><td>2147483647</td></tr><tr><td align="left">unsigned long</td><td align="left">0</td><td>4294967259</td></tr></tbody></table></li><li><p><strong><code>&lt;limits.h&gt;</code> 中说明了不同整数 &#x2F; 浮点数类型的特点</strong></p><table><thead><tr><th align="center"></th><th align="center">signed</th><th align="center">signed</th><th align="center">unsigned</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">最小值</td><td align="center">最大值</td><td align="center">最大值</td></tr><tr><td align="center">字符</td><td align="center">SCHAR_MIN</td><td align="center">SCHAR_MAX</td><td align="center">USCHAR_MAX</td></tr><tr><td align="center">短整型</td><td align="center">SHRT_MIN</td><td align="center">SHRT_MAX</td><td align="center">USHRT_MAX</td></tr><tr><td align="center">整型</td><td align="center">INT_MIN</td><td align="center">INT_MAX</td><td align="center">UINT_MAX</td></tr><tr><td align="center">长整型</td><td align="center">LONG_MIN</td><td align="center">LONG_MAX</td><td align="center">ULONG_MAX</td></tr><tr><td align="center">单精度</td><td align="center">FLT_MIN</td><td align="center">FLT_MAX</td><td align="center">&#x2F;</td></tr><tr><td align="center">双精度</td><td align="center">DBL_MIN</td><td align="center">DBL_MAX</td><td align="center">&#x2F;</td></tr><tr><td align="center">扩展精度</td><td align="center">LDBL_MIN</td><td align="center">LDBL_MAX</td><td align="center">&#x2F;</td></tr></tbody></table></li><li><p><strong>默认的 <code>char</code> 并未规定是否有符号</strong></p><ul><li>使用 <code>char</code> 型变量时最好将其范围限制在 [0, 127]</li><li>当明确声明了 <code>char</code> 是否有符号后,才对其进行算数运算</li></ul></li><li><p>整型字面值</p><ul><li><p><strong>默认情况下的十进制字面值将被指定为最短的能容纳该值的类型</strong></p></li><li><p><strong>在字面值加上后缀可以指定其整型的类型</strong></p><ul><li><p>l &#x2F; L: long</p></li><li><p>u &#x2F; U: unsigned</p></li><li><p>上面的 u &#x2F; l 可以进行组合</p></li></ul></li><li><p>八进制表示方法: 在数值前加上 <code>0</code></p></li><li><p>十六进制表示方法: 在数值前加上 <code>0x</code></p></li><li><p><strong>字符常量: 单引号下的单个字符(也可以是转义字符或三字母词)</strong></p></li></ul></li><li><p>枚举类型: 其值为符号常量,而非字面值</p><ul><li><strong>枚举类型的变量其本质上是整型</strong></li><li>枚举声明中的符号名会被当作整型常量处理(从0开始,后面的值比前面大1)</li></ul></li><li><p>浮点类型</p><ul><li><strong>浮点数字面值在默认情况下为 <code>double</code> 类型.后缀为 l&#x2F;L 可指定其为 <code>float</code></strong></li><li>所有浮点类型必须可以容纳 $10^{-37}\sim 10^{37}$ 间的任意值</li></ul></li></ol><h3 id="1-2-变量"><a href="#1-2-变量" class="headerlink" title="1.2 变量"></a>1.2 变量</h3><ol><li><p>变量和常量是程序处理的两种基本数据类型</p><ul><li>通常待处理的数据会被置于内存中</li><li>存放数据的位置即是一个地址,CPU 可以通过地址找到该数据</li></ul></li><li><p><strong>变量命名规则</strong></p><ul><li>只能由英文字母(<code>_</code> 也视为字母)和数字组成</li><li>英文字母开头</li><li>区分大小写</li><li>不能使用关键字</li></ul></li><li><p><strong>ANSI C 有32个关键字</strong></p><table><thead><tr><th>auto</th><th>break</th><th>case</th><th>char</th><th>const</th><th>continue</th><th>default</th><th>do</th></tr></thead><tbody><tr><td>double</td><td>else</td><td>enum</td><td>extern</td><td>float</td><td>for</td><td>goto</td><td>if</td></tr><tr><td>int</td><td>long</td><td>register</td><td>return</td><td>short</td><td>signed</td><td>sizeof</td><td>static</td></tr><tr><td>struct</td><td>switch</td><td>typedef</td><td>union</td><td>unsigned</td><td>void</td><td>volatile</td><td>while</td></tr></tbody></table><ul><li>C99 标准新增5个关键字: <code>inline, restrict, _Bool, _Complex, _Imaginary</code></li><li>C11 标准新增7个关键字: <code>_Alignas, _Alignof, _Atomic, _Static_assert, _Noreturn, _Thread_local, _Generic</code></li></ul></li><li><p>局部变量</p><ul><li><code>for</code> 语句中的初始化语句定义的是局部变量,仅适用于复合语句内部</li><li><strong>一个函数定义的变量无法在另一个函数中访问</strong></li><li>C 语言允许随处定义变量</li></ul></li><li><p>全局变量</p><ul><li><strong>定义于函数之外的即为全局变量.会自动初始化为 0</strong></li><li>函数内部存在同名全局变量和局部变量时,会屏蔽掉全局变量</li></ul></li><li><p>减少全局变量的使用</p><ul><li>全局在程序退出是才会被释放.导致占用更多内存</li><li>使用全局变量将导致: 命名空间污染, 耦合性提高</li></ul></li><li><p>C 语言的变量有用两种生存期: 静态存储期和自动存储期</p><ul><li><strong>静态存储期:</strong> 程序执行时一直占据存储空间,程序关闭才释放.如: 具有文件作用域的变量,函数名</li><li><strong>自动存储期</strong>: 代码块结束时自动释放存储空间.如: 具有代码块作用域的变量</li></ul></li><li><p>寄存器变量</p><ul><li>寄存器存在于 CPU 内部,CPU 对寄存器的读取和存储几乎没有延时</li><li><code>register</code> 关键字: 声明寄存器变量(实际很少用到)</li><li><code>register</code> 在编译器看来只是一个建议,编译器会考虑是否将其放入寄存器</li></ul></li><li><p>静态局部变量</p><ul><li><strong><code>static</code> 关键字: 用于声明局部变量时,将局部变量设为静态存储期,与全局变量一致</strong></li><li><strong>静态局部变量仅会被初始化一次</strong></li><li><strong>静态局部变量仍为局部变量,无法在别的函数中直接访问</strong></li></ul></li></ol><h3 id="1-3-常量"><a href="#1-3-常量" class="headerlink" title="1.3 常量"></a>1.3 常量</h3><ol><li><p>基本数据类型中的数据类型可作为常量.常用的还有字符串常量和符号常量</p><ul><li><p><strong>字符串常量: C 语言没有单独的字符串类型,采取字符数组的方式定义字符串</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> 变量名[字符数量];<br><span class="hljs-type">char</span> name[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br><span class="hljs-type">char</span> name[] = <span class="hljs-string">&quot;ys&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><p>C 语言约定用转义字符 <code>&#39;\0&#39;</code> (空字符)表示字符串的结束位置当系统读取到该转义字符时,说明字符串结束</p></li><li><p>以数组形式初始化时,需要给结尾的 <code>&#39;\0&#39;</code> 留出位置</p></li><li><p>使用字符串常量初始化并赋值时,编译器会自动在末尾补上 <code>&#39;\0&#39;</code></p></li></ul></li><li><p><strong>符号常量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> 标识符 常量</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> YEAR 2023</span><br></code></pre></td></tr></table></figure></li><li><p>转义字符</p><table><thead><tr><th>转义字符</th><th>含义</th><th>转义字符</th><th>含义</th></tr></thead><tbody><tr><td><code>\a</code></td><td>响铃(BEL)</td><td><code>\\</code></td><td>\</td></tr><tr><td><code>\b</code></td><td>退格(BS)</td><td><code>\&#39;</code></td><td>‘</td></tr><tr><td><code>\f</code></td><td>换页(FF)</td><td><code>\&quot;</code></td><td>“</td></tr><tr><td><code>\n</code></td><td>换行(LF)</td><td><code>\?</code></td><td>?</td></tr><tr><td><code>\r</code></td><td>回车(CR)</td><td><code>\0</code></td><td>NULL</td></tr><tr><td><code>\t</code></td><td>水平制表(HT)</td><td><code>\ddd</code></td><td>八进制值</td></tr><tr><td><code>\v</code></td><td>垂直制表(VT)</td><td><code>\xhh</code></td><td>十六进制值</td></tr></tbody></table></li></ul></li><li><p><strong><code>const</code> 关键字用来声明常量.常量与变量的区别仅在于其值是只读的</strong></p><ul><li><code>int const a;</code> 与 <code>const int a;</code> 声明方式变量时的效果完全相同</li><li>由于常量的值不可修改.因此声明时一般要进行初始化</li><li>作为形参的常量在函数被调用时会得到实参的值</li></ul></li><li><p><code>const</code> 与指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-type">const</span> *pci;      <span class="hljs-comment">// pci 指向一个整型常量</span><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> pci;      <span class="hljs-comment">// pci 指向一个整型变量,指向不可修改</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *<span class="hljs-type">const</span> pci <span class="hljs-comment">// pci 指向一个整型常量,且指向不可修改</span><br></code></pre></td></tr></table></figure></li><li><p><code>const</code> 与 <code>#define</code></p><ul><li><code>const</code> 只能使用于可以出现变量的地方</li><li><code>#define</code> 可以创建名字常量.只要字面值可以出现的地方均可使用</li></ul></li><li><p>变量初始化</p><ul><li>在程序链接时,静态变量存储位置被指定<ul><li><strong>因此若静态变量未显式地初始化,则会被初始化为0.且初始化只会进行一次</strong></li></ul></li><li>自动变量在链接时其存储位置无法判断.因此自动变量没有缺省的初始值.对其初始化会包含一条隐式的赋值语句<ul><li>对自动变量的初始化 相比于赋值语句效率不会提高(除非声明为 <code>const</code> 变量)</li><li>隐式的赋值语句会使得自动变量每次执行到它们的时候都会重新初始化</li><li>由于初始化在运行时执行,因此可以用任何表达式作为初始值</li><li><strong>若自动变量创建而未初始化时,则其值没有意义</strong></li></ul></li></ul></li></ol><h3 id="1-4-运算符"><a href="#1-4-运算符" class="headerlink" title="1.4 运算符"></a>1.4 运算符</h3><ol><li><p>使用括号可以完全避免因不清楚运算符优先级导致的问题.但括号太多反而会不好理解</p><table><thead><tr><th>优先级</th><th>运算符</th><th>结合律</th></tr></thead><tbody><tr><td>0</td><td>强制分组: <code>()</code></td><td>—&gt;</td></tr><tr><td>1</td><td>后缀运算符: <code>[]  ()  .  -&gt;</code></td><td>—&gt;</td></tr><tr><td>2</td><td>一元运算符: <code>++ -- ! ~ +  - * &amp; (type) sizeof _Alignof</code></td><td><strong>&lt;—</strong></td></tr><tr><td>3</td><td>乘除法运算符: <code>*  /  %</code></td><td>—&gt;</td></tr><tr><td>4</td><td>加减法运算符: <code>+  -</code></td><td>—&gt;</td></tr><tr><td>5</td><td>移位运算符: <code>&lt;&lt;  &gt;&gt;</code></td><td>—&gt;</td></tr><tr><td>6</td><td>关系运算符: <code>&lt;  &lt;=  &gt;  &gt;=</code></td><td>—&gt;</td></tr><tr><td>7</td><td>相等运算符: <code>==  !=</code></td><td>—&gt;</td></tr><tr><td>8</td><td>位运算符 AND: <code>&amp;</code></td><td>—&gt;</td></tr><tr><td>9</td><td>位运算符 XOR: <code>^</code></td><td>—&gt;</td></tr><tr><td>10</td><td>位运算符 OR: |</td><td>—&gt;</td></tr><tr><td>11</td><td>逻辑运算符 AND: <code>&amp;&amp;</code></td><td>—&gt;</td></tr><tr><td>12</td><td>逻辑运算符 OR: ||</td><td>—&gt;</td></tr><tr><td>13</td><td>条件运算符: <code>? :</code></td><td><strong>&lt;—</strong></td></tr><tr><td>14</td><td>赋值运算符: &#96;&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &amp;&#x3D; ^&#x3D;</td><td>&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D;&#96;</td></tr><tr><td>15</td><td>逗号运算符: <code>,</code></td><td>—&gt;</td></tr></tbody></table></li><li><p>单目运算符</p><ul><li><strong>单目运算符的优先级仅低于后缀运算符</strong></li><li>结合顺序为从右到左.即 <code>*p++</code> 会被认为是 <code>*(p++)</code></li></ul></li><li><p>双目运算符</p><ul><li><p>算术  –&gt;  移位  –&gt;  关系  –&gt;  位  –&gt;  逻辑(<strong>算移关位逻</strong>)</p></li><li><p>关系运算符中: 比较  –&gt; 判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 判断 a,b 的相对大小是否和 c,d 相同</span><br>a &lt; b == c &lt; d<br></code></pre></td></tr></table></figure></li><li><p>位运算符优先级: <code>~  --&gt;  &amp;  --&gt;  ^  --&gt;  |</code> (<strong>反,与,异,或</strong>)</p></li><li><p>逻辑运算符优先级: <code>!  --&gt;  &amp;&amp;  --&gt;  ||</code> (<strong>非与或</strong>)</p></li></ul></li><li><p>三目运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">taxRate = income &gt; <span class="hljs-number">40000</span> &amp;&amp; residence &lt; <span class="hljs-number">5</span> ? <span class="hljs-number">3.5</span> : <span class="hljs-number">2.0</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>三目运算符优先级低于: 算术, 移位, 关系, 位, 逻辑运算符.因而允许在条件表达式中包括关系运算符的逻辑组合</strong></li><li>三目运算符优先级高于: 赋值运算符.因而可以最后进行赋值操作</li></ul></li><li><p>逗号运算符</p><ul><li>优先级最低,其结果为最后一个表达式的值</li><li>在宏定义中作用明显</li></ul></li><li><p><strong>C 语言采用短路求值: 当前一个运算数的无法确定逻辑运算的结果时,才会对第二个运算数求值.</strong><br>换言之,如果第一个运算数已经可以确实整个逻辑运算的结果,后一个运算数便不会计算</p></li></ol><h3 id="1-5-作用域"><a href="#1-5-作用域" class="headerlink" title="1.5 作用域"></a>1.5 作用域</h3><ol><li>对象, 函数, 宏, 标识符均有作用域(scope)<ul><li>标识符的作用域: 程序中该标识符可以被使用的区域</li><li><strong>C 语言提供的作用域: 文件, 块, 函数原型, 函数</strong></li><li>对象, 函数, 标识符的作用域由其声明位置决定</li></ul></li><li><strong>文件作用域</strong><ul><li>位于代码块之外的标识符具有文件作用域</li><li>从声明到源文件结尾均可被访问</li><li>函数名具有文件作用域</li></ul></li><li><strong>代码块作用域</strong><ul><li>代码块: 位于一对 <code>&#123;&#125;</code> 之间的所有语句</li><li>代码块中标识符具有代码块作用域</li><li>代码块嵌套时,外层无法用名字访问内层的标识符.如果内层有同名标识符,外层的将会被屏蔽</li></ul></li><li><strong>原型作用域</strong><ul><li>仅适用于函数原型中的参数名</li><li>函数参数名不是必需的,也不用与函数定义的形参名匹配</li></ul></li><li><strong>函数作用域</strong><ul><li>仅适用于语句标签.即 <code>label</code> 语句</li><li>一个函数中所有语句标签必须唯一</li><li>作用: 将标签限制在同一函数内部,防止标签重名</li></ul></li></ol><h3 id="1-6-存储期"><a href="#1-6-存储期" class="headerlink" title="1.6 存储期"></a>1.6 存储期</h3><ol><li><strong>对象的存储期决定其生命周期.分为: 自动, 静态, 线程, 分配</strong></li><li><strong>自动存储期</strong><ul><li>自动存储期对象将在语句块执行结束时被释放</li><li>在语句块或作为函数参数声明的对象将会具有自动存储期</li></ul></li><li><strong>静态存储期</strong><ul><li>静态存储期对象在程序整个执行期间都有效</li><li>文件作用域中声明的对象将会具有静态存储期</li><li><code>static</code> 可将具有自动存储期的变量(位于代码块中)改为静态存储期</li></ul></li><li><strong>分配存储期</strong><ul><li>动态分配内存具有分配存储期.从分配开始,直到释放结束</li><li>动态分配的内存取自堆(heap).由内存管理器管理</li><li>内存管理器负责分配内存和释放内存.分配后由调用者管理内存</li></ul></li><li><strong>线程存储期</strong>(C11 引入)<ul><li>使用<code>_Thread_local</code>关键字声明线程局部变量</li><li>线程局部变量的地址在不同线程中是不同的,在每个线程中都有一份独立的实例</li><li>线程局部变量的析构在线程退出时进行</li></ul></li></ol><h3 id="1-7-链接属性"><a href="#1-7-链接属性" class="headerlink" title="1.7 链接属性"></a>1.7 链接属性</h3><ol><li><p>标识符的链接属性决定如何处理在不同文件中出现的标识符</p><ul><li>外部(<code>external</code>): 无论在哪个源文件,声明多少次.均当作同一实体</li><li>内部(<code>internal</code>): 在同一源文件中被当作同一实体,不同源文件则被看作不同实体</li><li>无(<code>none</code>): 总是被当作不同的独立个体</li><li><strong>具有文件作用域的标识符缺省的链接属性为: <code>external</code></strong></li><li><strong>具有代码块作用域的标识符缺省的链接属性为: <code>none</code></strong></li></ul></li><li><p>修改链接属性</p><ul><li><code>static</code>: 将链接属性为 <code>external</code> 的标识符(位于代码块外)改为 <code>internal</code><ul><li>可用于限制全局变量只能在单个源文件内部访问</li><li>可用于限制内部函数不被其他源文件调用</li></ul></li><li><code>extern</code>: 将链接属性为 <code>none</code> 的变量改为 <code>external</code><ul><li>可用于访问其他文件中的链接属性为 <code>external</code> 的变量</li></ul></li></ul></li><li><p><strong>作用域, 链接属性, 存储类型的总结</strong></p><table><thead><tr><th>变量类型</th><th>声明的位置</th><th>是否存在于堆栈</th><th>作用域</th><th>加上 static</th></tr></thead><tbody><tr><td>全局</td><td>代码块外</td><td>否</td><td>文件作用域</td><td>不允许其他源文件访问</td></tr><tr><td>局部</td><td>代码块内</td><td>是</td><td>代码块作用域</td><td>静态变量</td></tr><tr><td>形参</td><td>函数头部</td><td>是</td><td>函数作用域</td><td>&#x2F;</td></tr></tbody></table></li><li><p>存储类别</p><table><thead><tr><th>存储类别</th><th>存储期</th><th>作用域</th><th>链接</th><th>声明方式</th></tr></thead><tbody><tr><td>自动</td><td>自动</td><td>块</td><td>无</td><td>块内</td></tr><tr><td>寄存器</td><td>自动</td><td>块</td><td>无</td><td>块内, <code>register</code></td></tr><tr><td>静态外部链接</td><td>静态</td><td>文件</td><td>外部</td><td>所有函数外</td></tr><tr><td>静态内部链接</td><td>静态</td><td>文件</td><td>内部</td><td>所有函数外, <code>static</code></td></tr><tr><td>静态无链接</td><td>静态</td><td>块</td><td>无</td><td>块内, <code>static</code></td></tr></tbody></table></li></ol><h2 id="2-控制流"><a href="#2-控制流" class="headerlink" title="2 控制流"></a>2 控制流</h2><h3 id="2-1-分支"><a href="#2-1-分支" class="headerlink" title="2.1 分支"></a>2.1 分支</h3><ol><li><p><code>if</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (expression_1) &#123;<br>    code block <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expression_2) &#123;<br>    code block <span class="hljs-number">2</span>;<br>&#125;<br>...<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expression_n) &#123;<br>    code block n;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    code blcok;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>else if, else</code> 语句是可选的</li><li><strong><code>else</code> 只会和最近的 <code>if</code> 匹配,而与缩进无关</strong></li></ul></li><li><p><code>switch</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (expression) &#123;<br><span class="hljs-keyword">case</span> constant_expression_1:<br>    code block <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> constant_expression_2:<br>    code block <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">break</span>;<br>...<br><span class="hljs-keyword">case</span> constant_expression_n:<br>    code block n;<br>    <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>    code block;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>break</code> 语句是可选的,若没有 <code>break</code>,将发生 <code>break</code> 穿透</strong></li><li><strong><code>default</code> 语句是可选的,用于处理没有成功匹配的情况</strong></li></ul></li></ol><h3 id="2-2-循环"><a href="#2-2-循环" class="headerlink" title="2.2 循环"></a>2.2 循环</h3><ol><li><p><code>while</code>: 先计算表达式,若为真则执行循环体中的代码. 重复该步骤,直到条件表达式为假</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (expression) &#123;<br>    code block;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>do-while</code>: 先执行一次循环体中的代码,然后计算表达式,若为真则循环再次执行语句.重复该步骤,直到条件表达式为假</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br>    code block;<br>&#125; <span class="hljs-keyword">while</span> (expression);<br></code></pre></td></tr></table></figure></li><li><p><code>for</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(initialize; expression; adjust) &#123;<br>    code block;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>开始时,先进行一次初始化 -&gt; 判断循环条件 -&gt; 执行循环体 -&gt; 进行调整. 重复该步骤,直到循环条件为假</li><li><code>for</code> 语句的每一部分都是可选的<ul><li>初始化: 可在外部进行</li><li>循环条件: 省略后将默认为真(死循环)</li><li>调整: 也可在内部语句进行</li></ul></li><li><strong><code>for</code> 是 <code>while</code> 的语法糖,优点在于将决定迭代的条件整合到了一起</strong></li></ul></li><li><p><code>goto</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">goto</span> lable;<br>lable: 语句<br></code></pre></td></tr></table></figure><ul><li><code>:</code> 表示这里有一个标记</li><li><code>label</code> 可以是任何除 C 关键字以外的纯文本.设置在 <code>goto</code> 语句的前后均可</li><li><strong><code>goto</code> 关键字是不被推荐的实践,最好只用于在同一函数内使用</strong></li><li>可用于跳出多层循环, 或者 资源管理</li></ul></li><li><p><code>break</code>: 跳出本层循环</p></li><li><p><code>continue</code>: 跳过本轮循环,进入下一轮</p></li></ol><h3 id="2-3-函数"><a href="#2-3-函数" class="headerlink" title="2.3 函数"></a>2.3 函数</h3><ol><li><p>函数的定义方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">类型名 函数名(参数列表) &#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数的声明方式: 去掉函数体,加上分号即为声明语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">类型名 函数名(参数列表);<br></code></pre></td></tr></table></figure></li><li><p>函数的类型</p><ul><li><strong>任何一个 C 函数都有返回类型: <code>void</code> 或函数生成结果的类型</strong><ul><li>若函数在调用它的文件中,第一次调用之前进行了声明或定义.则其返回值类型是非常明确的</li><li><strong>若函数在被声明或定义之前被调用,则返回类型默认为 <code>int</code></strong></li><li>若需要调用另一文件中的函数,则应在调用它的文件中对其进行声明</li></ul></li><li>形参和实参的匹配<ul><li><strong>ANSI C 允许声明时指定函数的类型</strong></li><li>函数声明中可以省略参数类型的说明,而函数定义中不能省略</li></ul></li></ul></li><li><p><code>main</code> 函数和其他函数一样,如果未显示声明返回类型,则默认返回整型</p><ul><li>C 语言通过 <code>main</code> 函数的返回值告知系统是否执行成功(0 表示成功, 非0表示失败)</li></ul></li><li><p>参数的传递</p><ul><li><strong>C 语言是按值调用的(call-by-value),也称按值传递(pass-by-value)</strong></li><li><strong>形参(parameter)</strong>: 函数定义时的参数.仅在函数被调用时分配内存,调用结束后立即释放</li><li><strong>实参(argument)</strong>: 真实传递给函数的值.这种传值方式具有单向性</li><li>传址: 如果形参是指针,那么可以通过间接的方式修改地址存储的值</li><li>传数组: 本质上是传递数组首元素的地址</li></ul></li><li><p><strong>可变参数函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span>                <span class="hljs-comment">// 可变参数需要的头文件</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n, ...)</span> &#123;              <span class="hljs-comment">// ... 是占位符,表明参数个数不确定</span><br>    <span class="hljs-type">int</span> i, sum = <span class="hljs-number">0</span>;<br>    va_list vap;                   <span class="hljs-comment">// 定义参数列表</span><br>    va_start(vap, n);              <span class="hljs-comment">// 初始化参数列表, n 是第一个参数的名称</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        sum += va_arg(vap, <span class="hljs-type">int</span>);   <span class="hljs-comment">// 获取参数值, int 表示参数类型</span><br>    &#125;                              <span class="hljs-comment">// va_arg() 调用后, vap 自动指向下一个参数</span><br>    va_end(vap);                   <span class="hljs-comment">// 关闭参数列表</span><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>内联函数: 编译器像处理宏定义的方式,将整个内联函数直接在被调用处中展开</p><ul><li>内联函数的定义方式: 在函数定义的头前加上关键字 <code>inline</code></li><li>使用内联函数会导致代码编译的时间增加,但节省函数调用的时间消耗</li><li><strong>编译器会自动将一些常用的函数优化为内联函数</strong></li></ul></li></ol><h2 id="3-指针"><a href="#3-指针" class="headerlink" title="3 指针"></a>3 指针</h2><h3 id="3-1-指针与变量"><a href="#3-1-指针与变量" class="headerlink" title="3.1 指针与变量"></a>3.1 指针与变量</h3><ol><li><p><strong>指针就是内存地址. 而指针变量是: 存放内存地址的变量</strong></p></li><li><p>定义指针变量的方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">类型名 *指针变量名<br><span class="hljs-type">int</span> *pa<br></code></pre></td></tr></table></figure><ul><li>类型名: 指明对指针变量解引用(<code>*</code>)后得到的数据类型</li></ul></li><li><p><code>void</code> 指针</p><ul><li><strong><code>void</code> 指针称为通用指针,可以指向任意类型的数据</strong><ul><li>不要对 <code>void</code> 指针解引用</li><li>任何类型的指针均可转换为 <code>void</code> 指针,而再转换回来需要强制类型转换</li></ul></li></ul></li><li><p><code>NULL</code> 指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL ((void *)0)</span><br></code></pre></td></tr></table></figure><ul><li><code>(void *)</code>: 强制类型转换,将地址 0 强转为 <code>void</code> 指针<ul><li><strong>由于地址 0 通常不被使用,因此,<code>NULL</code> 是一个空指针,即不指向任何东西</strong></li><li>为防止解引用未初始化的指针,经常将其初始化为 <code>NULL</code></li><li>解引用 <code>NULL</code> 会直接使得程序崩溃.因此,在解引用指针时,应先判断是否为 <code>NULL</code></li></ul></li></ul></li><li><p>指针的运算</p><ul><li><strong>加减: 相当于将指针的位置移动相应的位置.即 <code>p+1</code> 表示指向 <code>p</code> 的下一个元素</strong></li><li>比较: 运用关系运算符进行比较时,可判断指针指向的前后关系</li></ul></li><li><p><code>*</code> 运算符</p><ul><li>在定义指针变量时,用于声明是指针</li><li>在对指针进行取值操作时,获取指针指向元素的值</li><li>定义指针和取值操作是不同的,属于符号的重用</li></ul></li><li><p><code>&amp;</code> 取址运算符: 对变量进行取址操作,获得变量的地址</p></li></ol><h3 id="3-2-指针与函数"><a href="#3-2-指针与函数" class="headerlink" title="3.2 指针与函数"></a>3.2 指针与函数</h3><ol><li><p>指针函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *<span class="hljs-title function_">fp</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// fp 是指针函数</span><br></code></pre></td></tr></table></figure><ul><li><strong>函数的类型由返回值决定.当函数返回值为指针类型时,函数即为指针函数</strong></li><li>指针函数的定义方式类似于定义指针: 在类型后面加上一个 <code>*</code></li><li><strong>不要返回局部变量的地址.因为局部变量仅存在于函数内部</strong></li></ul></li><li><p>函数指针(它是一个指针,指向函数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>);  <span class="hljs-comment">// fp 是函数指针</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>;  <span class="hljs-comment">// fun 是一个函数名,本质也是一个指针</span><br><br>fp = func;           <span class="hljs-comment">// 对函数指针的赋值方式.类型匹配可直接赋值</span><br>result = (*fp)(num); <span class="hljs-comment">// K&amp;R C 的调用方式.从声明形式的等价得出</span><br>result = fp(num);    <span class="hljs-comment">// UNIX 推广者的调用方式.从赋值语句的等价得出</span><br></code></pre></td></tr></table></figure><ul><li><p>函数名 <code>func</code> 是函数的首地址,类型为 <code>int (*)(int)</code></p></li><li><p><strong>对于函数名而言: 它本身是一个指针,且对其取值或取址的值仍是其本身</strong></p></li></ul></li><li><p>函数指针作为参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>), <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>; <span class="hljs-comment">// 第一个参数为函数指针</span><br><br><span class="hljs-comment">/* 函数名 add 作为实参传入 calc 函数.形参为 fp,是一个函数指针 */</span><br>result = calc(add, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure></li><li><p>函数指针作为返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>), <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><br><span class="hljs-comment">/* select 是一个函数.其参数为 char op.</span><br><span class="hljs-comment">** 返回值为一个函数指针.指向的函数类型为 int (*)(int, int) */</span><br><span class="hljs-type">int</span> (*select(<span class="hljs-type">char</span> op))(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><ul><li><code>select</code> 先与 <code>(char op)</code> 结合,成为一个函数,参数为 <code>char op</code></li><li>去掉 <code>*select(char op)</code> 后,剩余 <code>int (*)(int, int)</code> 成为 <code>select</code> 的返回值</li></ul></li></ol><h3 id="3-3-一维数组"><a href="#3-3-一维数组" class="headerlink" title="3.3 一维数组"></a>3.3 一维数组</h3><ol><li><p>声明方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">数据类型 数组名[数量];<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];  <span class="hljs-comment">// 数组下标索引从 0 开始</span><br></code></pre></td></tr></table></figure><ul><li><code>[]</code>: 后缀运算符,表示声明的对象是数组</li><li>数据类型: 指明当对数组中的元素进行访问时得到的数据类型</li><li>数量: 编译器需要根据 <code>数组类型和数量</code> 确定要分配的内存大小</li><li><strong>数组名: 其本质上是一个常量指针,其值为数组首元素的地址</strong></li></ul></li><li><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>若仅给部分元素进行初始化,则其他元素自动初始化为 0</strong></li><li>若省略数组长度,则将由编译器自行计算数组长度</li></ul></li><li><p>对于一个数组,需要的的数据为: 指向首个元素的指针 和 数组长度</p><ul><li>任何关于数组的操作,实际上均通过指针进行</li><li>任何一个数组下标运算等同于一个对应指针运算</li></ul></li><li><p><strong>访问数组元素: 数组名本质上是常量指针,指向数组的首个元素</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">arr[<span class="hljs-number">1</span>]; <span class="hljs-comment">// arr[1] 被计算为 *(arr+1)</span><br></code></pre></td></tr></table></figure></li><li><p>获取数组长度(数组名只有在作为 <code>sizeof</code> 运算符的参数时是数组)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> length = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);             <span class="hljs-comment">// 获取 arr 长度</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0])) <span class="hljs-comment">// 宏实现</span></span><br></code></pre></td></tr></table></figure></li><li><p>遍历数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;arr[%d]: %d\n&quot;</span>, i, arr[i]);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可变长数组: 可以用变量指定数组的维度</p><ul><li>C99 标准前,定义数组时,数组的长度必须为常量表达式或 <code>const</code> 常量</li><li><strong>C99 开始支持可变长数组.即数组的长度在程序运行时才决定.但完成定义后仍不能修改长度</strong></li></ul></li></ol><h3 id="3-4-二维数组"><a href="#3-4-二维数组" class="headerlink" title="3.4 二维数组"></a>3.4 二维数组</h3><ol><li><p>定义二维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">数据类型 数组名[行数][列数];<br><span class="hljs-type">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><ul><li><strong>二维数组在内存中线性存储</strong></li><li>根据后缀运算符的结合性分析<ul><li>从左到右,<code>a</code> 与 <code>[4]</code> 结合.因而 <code>a</code> 是一个拥有4个元素的数组</li><li><code>a[4]</code> 与 <code>[5]</code> 结合.因而 <code>a[4]</code> 的每个元素都是一个拥有5个元素的一维数组</li></ul></li></ul></li><li><p>初始化二维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 根据 线性存放特性 进行初始化 */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;;<br><br><span class="hljs-comment">/* 根据 二维数组本质上是数组的数组特性 进行初始化 */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>    &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;,<br>    &#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;<br>&#125;;<br><span class="hljs-comment">/* 部分值初始化 */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;&#123;<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>&#125;&#125;;<br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;<br><span class="hljs-comment">/* 指定元素初始化(C99) */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, [<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>, [<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>&#125;;<br><span class="hljs-comment">/* 第一个维度元素可不写,交由编译器计算 */</span><br><span class="hljs-type">int</span> a[][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>访问二维数组元素</p><ul><li><strong>数组名被理解为常量指针,而二维数组又是数组的数组</strong></li><li><strong>因而,<code>a[3][4]</code> 将被计算为 <code>*(*(a+3)+4)</code></strong></li></ul></li><li><p>遍历二维数组: 采用嵌套循环的方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; column; ++j) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;arr[%d][%d]: %d\n&quot;</span>, row, column, arr[row][column]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多维数组: 形式上与二维数组类似,仅需在定义时增加下标数量</p></li></ol><h3 id="3-5-指针的组合"><a href="#3-5-指针的组合" class="headerlink" title="3.5 指针的组合"></a>3.5 指针的组合</h3><ol><li><p><strong>二级指针(指针在定义就表明了如何解引用.定义时用到了多少 <code>*</code>,得到值就需要多少 <code>*</code>)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">520</span>;  <span class="hljs-comment">// int 类型变量</span><br><span class="hljs-type">int</span> *p = &amp;num;  <span class="hljs-comment">// int * 类型指针</span><br><span class="hljs-type">int</span> **pp = &amp;p;  <span class="hljs-comment">// int ** 类型的二级指针</span><br></code></pre></td></tr></table></figure></li><li><p>指针数组 和 二级指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *book[] = &#123;<br>    <span class="hljs-string">&quot;C 程序设计语言&quot;</span>,<br>    <span class="hljs-string">&quot;C 专家编程&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>book</code> 是指针数组,每个元素都是指针(字符串).现想要管理每个元素(字符串)</p></li><li><p>建立一个新数组,其中的每个元素都是指针,它们指向需要操作的对象(字符串).即:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> **cbook[<span class="hljs-number">2</span>];<br>cbook[<span class="hljs-number">0</span>] = &amp;book[<span class="hljs-number">0</span>];<br>cbook[<span class="hljs-number">1</span>] = &amp;book[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure></li></ul></li><li><p>指向常量的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> cnum = <span class="hljs-number">520</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;cnum;<br></code></pre></td></tr></table></figure><ul><li>指针可以指向被 <code>const</code> 修饰的变量,不能通过指针修改其值.指针指向可改变</li><li><code>const int</code> 表示指向的是一个整型常量</li></ul></li><li><p><strong>常量指针: 指向的是一个变量,其值可以修改,但指针指向不允许修改</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">520</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p = &amp;num;  <span class="hljs-comment">// const p 表示指针 p 是一个常量</span><br></code></pre></td></tr></table></figure></li><li><p>指向常量的常量指针: 指针自身不允许修改,其指向的值也不允许修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> cnum = <span class="hljs-number">520</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p = &amp;cnum;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-复合数据"><a href="#4-复合数据" class="headerlink" title="4 复合数据"></a>4 复合数据</h2><h3 id="4-1-结构体"><a href="#4-1-结构体" class="headerlink" title="4.1 结构体"></a>4.1 结构体</h3><ol><li><p>结构体定义方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名称 &#123;</span><br>    结构体成员<span class="hljs-number">1</span>;<br>    结构体成员<span class="hljs-number">2</span>;<br>    ...<br>    结构体成员n;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>关键字 <code>struct</code> 是必要的,结构体的声明需要分号</li><li><strong>结构体名称约定第一个字符使用大写</strong></li></ul></li><li><p>结构体声明方式(关键字 <code>struct</code> 是必要的)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名称 结构体变量名;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>访问结构体成员: 使用 <code>.</code> 运算符访问结构体变量</strong></p></li><li><p>初始化结构体</p><ul><li>在定义时即可对其初始化.形式与初始化数组一样:<br>用大括号包含所有成员值,逗号作为分隔符.此时需要将各个成员类型对号入座</li><li>C99 新增特性可以在初始化时指定成员值</li><li>数组初始化时指定成员方式为 <code>[下标]</code>.对应的,结构体初始化时使用 <code>.成员名</code> 的方式指定成员值</li><li><strong>未初始化的成员将被自动初始化.数值型初始化为 0 ,字符型初始化为 <code>&#39;\0&#39;</code></strong></li></ul></li><li><p><strong>编译器会对结构体的成员进行内存对齐.让 CPU 可以更快地读取 &#x2F; 处理数据</strong></p></li><li><p>结构体嵌套后仍使用 <code>.</code> 运算符访问结构体变量.只不过要用多次 <code>.</code> 运算符一直找到最底层的成员</p></li><li><p>结构体与数组</p><ul><li><p>结构体数组仍是数组,其成员为结构体类型的数据</p></li><li><p>结构体数组的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名称 数组名[长度];</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="4-2-结构体与指针"><a href="#4-2-结构体与指针" class="headerlink" title="4.2 结构体与指针"></a>4.2 结构体与指针</h3><ol><li><p><strong>结构体指针: 指向结构体的指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Book</span> *<span class="hljs-title">pt</span>;</span>  <span class="hljs-comment">// pt 是一个指向 struct Book 类型的指针</span><br></code></pre></td></tr></table></figure><ul><li><p>数组名是指向第一个元素的地址,但结构体变量名并非指向该结构体的地址</p></li><li><p>结构体的地址需要通过 <code>&amp;</code> 运算符获取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Book</span> <span class="hljs-title">book</span>;</span><br>pt = &amp;book;  <span class="hljs-comment">// 获取结构体变量的地址</span><br></code></pre></td></tr></table></figure></li><li><p><strong>结构体指针访问结构体成员有两种方法(一般使用 <code>-&gt;</code>,简洁直观)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">(*结构体指针).成员名  <span class="hljs-comment">// 先解引用,再访问成员</span><br>结构体指针 -&gt; 成员名  <span class="hljs-comment">// 使用箭头符号,隐含这是一个指针</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>传递结构体信息: 结构变量可以直接赋值.作为参数传递时也可以直接传递</p></li><li><p>传递指向结构体变量的指针</p><ul><li>直接传递结构体时,如果结构体变量很大,将会导致函数调用过程中时间和空间的开销相对大</li><li>传递结构体指针可以避免这种开销</li></ul></li></ol><h3 id="4-3-typedef"><a href="#4-3-typedef" class="headerlink" title="4.3 typedef"></a>4.3 <code>typedef</code></h3><ol><li><p>给数据类型起别名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> integer;<br>integer a;<br></code></pre></td></tr></table></figure></li><li><p><strong><code>typedef</code> 与 <code>#define</code> 的区别</strong></p><ul><li><p>顺序并不一样(但可统一为前一个对象作为操作对象,后一个对象为操作后的结果)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> integer int  <span class="hljs-comment">// 将 integer 替换为 int</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> integer; <span class="hljs-comment">// 给 int 起别名为 integer</span><br></code></pre></td></tr></table></figure></li><li><p>有修饰符时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 程序编译通过. integer 被替换为 int,a = 4294967295</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> integer int</span><br><span class="hljs-type">unsigned</span> integer a = <span class="hljs-number">-1</span>; <br><br><span class="hljs-comment">// 程序编译报错</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> integer;<br><span class="hljs-type">unsigned</span> integer a = <span class="hljs-number">-1</span>; <br></code></pre></td></tr></table></figure></li><li><p>定义指针变量时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 该语句预处理后替换为 int *a, b</span><br><span class="hljs-comment">** 此时 a 类型为int *, b 类型为 int */</span><br>ptrInt a, b;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ptrInt int *</span><br><br><span class="hljs-comment">/* a, b 类型均为 int *  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> * ptrInt;<br>ptrInt a, b; <br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>与结构体搭配(数据结构的链表需要该技巧)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 将 struct Date   赋予别名 DATE</span><br><span class="hljs-comment">** 将 struct Date * 赋予别名 PDATE */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Date</span> &#123;</span><br>    <span class="hljs-type">int</span> year;<br>    <span class="hljs-type">int</span> month;<br>    <span class="hljs-type">int</span> day;<br>&#125; DATE, *PDATE;<br><br>DATE date;    <span class="hljs-comment">// 定义结构体不再需要关键字 struct</span><br>PDATE pdate;  <span class="hljs-comment">// 定义的是 结构体指针</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="4-4-简化类型声明"><a href="#4-4-简化类型声明" class="headerlink" title="4.4 简化类型声明"></a>4.4 简化类型声明</h3><ol><li><p>数组指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*ptr)[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*PTR2ARRAY)</span>[3];<br></code></pre></td></tr></table></figure></li><li><p>函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*PTR2FUN)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure></li><li><p>指针函数与数组指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* array 是一个指针数组,其元素指向指针函数.指针函数参数为 int,返回值为 int *  */</span><br><span class="hljs-type">int</span> *(*<span class="hljs-built_in">array</span>[<span class="hljs-number">3</span>])(<span class="hljs-type">int</span>);<br><br><span class="hljs-comment">/* 直接使用 typedef 会导致数组长度固定为3, 因此分成两句 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> *(*PRT2FUN)(<span class="hljs-type">int</span>);  <span class="hljs-comment">// PRT2FUN 是一个指针,指向指针函数</span><br>PRT2FUN <span class="hljs-built_in">array</span>[<span class="hljs-number">3</span>];              <span class="hljs-comment">// array 是一个拥有3个元素的数组,元素类型为 PRT2FUN</span><br></code></pre></td></tr></table></figure></li><li><p>参数为函数指针,返回值为函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*funA(<span class="hljs-type">int</span>, <span class="hljs-type">void</span> (*funB)(<span class="hljs-type">int</span>)))(<span class="hljs-type">int</span>);<br><span class="hljs-comment">/* funA 是一个指针函数.有两个参数 int, funB</span><br><span class="hljs-comment">** funB 是一个函数指针,指向的类型为 void (int)</span><br><span class="hljs-comment">** 分析 funA 的返回值: 先化简 void (*funA(参数))(int).</span><br><span class="hljs-comment">** 返回值类型为 void (int),即函数指针 */</span><br><br><span class="hljs-comment">/* 提取出共同点,可以有更为清晰的定义方式 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*PTR2FUN)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-comment">// PTR2FUN 是一个函数指针</span><br>PTR2FUN <span class="hljs-title function_">funA</span><span class="hljs-params">(<span class="hljs-type">int</span>, PTR2FUN)</span>;<br></code></pre></td></tr></table></figure></li><li><p>获取类型转换符的方法为: 去掉变量名和分号,再用括号整体封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> (*h)();  <span class="hljs-comment">// 声明 h 是一个指针,指向一个返回值为 float 的函数</span><br>(<span class="hljs-type">float</span> (*)())  <span class="hljs-comment">// 构造出对应的类型转换符</span><br></code></pre></td></tr></table></figure></li><li><p>以显式的方式调用首地址为0的子例程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(*( <span class="hljs-type">void</span> (*)() ) <span class="hljs-number">0</span>)()<br></code></pre></td></tr></table></figure><ul><li><p>先考虑 <code>(* 0)();</code></p><ul><li>本意: 想对地址0进行解引用,然后调用函数</li><li>实际: 无法生效,因为 <code>*</code> 需要一个指针作为操作数,且这里还要求是函数指针</li><li>解决方法: 先将 0 强转为函数指针</li></ul></li><li><p>考虑 <code>(void(*)())</code>.这是就是需要的类型转换符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*funcptr)</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 函数指针</span><br>(*(funcptr)<span class="hljs-number">0</span>)();  <span class="hljs-comment">// 先将0强转为函数指针,然后调用该函数</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="4-5-union"><a href="#4-5-union" class="headerlink" title="4.5 union"></a>4.5 union</h3><ol><li><p><strong>共用体可以将多个成员存储在同一空间中,它们拥有相同的起始地址.最终存储的值取决最后赋值的变量</strong></p></li><li><p>声明方式: 与 struct 类似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> 共用体名称 &#123;</span><br>    共用体成员<span class="hljs-number">1</span>;<br>    共用体成员<span class="hljs-number">2</span>;<br>    ...<br>    共用体成员n;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>共用体的定义与访问方式均与结构体类似</p></li><li><p>初始化共用体: 不能同时对所有成员都初始化</p></li></ol><h3 id="4-6-enum"><a href="#4-6-enum" class="headerlink" title="4.6 enum"></a>4.6 enum</h3><ol><li><p>如果一个变量只有几种可能的值,可以将其定义为枚举类型</p></li><li><p>枚举类型声明方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> 枚举类型名称 &#123;</span><br>    枚举值名称<span class="hljs-number">1</span>, <br>    枚举值名称<span class="hljs-number">2</span>,<br>    ...<br>    枚举值名称n,<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>枚举变量定义方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> 枚举类型名称 枚举变量名;</span><br></code></pre></td></tr></table></figure><ul><li><strong>枚举值名称可以直接像标识符那样命名,称为枚举常量</strong></li><li><strong>默认情况下 枚举常量的值从 0 开始,往后依次递增</strong></li><li>如果不希望从 0 开始,可以在声明时赋值,往后依然递增</li><li>枚举变量允许自增运算,而 C++ 中不允许</li><li>枚举常量的值和名称在编译时已经指定,不再允许修改</li></ul></li></ol><h3 id="4-7-位域"><a href="#4-7-位域" class="headerlink" title="4.7 位域"></a>4.7 位域</h3><ol><li><p><strong>位域将1字节(Byte)的二进制位划分为几个不同的区域,并指定每个区域的位数</strong></p></li><li><p>每个域有一个域名,允许在程序中按域名进行单独的操作</p></li><li><p>使用位域的方法: 在定义结构体时,在结构体成员使用冒号: 和数字表示该成员所占的位数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span> &#123;</span><br>    <span class="hljs-comment">// type [member_name] : width;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a : <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> b : <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> c : <span class="hljs-number">2</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>位域的宽度不能超过它所依附的数据类型的长度.成员变量是有类型的,位域的宽度被该类型所限制</strong></p></li><li><p>位域成员可以没有名称.但需要给出数据类型和位宽.用于填充或调整成员的位置,不能使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> :<span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-位操作"><a href="#5-位操作" class="headerlink" title="5 位操作"></a>5 位操作</h2><h3 id="5-1-移位运算符"><a href="#5-1-移位运算符" class="headerlink" title="5.1 移位运算符"></a>5.1 移位运算符</h3><ol><li><p>位操作</p><ul><li><strong>C 语言并未明确规定1字节(Byte)的尺寸.而是将其定义为:</strong><br><strong>可寻址的数据存储单位,其尺寸必须可以容纳运行环境的基本字符集的任何成员</strong></li><li>C 语言仅明确规定了 <code>char</code> 类型占用 1 Byte.其他类型仅给出相对的大小关系.具体尺寸由环境约束</li><li>编译器规定了 1 Byte 的位数.写在头文件 <code>&lt;limits.h&gt;</code> 中</li><li>C 语言允许通过位域的形式来按位存取,且允许精确到 位 的运算</li></ul></li><li><p>左移运算符</p><ul><li><p>左移运算符拥有两个操作数</p></li><li><p>左侧表示被移位的数据,右侧指定移动的位数</p></li><li><p><strong>左移移出的位数全部舍弃.右侧用 0 填充</strong></p></li><li><p>将整数左移 N 位相当于乘以 $2^N$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">result = <span class="hljs-number">0b1001010</span> &lt;&lt; <span class="hljs-number">2</span>;<br><span class="hljs-comment">// result = 0b00101000</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>右移运算符</p><ul><li><p>右移运算符拥有两个操作数</p></li><li><p>左侧表示被移位的数据,右侧指定移动的位数</p></li><li><p><strong>右移移出的位数全部舍弃.左侧用 0 填充(如果是负数,用1填充.因此负数右移永远不会为0)</strong></p></li><li><p>将整数右移 N 位相当于除以 $2^N$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">result = <span class="hljs-number">0b11001010</span> &gt;&gt; <span class="hljs-number">2</span>;<br><span class="hljs-comment">// result = 0b00110010</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>左移运算符,右移运算符均可与赋值号结合</p></li><li><p>未定义行为</p><ul><li>左移 &#x2F; 右移运算符右侧指定移动的位数为 负数 时</li><li>右侧指定移动的位数 大于 左侧操作数的最大宽度时</li></ul></li></ol><h3 id="5-2-掩码"><a href="#5-2-掩码" class="headerlink" title="5.2 掩码"></a>5.2 掩码</h3><ol><li><p>掩码</p><ul><li><strong>掩码是一串二进制数字,通过与目标数字的按位操作,达到屏蔽指定位实现需求</strong></li><li>掩码本身的值一般将想要操作的对象位 置1,不变的对象位 置0</li></ul></li><li><p><strong>判断指定位</strong>: 将源数据对指定的掩码进行按位与 <code>&amp;</code>.判断结果是否与掩码本身相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((value &amp; mask) == mask) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>打开位</strong>: 将源数据对指定的掩码进行按位或 <code>|</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">value |= mask;<br></code></pre></td></tr></table></figure></li><li><p><strong>关闭位</strong>: 将源数据对取反后的掩码进行按位与 <code>&amp;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">value &amp;= ~mask;<br></code></pre></td></tr></table></figure></li><li><p><strong>转置位</strong>: 将源数据对指定的掩码进行按位异或 ^</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">value ^= mask;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C 语言</tag>
      
      <tag>计算机</tag>
      
      <tag>Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
