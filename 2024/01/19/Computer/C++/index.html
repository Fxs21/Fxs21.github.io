

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Shuang">
  <meta name="keywords" content="Shuang">
  
    <meta name="description" content="C++ 语法. 面向对象; 异常处理; 文件 IO; 模板; STL.">
<meta property="og:type" content="article">
<meta property="og:title" content="C++">
<meta property="og:url" content="http://example.com/2024/01/19/Computer/C++/index.html">
<meta property="og:site_name" content="Shuang blog">
<meta property="og:description" content="C++ 语法. 面向对象; 异常处理; 文件 IO; 模板; STL.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/CPP.svg">
<meta property="article:published_time" content="2024-01-18T16:03:52.701Z">
<meta property="article:modified_time" content="2025-09-18T15:46:37.811Z">
<meta property="article:author" content="Shuang">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="计算机">
<meta property="article:tag" content="Code">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/CPP.svg">
  
  
  
  <title>C++ - Shuang blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>windsand</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/train.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-01-19 00:03" pubdate>
          2024年1月19日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          96 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C++</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="0-基础语法"><a href="#0-基础语法" class="headerlink" title="0 基础语法"></a>0 基础语法</h2><h3 id="0-1-关键字"><a href="#0-1-关键字" class="headerlink" title="0.1 关键字"></a>0.1 关键字</h3><ol>
<li><p>C++ 语言特性直接支持4种程序设计风格(核心哲学: 零开销抽象)</p>
<ul>
<li><strong>过程式程序设计</strong>: 专注于处理和设计恰当的数据结构(如 C 语言)</li>
<li><strong>数据抽象</strong>: 专注于接口的设计, 一般实现细节的隐藏和特殊的表示方式(具体类, 抽象类)</li>
<li><strong>面向对象程序设计</strong>: 专注于类层次的设计, 实现, 使用(通过封装, 继承, 多态)</li>
<li><strong>泛型程序设计</strong>: 专注于通用算法的设计, 实现, 使用(通过模板)</li>
</ul>
</li>
<li><p>ANSI C 有32个关键字</p>
<table>
<thead>
<tr>
<th>auto</th>
<th>break</th>
<th>case</th>
<th>char</th>
<th>const</th>
<th>continue</th>
<th>default</th>
<th>do</th>
</tr>
</thead>
<tbody><tr>
<td>double</td>
<td>else</td>
<td>enum</td>
<td>extern</td>
<td>float</td>
<td>for</td>
<td>goto</td>
<td>if</td>
</tr>
<tr>
<td>int</td>
<td>long</td>
<td>register</td>
<td>return</td>
<td>short</td>
<td>signed</td>
<td>sizeof</td>
<td>static</td>
</tr>
<tr>
<td>struct</td>
<td>switch</td>
<td>typedef</td>
<td>union</td>
<td>unsigned</td>
<td>void</td>
<td>volatile</td>
<td>while</td>
</tr>
</tbody></table>
</li>
<li><p>C99 标准新增5个关键字: <code>inline, restrict, _Bool, _Complex, _Imaginary</code></p>
</li>
<li><p>C11 标准新增7个关键字: <code>_Alignas, _Alignof, _Atomic, _Static_assert, _Noreturn, _Thread_local, _Generic</code></p>
</li>
<li><p><strong>C++98&#x2F;03 相较 ANSI C 增加的31个关键字(共63个)</strong></p>
<table>
<thead>
<tr>
<th>asm</th>
<th>bool</th>
<th>catch</th>
<th>class</th>
<th>const_cast</th>
</tr>
</thead>
<tbody><tr>
<td>delete</td>
<td>dynamic_cast</td>
<td>explicit</td>
<td>export</td>
<td>false</td>
</tr>
<tr>
<td>friend</td>
<td>inline</td>
<td>mutable</td>
<td>namespace</td>
<td>new</td>
</tr>
<tr>
<td>operate</td>
<td>private</td>
<td>protected</td>
<td>public</td>
<td>reinterpret_cast</td>
</tr>
<tr>
<td>static_cast</td>
<td>template</td>
<td>this</td>
<td>throw</td>
<td>true</td>
</tr>
<tr>
<td>try</td>
<td>typeid</td>
<td>typename</td>
<td>using</td>
<td>virtual</td>
</tr>
<tr>
<td>wchar_t</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p><strong>C++11 相较于 C++98 新增的10个关键字(共73个)</strong></p>
<table>
<thead>
<tr>
<th>alignas</th>
<th>alignof</th>
<th>char16_t</th>
<th>char32_t</th>
<th>constexpr</th>
</tr>
</thead>
<tbody><tr>
<td>decltype</td>
<td>noexcept</td>
<td>nullptr</td>
<td>static_assert</td>
<td>thread_local</td>
</tr>
</tbody></table>
</li>
<li><p>逻辑运算符: <code>and, or, not, and_eq, or_eq, not_eq, bitand, bitor, compl, xor, xor_eq</code></p>
</li>
</ol>
<h3 id="0-2-命名空间"><a href="#0-2-命名空间" class="headerlink" title="0.2 命名空间"></a>0.2 命名空间</h3><ol>
<li><p><code>hello, world</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;hello, world&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><code>using</code> 的使用(以 <code>std::cout</code> 对象为例.注意不要在全局作用域的头文件中使用 <code>using</code>)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;         <span class="hljs-comment">// 使得 std 命名空间中的所有名称都可直接使用.方便但不推荐</span><br><span class="hljs-keyword">using</span> std::cout;             <span class="hljs-comment">// 仅引入需要使用的 std::cout, 并简化为 cout. 推荐的使用方式</span><br>std::coot &lt;&lt; <span class="hljs-string">&quot;Hello,world!&quot;</span>; <span class="hljs-comment">// 不使用 using 编译指令.而是都每次都加上 std:: 前缀.比较麻烦</span><br></code></pre></td></tr></table></figure></li>
<li><p><code>namespace</code> 的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> 名称 &#123;<br>    <span class="hljs-comment">/* 在此处声明变量, 函数, 类型, 对象... 其他位置进行实现 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>namespace</code> 注意事项</p>
<ul>
<li><p>访问方式(与访问类成员类似,但运算符为 <code>::</code>)</p>
<ul>
<li>内部访问: 直接访问即可,无需任何条件</li>
<li><strong>外部访问: 通过 <code>::</code> 作用域解析运算符访问命名空间成员</strong></li>
</ul>
</li>
<li><p>只能在全局范围定义(如函数内不允许定义命名空间)</p>
</li>
<li><p>可以嵌套定义.访问时使用多次 <code>::</code> 即可访问</p>
</li>
<li><p>实现与声明通常分离(声明于 <code>.h</code> 文件,实现于 <code>.cpp</code> 文件)</p>
</li>
<li><p>命名空间可以起别名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> alias = std;  <span class="hljs-comment">// 直接赋值.后续即可使用别名</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="0-3-兼容性"><a href="#0-3-兼容性" class="headerlink" title="0.3 兼容性"></a>0.3 兼容性</h3><ol>
<li><p>C 与 C++ 的兼容性</p>
<ul>
<li><strong>C++ 几乎是 C 的超集.C 语言的语法在 C++ 中可以通用(如预处理器, 变量声明, 函数声明)</strong></li>
<li><strong>C++ 增加了面向对象(通过类)与泛型编程(通过模板)</strong></li>
</ul>
</li>
<li><p>对 C 程序员的建议</p>
<ul>
<li><strong>C++ 几乎不需要宏替换</strong><ul>
<li>使用 <code>const, constexpr, enum, enum class</code> 定义显式常量</li>
<li>使用 <code>inline</code> 避免函数调用的开销</li>
<li>使用 <code>template</code> 指明函数族和类型族</li>
<li>使用 <code>namespace</code> 避免命名冲突</li>
</ul>
</li>
<li>在需要使用一个变量时才声明,且声明后立即进行初始化</li>
<li>不要使用 <code>malloc</code>, 而是使用 <code>new</code></li>
<li>避免使用 <code>void *, 类型转换</code></li>
<li>没有参数的不需要写 <code>void</code>.形参列表为空就好</li>
<li>减少 C 风格字符串的使用.而是使用 <code>string</code></li>
<li>C++ 不推荐使用 C 风格的数组,而是采用 <code>std::array, std::vector</code> 容器</li>
</ul>
</li>
<li><p>文件格式</p>
<ul>
<li>C 语言的源代码使用 <code>.c</code>,而 C++ 源代码的拓展名常用 <code>.cpp</code></li>
<li>C 语言的头文件使用 <code>.h</code>,而 C++ 头文件没有拓展名(如 C 中的 <code>math.h</code> 改为 <code>cmath</code>)</li>
</ul>
</li>
<li><p>API 适配: 假设一个头文件声明了 C 语言的函数和全局变量,但却可能会被 C++ 代码包含,则需要特殊处理</p>
<ul>
<li><p>因为 C++ 编译器对符号修饰的处理与 C 不同,因而导致链接出错</p>
</li>
<li><p>C++ 具有 <code>extern &quot;C&quot;</code> 关键字,用于处理与 C 的兼容性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>    <span class="hljs-type">int</span> var;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>处理方式: 正常编写 C 程序.而使用预编译指令处理头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus  <span class="hljs-comment">// C++ 编译时会默认定义 __cplusplus 宏</span></span><br>	<span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// C function declarations here</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>	&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="0-4-数据"><a href="#0-4-数据" class="headerlink" title="0.4 数据"></a>0.4 数据</h3><ol>
<li><p>数值字面量</p>
<ul>
<li>整数: <strong>二进制(前缀 0b)</strong>, 八进制(前缀 0), 十进制(默认形式), 十六进制(前缀 0x)</li>
<li><strong>分隔符 <code>&#39;</code></strong>: 如 <code>100&#39;000, 0.123&#39;456f, 0b1000&#39;000</code></li>
<li>C 定义 <code>NULL</code> 为 <code>((void *) 0)</code>.而 C++ 定义 <code>NULL</code> 为 0.应该使用 <code>nullptr</code> 表示空指针</li>
</ul>
</li>
<li><p>初始化列表对不同对象的初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> l &#123;<span class="hljs-number">5400UL</span>&#125;;  <span class="hljs-comment">// 相当于 unsigned long l = 5400UL;</span><br><span class="hljs-type">int</span> array[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;     <span class="hljs-comment">// 省略了赋值号,并由编译器推断数组长度</span><br><span class="hljs-comment">// 零初始化的行为: 数值类型初始化为 0; 指针类型初始化为 nullptr; 类对象调用默认构造函数</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>变量类型转换(<code>static_cast</code> 关键字)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> f = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> a &#123; (<span class="hljs-type">int</span>)f &#125;;               <span class="hljs-comment">// C 风格强制类型转换</span><br><span class="hljs-type">int</span> b &#123; <span class="hljs-built_in">int</span>(f) &#125;;               <span class="hljs-comment">// 使用较少</span><br><span class="hljs-type">int</span> c &#123; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(f) &#125;;  <span class="hljs-comment">// 推荐使用</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>枚举类</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// c++ 枚举类定义需要 class 关键字.且枚举类不能与整数混用</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">piece_type</span> &#123;King, Queen, Rook, Pawn&#125;;<br><br><span class="hljs-comment">// 访问枚举类: 与访问类常量相似(因为不同枚举类被当作不同的作用域.这区别于 C 语言的枚举)</span><br>piece_type piece&#123; PieceType::King &#125;;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">piece_type</span>;  <span class="hljs-comment">// C++20 语法</span><br>piece = Queen;          <span class="hljs-comment">// 无需使用全名访问</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>if, switch</code> 语句的初始化器: 初始化引入的变量作用域局限于条件语句内部</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>( &lt;初始化&gt;; &lt;条件语句&gt; )   &#123; <span class="hljs-comment">/* code */</span> &#125;<br><span class="hljs-keyword">switch</span>( &lt;初始化&gt;; &lt;表达式&gt; ) &#123; <span class="hljs-comment">/* code */</span> &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>基于范围的 <code>for</code> 循环</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>( &lt;初始化&gt;; &lt;范围声明&gt;) &#123; <span class="hljs-comment">/* code */</span> &#125;  <span class="hljs-comment">// C++20 基于范围的 for 循环的初始化器</span><br><br><span class="hljs-keyword">for</span>( array arr&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;; <span class="hljs-type">int</span> i : arr )<br>    cout &lt;&lt; i &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="0-5-内存"><a href="#0-5-内存" class="headerlink" title="0.5 内存"></a>0.5 内存</h3><ol>
<li><p>C++ 中利用 <code>new</code> 操作符在堆区申请内存,利用操作符 <code>delete</code> 释放空间</p>
</li>
<li><p><code>new</code> 申请单个数据的内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 申请1个 int 类型大小的内存空间,且初始化为 10</span><br>cout &lt;&lt; *p &lt;&lt; endl;    <span class="hljs-comment">// 使用 p 存储的数据</span><br><span class="hljs-keyword">delete</span> p;              <span class="hljs-comment">// 释放申请的空间.必须是由 new 创建的</span><br>p = <span class="hljs-literal">nullptr</span>;           <span class="hljs-comment">// 最佳实践.防止悬空指针</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>new</code> 申请数组内存(注意释放内存时 <code>delete</code> 的格式应与 <code>new</code> 对应)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];	<span class="hljs-comment">// 申请的是 int[],长度为10</span><br><span class="hljs-keyword">delete</span>[] arr;           <span class="hljs-comment">// 对应地,释放时要表明是数组 delete[]</span><br>arr = <span class="hljs-literal">nullptr</span>;          <span class="hljs-comment">// 释放空间后将指针置空.防止再次使用</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>new, delete</code> 与 <code>malloc, free</code> 对比</p>
<ul>
<li><code>new, delete</code> 是 C++ 的操作符(可重载.会调用构造 &#x2F; 析构函数).而 <code>malloc, free</code> 是标准库函数</li>
<li><code>new</code> 直接返回对应类型指针.而 <code>malloc</code> 需要手动计算字节数并返回 <code>void *</code></li>
</ul>
</li>
<li><p><strong>在现代 C++ 中,应尽量避免直接使用 <code>new</code> 和 <code>delete</code>.转而使用智能指针管理内存生命周期</strong></p>
</li>
</ol>
<h3 id="0-6-引用"><a href="#0-6-引用" class="headerlink" title="0.6 引用"></a>0.6 引用</h3><ol>
<li><p><strong>引用: 给变量起别名(本质为指针常量).引用必须初始化.且初始化后不可修改其指向对象,而只能修改其值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;b = a;  <span class="hljs-comment">// &amp; 表示引用变量  &lt;==&gt; int* const p = &amp;a;</span><br>b = <span class="hljs-number">100</span>;     <span class="hljs-comment">// 直接修改引用名  &lt;==&gt; *p = 100;</span><br></code></pre></td></tr></table></figure></li>
<li><p><strong>引用作为函数参数: 可以简化指针修改实参的语法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 1. 值传递: 这无法完成 &quot;值交换功能&quot; */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_swap1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> temp = a; a = b; b = temp;&#125;<br><br><span class="hljs-comment">/* 2. 地址传递: 完成了 &quot;值交换功能&quot;,但需要进行取址/取值操作 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_swap2</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> </span>&#123;<span class="hljs-type">int</span> temp = *a; *a = *b; *b = temp;&#125;<br><br><span class="hljs-comment">/* 3. 引用传递: 完成了 &quot;值交换功能&quot;,且代码中并未直接出现指针 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_swap3</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span> </span>&#123;<span class="hljs-type">int</span> temp = a; a = b; b = temp;&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>引用作为返回值</p>
<ul>
<li>引用可以作为函数的返回值(注意不要返回局部变量引用)</li>
<li>函数调用可作为左值(因为函数调用后返回的是变量引用).实现链式调用</li>
</ul>
</li>
<li><p>常量引用: 主要用来修饰形参,防止误操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 在函数形参列表中,可以加 const 修饰形参,防止形参改变实参 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_value</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;v)</span> </span>&#123;<br>	<span class="hljs-comment">// v += 10;  // 对常量进行修改, 将会导致编译报错</span><br>	cout &lt;&lt; v &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="0-7-函数"><a href="#0-7-函数" class="headerlink" title="0.7 函数"></a>0.7 函数</h3><ol>
<li><p><strong>默认参数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 函数的形参可以有默认值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>)</span> </span>&#123;<br>    <span class="hljs-comment">/* code */</span><br>&#125;<br><span class="hljs-comment">// 如果某个位置参数有默认值,那么从这个位置 往后的参数都必须有默认值</span><br><span class="hljs-comment">// 如果函数声明有默认值,函数实现就不能有默认参数(因为导致语义二义性)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>占位参数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 函数占位参数也可以有默认参数.调用函数时必须填补 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> = <span class="hljs-number">10</span>)</span> </span>&#123;<br>	<span class="hljs-comment">/* code */</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>函数重载</strong>: 函数名可以相同,提高复用性</p>
<ul>
<li>函数重载条件<ul>
<li>函数名相同,且位于同一个作用域</li>
<li>函数的参数不同(类型 &#x2F; 个数 &#x2F; 顺序的任意一种)</li>
</ul>
</li>
<li>注意事项<ul>
<li>返回值不作为函数重载的条件</li>
<li>引用可作为重载条件(是否被 <code>const</code> 修饰的引用形参)</li>
<li><strong>函数重载碰到函数默认参数时.会产生歧义,应避免</strong></li>
</ul>
</li>
<li>函数被调用时,会根据传入参数不同匹配需要调用的函数</li>
</ul>
</li>
<li><p><strong>匿名函数(labmda)</strong>: .属于可调用对象,特点为就地定义,就地使用</p>
<ul>
<li><p>C++ 中 lambda 是函数对象的语法糖.在任何需要可调用对象的接口,都可传入 lambda 匿名函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture_clause] (parameters) -&gt; return_type &#123;<br>    <span class="hljs-comment">/* code */</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>捕获列表: lambda 所在父作用域定义的变量列表</p>
</li>
<li><p>父作用域: 包含 lambda 函数的语句块</p>
</li>
<li><p>空捕获列表: 不使用父作用域的任何局部变量</p>
</li>
<li><p>隐式捕获: 不在捕获列表中指定局部变量,而是靠编译器推导</p>
<ul>
<li><code>[=]</code>: 值传递的方式捕获父作用域的所有变量</li>
<li><code>[&amp;]</code>: 引用传递的方式捕获父作用域的所有变量</li>
</ul>
</li>
<li><p>捕获 <code>this</code> 指针: 使得 lambda 表达式拥有与当前类成员相同的访问权限</p>
</li>
</ul>
</li>
</ol>
<h3 id="0-8-文件"><a href="#0-8-文件" class="headerlink" title="0.8 文件"></a>0.8 文件</h3><ol>
<li><p>写文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>              <span class="hljs-comment">// 文件操作头文件</span></span><br><br>ofstream ofs;                   <span class="hljs-comment">// 创建流对象</span><br>ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::out); <span class="hljs-comment">// 打开文件</span><br>ofs &lt;&lt; <span class="hljs-string">&quot;姓名:张三&quot;</span> &lt;&lt; endl;      <span class="hljs-comment">// 写入数据</span><br>ofs &lt;&lt; <span class="hljs-string">&quot;性别:男&quot;</span> &lt;&lt; endl;<br>ofs.<span class="hljs-built_in">close</span>();                    <span class="hljs-comment">// 关闭文件</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>文件打开模式(利用 <code>|</code> 操作符可以组合模式)</p>
<table>
<thead>
<tr>
<th>mode</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ios::in</code></td>
<td>读文件</td>
</tr>
<tr>
<td><code>ios::out</code></td>
<td>写文件</td>
</tr>
<tr>
<td><code>ios::ate</code></td>
<td>将文件指针置于文件尾</td>
</tr>
<tr>
<td><code>ios::app</code></td>
<td>追加方式写文件</td>
</tr>
<tr>
<td><code>ios::trunc</code></td>
<td>如果文件存在,先删除,再创建</td>
</tr>
<tr>
<td><code>ios::binary</code></td>
<td>二进制方式</td>
</tr>
</tbody></table>
</li>
<li><p>读文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">ifstream ifs;                  <span class="hljs-comment">// 创建流对象</span><br>ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::in); <span class="hljs-comment">// 打开文件</span><br><br><span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>()) &#123;          <span class="hljs-comment">// 使用 is_open 方法判断是否打开成功</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">/* 在此处读取文件... */</span><br>ifs.<span class="hljs-built_in">close</span>();                   <span class="hljs-comment">// 关闭文件</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>多种读取方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 1. 右移运算符将 ifs 中数据读入 buf.完毕后返回 false */</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123; <span class="hljs-number">0</span> &#125;; <span class="hljs-comment">// 将 buf 全初始化为0</span><br><span class="hljs-keyword">while</span> (ifs &gt;&gt; buf) &#123; cout &lt;&lt; buf &lt;&lt; endl;&#125;<br><br><span class="hljs-comment">/* 2. getline 方法读入一行.参数 str 为存放数据的地址,count 为最大读入数量 */</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123; <span class="hljs-number">0</span> &#125;; <span class="hljs-comment">// 将 buf 全初始化为0</span><br><span class="hljs-keyword">while</span> (ifs.<span class="hljs-built_in">getline</span>(buf, <span class="hljs-built_in">sizeof</span>(buf))) &#123; cout &lt;&lt; buf &lt;&lt; endl;&#125;<br><br><span class="hljs-comment">/* 3. 全局函数 getline 读入一行 */</span><br>string buf;  <span class="hljs-comment">// 使用 string 对象进行维护</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(ifs, buf)) &#123; cout &lt;&lt; buf &lt;&lt; endl;&#125;<br><br><span class="hljs-comment">/* 4. get 方法每次只读一个字符 */</span><br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span> ((c = ifs.<span class="hljs-built_in">get</span>()) != EOF) &#123;cout &lt;&lt; c;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>以二进制的方式对文件进行读写操作.打开方式要指定为 <code>ios::binary</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br>	<span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">/* 二进制文件操作: 写数据 */</span><br><span class="hljs-function">ofstream <span class="hljs-title">ofs</span><span class="hljs-params">(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;<br>Person p = &#123;<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>&#125;;<br>ofs.<span class="hljs-built_in">write</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)&amp;p, <span class="hljs-built_in">sizeof</span>(p));<br>ofs.<span class="hljs-built_in">close</span>();<br><br><span class="hljs-comment">/* 二进制文件操作: 读数据 */</span><br><span class="hljs-function">ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;<br><span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>()) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;<br>&#125;<br>ifs.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span> *)&amp;p, <span class="hljs-built_in">sizeof</span>(p));<br><br>cout &lt;&lt; <span class="hljs-string">&quot;姓名: &quot;</span> &lt;&lt; p.name &lt;&lt; <span class="hljs-string">&quot; 年龄: &quot;</span> &lt;&lt; p.age &lt;&lt; endl;<br>ifs.<span class="hljs-built_in">close</span>();<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1 面向对象"></a>1 面向对象</h2><h3 id="1-1-封装"><a href="#1-1-封装" class="headerlink" title="1.1 封装"></a>1.1 封装</h3><ol>
<li><p><strong>面向对象的三大特性: 封装, 继承, 多态</strong></p>
</li>
<li><p>封装的作用</p>
<ul>
<li>将属性和行为作为一个整体</li>
<li>对属性和行为进行权限控制</li>
</ul>
</li>
<li><p>在设计类的时候,属性和行为封装在一起</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> radius &#123;<span class="hljs-number">0</span>&#125; ;  <span class="hljs-comment">// 类内成员初始化器</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">get_perimeter</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span>  <span class="hljs-number">2</span> * PI * radius;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Circle c&#123;&#125;;     <span class="hljs-comment">// 实例化对象</span><br>    c.radius = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 类实例访问方式与结构体类似.使用 . 或 -&gt;</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Circle perimeter: &quot;</span> &lt;&lt; c.<span class="hljs-built_in">get_perimeter</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>属性与方法的权限控制</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>权限类别</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public</code></td>
<td>公共权限</td>
<td>类内 &#x2F; 类外均可访问.用于提供接口</td>
</tr>
<tr>
<td><code>protected</code></td>
<td>保护权限</td>
<td>类内可以访问,子类可以访问.但类外不可以访问</td>
</tr>
<tr>
<td><code>private</code></td>
<td>私有权限</td>
<td>类内可访问,类外不可访问.用于提供实现细节</td>
</tr>
</tbody></table>
</li>
<li><p>C++ 中 <code>struct</code> 和 <code>class</code> 区别在于默认的访问权限不同.<code>struct</code> 默认公共; <code>class</code> 默认私有</p>
</li>
<li><p>成员属性设为 <code>private</code> 的优点: 控制读写权限</p>
<ul>
<li>对于读权限,通过 <code>get</code> 方法(控制访问权限)</li>
<li>对于写权限,通过 <code>set</code> 方法(检测数据的合法性)</li>
</ul>
</li>
</ol>
<h3 id="1-2-默认函数"><a href="#1-2-默认函数" class="headerlink" title="1.2 默认函数"></a>1.2 默认函数</h3><ol>
<li><p><strong>构造函数: 用于创建对象时为对象的成员属性赋值,将由编译器自动调用(只会调用一次)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 构造函数名称与类名相同.没有返回值且不用写 void.支持重载</span><br><span class="hljs-built_in">ClassName</span>() &#123;<br>    <span class="hljs-comment">/* code */</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>析构函数: 用于对象销毁前的清理工作,将由编译器自动调用(只会调用一次)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 析构函数没有返回值,但不用写 void.不可以有参数,因此不可重载</span><br>~<span class="hljs-built_in">ClassName</span>() &#123;<br>    <span class="hljs-comment">/* code */</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>类内默认函数</p>
<ul>
<li><strong>默认情况下,C++ 编译器至少给一个类添加4个函数</strong><ul>
<li>默认构造函数(无参,函数体为空)</li>
<li>默认析构函数(无参,函数体为空)</li>
<li>默认拷贝构造函数, 对属性进行值拷贝</li>
<li>赋值运算符 <code>operator=</code>: 对属性进行值拷贝.非构造情况下调用</li>
</ul>
</li>
<li>若用户定义有参构造函数,C++ 不再提供默认无参构造,但是仍提供默认拷贝构造</li>
<li>若用户定义拷贝构造函数,C++ 不再提供其他构造函数</li>
</ul>
</li>
<li><p>深拷贝与浅拷贝</p>
<ul>
<li>浅拷贝: 简单的赋值拷贝操作</li>
<li>深拷贝: 在堆区重新申请空间,进行拷贝操作<ul>
<li>如果属性有在堆区申请空间的操作,则析构函数应包含释放内存操作</li>
<li>浅拷贝将会导致重复释放内存.需要自己提供拷贝构造函数避免该问题</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="1-3-类成员"><a href="#1-3-类成员" class="headerlink" title="1.3 类成员"></a>1.3 类成员</h3><ol>
<li><p><strong>静态成员: 在成员变量和成员函数前加上关键字 <code>static</code></strong></p>
<ul>
<li>静态成员变量: 所有对象共享同一份数据; 在编译阶段分配内存; 类内声明,类外初始化</li>
<li>静态成员函数: 所有对象共享同一个函数; <strong>静态成员函数只能访问静态成员变量</strong></li>
<li>静态成员可以通过类名直接访问: <code>对象.成员</code> 或 <code>类名::成员</code></li>
</ul>
</li>
<li><p>成员变量和成员函数分开存储.只有非静态成员变量属于类的对象之中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Person</span>() &#123;mA = <span class="hljs-number">0</span>;&#125;<br>	<span class="hljs-type">int</span> mA;           <span class="hljs-comment">// 非静态成员变量占对象空间</span><br>	<span class="hljs-type">static</span> <span class="hljs-type">int</span> mB;    <span class="hljs-comment">// 静态成员变量不占对象空间</span><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;	  <span class="hljs-comment">// 函数也不占对象空间,所有函数共享一个函数实例</span><br>		cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mA &lt;&lt; endl;<br>	&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">sfunc</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// 静态成员函数也不占对象空间</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>C++ 通过特殊的对象指针 <code>this</code> 指针,指向调用方法的对象.是一个指针常量</strong></p>
<ul>
<li><p><code>this</code> 指针隐含于每一个非静态成员函数内.也不需要定义,可直接使用</p>
</li>
<li><p>形参和成员变量同名时,可用 <code>this</code> 指针来区分</p>
</li>
<li><p>在类的非静态成员函数中返回对象本身,可使用 <code>return *this</code></p>
</li>
</ul>
</li>
<li><p>常函数: 成员函数最后加 <code>const</code></p>
<ul>
<li><strong>常函数内不可以修改成员属性</strong></li>
<li>成员属性声明时加关键字 <code>mutable</code> 后,在常函数中依然可以修改</li>
</ul>
</li>
<li><p>常对象: 声明对象前加 <code>const</code> 称该对象为常对象</p>
<ul>
<li><p><strong>常对象不能修改成员变量,只能访问.因此只能调用常函数</strong></p>
</li>
<li><p>常对象可以修改 <code>mutable</code> 修饰成员变量.可访问 <code>public</code> 属性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123; property1 = <span class="hljs-number">0</span>; property2 = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-comment">/* this 指针的类型为 Type* const this;</span><br><span class="hljs-comment">** this 指针的本质是一个指针常量,指针的指向不可修改</span><br><span class="hljs-comment">** 如果想让指针指向的值也不可以修改,需要声明常函数  */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>     <span class="hljs-comment">/* 成员函数加上 const,本质是在修饰 this 指针指向数据的类型</span><br><span class="hljs-comment">     ** 此时 this 指针类型为 const Type* const pointer</span><br><span class="hljs-comment">     ** 则 this 指向的数据不能修改,除使用 mutable 修饰的变量 */</span><br>	<span class="hljs-keyword">this</span>-&gt;property2 = <span class="hljs-number">100</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> property1;<br><span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> property2;  <span class="hljs-comment">// mutable: 可修改,可变的</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="1-4-类初始化"><a href="#1-4-类初始化" class="headerlink" title="1.4 类初始化"></a>1.4 类初始化</h3><ol>
<li><p>简单的类定义示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/* 无参构造函数.若没有任何构造函数,则编译器默认提供一个空实现.但建议手动添加 */</span><br>    <span class="hljs-built_in">Person</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;&#125;<br><br>    <span class="hljs-comment">/* 有参构造函数.可以重载,可以有默认参数,但建议不要同时出现 */</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a) &#123;<br>         age = a;<br>         cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">/* 拷贝构造函数.编译器默认实现为对属性的简单赋值 */</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person &amp;p) &#123;  <span class="hljs-comment">// p 引用的是右值(将要被拷贝的对象)</span><br>         age = p.age;           <span class="hljs-comment">// 当属性为指针且指向堆空间时.要按需实现拷贝逻辑</span><br>         cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">/* 析构函数 */</span><br>    ~<span class="hljs-built_in">Person</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;&#125;<br><span class="hljs-keyword">public</span>: <span class="hljs-type">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>构造函数的调用方式</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 调用无参构造函数 */</span><br>Person p;    <span class="hljs-comment">// 正确.使用无参构造函数.注意不需要括号</span><br><span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 错误.编译器理解为函数声明</span><br><br><span class="hljs-comment">/* 调用有参的构造函数 */</span><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;	<span class="hljs-comment">// 括号法(常用方式).直接进行初始化,而非使用变量接收</span><br><br><span class="hljs-comment">/* 显式调用 */</span><br>Person p2 = <span class="hljs-built_in">Person</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// Person(10) 是匿名对象.当前行结束之后,会立即析构</span><br>Person p3 = <span class="hljs-built_in">Person</span>(p2);  <span class="hljs-comment">// 使用已有的对象进行初始化.触发拷贝构造</span><br><br><span class="hljs-comment">/* 隐式转换 */</span><br>Person p4 = <span class="hljs-number">10</span>;  <span class="hljs-comment">// Person p4 = Person(10); </span><br>Person p5 = p4;  <span class="hljs-comment">// Person p5 = Person(p4); 触发拷贝构造</span><br><br><span class="hljs-comment">/* 不能利用拷贝构造函数来初始化匿名对象.因为编译器会理解为对象声明 */</span><br><span class="hljs-built_in">Person</span>(p5);  <span class="hljs-comment">// 错误.编译器理解为 Person p5; 对 p5 重定义</span><br></code></pre></td></tr></table></figure></li>
<li><p><strong>拷贝构造函数</strong>调用时机: 通常有三种情况(用已有的对象创建其他对象)</p>
<ul>
<li>用已创建的对象来初始化一个新对象<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;  <span class="hljs-comment">// 使用 p1 创建对象 p2.即拷贝构造</span><br></code></pre></td></tr></table></figure></li>
<li>以值传递的方式给函数参数传值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Person p)</span></span>;  <span class="hljs-comment">// func 函数以值传递形式接收对象</span><br><span class="hljs-built_in">func</span>(p);              <span class="hljs-comment">// func 调用时,实参传递给形参,触发拷贝构造</span><br></code></pre></td></tr></table></figure></li>
<li>以值方式返回局部对象<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Person <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    Person p;<br>    <span class="hljs-keyword">return</span> p;  <span class="hljs-comment">// func 函数以值的形式返回局部对象</span><br>&#125;<br>Person p = <span class="hljs-built_in">func</span>();  <span class="hljs-comment">// 接收 func 函数的返回值时,触发拷贝构造</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>初始化成员列表</strong>使用时机</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">ClassName</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b): <span class="hljs-built_in">property1</span>(a), <span class="hljs-built_in">property2</span>(b) &#123;&#125;<br><span class="hljs-function">ClassName <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">8</span>)</span></span>;	<span class="hljs-comment">// 创建对象时进行的初始化: property1=2; property2=8;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>某个属性为引用(为其赋初值)</li>
<li>某个属性被 <code>const</code> 修饰(为其赋初值)</li>
<li>某个属性是其他类的对象(为了构造对象)</li>
</ul>
</li>
</ol>
<h3 id="1-5-友元"><a href="#1-5-友元" class="headerlink" title="1.5 友元"></a>1.5 友元</h3><ol>
<li>友元作用: 让函数或者类可以访问另一个类中的私有成员<ul>
<li>实现: 将类 &#x2F; 函数声明语句置于需要被访问私有成员的类中(无需权限修饰符)</li>
<li><strong>友元理论上提高程序的运行效率(因为无需进行类型检查,安全检查).但破坏了封装性</strong></li>
<li>示例: 全局函数做友元<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span> &#123;<br><span class="hljs-comment">/* 声明全局函数 good_guy 是 Building 类的友元 */</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">good_guy</span><span class="hljs-params">(Building * building)</span></span>;<br><span class="hljs-keyword">public</span>:	<span class="hljs-built_in">Building</span>() &#123; <span class="hljs-keyword">this</span>-&gt;bed_room = <span class="hljs-string">&quot;卧室&quot;</span>; &#125;<br><span class="hljs-keyword">private</span>: string bed_room; <span class="hljs-comment">// 卧室</span><br>&#125;;<br><br><span class="hljs-comment">/* 全局函数 good_guy 可以访问 Building 类的私有成员 bed_room */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">good_guy</span><span class="hljs-params">(Building * building)</span> </span>&#123;<br>	cout &lt;&lt; building-&gt;bed_room &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>友元类: 友元类的所有方法均可访问其私有成员<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>友元关系不能继承.即友元类的子类不是友元类</li>
<li>友元关系是单向的.即反向的友元关系需要在另一类中手动声明</li>
<li>友元关系不具有传递性.即友元的友元不是友元</li>
</ul>
</li>
<li>友元函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">ClassName::func</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>友元函数没有 <code>this</code> 指针</li>
<li>两个类需要共享数据时,可以将一个类的方法作为另一个类的友元函数</li>
</ul>
</li>
</ol>
<h3 id="1-6-运算符重载"><a href="#1-6-运算符重载" class="headerlink" title="1.6 运算符重载"></a>1.6 运算符重载</h3><ol>
<li><p>运算符重载</p>
<ul>
<li>对已有的运算符重定义,赋予其另一种功能 以适应不同的数据类型</li>
<li><strong>对于内置的数据类型的表达式,运算符含义不可改变,不要滥用运算符重载</strong></li>
<li>可以重载的运算符<table>
<thead>
<tr>
<th>类别</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td>单目运算符</td>
<td>+(正), -(负), *(取值), &amp;(取址), ++, –</td>
</tr>
<tr>
<td>算术运算符</td>
<td><code>+, -, *, /, %</code></td>
</tr>
<tr>
<td>关系运算符</td>
<td><code>==, !=, &lt;, &gt;, &lt;=, &gt;=</code></td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>&#96;</td>
</tr>
<tr>
<td>位运算符</td>
<td>&#96;</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>&#96;&#x3D;, +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D;, %&#x3D;,</td>
</tr>
<tr>
<td>空间申请释放</td>
<td><code>new, delete, new[], delete[]</code></td>
</tr>
<tr>
<td>其他</td>
<td><code>()</code>(函数调用)  <code>,</code>(逗号)  <code>[]</code>(下标)</td>
</tr>
</tbody></table>
</li>
<li>不可重载的运算符<ul>
<li><code>.</code>(成员访问)  <code>-&gt;</code>(成员访问)  <code>::</code>(域访问)</li>
<li><code>sizeof</code>(长度计算)  <code>:?</code>(条件运算)  <code>#</code>(预处理)</li>
</ul>
</li>
</ul>
</li>
<li><p><code>+</code> 运算符重载</p>
<ul>
<li>示例: 对自定义的数据类型相加运算</li>
<li>实现方式: <strong>将成员 &#x2F; 全局函数名改为 <code>operator+</code> 即可重载 <code>+</code> 运算符</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">ClassName <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> ClassName&amp; p) &#123;<br>    ClassName temp;<br>    temp.property1 = <span class="hljs-keyword">this</span>-&gt;property1 + p.property1;<br>    temp.property2 = <span class="hljs-keyword">this</span>-&gt;property2 + p.property2;<br>    <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回加法运行后的结果(对象)</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>&lt;&lt;</code> 运算符重载</p>
<ul>
<li>示例: 输出自定义的数据类型</li>
<li>只能用全局函数重载 <code>&lt;&lt;</code>(可在类中加上 <code>friend</code> 通过友元函数实现访问私有成员)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// &lt;&lt; 运算符的参数为: out 以及 p 对象的引用</span><br><span class="hljs-comment">// 返回: ostream 类的引用,便于链式编程</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, ClassName&amp; p) &#123;<br>	out &lt;&lt; p.property1 &lt;&lt; p.property2; <span class="hljs-comment">// 输出对象的属性</span><br>	<span class="hljs-keyword">return</span> out;	<span class="hljs-comment">// out 是 ostream 对象</span><br>&#125;<br><span class="hljs-comment">// 本质上调用方式为 operator&lt;&lt;(cout, p) 被编译器简化为 cout &lt;&lt; p</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>++</code> 运算符重载</p>
<ul>
<li>示例: 通过重载递增运算符,实现自己的整型数据</li>
<li>前置递增返回引用,后置递增返回值</li>
<li>前置 <code>++</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">ClassName&amp; <span class="hljs-keyword">operator</span>++() &#123; <span class="hljs-comment">// 前置++ 返回计算后的引用</span><br>	property++;<br>	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;	<span class="hljs-comment">// 操作后返回自身.可链式调用</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>后置 <code>++</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 参数列表的 int 为占位符(且只能为 int),表示这是后置++</span><br>ClassName <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>	ClassName temp = *<span class="hljs-keyword">this</span>;	<span class="hljs-comment">// 用临时对象存储初始对象</span><br>	property++;<br>	<span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回操作后记录的对象.该实现不可链式调用</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>=</code> 运算符重载</p>
<ul>
<li>如果类中有属性指向堆区,做赋值操作时也会(拷贝构造也会)出现深浅拷贝问题</li>
<li>编译器在进行对象之间的赋值时,会进行浅拷贝.即单纯的值拷贝<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">ClassName&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ClassName &amp;p) &#123;  <span class="hljs-comment">// 编译器默认提供浅拷贝实现</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;p)  <span class="hljs-comment">// 处理自赋值</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">if</span> (ptr != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">delete</span> ptr;  <span class="hljs-comment">// 释放自身原本就有的指针成员变量</span><br>        ptr = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 释放后指向空指针</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (p.ptr != <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 解引用指针前保证不为空</span><br>        ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.ptr);  <span class="hljs-comment">// 深拷贝逻辑</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回自身.可链式调用</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>关系运算符重载: 让两个自定义类型对象进行对比操作</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> ClassName&amp; p) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;property == p.property) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br>    <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> ClassName&amp; p) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;property == p.property) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>    <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br>&#125;<br><span class="hljs-comment">// 类似的可以重载 &lt;, &gt;, &lt;=, &gt;=</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>函数调用运算符重载: <code>()</code> 重载后使用的方式类似函数的调用,因此称为<strong>仿函数</strong></p>
</li>
</ol>
<h3 id="1-7-继承"><a href="#1-7-继承" class="headerlink" title="1.7 继承"></a>1.7 继承</h3><ol>
<li><p>使用继承减少重复的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> 子类名: 继承方式 父类名 &#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>继承方式(注意三种方式中,子类均无法访问父类 private 成员)</p>
<table>
<thead>
<tr>
<th>继承方式</th>
<th>关键字</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>公共继承</td>
<td><code>public</code></td>
<td>除私有成员,其他原封不动地继承</td>
</tr>
<tr>
<td>保护继承</td>
<td><code>protected</code></td>
<td>父类 <code>public, protected</code> 成员均继承为 <code>protected</code> 成员</td>
</tr>
<tr>
<td>私有继承</td>
<td><code>private</code></td>
<td>父类 <code>public, protected</code> 成员均继承为 <code>private</code> 成员</td>
</tr>
</tbody></table>
<ul>
<li><strong>父类中所有非静态成员变量(静态成员仍会共享)都会被继承,包括私有成员</strong></li>
<li><strong>编译器隐藏了父类的私有成员,子类不可访问)</strong></li>
</ul>
</li>
<li><p>父类和子类的构造,析构顺序</p>
<ul>
<li><strong>先调用父类构造函数,再调用子类构造函数</strong></li>
<li>析构顺序与构造顺序相反.先析构子类对象,再析构父类对象</li>
</ul>
</li>
<li><p>继承时子类与父类同名成员处理</p>
<ul>
<li>访问子类同名成员: 直接访问.即对象优先访问本类的成员</li>
<li>访问父类同名成员: 需要加作用域 <code>p.FatherClass::property</code></li>
<li><strong>当子类与父类拥有同名的成员函数,子类会隐藏父类中所有同名成员函数(包括重载)</strong></li>
<li><strong>当发生函数隐藏时,子类对象需要加上作用域则可以访问到父类中同名函数</strong></li>
</ul>
</li>
<li><p>多继承: C++ 允许一个类继承多个类(若父类间出现了同名情况,子类访问其成员时要加作用域)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> 子类名: 继承方式 父类<span class="hljs-number">1</span> ,继承方式 父类<span class="hljs-number">2.</span>.. &#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>菱形继承: 两个派生类继承同一个基类,而后某个类同时继承这两个派生类</p>
<ul>
<li>子类继承两份相同的数据,导致资源浪费以及毫无意义</li>
<li>利用虚继承(在继承方式前加上  <code>virtual</code> 关键字)可以解决菱形继承浪费资源问题</li>
</ul>
</li>
</ol>
<h3 id="1-8-虚函数"><a href="#1-8-虚函数" class="headerlink" title="1.8 虚函数"></a>1.8 虚函数</h3><ol>
<li><p><strong>虚函数目的: 通过父类对象指针(指向子类)访问子类定义的函数</strong></p>
<ul>
<li>函数最前面加上 <code>virtual</code> 关键字即成为虚函数</li>
<li><strong>函数重写: 子类对父类(允许访问的)虚函数的实现过程进行重新编写(形参必须完全一致)</strong></li>
<li>父类对象指针(指向子类)调用虚函数时,会优先寻找子类是否重写了该方法并调用</li>
<li><code>override</code> 关键字可以显式的声明该方法是对父类方法的重写</li>
</ul>
</li>
<li><p>纯虚函数</p>
<ul>
<li><p>在动态多态中,通常父类中虚函数的实现是毫无意义的</p>
</li>
<li><p><strong>调用的都是子类重写的内容.因此可以直接将父类的虚函数改为纯虚函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">virtual</span> 返回值类型 函数名(参数列表) = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>抽象类: 有纯虚函数的类</strong></p>
<ul>
<li>抽象类无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数,否则也属于抽象类</li>
</ul>
</li>
<li><p>虚析构</p>
<ul>
<li><strong>使用多态时,若父类没有将析构声明为虚析构,将导致析构时仅调用父类析构函数</strong></li>
<li>若此时子类中有属性开辟到堆区时,没有进行释放,从而导致内存泄露</li>
<li>解决方式: 将父类中的析构函数改为虚析构或者纯虚析构</li>
<li>注意: 若子类没有堆区数据待释放,则不需要虚析构函数</li>
</ul>
</li>
<li><p>虚析构和纯虚析构</p>
<ul>
<li>均可以通过父类指针释放子类对象</li>
<li><strong>纯虚析构不仅要声明,还必须有具体的函数实现.否则编译报错</strong></li>
</ul>
</li>
<li><p>虚函数表: 记录虚函数地址</p>
<ul>
<li>虚函数指针(vfptr, virtual function pointer): 指向虚函数表</li>
<li>当子类重写父类的虚函数时,子类的虚函数表存储的函数指针被替换重写函数的地址</li>
<li><strong>当父类引用子类对象时,调用虚函数会在子类的虚函数表中查找.实现多态</strong></li>
</ul>
</li>
</ol>
<h3 id="1-9-多态"><a href="#1-9-多态" class="headerlink" title="1.9 多态"></a>1.9 多态</h3><ol>
<li>多态分为: 静态 &#x2F; 动态<ul>
<li><strong>静态多态: 父类成员隐藏, 函数重载, 运算符重载, 泛型编程</strong></li>
<li><strong>动态多态: 子类重写方法和虚函数实现运行时多态</strong></li>
<li>静态多态的函数地址早绑定: 编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定: 运行阶段确定函数地址</li>
</ul>
</li>
<li>动态多态需满足条件<ul>
<li>存在继承关系</li>
<li>子类重写父类中的虚函数</li>
<li>父类指针(或引用)指向子类的对象</li>
</ul>
</li>
<li>多态案例: 分别利用普通方式和多态方式,实现对两个操作数进行运算的计算器类<ul>
<li><p>普通方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">(string oper)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;+&quot;</span>) &#123;<span class="hljs-keyword">return</span> num1 + num2;&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;-&quot;</span>) &#123;<span class="hljs-keyword">return</span> num1 - num2;&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;*&quot;</span>) &#123;<span class="hljs-keyword">return</span> num1 * num2;&#125;<br>	&#125;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">int</span> num1;<br>	<span class="hljs-type">int</span> num2;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>多态方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCalculator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> num1;<br>	<span class="hljs-type">int</span> num2;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddCalculator</span>: <span class="hljs-keyword">public</span> AbstractCalculator<br>&#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> num1 + num2;&#125; &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubCalculator</span>: <span class="hljs-keyword">public</span> AbstractCalculator<br>&#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> num1 - num2;&#125; &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulCalculator</span>: <span class="hljs-keyword">public</span> AbstractCalculator<br>&#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> num1 * num2;&#125; &#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="2-现代-C"><a href="#2-现代-C" class="headerlink" title="2 现代 C++"></a>2 现代 C++</h2><h3 id="2-1-类型推断"><a href="#2-1-类型推断" class="headerlink" title="2.1 类型推断"></a>2.1 类型推断</h3><ol>
<li><p>用于范围 <code>for</code> 循环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">/* 拷贝元素(修改 v 不会影响原容器) */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : vec) &#123;<br>    v *= <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">/* 使用引用.避免拷贝,可直接修改元素 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v : vec) &#123;<br>    v *= <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">/* 使用常量引用.避免拷贝,且禁止修改 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;v : vec) &#123;<br>    std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>推断函数返回类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* C++14 编译器推导返回类型为 int */</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">/* 可以接受任何支持 + 操作的类型 */</span><br><span class="hljs-keyword">auto</span> adder = [](<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>结构化绑定: 声明多个变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, std::string&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>)</span></span>;<br><br><span class="hljs-comment">/* 传统方式 */</span><br><span class="hljs-type">int</span> id_old = p.first;<br>std::string name_old = p.second;<br><br><span class="hljs-comment">/* C++17 结构化绑定 */</span><br><span class="hljs-keyword">auto</span> [id, name] = p; <span class="hljs-comment">// id 是 int, name 是 std::string</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-2-智能指针"><a href="#2-2-智能指针" class="headerlink" title="2.2 智能指针"></a>2.2 智能指针</h3><ol>
<li><p><strong>RAII(Resource Acquisition Is Initialization): 资源请求即初始化</strong></p>
<ul>
<li><p>c++ 特有的资源管理方式.依托于栈和析构函数,对资源进行管理.也是异常安全的管理方式</p>
</li>
<li><p>资源在对象初始化时申请,当弹栈时会调用析构函数释放资源</p>
</li>
</ul>
</li>
<li><p>智能指针基本原理即通过 RAII 实现对内存进行管理</p>
<ul>
<li>智能指针会对被引用对象进行计数.新增引用+1,释放时-1.为零时将其释放</li>
<li>智能指针支持裸指针的所有操作.如 <code>*, ++, --, +=, &lt;, &gt;</code></li>
<li>C++11 引入 <code>shared_ptr, uniptr_ptr, weak_ptr</code> 三种智能指针,应对不同场景</li>
<li>智能指针重载了 <code>*  -&gt;  []</code> 运算符,使得它们的使用与裸指针类似</li>
</ul>
</li>
<li><p>标准库在 <code>&lt;memory&gt;</code> 头文件中提供了三种主要的智能指针</p>
<table>
<thead>
<tr>
<th align="left">智能指针</th>
<th align="left">所有权模型</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>std::unique_ptr</code></td>
<td align="left">独占所有权</td>
<td align="left">资源只能被一个指针拥有.轻量, 高效, 默认选择</td>
</tr>
<tr>
<td align="left"><code>std::shared_ptr</code></td>
<td align="left">共享所有权</td>
<td align="left">资源可以被多个指针共享.通过引用计数管理</td>
</tr>
<tr>
<td align="left"><code>std::weak_ptr</code></td>
<td align="left">弱引用</td>
<td align="left">不增加引用计数.与 <code>shared_ptr</code> 配合使用,解决循环引用问题</td>
</tr>
</tbody></table>
</li>
<li><p><code>std::unique_ptr</code> 独占其所指对象的所有权.没有拷贝语义(拷贝构造和赋值函数).可移动(<code>std::move</code> 转移所有权)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">m_value</span>(value) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; m_value &lt;&lt; std::endl; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_value;<br>&#125;;<br><br><span class="hljs-comment">/* 创建并使用 unique_ptr */</span><br><span class="hljs-keyword">auto</span> u1 = std::<span class="hljs-built_in">make_unique</span>&lt;MyClass&gt;(<span class="hljs-number">100</span>);<br>u1-&gt;<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 输出 100</span><br><br><span class="hljs-comment">/* 可以移动但不能拷贝 */</span><br><span class="hljs-comment">// std::unique_ptr&lt;int&gt; u2 = u1; // 错误.不能拷贝</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; u2 = std::<span class="hljs-built_in">move</span>(u1); <span class="hljs-comment">// 正确.所有权从 u1 转移到 u2. u1 变为 nullptr</span><br><br><span class="hljs-comment">/* 手动释放资源 */</span><br>u<span class="hljs-number">2.</span><span class="hljs-built_in">reset</span>();                  <span class="hljs-comment">// 与 u2 = nullptr 效果相同</span><br><span class="hljs-type">int</span>* raw_ptr = u<span class="hljs-number">2.</span><span class="hljs-built_in">release</span>(); <span class="hljs-comment">// 释放所有权,并返回原始指针.u2 变为 nullptr</span><br><span class="hljs-keyword">delete</span> raw_ptr;              <span class="hljs-comment">// 注意对象并不会被释放,而是需要自己管理</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>std::shared_ptr</code> 通过引用计数机制实现共享所有权.拥有拷贝语义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 创建 shared_ptr */</span><br><span class="hljs-keyword">auto</span> s1 = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2024</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;s1 use count: &quot;</span> &lt;&lt; s<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 1</span><br><br><span class="hljs-comment">/* 模拟代码块作用域的使用 */</span><br>&#123;<br>    std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; s2 = s1; <span class="hljs-comment">// 拷贝.引用计数+1</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s1 use count: &quot;</span> &lt;&lt; s<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出 2</span><br>    *s2 = <span class="hljs-number">100</span>;<br>    std::cout &lt;&lt; *s1 &lt;&lt; std::endl; <span class="hljs-comment">// 输出 100，s1 和 s2 指向同一对象</span><br>&#125; <span class="hljs-comment">// s2 离开作用域.被销毁,引用计数-1</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>std::weak_ptr</code> 不增加引用计数,即不拥有对象所有权.目的是解决 <code>shared_ptr</code> 循环引用问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 创建 weak_ptr.引用计数不变 */</span><br><span class="hljs-keyword">auto</span> shared = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">99</span>);<br>std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; weak = shared;<br><br><span class="hljs-comment">/* 要使用 weak_ptr.必须将其转换为 shared_ptr */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> temp_shared = weak.<span class="hljs-built_in">lock</span>()) &#123; <span class="hljs-comment">// 如果对象还存在.lock() 返回一个有效的 shared_ptr</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; *temp_shared &lt;&lt; std::endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Object has been destroyed&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>shared.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">// 释放资源.引用计数变为0</span><br><br><span class="hljs-comment">/* 释放后再次检查 */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> temp_shared = weak.<span class="hljs-built_in">lock</span>()) &#123;<br>    <span class="hljs-comment">// 不会执行到这里</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Object has been destroyed&quot;</span> &lt;&lt; std::endl; <span class="hljs-comment">// 这里会执行</span><br>&#125;<br><span class="hljs-comment">// 也可以使用 weak.expired() 来检查对象是否已被销毁</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-3-移动语义"><a href="#2-3-移动语义" class="headerlink" title="2.3 移动语义"></a>2.3 移动语义</h3><ol>
<li><p>如何将一个冰箱里的大象放入另一个冰箱</p>
<ul>
<li>拷贝复制: 将冰箱1的大象复制,然后放入冰箱2,最后让冰箱1原本的大象消失</li>
<li>移动: 打开冰箱,移动大象,关上冰箱</li>
</ul>
</li>
<li><p>C++11 之前只有复制语义(通过析构函数, 拷贝构造函数, 赋值函数)</p>
<ul>
<li>对于对象的非指针,非引用的行为都会使用复制语义</li>
<li>在拥有内存对象的资源中,需要定义这三个函数,并实现深拷贝</li>
<li>在一些场景中,对象拷贝后就立即被销毁.此时使用移动而非拷贝对象可提高性能</li>
</ul>
</li>
<li><p>左值与右值</p>
<ul>
<li>左值: 可以对其取址</li>
<li>右值: 不能取址,只能取值.通常位于赋值号右侧</li>
<li>将亡值: 如函数返回时的临时对象, 非引用的形参, 将被移动的对象</li>
</ul>
</li>
<li><p>右值引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> &amp;&amp;r = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 右值引用.使用 &amp;&amp; 可以引用字面量</span><br></code></pre></td></tr></table></figure>

<ul>
<li>返回左值的对象: 返回左值引用的函数, 赋值, 下标, 解引用, 前置递增&#x2F;递减</li>
<li>返回右值的对象(会产生临时变量): 返回非引用类型的函数, 算术, 关系, 位, 后置递增&#x2F;递减</li>
<li>左值引用不能引用右值(因为右值不能改变.但 const 左值引用可以指向右值)</li>
</ul>
</li>
<li><p>移动语义: 从源对象窃取资源,而非拷贝资源.源对象不再拥有资源</p>
</li>
<li><p><strong>支持移动语义的对象需要定义移动构造函数和移动赋值函数(形参为右值引用)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 相较于 const 左值引用.右值可直接修改对象成员</span><br><span class="hljs-built_in">ClassName</span>(ClassName&amp;&amp; t) <span class="hljs-keyword">noexcept</span> &#123;&#125;  <span class="hljs-comment">// 移动构造函数</span><br>ClassName&amp; <span class="hljs-keyword">operator</span>=(ClassName&amp;&amp; t) <span class="hljs-keyword">noexcept</span> &#123;&#125;  <span class="hljs-comment">// 移动赋值函数</span><br></code></pre></td></tr></table></figure>

<ul>
<li>将对象中的资源移走,而非赋值.因此不分配内存</li>
<li>移动后的源对象因为是右值引用会被销毁.因此内部资源被置为无效</li>
<li>必须声明为 <code>noexcept</code>.因为若移动时抛出异常会导致源对象资源被破坏</li>
</ul>
</li>
<li><p>编译器有条件的提供默认移动操作(不要依赖编译器,最好自己实现)</p>
<ul>
<li>类中没有自定义拷贝控制成员(析构函数, 拷贝构造函数, 赋值函数)</li>
<li>所有的数据成员都能移动构造或移动赋值</li>
</ul>
</li>
<li><p><code>std::move</code>: 将左值转换为右值引用,其本身不产生移动操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string s = <span class="hljs-string">&quot;abc&quot;</span>;<br>std::string &amp;&amp;s1 = std::<span class="hljs-built_in">move</span>(s);  <span class="hljs-comment">// s1 是对 s 的右值引用</span><br>std::cout &lt;&lt; s.<span class="hljs-built_in">c_str</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 abc.说明并未发生移动语义</span><br><span class="hljs-function">std::string <span class="hljs-title">ss</span><span class="hljs-params">(std::move(s))</span></span>;  <span class="hljs-comment">// 将右值引用传入构造函数,触发移动构造函数</span><br><span class="hljs-comment">// 在移动语义发生后,不应再使用源对象</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-4-chrono-库"><a href="#2-4-chrono-库" class="headerlink" title="2.4 chrono 库"></a>2.4 chrono 库</h3><ol>
<li><p>时间处理的需求</p>
<ul>
<li>获取当前时间.如记录日志,精确到毫秒</li>
<li>计算时间间隔.如计算代码块的运行时长</li>
<li>获取日期,进行换算</li>
<li>定时器(chrono 不支持)</li>
</ul>
</li>
<li><p>chrono: C++11 提供的跨平台,强类型的时间日期处理库.使用前需要包含头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>clock</code>: 时钟.使用时间点(time point)与间隔(duration)的方式确定当前时间</p>
<ul>
<li><p><code>system_clock</code>: 系统时间.原点时间为 UNIX 1970-01-01 00:00::00 UTC</p>
<ul>
<li><p>拥有三个静态方法: <code>now, to_time, from_time_c</code></p>
</li>
<li><p>不稳定性: 如果修改了系统时间,将会导致 <code>system_clock</code> 变化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> timePoint = std::chrono::system_clock::<span class="hljs-built_in">now</span>();  <span class="hljs-comment">// 先获取当前时间</span><br><span class="hljs-keyword">auto</span> duration = timePoint.<span class="hljs-built_in">time_since_epoch</span>();  <span class="hljs-comment">// 转为时间间隔</span><br>std::cout &lt;&lt; duration.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 17370304141602793</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>steady_clock</code>: 处理器 tick 时间.原点时间为机器启动的时刻</p>
<ul>
<li>拥有 <code>now</code> 静态方法.一般用于度量时间间隔</li>
<li>稳定性: <code>now</code> 方法确保返回值不小于上次调用的返回值(就算修改系统时间也是)</li>
</ul>
</li>
<li><p><code>high_resolution_clock</code>: 当前系统支持的最高精度.使用场景和用法与 <code>steady_clock</code> 一致</p>
</li>
</ul>
</li>
<li><p><code>duration</code>: 时间间隔</p>
<ul>
<li><p>比率(<code>std::ratio</code>)模板类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">intmax_t</span> Num, std::<span class="hljs-type">intmax_t</span> Denom = <span class="hljs-number">1</span>&gt; <span class="hljs-keyword">class</span> ratio &#123;&#125;<br><span class="hljs-comment">// Num: 分子</span><br><span class="hljs-comment">// Denom: 分母.不可为零,不可为最小的负数.且已经约分到最简</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>Duration 模板类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Rep</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Period</span> = ratio&lt;<span class="hljs-number">1</span>&gt; &gt; <span class="hljs-keyword">class</span> duration &#123;&#125;<br><span class="hljs-comment">// Period: 精度.如 ratio&lt;1&gt; 为秒, ratio&lt;1, 1000&gt; 为毫秒</span><br><span class="hljs-comment">// duration 支持算术运算符和比较运算符</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>system_clock, steady_clock, high_resolution_clock</code> 各自拥有精度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::chrono::system_clock::period::num;  <span class="hljs-comment">// 分子默认为 1</span><br>std::chrono::system_clock::period::den;  <span class="hljs-comment">// 分母代表精度. 10e7</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>预定义的基本时间单元</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> nanoseconds  = duration&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, nano&gt;;   <span class="hljs-comment">// 纳秒</span><br><span class="hljs-keyword">using</span> microseconds = duration&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, micro&gt;;  <span class="hljs-comment">// 微秒</span><br><span class="hljs-keyword">using</span> milliseconds = duration&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, milli&gt;;  <span class="hljs-comment">// 毫秒</span><br><span class="hljs-keyword">using</span> seconds      = duration&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;;<br><span class="hljs-keyword">using</span> minutes      = duration&lt;<span class="hljs-type">int</span>, ratio&lt;<span class="hljs-number">60</span>&gt;&gt;;<br><span class="hljs-keyword">using</span> hours        = duration&lt;<span class="hljs-type">int</span>, ratio&lt;<span class="hljs-number">3600</span>&gt;&gt;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>自定义时间单元</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> std::chrono::duration&lt;<span class="hljs-type">long</span>, std::ratio&lt;<span class="hljs-number">1</span>, <span class="hljs-number">25</span>&gt;&gt; FrameRate;  <span class="hljs-comment">// 25帧率</span><br><span class="hljs-built_in">Frame</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 3帧的时间间隔 1/25*3 = 120ms</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>time point</code>: 时间点模板类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Duration</span>=<span class="hljs-keyword">typename</span> Clock::duration&gt; <span class="hljs-keyword">class</span> time_point &#123;&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-模板"><a href="#3-模板" class="headerlink" title="3 模板"></a>3 模板</h2><h3 id="3-1-函数模板"><a href="#3-1-函数模板" class="headerlink" title="3.1 函数模板"></a>3.1 函数模板</h3><ol>
<li><p><strong>函数模板: 对类型进行参数化(建立通用函数,其返回值类型和形参类型可以不具体指定,用虚拟类型来代表)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-comment">// 函数模板声明</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> </span>&#123;<br>	T temp = a;<br>	a = b;<br>	b = temp;<br>&#125;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">my_swap</span>(a, b);       <span class="hljs-comment">// 自动进行类型推导</span><br><span class="hljs-built_in">my_swap</span>&lt;<span class="hljs-type">int</span>&gt;(a, b);	 <span class="hljs-comment">// 显式地指定类型.此时 T 被明确指定为 int</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>template</code>: 声明创建模板</p>
</li>
<li><p><code>typename</code>: 声明后面的符号是一种数据类型,也可以用 <code>class</code> 代替</p>
</li>
<li><p><code>T</code>: 通用的数据类型.名称可以替换,通常大写</p>
</li>
</ul>
</li>
<li><p>函数模板使用要求</p>
<ul>
<li>自动类型推导,必须推导出一致的数据类型 <code>T</code>,才可使用</li>
<li>模板必须要确定出 <code>T</code> 的数据类型,才可使用</li>
</ul>
</li>
<li><p><strong>普通函数与函数模板的区别</strong></p>
<ul>
<li>类型转换<ul>
<li>普通函数调用时,可以发生自动类型转换(隐式类型转换)</li>
<li>函数模板进行自动类型推导时,不会发生隐式类型转换(显式指定类型时,则可以)</li>
</ul>
</li>
<li>调用规则<ul>
<li><strong>若函数模板和普通函数都可以调用,则优先调用普通函数</strong></li>
<li>可以通过空模板参数列表来强制调用函数模板.即 <code>&lt;&gt;</code> 里为空</li>
<li>如果函数模板可以产生更好的匹配,则优先调用函数模板</li>
</ul>
</li>
</ul>
</li>
<li><p>模板的重载</p>
<ul>
<li>为这些特定的类型提供具体化的模板.调用时,具体化参数的函数模板优先于更广泛的模板<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-type">bool</span> <span class="hljs-title">my_compare</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> </span>&#123;&#125;<br><span class="hljs-comment">/* 模板的重载(Person 是具体的数据类型). 开头的 template&lt;&gt; 声明是模板 */</span><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">my_compare</span><span class="hljs-params">(Person &amp;p1, Person &amp;p2)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li>
<li>利用具体化的模板,可以解决自定义类型的通用化</li>
<li><strong>学习模板并不是为了写模板,而是在 STL 能够运用系统提供的模板</strong></li>
</ul>
</li>
</ol>
<h3 id="3-2-类模板"><a href="#3-2-类模板" class="headerlink" title="3.2 类模板"></a>3.2 类模板</h3><ol>
<li><p><strong>类模板作用: 建立通用类.类中成员的数据类型可不具体指定,用虚拟的类型来代表</strong></p>
</li>
<li><p>类模板和函数模板语法相似</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span> = <span class="hljs-type">int</span>&gt;  <span class="hljs-comment">// 类模板声明</span><br><span class="hljs-keyword">class</span> Person &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Person</span>(T1 name, T2 age) &#123;<br>		<span class="hljs-keyword">this</span>-&gt;name = name;<br>		<span class="hljs-keyword">this</span>-&gt;age = age;<br>	&#125;<br><br>	T1 name;<br>	T2 age;<br>&#125;;<br><br><span class="hljs-comment">// 创建对象.此时 string -&gt; T1, int -&gt; T2</span><br>Person&lt;string, <span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>类模板和函数模板的区别</p>
<ul>
<li><strong>类模板不能自动类型推导,必须显式指定</strong></li>
<li>类模板在模板参数列表中可以有默认参数(写在声明的地方)</li>
</ul>
</li>
<li><p><strong>类模板中的成员函数在调用时才创建(区别于普通方法在编译时即可创建)</strong></p>
<ul>
<li>因此类模板的分文件编写会导致链接阶段失败</li>
<li>解决方法: 将声明和实现写到同一个文件中,并更改后缀名为 <code>.hpp</code></li>
</ul>
</li>
<li><p>类模板对象做为函数参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 1. 指定传入的类型 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Person&lt;string, <span class="hljs-type">int</span>&gt;&amp; p)</span></span>;  <span class="hljs-comment">// 显式指定模板对象的数据类型</span><br><br><span class="hljs-comment">/* 2. 参数模板化 */</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;   <span class="hljs-comment">// 将函数改为函数模板</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Person&lt;T1, T2&gt;&amp; p)</span></span>;  <span class="hljs-comment">// 模板对象中的参数以虚拟类型进行传递</span><br><br><span class="hljs-comment">/* 3. 整个类模板化 */</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T&amp; p)</span></span>;  <span class="hljs-comment">// 将对象类型模板化进行传递</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>类模板与继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 当子类继承类模板时.声明时要指定出父类中 T 的类型(若不指定,编译器无法给子类分配内存) */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>: <span class="hljs-keyword">public</span> Person&lt;string, <span class="hljs-type">int</span>&gt; &#123;&#125;;<br><br><span class="hljs-comment">/* 如果想灵活指定出父类中 T 的类型,子类也需变为类模板 */</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>: <span class="hljs-keyword">public</span> Person&lt;T1, T2&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>类模板成员函数的类外实现,需要加上模板参数列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 类内声明 */</span><br><span class="hljs-built_in">Person</span>(T1 name, T2 age);<br><span class="hljs-comment">/* 类外实现 */</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>&gt;<br>Person&lt;T1, T2&gt;::<span class="hljs-built_in">Person</span>(T1 name, T2 age) &#123;&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-3-STL"><a href="#3-3-STL" class="headerlink" title="3.3 STL"></a>3.3 STL</h3><ol>
<li><p>STL(Standard Template Library,标准模板库)</p>
<ul>
<li><strong>STL 从广义上分为: 容器(container), 算法(algorithm), 迭代器(iterator)</strong></li>
<li>容器和算法之间通过迭代器进行无缝连接</li>
<li>STL 几乎所有的代码都采用了模板类或者模板函数</li>
</ul>
</li>
<li><p>STL 组件</p>
<ul>
<li><strong>容器</strong>: 各种数据结构,如 <code>vector, list, deque, set, map...</code></li>
<li><strong>算法</strong>: 各种常用的算法,如 <code>sort, find, copy, for_each...</code></li>
<li><strong>迭代器</strong>: 容器与算法之间的胶合剂</li>
<li><strong>仿函数</strong>: 行为类似函数,可作为算法的某种策略</li>
<li><strong>适配器</strong>: 修饰容器, 仿函数, 迭代器接口</li>
<li><strong>空间配置器</strong>: 负责空间的配置与管理</li>
</ul>
</li>
<li><p><strong>容器: 存放数据的地方</strong></p>
<ul>
<li>序列式容器: 强调排序.每个元素有固定的位置</li>
<li>关联式容器: 二叉树结构.各元素之间没有严格的物理上的顺序关系</li>
</ul>
</li>
<li><p><strong>算法: 解决问题的有限步骤</strong></p>
<ul>
<li><p>质变算法: 运算过程中会更改区间内的元素的内容. 如拷贝, 替换, 删除…</p>
</li>
<li><p>非质变算法: 运算过程中不会更改区间内的元素内容. 如查找, 计数, 遍历, 寻找极值…</p>
</li>
<li><p>STL 算法主要包含于头文件 <code>&lt;algorithm&gt;, &lt;functional&gt;, &lt;numeric&gt;</code></p>
<ul>
<li><code>&lt;algorithm&gt;</code> 是 STL 中最大的一个.涉及比较, 交换, 查找, 遍历操作, 复制, 修改…</li>
<li><code>&lt;numeric&gt;</code> 体积很小,只包括几个在序列上面进行的简单数学运算的模板函数</li>
<li><code>&lt;functional&gt;</code> 定义了一些模板类,用于声明函数对象</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>迭代器: 容器和算法之间粘合剂</strong></p>
<ul>
<li><p>能够依序寻访某个容器的元素,又无需暴露该容器的内部表示方式</p>
</li>
<li><p>每个容器都有自己专属的迭代器.算法通过迭代器访问容器的元素</p>
</li>
<li><p>迭代器使用非常类似于指针,初学阶段可以先理解迭代器为指针</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读. 支持 ++, &#x3D;&#x3D;, !&#x3D;</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写. 支持 ++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作,并能向前推进迭代器</td>
<td>读写. 支持 ++, &#x3D;&#x3D;, !&#x3D;</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作,并能向前和向后操作</td>
<td>读写. 支持 ++, –</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作,可以以跳跃的方式访问任意数据</td>
<td>读写. 支持 ++, –, [n], -n, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;</td>
</tr>
</tbody></table>
</li>
<li><p><strong>常用的容器中迭代器种类为双向迭代器, 随机访问迭代器</strong></p>
</li>
</ul>
</li>
</ol>
<h3 id="3-4-函数对象"><a href="#3-4-函数对象" class="headerlink" title="3.4 函数对象"></a>3.4 函数对象</h3><ol>
<li><p><strong>函数对象</strong>: 重载了函数调用操作符 <code>()</code>的类对象.也称仿函数</p>
<ul>
<li>函数对象在使用时.可像普通函数那样调用: 有参数,有返回值</li>
<li>函数对象超出普通函数的概念: 可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ul>
</li>
<li><p><strong>谓词</strong>: 返回 <code>bool</code> 类型的仿函数.接受一 &#x2F; 二个参数,称为一 &#x2F; 二元谓词</p>
</li>
<li><p><strong>STL 内建的函数对象: 算术仿函数, 关系仿函数, 逻辑仿函数</strong></p>
<ul>
<li><p>需要内建函数对象需要包含头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>这些仿函数所产生的对象,用法和普通函数完全相同.函数原型形如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T plus&lt;T&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>算术仿函数实现四则运算(<code>+ - * / %</code>)</p>
<ul>
<li><p>对应的仿函数名称为: <code>plus, minus, multiplies, divides, modulus</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">plus&lt;<span class="hljs-type">int</span>&gt; p;  <span class="hljs-comment">// 加法仿函数.虽然是二元运算,但要求两者类型相同,仍只需一个类型标识</span><br><span class="hljs-built_in">p</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">// 结果为 30</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>另外,还有 <code>negate</code> 是一元运算,表示取负</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">negate&lt;<span class="hljs-type">int</span>&gt; neg;  <span class="hljs-comment">// 取负仿函数</span><br><span class="hljs-built_in">neg</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 结果为 -10</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>关系仿函数实现比较运算(<code>= != &gt; &gt;= &lt; &lt;=</code>)</p>
<ul>
<li><p>对应的仿函数名称为: <code>equal_to, not_equal_to, greater, greater_equal, less, less_equal</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-comment">// sort 算法可以使用仿函数指定排序规则.默认升序排列 less&lt;&gt;()</span><br><span class="hljs-comment">// greater&lt;int&gt;() 是匿名对象,实现降序排列</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>逻辑仿函数实现逻辑运算(<code>&amp;&amp; || !</code>).对应的仿函数名称为: <code>logical_and, logical_or, logical_not</code></p>
</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="category-chain-item">计算机</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/" class="print-no-link">#C++</a>
      
        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="print-no-link">#计算机</a>
      
        <a href="/tags/Code/" class="print-no-link">#Code</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++</div>
      <div>http://example.com/2024/01/19/Computer/C++/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Shuang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年1月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/04/01/Embedded/STM32/" title="STM32">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">STM32</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/06/02/Tool/Git/" title="Git">
                        <span class="hidden-mobile">Git</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
