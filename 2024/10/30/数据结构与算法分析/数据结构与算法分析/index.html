

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Shuang">
  <meta name="keywords" content="Shuang">
  
    <meta name="description" content="组织大量数据的方法与对算法运行时间的评估">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法分析">
<meta property="og:url" content="http://windsand.top/2024/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Shuang blog">
<meta property="og:description" content="组织大量数据的方法与对算法运行时间的评估">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://windsand.top/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9AC%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0.png">
<meta property="article:published_time" content="2024-10-29T18:29:52.796Z">
<meta property="article:modified_time" content="2024-10-29T19:11:46.229Z">
<meta property="article:author" content="Shuang">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://windsand.top/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9AC%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0.png">
  
  
  
  <title>数据结构与算法分析 - Shuang blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"windsand.top","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>windsand</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/train.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="数据结构与算法分析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-10-30 02:29" pubdate>
          2024年10月30日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          10k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          85 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">数据结构与算法分析</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="数据结构与算法分析"><a href="#数据结构与算法分析" class="headerlink" title="数据结构与算法分析"></a>数据结构与算法分析</h1><h2 id="0-算法分析"><a href="#0-算法分析" class="headerlink" title="0 算法分析"></a>0 算法分析</h2><h3 id="0-1-基础概念"><a href="#0-1-基础概念" class="headerlink" title="0.1 基础概念"></a>0.1 基础概念</h3><ol>
<li>概念<ul>
<li>数据结构: 组织大量数据的方法</li>
<li>算法分析: 对算法运行时间的评估</li>
<li><strong>算法(algorithm)</strong>: 为求解一个问题所需遵循的,被清楚指定的简单指令集合</li>
<li>当某种算法被给定时,则需要确定该算法所需的时间和空间等资源量</li>
</ul>
</li>
<li><strong>抽象数据类型(Abstract Data Type,ADT)</strong>: 是一些操作的集合,是数学上的抽象<ul>
<li>例如表,集合,图以及它们的操作可看作抽象数据类型</li>
<li>例如集合ADT,可以有 并(union), 交(intersection), 补(complement), 求大小(size)等操作</li>
<li>基本思路: 只在程序中编写一次,其他地方需要运行 ADT 上的操作时,可通过调用函数实现</li>
</ul>
</li>
<li>定义: 建立无穷大量之间的相对级别<ul>
<li>$\mathrm{if} \quad \exists c,n_0\in N_+,N\geq n_0\quad\mathrm{s.t.} T(N)\leq cf(N), \mathrm{then} \quad T(N)&#x3D;O(f(N))$</li>
<li>$\mathrm{if} \quad \exists c,n_0\in N_+,N\geq n_0  \quad  \mathrm{s.t.} T(N)\geq cg(N),\mathrm{then} \quad T(N)&#x3D;\Omega(g(N))$</li>
<li>$T(N)&#x3D;O(h(N))  \quad and\quad T(N)&#x3D;\Omega(h(N)) \iff T(N)&#x3D;\Theta(h(N))$</li>
<li>$T(N)&#x3D;O(p(N)) \quad and \quad T(N)\neq \Theta(p(N)), \mathrm{then} \quad T(N)&#x3D;o(f(N))$</li>
</ul>
</li>
<li>简要说明<ul>
<li>$O$: 高阶无穷大</li>
<li>$\Omega$: 低阶无穷大</li>
<li>$\Theta$: 同阶无穷大</li>
<li>$o$: 严格的高阶无穷大</li>
</ul>
</li>
<li><strong>一般采用大$O$记法</strong>.例如 $T(N)&#x3D;2N^2+N&#x3D;O(N^2)$<ul>
<li>不要将常数或低阶项放入大$O$,直接忽略即可</li>
<li>典型的增长率(递增排列): $C, \mathrm{log}N, \mathrm{log}^2N, N, N\mathrm{log}N, N^2, N^3, 2^N$</li>
<li>可以使用洛必达法则确定两个函数的相对级别</li>
</ul>
</li>
</ol>
<h3 id="0-2-计算方式"><a href="#0-2-计算方式" class="headerlink" title="0.2 计算方式"></a>0.2 计算方式</h3><ol>
<li>为在正式的框架中分析算法,需要一个计算模型<ul>
<li>假定一个标准计算机,它顺序执行指令.拥有简单的指令系统(如加减乘除,赋值等)</li>
<li>特别地,该模型机执行任意一条简单指令都恰好花费一个时间单元</li>
<li>该模型机具有无限内存</li>
</ul>
</li>
<li>待分析的问题<ul>
<li>最重要的资源一般为运行时间</li>
<li>在这里分析对运行时间的影响因素有: 使用的算法, 对该算法的输入(主要方面)</li>
<li>考虑两个函数<ul>
<li>$T_{avg}(N)$: 输入为 N 时算法所花费的平均时间</li>
<li>$T_{worst}(N)$: 输入为 N 时算法在最坏情况下花费的时间</li>
<li><strong>主要考虑 $T_{worst}(N)$.因为它为所有的输入提供了一个运行时间上界</strong></li>
</ul>
</li>
<li>当两个程序花费的时间大致相同时,判断运行速度的方法是将其编码并运行</li>
<li>为简化分析,系数,低阶项,常数项直接抛弃.只计算其上界: 大$O$</li>
</ul>
</li>
</ol>
<h3 id="0-3-运行时间计算"><a href="#0-3-运行时间计算" class="headerlink" title="0.3 运行时间计算"></a>0.3 运行时间计算</h3><ol>
<li><p>分析案例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 计算 1~n 的立方和 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> partialSum = <span class="hljs-number">0</span>;			<span class="hljs-comment">// 声明不计时间,赋值计1个时间单元</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i &lt;= n, i++) &#123;	<span class="hljs-comment">// 初始化赋值计1次,判断循环条件计n+1次,自增计n次</span><br>        partialSum += i * i * i;<span class="hljs-comment">// 乘法2次,加法1次,赋值1次.重复n次,共计4n个时间单元</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> partialSum;			<span class="hljs-comment">// 返回计1个时间单元</span><br>&#125;  <span class="hljs-comment">// 本算法共计6n+4个时间单元,即 O(N)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>一般法则</p>
<ul>
<li><code>for</code>: 运行时间最多为循环语句的运行时间乘以迭代次数</li>
<li>嵌套 <code>for</code>: 由里向外分析循环.嵌套循环内部一条语句总运行时间为: 该语句运行时间乘以<code>for</code>循环大小的乘积</li>
<li>顺序语句: 对各语句的运行时间求和(事实上,只需考虑运行时间最长的语句)</li>
<li><code>if/else</code>: 判断语句运行时间加上分支语句中最长的运行时间</li>
<li><strong>分析的基本策略为从内部向外扩展.如果有函数调用,则应该首先分析</strong></li>
</ul>
</li>
<li><p>考虑 Fibonacci 数列递归求和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-1</span>) + fib(n<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>运行时间为: $T(N)&#x3D;T(N-1)+T(N-2)\quad (n\geq2)$.这是一个指数级增长</li>
<li>运行效率低下的原因为: 进行了大量的重复计算,且计算结果被抛弃</li>
<li>改进: 用一个数组将计算结果存储起来,将可以大大提高运行效率</li>
</ul>
</li>
<li><p>最大子序列和问题的四种算法</p>
<ul>
<li><p>问题: 给定整数 $A_1,A_2,\dots,A_n$, 求  $\sum\limits^j_{k&#x3D;i}A_k$ 的最大值(假定数组中均为负数,则最大子序列和为0)</p>
</li>
<li><p>穷举所有的可能 $\Theta(n^3)$</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumN3</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i; j&lt;n; j++) &#123;<br>            <span class="hljs-type">int</span> thisSum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i; k&lt;=j; k++) &#123;<br>                thisSum += a[k];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(thisSum &gt; maxSum)<br>                maxSum = thisSum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>分析可知,最内层的 for 冗余,将其去掉 $O(N^2)$</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumN2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-type">int</span> thisSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i; j&lt;n; j++) &#123;<br>            thisSum += a[j];<br>            <span class="hljs-keyword">if</span>(thisSum &gt; maxSum)<br>                maxSum = thisSum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>递归 $O(N\mathrm{logN})$</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumNlogN</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left == right) 		<span class="hljs-comment">// 参数为数组,左边界,右边界</span><br>        <span class="hljs-keyword">return</span> a[left] &gt; <span class="hljs-number">0</span> ? a[left] : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> center = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> maxLeftSum, maxRightSum;<br>    maxLeftSum = maxSubseqSumNlogN(a, left, center);  <span class="hljs-comment">// 递归调用</span><br>    maxRightSum = maxSubseqSumNlogN(a, center + <span class="hljs-number">1</span>, right);<br><br>    <span class="hljs-type">int</span> maxLeftBrdSum,  maxRightBrdSum,     leftBrdSum,     rightBrdSum;<br>    maxLeftBrdSum = <span class="hljs-number">0</span>;  maxRightBrdSum = <span class="hljs-number">0</span>; leftBrdSum = <span class="hljs-number">0</span>; rightBrdSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=center; i&gt;=left; i--) &#123;  <span class="hljs-comment">// 计算中值到左边界的最大和</span><br>        leftBrdSum += a[i];<br>        <span class="hljs-keyword">if</span>(leftBrdSum &gt; maxLeftBrdSum)<br>            maxLeftBrdSum = leftBrdSum;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=center+<span class="hljs-number">1</span>; i&lt;=right; i++) &#123;  <span class="hljs-comment">// 计算中值到右边界的最大和</span><br>        rightBrdSum += a[i];<br>        <span class="hljs-keyword">if</span>(rightBrdSum &gt; maxRightBrdSum)<br>            maxRightBrdSum = rightBrdSum;<br>    &#125;<br>    <span class="hljs-comment">// 返回三者的最大值</span><br>    <span class="hljs-keyword">if</span> (maxLeftSum &gt;= maxRightSum)<br>        <span class="hljs-keyword">return</span> maxLeftSum &gt;= maxLeftBrdSum + maxRightBrdSum ? maxLeftSum : maxLeftBrdSum + maxRightBrdSum;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> maxRightSum &gt;= maxLeftBrdSum + maxRightBrdSum ? maxRightSum : maxLeftBrdSum + maxRightBrdSum;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>线性算法 $O(N)$</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubseqSumN</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> thisSum, maxSum;<br>    thisSum = <span class="hljs-number">0</span>; maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++) &#123;<br>        thisSum += a[j];<br>        <span class="hljs-keyword">if</span>(thisSum &gt; maxSum)<br>            maxSum = thisSum;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(thisSum &lt; <span class="hljs-number">0</span>)<br>            thisSum = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>运行代码(将上述代码置于一个文件下即可运行)</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">-2</span>&#125;;<br>    <span class="hljs-type">int</span> arrLength = <span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(N^3)   = %d\n&quot;</span>,maxSubseqSumN3(a, arrLength));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(N^2)   = %d\n&quot;</span>,maxSubseqSumN2(a, arrLength));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(NlogN) = %d\n&quot;</span>,maxSubseqSumNlogN(a, <span class="hljs-number">0</span>, arrLength - <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maxSubseqSum(N)     = %d\n&quot;</span>,maxSubseqSumN(a, arrLength));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>运行时间中的对数</p>
<ul>
<li><p>对数经常出现的场景有</p>
<ul>
<li>若算法利用 $O(1)$ ,即在常数时间里将问题的规模削减一部分(如50%).则该算法为 $O(\mathrm{log}N)$</li>
<li>若算法利用 $O(1)$ ,即在常数时间里将问题的规模消减一个常数(如 -1).则该算法为 $O(N)$</li>
</ul>
</li>
<li><p>考虑到仅仅是将 N 个数据读入耗费的时间即为 $\Theta(N)$ .当谈及$O(\mathrm{log}N)$ 时均假定数据已读入</p>
</li>
<li><p>下面三个算法均为 $O(\mathrm{log}N)$</p>
<ul>
<li>二分查找(给定整数$X$,已排序数组 $A_0,A_1,\dots,A_{n-1}$ ,求满足$A_i&#x3D;X$的下标 $i$)</li>
</ul>
<pre><code class="hljs"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">float</span> elementType;<br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> elementType arr[], elementType x, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> low, mid, high;<br>    low = <span class="hljs-number">0</span>; high =n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>        mid = (low+high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(arr[mid] &lt; x)<br>            low = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; x)<br>            high = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</code></pre>
<ul>
<li><p>欧几里得算法(计算最大公因数)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> m,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rem;<br>    <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>) &#123;<br>        rem = m % n;<br>        m = n;<br>        n = rem;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>幂运算</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">int</span> x,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == n)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> == n % <span class="hljs-number">2</span> ? <span class="hljs-built_in">pow</span>(x * x, n / <span class="hljs-number">2</span>) : <span class="hljs-built_in">pow</span>(x * x, n / <span class="hljs-number">2</span>) * x;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1 线性表"></a>1 线性表</h2><h3 id="1-1-单链表"><a href="#1-1-单链表" class="headerlink" title="1.1 单链表"></a>1.1 单链表</h3><ol>
<li><p>表: 形如 $a_1, a_2,\dots ,a_n$ 的有限序列.其中 $a_i$ 为数据元素 </p>
<ul>
<li>其大小为 n (当 n&#x3D;&#x3D;0 称为空表,empty list)</li>
<li>表的操作: 创建空表(makeEmpty), 插入元素(Insert), 删除元素(Delete), 查找元素(find), 打印表(printList)</li>
<li>由于数组对于插入和删除元素的运行太慢,一般不用简单数组实现表</li>
</ul>
</li>
<li><p>链表: 由一系列的无需在内存中相连的结构组成</p>
<ul>
<li>每个结构含有表元素以及指向该元素后继元结构的指针(next 指针)</li>
<li>最后一个元素的 next 指针 指向 NULL</li>
<li><strong>预留一个标志节点作为表头(head).其位置为0</strong></li>
</ul>
</li>
<li><p>链表接口(具体实现见 <code>single_linked_list</code>.不考虑数组实现方式)</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SINGLE_LINKED_LIST_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SINGLE_LINKED_LIST_H</span><br><br><span class="hljs-comment">/*********************************************************/</span><br><span class="hljs-comment">/* node:        结构体类型名,链表结点</span><br><span class="hljs-comment">** ptr2node:    结构体指针,指向链表结点的指针</span><br><span class="hljs-comment">** list:        结构体指针,一般将头结点声明为 list 类型</span><br><span class="hljs-comment">** position:    结构体指针,一般将其它结点声明为 position 类型</span><br><span class="hljs-comment">** elementType: 元素类型名 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr2node</span>;</span><br><span class="hljs-keyword">typedef</span> ptr2node <span class="hljs-built_in">list</span>;<br><span class="hljs-keyword">typedef</span> ptr2node position;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    elementType element;<br>    position next;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(elementType x, elementType y)</span>;<br><br><span class="hljs-comment">/*********************************************************/</span><br><span class="hljs-comment">/* 链表相关函数.除了创建空链表,其它函数都需要参数 list l,以指明操作对象 */</span><br><span class="hljs-comment">/********** 1.创建与销毁 **********/</span><br><span class="hljs-built_in">list</span> <span class="hljs-title function_">makeList</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">clearList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deleteList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><br><span class="hljs-comment">/********** 2.获取长度 **********/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmptyList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isLast</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, position p)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">lenList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l)</span>;<br><br><span class="hljs-comment">/********** 3.增删改查 **********/</span><br>position <span class="hljs-title function_">findPosition</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x)</span>;<br>position <span class="hljs-title function_">findPrevious</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">findIndex</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x, compare func)</span>;<br>elementType *<span class="hljs-title function_">findElem</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, <span class="hljs-type">int</span> index)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-built_in">list</span> l, elementType x, position p)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* SINGLE_LINKED_LIST_H */</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>常见错误</p>
<ul>
<li>未初始化指针: 如果不知道应将指针初始化为什么,则将其初始化为 NULL</li>
<li><code>malloc</code> 函数的使用<ul>
<li>声明一个结构体指针是并不创建该结构.仅留出足够容纳结构的空间</li>
<li>若只需要一个结构体指针沿着表前进(例: <code>printList</code> 函数中的 <code>tmp</code>),则不需要使用 <code>malloc</code></li>
<li>当空间不再需要时.应使用 <code>free</code> 函数回收</li>
<li>若链表未执行过删除操作,则 <code>malloc</code> 调用次数应等于表的大小.若有表头,调用次数会多一次</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="1-2-链表使用"><a href="#1-2-链表使用" class="headerlink" title="1.2 链表使用"></a>1.2 链表使用</h3><ol>
<li><p>双链表: 在数据结构中增加一个域,使其指向前一个单元</p>
<ul>
<li><p>增加空间需求.因为需要额外存储一个指针</p>
</li>
<li><p>使得插入和删除的开销增加一倍.因为需要对增加的指针进行定位</p>
</li>
<li><p>简化删除操作.因为不再需要定位前驱元</p>
</li>
</ul>
</li>
<li><p>循环链表: 令最后一个单元指向第一个单元(可以存在表头,令最后一个单元指向表头)</p>
</li>
<li><p><strong>基数排序(radix sort)</strong></p>
<ul>
<li>桶式排序(bucket sort)<ul>
<li>问题: 存在 $n$ 个整数 $a_i(0\leq x_i\leq M-1,1\leq i\leq n)$ 需要排序</li>
<li>预留一个大小为 $M$ 的 count 数组.即 count 有 $M$ 个单元(桶).初始情况下 count 内元素为空</li>
<li>当 $a_i$ 被读入时,$\mathrm{count}[a_i]$ 自增1;所有的输入被读入后,扫描数组 count,打印排好序的表</li>
<li>该算法的时间花费为 $O(M+N)$</li>
</ul>
</li>
<li>基数排序是桶式排序的推广<ul>
<li>考虑当桶的数量远大于数的个数时.桶式排序便不再适合</li>
<li>若存在 $n$ 个整数 $a_i(0\leq x_i\leq n^p-1,1\leq i\leq n)$ 需要排序.进行多次桶式排序</li>
<li>第一步以最低位进行桶式排序,依次按位数桶式排序,直到最高位完成进行桶式排序</li>
<li>该算法的时间花费为 $O(p(n+b))$.其中p为趟数,n为元素个数,b为桶数</li>
</ul>
</li>
<li>例: 对 0~9 的立方进行基数排序<ul>
<li>原始数组: [0, 1, 512, 343, 64, 125, 216, 27, 8, 729]</li>
<li>第一次排序结果: [0, 1, 512 ,343, 64, 125, 216, 27, 8, 729]</li>
<li>第二次排序结果: [8, 1, 0], [216, 512], [729,27,125],  [343], [64]</li>
<li>第三次排序结果: [64,27,8,1,0], [125], [216], [343], [512], [729]</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="1-3-栈"><a href="#1-3-栈" class="headerlink" title="1.3 栈"></a>1.3 栈</h3><ol>
<li><p>栈(stack): 限制插入和删除只能在一个位置(栈顶, top)进行的表</p>
<ul>
<li>栈的基本操作有: 入栈(push),出栈(pop)</li>
<li>栈的特点: 后进先出(LIFO),且只有栈顶元素可访问</li>
<li>栈的链表实现及其操作不涉及栈的大小,因此均为常数时间开销.缺点在于需要承担 <code>malloc,free</code> 的开销</li>
<li>当栈采用头插法进行入栈,则头节点的后继元即为栈顶,因此出栈只需删除头节点的后继元</li>
</ul>
</li>
<li><p>栈接口(具体实现见 <code>stack</code>.不考虑数组实现方式)</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STACK_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr2node</span>;</span><br><span class="hljs-keyword">typedef</span> ptr2node <span class="hljs-built_in">stack</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    elementType element;<br>    ptr2node next;<br>&#125;;<br><br><span class="hljs-built_in">stack</span> <span class="hljs-title function_">makeStack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deleteStack</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s, elementType x)</span>;<br>elementType <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* STACK_H */</span></span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-4-队列"><a href="#1-4-队列" class="headerlink" title="1.4 队列"></a>1.4 队列</h3><ol>
<li><p>队列(queue): 限制插入(队尾, rear)和删除(队头, front)只能在两端分别进行的表</p>
<ul>
<li>队列的基本操作有入队(enqueue),出队(dequeue)</li>
<li>队列的特点: 先进先出(FIFO);只有队头元素可访问</li>
</ul>
</li>
<li><p>队列的链表实现的注意事项</p>
<ul>
<li>队列需要指向队头(front)和队尾(rear)的两个指针</li>
<li>当进行入队操作时,采用尾插法,且需要将 rear 指针向后移动一位</li>
<li>当进行出队操作时,需要先判断队列是否为空(front &#x3D;&#x3D; rear),然后删除 front 指针的后继元</li>
</ul>
</li>
<li><p>队列接口(具体实现见 <code>queue</code>.不考虑数组实现方式)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> QUEUE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUEUE_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr2node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elementType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    elementType element;<br>    ptr2node next;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ptr2node front;<br>    ptr2node rear;<br>&#125; *<span class="hljs-built_in">queue</span>;<br><br><span class="hljs-built_in">queue</span> <span class="hljs-title function_">makeQueue</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deleteQueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q, elementType e)</span>;<br>elementType <span class="hljs-title function_">dequeue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* QUEUE_H */</span></span><br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-树"><a href="#2-树" class="headerlink" title="2 树"></a>2 树</h2><h3 id="2-1-树的实现"><a href="#2-1-树的实现" class="headerlink" title="2.1 树的实现"></a>2.1 树的实现</h3><ol>
<li><p>树的递归定义: 一棵<strong>树</strong>是一些节点的集合(可以是空集).若非空,则一棵树由称为<strong>根</strong>(root)的节点 r,以及0个或多个非空的(子)树 $T_1,T_2,\dots,T_k$ 组成,这些<strong>子树</strong>中的每一颗的根都被来自根 r 的一条有向边所连接</p>
<ul>
<li><strong>叶</strong>(leaf): 没有子节点的节点</li>
<li><strong>兄弟</strong>(sibling): 具有相同父节点的节点</li>
<li><strong>路径</strong>(path): 从节点 $n_1$ 到 $n_k$ 的路径为 $n_1, n_2,\dots,n_k$ 的一个序列.且对于 $1\leq i&lt;k$,有 $n_i$ 是 $n_{i+1}$ 的父节点</li>
<li><strong>路径的长</strong>(length): 路径上 边的条数,即 $k-1$.每一节点到自身的路径长为0</li>
<li><strong>深度</strong>(depth): 对于任意节点 $n_i$,其深度为从根到 $n_i$ 的唯一路径的长</li>
</ul>
</li>
<li><p>树的实现</p>
<ul>
<li><p>在每一个节点除数据外,还需要的两个指针指向它的第一子节点(向下)及下一个兄弟节点(向右)</p>
</li>
<li><p>树的节点声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">prtToNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> &#123;</span><br>    elementType element;<br>    prtToNode firstChild;<br>    prtToNode nextSibling;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>树的遍历</p>
<ul>
<li><p>树经常用于操作系统中的目录结构</p>
<ul>
<li>例如 Unix 系统中的文件 <code>/usr/mark/book/ch1.r</code></li>
<li>第一个 &#x2F; 后的每个 &#x2F; 都表示一条边</li>
</ul>
</li>
<li><p>考虑以下述格式打印目录中的所有文件: 深度为 $d_i$ 的文件的名称前有 $d_i$ 个 <kbd>tab</kbd> 进行缩进,然后打印</p>
</li>
<li><p>实现思路: 以递归的方式打印</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">listDir</span><span class="hljs-params">(directoryOrFile d, <span class="hljs-type">int</span> depth)</span> &#123;<br>    <span class="hljs-keyword">if</span>(d is a legitimate entry) &#123;<br>        printName(d, depth);<br>        <span class="hljs-keyword">if</span>(d is a directory) &#123;<br>            <span class="hljs-keyword">for</span> each child, c, of d<br>                <span class="hljs-title function_">listDir</span><span class="hljs-params">(c, depth + <span class="hljs-number">1</span>)</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">listDirectory</span><span class="hljs-params">(directoryOrFile d)</span> &#123;<br>    listDir(d, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>算法核心函数 <code>listDir</code>: 参数为目录树的引用.如果是目录,则递归的处理子节点,文件名则被缩进后打印</li>
<li>驱动函数 <code>listDirectory</code>: 考虑到 <code>listDir</code> 的参数 <code>depth</code> 为内部递归变量.<br>因此需要驱动函数(这里赋值为0)</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="2-2-二叉树"><a href="#2-2-二叉树" class="headerlink" title="2.2 二叉树"></a>2.2 二叉树</h3><ol>
<li><p><strong>二叉树</strong>: 每个节点的子节点都不超过2个的树</p>
<ul>
<li>平均二叉树的深度通常比节点数 N 小得多,平均深度为 $O(\sqrt N)$</li>
<li><strong>二叉查找树</strong>(binary search tree)的平均深度为 $O(\log N)$.但在最坏的情况下可以为 N-1</li>
</ul>
</li>
<li><p>二叉树的实现</p>
<ul>
<li><p>由于二叉树最多有两个子节点,因此可以直接用指针指向它们</p>
</li>
<li><p>二叉树的节点声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">ptrToNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ptrToNode</span> <span class="hljs-title">tree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> &#123;</span><br>    elementType element;<br>    tree left;<br>    tree right;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="2-3-二叉查找树"><a href="#2-3-二叉查找树" class="headerlink" title="2.3 二叉查找树"></a>2.3 二叉查找树</h3><ol>
<li><p>二叉树经常用于查找.给树中的每个节点指定一个关键字值(假定为整数,且唯一)</p>
</li>
<li><p><strong>二叉查找树</strong>: 对于树中的每个节点 X,其左子树所有关键字值小于X关键字值,右子树所有关键字值大于X关键字值</p>
<ul>
<li>考虑到树的递归定义,对二叉查找树的操作通常采用递归处理</li>
<li>考虑到所有的元素都是有序的,因此假定运算符 <code>&lt;, =, &gt;</code> 均可用于这些元素</li>
</ul>
</li>
<li><p>二叉查找树的声明(<code>searchTree.h</code>文件中)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SEARCH_TREE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEARCH_TREE_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">position</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> *<span class="hljs-title">searchTree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treeNode</span> &#123;</span><br>    elementType element;<br>    searchTree left;<br>    searchTree right;<br>&#125;<br><br>searchTree <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">(searchTree t)</span>;  <span class="hljs-comment">// 创建空树</span><br>position <span class="hljs-title function_">find</span><span class="hljs-params">(elementType x, searchTree t)</span>;  <span class="hljs-comment">// 查找元素位置</span><br>position <span class="hljs-title function_">findMin</span><span class="hljs-params">(searchTree t)</span>;  <span class="hljs-comment">// 查找最小值位置</span><br>position <span class="hljs-title function_">findMax</span><span class="hljs-params">(searchTree t)</span>;  <span class="hljs-comment">// 查找最大值位置</span><br>searchTree <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, searchTree t)</span>;  <span class="hljs-comment">// 插入元素</span><br>searchTree <span class="hljs-title function_">delete</span><span class="hljs-params">(elementType x, searchTree t)</span>;  <span class="hljs-comment">// 删除元素</span><br>elementType <span class="hljs-title function_">retrieve</span><span class="hljs-params">(position p)</span>;  <span class="hljs-comment">// 检索位置信息</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* SEARCH_TREE_H */</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>源文件 <code>searchTree.c</code> 中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c">searchTree <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">(searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t != <span class="hljs-literal">NULL</span>) &#123;<br>        makeEmpty(t-&gt;left);<br>        makeEmpty(t-&gt;right);<br>        <span class="hljs-built_in">free</span>(t);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>position <span class="hljs-title function_">find</span><span class="hljs-params">(elementType x, searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(x &lt; t-&gt;element)<br>        <span class="hljs-keyword">return</span> find(x, t-&gt;left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t-&gt;element)<br>        <span class="hljs-keyword">return</span> find(x, t-&gt;right);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> t;<br>&#125;<br><br>position <span class="hljs-title function_">findMin</span><span class="hljs-params">(searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;left == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> t;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> findMin(t-&gt;left);<br>&#125;<br><br>position <span class="hljs-title function_">findMax</span><span class="hljs-params">(searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t != <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">while</span>(t-&gt;right != <span class="hljs-literal">NULL</span>)<br>            t = t-&gt;right;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br>searchTree <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, searchTree t)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>) &#123;<br>        t = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> treeNode));<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">NULL</span>)<br>            fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            t-&gt;element = x;<br>            t-&gt;left = t-&gt;right = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; t-&gt;element)<br>        t-&gt;left = insert(x, t-&gt;left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t-&gt;element)<br>        t-&gt;right = insert(x, t-&gt;right);<br>    <span class="hljs-comment">/* else x已经在树中,不在执行任何操作 */</span><br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br>searchTree <span class="hljs-title function_">delete</span><span class="hljs-params">(elementType x, searchTree t)</span> &#123;<br>    position tmp;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)  <span class="hljs-comment">/* 空树 */</span><br>        Error(<span class="hljs-string">&quot;Element not found&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; t-&gt;element)  <span class="hljs-comment">/* 向左 */</span><br>        t-&gt;left = delete(x, t-&gt;left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t-&gt;element)  <span class="hljs-comment">/* 向右 */</span><br>        t-&gt;right = delete(x, t-&gt;right);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;left &amp;&amp; t-&gt;right) &#123; <span class="hljs-comment">/* 2个子节点 */</span><br>        tmp = findMin(t-&gt;right);<br>        t-&gt;element = tmp-&gt;element;<br>        t-&gt;right = delete(t-&gt;element, t-&gt;right);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        tmp = t;<br>        <span class="hljs-keyword">if</span>(t-&gt;left == <span class="hljs-literal">NULL</span>)<br>            t = t-&gt;right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;right == <span class="hljs-literal">NULL</span>)<br>            t = t-&gt;left;<br>        <span class="hljs-built_in">free</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-4-AVL-树"><a href="#2-4-AVL-树" class="headerlink" title="2.4 AVL 树"></a>2.4 AVL 树</h3><ol>
<li><strong>AVL树</strong>(Adelson-Velskii Landis): 带有平衡条件(需易保持)的二叉查找树.且保证树的深度为$O(\log N)$<ul>
<li>AVL 树要求每个节点的左子树和右子树的高度最多差1(空树的高度定义为-1)</li>
<li>AVL 树的高度最多为$1.44\log (N+2)-1.328$. 因此可以保证除插入外的操作(删除为惰性)均为 $O(\log N)$</li>
</ul>
</li>
<li><strong>旋转</strong>: AVL 树的插入操作可能会破坏平衡条件,因此隐含着困难.但总是可以经过修正使得性质恢复<ul>
<li>插入后,只有插入点到根节点路径上的节点的平衡可能被改变.沿着此路径向上找到一个破坏了 AVL 条件的节点,调整该节点重新平衡该树,将会使得整棵树满足 AVL 条件</li>
<li>设需要重新平衡的节点为 $\alpha$.导致不平衡出现的插入位置共有4种情况<ol>
<li>左子节点的左子树</li>
<li>左子节点的右子树</li>
<li>右子节点的左子树</li>
<li>右子节点的右子树</li>
</ol>
</li>
<li>情形1,4 与 情形2,3 为关于 $\alpha$节点的对称.分别通过单旋转和双旋转进行处理</li>
</ul>
</li>
</ol>
<h2 id="3-散列"><a href="#3-散列" class="headerlink" title="3 散列"></a>3 散列</h2><h3 id="3-1-散列函数"><a href="#3-1-散列函数" class="headerlink" title="3.1 散列函数"></a>3.1 散列函数</h3><ol>
<li><p>散列表(hash table)ADT: 仅支持二叉查找树所允许的一部分操作,其实现常称为<strong>散列</strong>(hashing)</p>
<ul>
<li>散列以常数平均时间执行 插入,删除,查找,但需要元素间任何排序信息的操作不会得到有效支持</li>
<li>理想的散列表数据结构是一个含有<strong>关键字</strong>的具有固定大小的数组</li>
<li>关键字的典型是带有信息的字符串,而表的大小记为 Table-Size</li>
</ul>
</li>
<li><p><strong>映射函数</strong>(hash function): 将关键字映射到 [0, Table-Size) 区间中的某个数,且放到适当的单元中</p>
<ul>
<li>理想的映射函数应运算简单,且保证不同的关键字映射到不同的单元</li>
<li>实际上不可能,因为关键字是无穷的,而单元的数量是有限的</li>
<li>因此要找一个散列函数,能在单元间均匀的分配关键字</li>
<li><strong>冲突</strong>(collision): 两个关键字散列到同一个值</li>
</ul>
</li>
<li><p>散列函数</p>
<ul>
<li><p>若输入的关键字为整数,一般采用返回 <code>key mod tableSize</code>.保证表的大小为素数时效果较好</p>
</li>
<li><p>若输入的关键字为字符串</p>
<ol>
<li><p>可以将字符串中的字符的 ASCII 码值之和作为关键字(简单,但当表很大时将会分配不均)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index;<br>index <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">int</span> tableSize)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashVal = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*key != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        hashVal += *key++;<br>    <span class="hljs-keyword">return</span> hashVal % tableSize;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>考虑计算 $\mathrm{\sum\limits_{i&#x3D;0}^{keySize&#x3D;1}key[keySize-i-1]}\cdot 32^i$(根据 Horner 法则计算 32 的多项式函数)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">index <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">int</span> tableSize)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashVal = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*key != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        hashVal = (hashVal &lt;&lt; <span class="hljs-number">5</span>) + *key++;<br>    <span class="hljs-keyword">return</span> hashVal % tableSize;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>如计算 $h_k &#x3D; k_1 + 32k_2 + 32^2k_3$ 的方式为 $h_k &#x3D; ((k_3) \times 32 + k_2) \times 32+k_1$ </li>
<li>关键行中的 <code>&lt;&lt; 5</code> 即为乘以32, 且其中的加法还可以使用按位异或 <code>^</code> 代替</li>
<li>该算法的优点在于极其简单,当允许溢出时速度很也快</li>
<li>如果关键字特别长,不仅时间花费大,而且前面的字符还会被移出.此时通常不采用全部字符</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="3-2-消除冲突"><a href="#3-2-消除冲突" class="headerlink" title="3.2 消除冲突"></a>3.2 消除冲突</h3><ol>
<li><p>当一个元素被插入处已存在另一个元素(即不同关键字的散列值相同),此时将产生冲突</p>
<ul>
<li>解决冲突的方式有: 分离链接法(separate chaining), 开放定址法(open addressing)</li>
</ul>
</li>
<li><p>分离链接法: 将散列到同一个值的所有元素保存到一个表中</p>
<ul>
<li><p>示例: 关键字为前10个数的平方(0, 1, 4, 9, 16, 25, 36, 49, 64, 81).散列函数为 $hash(x) &#x3D; x \space mod \space 10$</p>
</li>
<li><p>则分离链接散列表形如</p>
<p><img src="/2024/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/assets/%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%95%A3%E5%88%97%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="1"></p>
</li>
<li><p>插入操作: 遍历相应的表以检查该元素是否以处于适当的位置.如果是新元素,则将其插入到表的前端&#x2F;末尾</p>
</li>
<li><p>分离链接散列表的的实现</p>
<ul>
<li><p>头文件 <code>hashSeq.h</code> 中(其中 listNode 的结构与链表相同)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HASH_SEQ_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HASH_SEQ_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTbl</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">position</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTbl</span> *<span class="hljs-title">hashTable</span>;</span><br><br>hashTable <span class="hljs-title function_">initializeTable</span><span class="hljs-params">(<span class="hljs-type">int</span> tableSize)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">destroyTable</span><span class="hljs-params">(hashTable h)</span>;<br>position <span class="hljs-title function_">find</span><span class="hljs-params">(elementType key, hashTable h)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType key, hashTable h)</span>;<br>elementType <span class="hljs-title function_">retrieve</span><span class="hljs-params">(position p)</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br>    elementType element;<br>    position next;<br>&#125;<br><span class="hljs-keyword">typedef</span> position <span class="hljs-built_in">list</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTbl</span> &#123;</span><br>    <span class="hljs-type">int</span> tableSize;<br>    <span class="hljs-built_in">list</span> *theLists;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>源文件 <code>hashSeq.c</code> 中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">hashTable <span class="hljs-title function_">initializeTable</span><span class="hljs-params">(<span class="hljs-type">int</span> tableSize)</span> &#123;<br>    hashTable h;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>(tableSize &lt; minTableSize) &#123;<br>        error(<span class="hljs-string">&quot;Table size too small&quot;</span>);<br>        retrun <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>    h = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> hashTbl));<br>    <span class="hljs-keyword">if</span>(h == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    h-&gt;tableSize = nextPrime(tableSize);<br>    <br>    h-&gt;theLists = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">list</span>) * h-&gt;tableSize);<br>    <span class="hljs-keyword">if</span>(h-&gt;theLists == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; h-&gt;tableSize; i++) &#123;<br>        h-&gt;theLists[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> listNode));<br>        <span class="hljs-keyword">if</span>(h-&gt;theLists[i] == <span class="hljs-literal">NULL</span>)<br>            fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            h-&gt;theLists[i]-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType key, hashTable h)</span> &#123;<br>    position pos, newCell;<br>    <span class="hljs-built_in">list</span> l;<br>    pos = find(key, h);<br>    <span class="hljs-keyword">if</span>(pos == <span class="hljs-literal">NULL</span>) &#123;<br>        newCell = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> listNode));<br>        <span class="hljs-keyword">if</span>(newCell == <span class="hljs-literal">NULL</span>)<br>            fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            l = h-&gt;thelists[hash(key, h-&gt;tableSize)];<br>            newCell-&gt;next = l-&gt;next;<br>            newCell-&gt;element = key;<br>            l-&gt;next = newCell;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>开放定址法: 当冲突发生时,尝试选择另外的单元,知道找出空的单元为止</p>
<ul>
<li>考虑单元 $h_0(X),h_1(X),h_2(X), \cdots,$相继试选.其中 $h_i(X) &#x3D; (hash(x)+F(i))\mod \mathrm{tableSize}$</li>
<li>函数 $F$ 是冲突解决方法,且 $F(0) &#x3D; 0$ </li>
<li>开放地址法需要将所有数据置于表内,因此散列表较大.但省去了给新单元分配地址的时间</li>
</ul>
</li>
</ol>
<h3 id="3-3-再散列"><a href="#3-3-再散列" class="headerlink" title="3.3 再散列"></a>3.3 再散列</h3><ol>
<li><p><strong>再散列</strong>(rehashing): 对于开放定址法,如果表的元素太满,则操作时间消耗增长,且插入可能失败.此时可以建立另外一个约两倍大的表(同时使用一个相关的新散列函数),扫描整个原始散列表,计算每个元素的新散列值并将其插入到新表中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">hashTable <span class="hljs-title function_">rehash</span><span class="hljs-params">(hashTable h)</span> &#123;<br>    <span class="hljs-type">int</span> i, oldSize;<br>    cell *oldCell;<br>    oldCells = h-&gt;theCells;<br>    oldSize = h-&gt;tableSize;<br>    h = initializeTable(<span class="hljs-number">2</span> * oldSize);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; oldSize; i++) &#123;<br>        <span class="hljs-keyword">if</span>(oldCells[i].info == legitimate)<br>            insert(oldCells[i].element, h);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(oldCells);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="4-优先队列"><a href="#4-优先队列" class="headerlink" title="4 优先队列"></a>4 优先队列</h2><h3 id="4-1-优先队列"><a href="#4-1-优先队列" class="headerlink" title="4.1 优先队列"></a>4.1 优先队列</h3><ol>
<li><strong>优先队列</strong>(priority queue): 是允许至少插入(入队)和删除最小(出队:找出,返回,删除优先队列中的最小元素)的数据结构</li>
<li>优先队列的简单实现方式<ul>
<li>使用简单链表: 在表头进行插入$O(1)$,遍历链表以实现删除最小元$O(n)$</li>
<li>始终让表保持排序状态: 进行顺序插入$O(n)$和删除操作$O(1)$</li>
<li>二叉查找树: 对插入和删除操作均为 $O(\log n)$</li>
</ul>
</li>
</ol>
<h3 id="4-2-二叉堆"><a href="#4-2-二叉堆" class="headerlink" title="4.2 二叉堆"></a>4.2 二叉堆</h3><ol>
<li><p>二叉堆(binary heap) 具有两个性质: 结构性和堆序性.因此堆的操作需要堆的所有性质都被满足才终止</p>
</li>
<li><p>结构性质: <strong>堆</strong>(heap): 一颗被完全填满的二叉树(完全二叉树, complete binary tree),底层可以例外(从左到右填入)</p>
<ul>
<li>高为 h 的完全二叉树节点数为: $[2^h, 2^{h+1})$.因而完全二叉树的高是 $\lfloor \log N \rfloor$</li>
<li>完全二叉树可以用数组进行表示,而不需要指针</li>
<li>考虑位置为 i 的元素,其左子节点位于 2i,右子节点位于左子节点后的 2i+1,父节点位于 $\lfloor i&#x2F;2 \rfloor$ </li>
<li>堆数据结构将由 一个数组(无论关键为什么类型),一个代表最大值的整数,当前堆大小的整数 组成</li>
</ul>
</li>
<li><p>堆序性质: 使操作快速执行</p>
<ul>
<li>考虑需要找出最小元,因此最小元应该在根上</li>
<li>将任意子树也视为一个堆,则任意节点应小于其所有后裔</li>
<li><strong>堆序性质</strong>: 在一个堆中,对于任意节点 X, X父节点的关键字小于X的关键字(根节点除外)</li>
</ul>
</li>
<li><p>优先队列的声明(<code>binaryHeap.h</code>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BIN_HEAP_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIN_HEAP_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapStruct</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapStruct</span> *<span class="hljs-title">priorityQueue</span>;</span><br><br>priorityQueue <span class="hljs-title function_">initialize</span><span class="hljs-params">(<span class="hljs-type">int</span> maxElements)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, priorityQueue h)</span>;<br>elementType <span class="hljs-title function_">deleteMin</span><span class="hljs-params">(priorityQueue h)</span>;<br>elementType <span class="hljs-title function_">findMin</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(priorityQueue h)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">(priorityQueue h)</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapStruct</span> &#123;</span><br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> size;<br>    elementType *elements;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>优先队列的操作(<code>binaryHeap.c</code>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">priorityQueue <span class="hljs-title function_">initialize</span><span class="hljs-params">(<span class="hljs-type">int</span> maxElements)</span> &#123;<br>    priorityQueue h;<br>    <span class="hljs-keyword">if</span>( maxElements &lt; minPQSize )<br>        error(<span class="hljs-string">&quot;Priority queue size is too small&quot;</span>);<br>    h = <span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>( <span class="hljs-keyword">struct</span> heapStruct ) );<br>    <span class="hljs-keyword">if</span>(h == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    h-&gt;elements = <span class="hljs-built_in">malloc</span>( ( maxElements + <span class="hljs-number">1</span> ) * <span class="hljs-keyword">sizeof</span>(elementsType) );<br>    <span class="hljs-keyword">if</span>( h-&gt;elements == <span class="hljs-literal">NULL</span> )<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    h-&gt;capacity = maxElements;<br>    h-&gt;size = <span class="hljs-number">0</span>;<br>    h-&gt;elements[<span class="hljs-number">0</span>] = minData;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(elementType x, priorityQueue h)</span> &#123;<br>    <span class="hljs-keyword">if</span>(isFull(h)) &#123;<br>        error(<span class="hljs-string">&quot;Priority queue is full&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = ++h-&gt;size; h-&gt;elements[ i / <span class="hljs-number">2</span> ] &gt; x; i /= <span class="hljs-number">2</span>)<br>        h-&gt;elements[ i ] = h-&gt;elements[ i / <span class="hljs-number">2</span> ];<br>    h-&gt;elements[i] = x;<br>&#125;<br><br>elementType <span class="hljs-title function_">deleteMin</span><span class="hljs-params">(priorityQueue h)</span> &#123;<br>    <span class="hljs-type">int</span> child;<br>    elementType minElement, lastElement;<br>    <span class="hljs-keyword">if</span>( isEmpty(h) ) &#123;<br>        error(<span class="hljs-string">&quot;Priority queue is full&quot;</span>);<br>        <span class="hljs-keyword">return</span> h-&gt;elements[<span class="hljs-number">0</span>];<br>    &#125;<br>    minElement = h-&gt;elements[<span class="hljs-number">1</span>];<br>    lastElement = h-&gt;elements[h-&gt;size--];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i * <span class="hljs-number">2</span> &lt;=  h-&gt;size; i = child) &#123;<br>        child = i * <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(child != h-&gt;size &amp;&amp; h-&gt;elements[child+<span class="hljs-number">1</span>] &lt; h-&gt;elements[child])<br>            child++;<br>        <span class="hljs-keyword">if</span>(lastElement &gt; h-&gt;elements[child])<br>            h-&gt;elements[i] = h-&gt;elements[child];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    h-&gt;elements[i] = lastElement;<br>    <span class="hljs-keyword">return</span> minElement;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-排序"><a href="#5-排序" class="headerlink" title="5 排序"></a>5 排序</h2><ol>
<li>排序算法接受的参数为: 数组首地址, 及一个表示数组元素个数的整数</li>
<li>基于比较的排序: 假定对于元素而言,运算符 <code>&lt;, &gt;</code> 是存在的</li>
<li>逆序(inversion): 与线性代数中的关于排列的逆序数定义类似<ul>
<li>n 个互异数的数组的平均逆序数为 $\frac{n(n-1)}4$</li>
<li>通过交换相邻元素进行排序的任何算法平均需要 $\Omega(N^2)$</li>
<li>排序算法通过删除逆序进行,为了有效运行,必须每次删除不止一个逆序</li>
</ul>
</li>
<li>间接排序(indirect sorting): 由于交换结构的操作是昂贵的,因而可以创建数组(其元素为指向结构的指针).通过比较指针指向的关键字,并在必要时交换指针来进行排序</li>
<li>排序的一般下界<ul>
<li>任何只用到比较的算法在最坏的情况下需要 $\Omega(N\log N)$ 次比较,因而归并排序和堆排序最优</li>
<li>任何只用到比较的算法在平均的情况下需要 $\Omega(N\log N)$ 次比较,因而快速排序是最优的</li>
</ul>
</li>
</ol>
<h3 id="5-1-插入排序"><a href="#5-1-插入排序" class="headerlink" title="5.1 插入排序"></a>5.1 插入排序</h3><ol>
<li><p>插入排序(insert sort)</p>
<ul>
<li><p>将数组假想为两部分: 前面的为已排序数组,后面的为待排序数组</p>
</li>
<li><p>初始状态为已排序数组只有第一个元素,剩余为待排序数组</p>
</li>
<li><p>遍历待排序数组,将每个未排序元素插入到已排序数组中恰当的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    elementType tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>; p &lt; n; ++p) &#123;<br>        tmp = arr[p];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = p; j&gt;<span class="hljs-number">0</span> &amp;&amp; arr[j<span class="hljs-number">-1</span>] &gt; tmp; --j)<br>            arr[j] = arr[j<span class="hljs-number">-1</span>];<br>        arr[j] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>时间复杂度: $O(N^2)$</p>
<ul>
<li>当输入数据为逆序时,达到此上界</li>
<li>当输入数据已排序时,运行时间为 $O(N)$</li>
<li>对于几乎已经排序的数据(逆序数 I 较小),插入排序很快,其时间为 $O(I+N)$</li>
</ul>
</li>
</ol>
<h3 id="5-2-希尔排序"><a href="#5-2-希尔排序" class="headerlink" title="5.2 希尔排序"></a>5.2 希尔排序</h3><ol>
<li><p>希尔排序(缩小增量排序, diminishing increment sort): 先将整个待排序的序列分割为若干子序列分别进行直接插入排序,待整个序列中的记录基本有序时,在对全体进行直接插入排序</p>
<ul>
<li><p>增量序列: $h_1, h_2, \dots,h_t$,其中 $h_1 &#x3D; 1$</p>
</li>
<li><p>$h_k$-排序数组: $\forall i,arr[i] \leq arr[i+h_k]$</p>
</li>
<li><p>希尔增量通常取 $h_t &#x3D; \lfloor n&#x2F;2 \rfloor, h_k &#x3D; \lfloor h_{k+1}&#x2F;2 \rfloor$ </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    elementType tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> increment = n/<span class="hljs-number">2</span>; increment &gt; <span class="hljs-number">0</span>; increment /= <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = increment; i &lt; n; ++i) &#123;<br>            tmp = arr[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &gt;= increment; j -= increment)<br>                <span class="hljs-keyword">if</span>(tmp &lt; arr[j - increment])<br>                    a[j] = a[j - increment];<br>            	<span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">break</span>;<br>                arr[j] = tmp;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>时间复杂度(希尔排序算法简单,但分析极其困难)</p>
<ul>
<li>希尔增量下的希尔排序的最坏情形运行时间 $\Theta(N^2)$</li>
<li>Hibbard 增量: 形如 $1, 3, 7, \dots , 2^k-1$.最坏情形运行时间 $\Theta(N^\frac32)$</li>
</ul>
</li>
</ol>
<h3 id="5-3-堆排序"><a href="#5-3-堆排序" class="headerlink" title="5.3 堆排序"></a>5.3 堆排序</h3><ol>
<li><p>堆排序(heap sort): 考虑建立二叉堆 $O(N)$,执行 N 次 <code>deleteMin</code> $O(N\log N)$.按照顺序,最小的元素将会先离开堆,将这些元素记录到第二个数组即可得到排序数组</p>
</li>
<li><p>上述算法需要额外的数组空间,可以每次在 <code>deleteMin</code> 操作后,将最后空出来的单元用于存放元素.此时得到的将是逆序的排序数组,因而可以构建具有 <code>deleteMax</code> 操作的二叉堆</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> leftChild(i) (2 * (i) + 1)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">percDown</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> child;<br>    <span class="hljs-keyword">for</span>(elementType tmp = arr[i]; leftChild(i) &lt; n; i = child) &#123;<br>        <span class="hljs-keyword">if</span>(child != n - <span class="hljs-number">1</span> &amp;&amp; arr[child + <span class="hljs-number">1</span>] &gt; arr[child])<br>            child++;<br>        <span class="hljs-keyword">if</span>(tmp &lt; a[child])<br>            arr[i] = arr[child];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    arr[i] = tmp;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        percDown(arr, i, n);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>        swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[i]);<br>        percDown(arr, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>堆排序是非常稳定的算法: 平均使用的比较只比最坏情形略少</p>
</li>
</ol>
<h3 id="5-4-归并排序"><a href="#5-4-归并排序" class="headerlink" title="5.4 归并排序"></a>5.4 归并排序</h3><ol>
<li><p>考虑合并2个已排序的数组: 设定2个指针分别指向数组的起始位置.比较2个指针指向的元素,将较小的元素放入输出数组,并移动指针.重复这一过程,直到某一指针到达末尾</p>
</li>
<li><p>归并排序(merge sort): 以分治递归的形式合并已排序数组 $O(N\log N)$.使用的比较次数几乎最优</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mSort</span><span class="hljs-params">(elementType arr[], elementType tmpArr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> center;<br>    <span class="hljs-keyword">if</span>(left &lt; right) &#123;<br>        center = (left + right) / <span class="hljs-number">2</span>;<br>        mSort(arr, tmpArr, left, center);<br>        mSort(arr, tmpArr, center + <span class="hljs-number">1</span>, right);<br>        merge(arr, tmpArr, left, center + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mergeSord</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    elementType *tmpArr = <span class="hljs-built_in">malloc</span>( n * <span class="hljs-keyword">sizeof</span>(elementType) );<br>    <span class="hljs-keyword">if</span>(tmpArr != <span class="hljs-literal">NULL</span>) &#123;<br>        mSort(arr, tmpArr, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">free</span>(tmpArr);<br>    &#125; <span class="hljs-keyword">else</span><br>        fatalError(<span class="hljs-string">&quot;No space for tmp array!&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(elementType arr[], elementType tmpArr[], <span class="hljs-type">int</span> lpos, <span class="hljs-type">int</span> rpos, <span class="hljs-type">int</span> rightEnd)</span> &#123;<br>    <span class="hljs-type">int</span> leftEnd = rpos - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> tmpPos = lpos;<br>    <span class="hljs-type">int</span> numElements = rightEnd - lpos + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(lpos &lt;= leftEnd &amp;&amp; rpos &lt;= rightEnd)<br>        <span class="hljs-keyword">if</span>(arr[lpos] &lt;= arr[rpos])<br>            tmpArr[tmpPos++] = arr[lpos++];<br>    	<span class="hljs-keyword">else</span><br>            tmpArr[tmpPos++] = arr[rpos++];<br>    <span class="hljs-keyword">while</span>(lpos &lt;= leftEnd)<br>        tmpArr[tmpPos++] = arr[lpos++];<br>    <span class="hljs-keyword">while</span>(rpos &lt;= rightEnd)<br>        tmpArr[tmpPos++] = arr[rpos++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numElements; ++i, --rightEnd) &#123;<br>        arr[rightEnd] = tmpArr[rightEnd];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-5-快速排序"><a href="#5-5-快速排序" class="headerlink" title="5.5 快速排序"></a>5.5 快速排序</h3><ol>
<li><p>快速排序(quick sort): 实践中最快的已知排序算法,平均运行时间 $O(N\log N)$</p>
<ul>
<li>若 S 中元素个数为 0 或 1,则直接返回</li>
<li>选取 S 中的任意元素 v,其称为基准(pivot)</li>
<li>分区并排序: 将 $S-{v}$ 分为两个不相交集合: $S_1 &#x3D;{x\in S-{v}|x\leq v},S_2 &#x3D;{x\in S-{v}|x\geq v} $ </li>
<li>递归地将小于基准元素的子数列和大于基准值元素的子数组排序</li>
</ul>
</li>
<li><p>选取基准</p>
<ul>
<li>错误的方式: 选取第一个元素作为基准.若输入是预排序或反序的,将会产生劣质的分割</li>
<li>安全的方式: 随机选取基准.但考虑到生成随机数是昂贵的,因而无法减少算法其余部分的平均运行时间</li>
<li>数中值分割法: 基准的最好选择是数组的中值,但这很难算出.因而可以考虑三个元素(左侧,中心,右侧位置)的中值作为基准.消除了预排序输入的坏情形,并减少约 5% 的时间</li>
</ul>
</li>
<li><p>分割策略</p>
<ul>
<li>将基准元与最后的元素进行交换,使得基准元离开要被分割的数据段</li>
<li>设置双指针 i, j. 初始时刻分别指向数组的第一个元素和倒数第二个元素(因为最后一个元素为基准)</li>
<li>当 i &lt; j 时,将 i 右移,直到遇到大于基准元的数.同理,将 j 左移,直到遇到小于基准元的数</li>
<li>若停止后的仍满足 i &lt; j,则将 i, j 指向的两个元素互换.重复该过程,直到 i, j 彼此交错</li>
<li>当 i, j 交错后,将基准元与 i 所指向的元素互换,即可完成分割</li>
</ul>
</li>
<li><p>对于小数组(n &lt; 20),快速排序不如插入排序好</p>
<ul>
<li>由于快速排序是递归的,因此小数组排序的情况经常发生</li>
<li>对小数组不进行递归排序,而进行插入排序将会节约15%的时间.截至范围可选择 n&#x3D;10</li>
</ul>
</li>
<li><p>快速排序的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> n)</span> &#123;<br>    qSort(arr, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>&#125;<br><br>elementType <span class="hljs-title function_">median3</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> center = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(arr[left] &gt; arr[center])<br>        swap(&amp;arr[left], &amp;arr[center]);<br>    <span class="hljs-keyword">if</span>(arr[left] &gt; arr[right])<br>        swap(&amp;arr[left], &amp;arr[right]);<br>    <span class="hljs-keyword">if</span>(arr[center] &gt; arr[right])<br>        swap(&amp;arr[center], &amp;arr[right]);<br>    swap(&amp;arr[center], &amp;arr[right - <span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> arr[right - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">qSort</span><span class="hljs-params">(elementType arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    elementType pivot;<br>    <span class="hljs-keyword">if</span>(left + cutOff &lt;= right) &#123;<br>        pivot = median3(arr, left, right);<br>        <span class="hljs-type">int</span> i = left;<br>        <span class="hljs-type">int</span> j = right - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(;;) &#123;<br>            <span class="hljs-keyword">while</span>(arr[++i] &lt; pivot) &#123;&#125;<br>            <span class="hljs-keyword">while</span>(arr[--j] &lt; pivot) &#123;&#125;<br>            <span class="hljs-keyword">if</span>(i &lt; j)<br>                swap(&amp;arr[i], &amp;arr[j]);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        swap(&amp;arr[i], &amp;arr[right - <span class="hljs-number">1</span>]);<br>        qSort(arr, left, i - <span class="hljs-number">1</span>);<br>        qSort(arr, i + <span class="hljs-number">1</span>, right);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        insertSort(arr + left, right - left + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="6-图论算法"><a href="#6-图论算法" class="headerlink" title="6 图论算法"></a>6 图论算法</h2><h3 id="6-1-图的定义"><a href="#6-1-图的定义" class="headerlink" title="6.1 图的定义"></a>6.1 图的定义</h3><ol>
<li>图(graph): 由顶点(vertex)的集合 V,边(edge)的集合 E 组成<ul>
<li>每条边都是点对(v, w), 其中 $v,w\in V$</li>
<li>若点对是有序的,则图是有向(directed)的,称为有向图(digraph)</li>
<li>顶点 v, w 邻接等价于当 $(v,w)\in E$</li>
<li>边可以有第三种成分: 权(weight) 或 值(cost)</li>
</ul>
</li>
<li>图中的路径(path)<ul>
<li>路径是顶点序列: $w_1, w_2, \dots, w_N \space\space \mathrm{s.t.}(w_i,w_{i+1})\in E,1\leq i&lt;E$ </li>
<li>路径的长(length): 边的数量,即 N-1</li>
<li>环(loop): 从一个顶点到自身的边</li>
<li>简单路径: 所有的顶点都互异,但第一个和最后一个顶点可以相同</li>
</ul>
</li>
<li>图中的圈(cycle)<ul>
<li>有向图中的圈: 满足 $w_1 &#x3D; w_N$ 且长至少为1的一条路径</li>
<li>无向图中的圈则额外要求边是互异的</li>
</ul>
</li>
<li>连通(connected)<ul>
<li>在无向图中从每一个顶点到每个其他顶点都存在一条路径</li>
<li>在有向图中,这种性质称为强连通(strongly connected)</li>
<li>若有向图不是强连通的,但其基础图(underlying graph, 即去掉弧的方向)是连通的,则称为弱连通(weakly connected)</li>
<li>完全图(complete graph): 每个顶点间都存在一条边</li>
</ul>
</li>
<li>图的表示(有向图)<ul>
<li>使用一个二维数组,即**邻接矩阵(adjacent matrix)**表示<ul>
<li>对于每条边(u, v),置 <code>A[u][v] = 1</code>.其他元素为0</li>
<li>若该边有一个权,则可置 <code>A[u][v]</code> 等于该权.使用很大&#x2F;小的数表示不存在的边</li>
<li>若图是稀疏的(sparse), 该方法所需求的空间 $\Theta(|V|^2)$ 过大了</li>
</ul>
</li>
<li><strong>邻接表(adjacent list)</strong>: 对每一个顶点,使用一个表存放所有的邻接点<ul>
<li>空间需求为 $O(|E|+|V|)$</li>
<li>邻接表是图的标准表示方法</li>
</ul>
</li>
<li>考虑到实际中顶点都有名字,因此需要使用散列表建立名字到数字的映射<ul>
<li>散列表中对每个顶点存储一个名字和一个内部编号( 1 ~ |V| 之间)</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="6-2-最短路径算法"><a href="#6-2-最短路径算法" class="headerlink" title="6.2 最短路径算法"></a>6.2 最短路径算法</h3><ol>
<li><p>输入一个赋权图: 与每条边 $(v_i, v_j)$ 联系的是穿越该弧的代价 $c_{i,j}$</p>
<ul>
<li>赋权路径长(weighted path length): $v_1v_2\dots v_N$ 路径的值为 $\sum\limits^{N-1}<em>{i&#x3D;1}c</em>{i,j}$</li>
</ul>
</li>
<li><p>单源最短路径问题: 给定赋权图 $G&#x3D;(V,E)$ 和特定顶点 s 作为输入,找出 s 到 G 每个点的最短赋权路径</p>
</li>
<li><p>无权最短路径</p>
<ul>
<li><p>广度优先搜索(breadth-first search): 按层处理顶点,距离最近的先辈赋值,最远的最后赋值</p>
</li>
<li><p>显然顶点s到自身距离为0,然后考察与s邻接的点,其距离为1.然后考察邻接的邻接,直到完成所有点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unWeigted</span><span class="hljs-params">(table t)</span> &#123;<br>    vertex v, w;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> currDist = <span class="hljs-number">0</span>; currDist &lt; numVetex; ++currDist)<br>        <span class="hljs-keyword">for</span> each vertex v<br>            <span class="hljs-title function_">if</span><span class="hljs-params">(!t[v].known &amp;&amp; t[v].dist == currDist)</span> &#123;<br>                t[v].known = True;<br>                <span class="hljs-keyword">for</span> each w adjacent to v<br>                    <span class="hljs-title function_">if</span><span class="hljs-params">(t[w].dist == infinity)</span> &#123;<br>                        t[w].dist = currDist + <span class="hljs-number">1</span>;<br>                        t[w].path = v;<br>                    &#125;<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Dijkstra 算法: 考虑赋权图的单源最短路径问题.仍借鉴无权时的思路</p>
<ul>
<li>顶点 s 到自身的距离为0,将其标记为已知,因为此时多了一个已知点,则可以获得其到达邻接点的距离</li>
<li>选取距离最小的点(贪心法,greedy algorithm)标记为已知,则有可以更新其到达邻接点的距离</li>
<li>重复该过程,直到获得到达目标点的最短距离</li>
<li>对于没有负值边的图,该算法总能完成.一旦出现负值边,则可能出现错误的答案</li>
</ul>
</li>
</ol>
<h2 id="7-算法设计技巧"><a href="#7-算法设计技巧" class="headerlink" title="7 算法设计技巧"></a>7 算法设计技巧</h2><h3 id="7-1-贪婪算法"><a href="#7-1-贪婪算法" class="headerlink" title="7.1 贪婪算法"></a>7.1 贪婪算法</h3><ol>
<li>贪婪算法分阶段工作.在每一个阶段,认为所作的决定是最好的,而不考虑将来的后果(即局部最优)<ul>
<li>当算法终止时,若局部最优就是全局最优,则算法正确.否则将得到一个次优解(suboptimal solution)</li>
<li>若不要求绝对最佳答案,也可通过简单的贪婪算法生成近似答案</li>
</ul>
</li>
<li>Huffman 编码<ul>
<li>ASCII 编码有约100个可打印字符和控制字符组成,需要 $\lceil \log 128\rceil&#x3D;7$ 位表示,可添加第8位作为校验位<ul>
<li>现实中,许多文件都含有大量的数字,空格和换行,而 q, x 很少</li>
<li>采用非等长编码,使经常出现的字符代码较短,可以节约磁盘空间</li>
</ul>
</li>
<li>对于代表字符的二进制代码,可以用二叉树来表示<ul>
<li>只在树叶上有数据.且每个字符从根节点开始,用0指示向左分支,用1指示向右分支</li>
<li>若字符 $c_i$ 在深度 $d_i$ 处,且出现 $f_i$ 次.则该字符代码的值(cost)为 $\sum d_i f_i$</li>
</ul>
</li>
</ul>
</li>
<li>Huffman 算法<ul>
<li>假设字符数量为 C.算法开始时存在 C 棵单节点树(每个字符一颗)</li>
<li>任意选取有最小权(树的权等于其树叶频率的和)的两棵树,任意形成以这两棵树为子树的新树</li>
<li>将这样的过程进行 C-1 次.即可得到最优 Huffman 编码树</li>
</ul>
</li>
</ol>
<h3 id="7-2-分治算法"><a href="#7-2-分治算法" class="headerlink" title="7.2 分治算法"></a>7.2 分治算法</h3><ol>
<li>分治(divide and conquer)算法<ul>
<li>分: 递归解决较小的问题(基本情况除外)</li>
<li>治: 从子问题的解 构建原问题的解</li>
</ul>
</li>
<li>最近点问题: 找出平面上点列中最近(欧几里得距离)的一对点<ul>
<li>暴力算法: 计算每个点对之间的距离,找出最小值 $O(N^2)$</li>
<li>分治算法思路<ul>
<li>将平面上的点分为两半,最近点对存在三种可能: 均在左, 均在右, 一个在左一个在右</li>
<li>记不同情况的最近点对的最小距离为: 左侧点集 $d_l$,右侧点集 $d_r$,两侧点间的距离 $d_c$</li>
<li>对于 $d_l, d_r$,可以递归的进行计算.关键在于如何计算 $d_c$</li>
</ul>
</li>
<li>$d_c$ 的计算<ul>
<li>令 $\delta &#x3D; \min(d_l, d_r)$.如果 $d_c$ 对 $\delta$ 有改进,则只需计算 $d_c$</li>
<li>若 $d_c$ 是这样的距离,则定义 $d_c$ 的两个点必然在分割线的 $\delta$ 邻域内(一个带状区域).限制考察点的数量</li>
<li>对于均匀分布的点集,则平均有 $O(\sqrt N)$ 个点位于邻域内,此时可采用暴力求解 $O(N)$</li>
</ul>
</li>
</ul>
</li>
<li>选择问题: 找出含有 N 个元素的表 S 中的第 k 个最小的元素(对于中位数 $k &#x3D; \lceil N&#x2F;2 \rceil$ 特别关注)<ul>
<li>通过对元素的快速排序,此问题以 $O(N\log N)$ 的最坏情形时间解决</li>
<li>五分化中项的中项 选择快速排序的基准<ul>
<li>将 N 个元素分为 $\lfloor N&#x2F;5 \rfloor$ 组,每5个元素一组,最多忽略4个元素</li>
<li>找出每组的中项,得到 $\lfloor N&#x2F;5 \rfloor$ 个中项的表 M,找出 M 的中项并返回</li>
</ul>
</li>
<li>使用五分化中项的中项的快速选择算法的运行时间为 $O(N)$.但实践中该算法并不实用</li>
</ul>
</li>
</ol>
<h3 id="7-3-动态规划"><a href="#7-3-动态规划" class="headerlink" title="7.3 动态规划"></a>7.3 动态规划</h3><ol>
<li><p>动态规划(dynamic programming)</p>
<ul>
<li>数学递归公式均可直接翻译为递归算法,但现实中编译器往往不发正确对待递归算法,而导致低效</li>
<li>当这种情况发生时,便需要给编译器提供帮助.改写为非递归的算法,并将子问题的答案记录在一个表内</li>
</ul>
</li>
<li><p>使用表代替递归</p>
<ul>
<li><p>计算 Fibonacci 数的自然递归效率非常低,是指数级别的</p>
</li>
<li><p>使用一个表将中间的计算结果存储起来,则可避免大量的冗余计算,下面计算 $c_n &#x3D; \frac2n\sum\limits_{i&#x3D;0}^{n-1}c_i+n,\space c_0 &#x3D; 1$</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">double</span> *c = <span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>( <span class="hljs-type">double</span> ) * ( n + <span class="hljs-number">1</span> ) );<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-literal">NULL</span>)<br>        fatalError(<span class="hljs-string">&quot;Out of space!&quot;</span>);<br>    c[<span class="hljs-number">0</span>] = <span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j)<br>            sum += c[j];<br>        c[i] = <span class="hljs-number">2.0</span> * sum / i + i;<br>    &#125;<br>    <span class="hljs-type">int</span> answer = c[n];<br>    <span class="hljs-built_in">free</span>(c);<br>    <span class="hljs-keyword">return</span> answer;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/" class="category-chain-item">数据结构与算法分析</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="print-no-link">#数据结构</a>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>数据结构与算法分析</div>
      <div>http://windsand.top/2024/10/30/数据结构与算法分析/数据结构与算法分析/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Shuang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年10月30日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/10/30/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/" title="C语言入门">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C语言入门</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/10/30/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E2%80%94%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E2%80%94%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96/" title="Python 编程快速上手—让繁琐工作自动化">
                        <span class="hidden-mobile">Python 编程快速上手—让繁琐工作自动化</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
